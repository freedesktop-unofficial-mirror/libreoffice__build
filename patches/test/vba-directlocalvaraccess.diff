diff -r 869606102f87 basic/source/classes/image.cxx
--- a/basic/source/classes/image.cxx	Fri May 07 11:11:46 2010 +0100
+++ b/basic/source/classes/image.cxx	Fri May 07 15:08:07 2010 +0100
@@ -37,6 +37,47 @@
 #include <string.h>		// memset() etc
 #include "image.hxx"
 #include <codegen.hxx>
+
+ProcRefHandler::ProcRefHandler( const String& procName ) : m_sName( procName ), m_nOffsetGen( 0 )
+{
+}
+
+UINT32 
+ProcRefHandler::getProcRefOffset( UINT32 nOp )
+{
+    INT32ToINT32::iterator it = mOpToOffsetMap.find( nOp );
+    if ( it == mOpToOffsetMap.end() )
+    {
+        // generate Offset
+        INT32 nOff =  m_nOffsetGen++; 
+        mOpToOffsetMap[ nOp ] = nOff;
+        mOffsetToOp[ nOff ] = nOp;
+        return nOff;
+    }
+    return it->second;
+}
+
+UINT32 
+ProcRefHandler::getIdForProcRefOffset( UINT32 nOffset )
+{
+    return mOffsetToOp[ nOffset ];
+}
+
+ProcRefHandler* SbiImage::GetProcRef( const String& rProcName )
+{
+    ProcRefHandler* pHandler = NULL;
+    vProcRefHandlers::iterator it_end = m_vPropRefHandlers.end();
+    for ( vProcRefHandlers::iterator it = m_vPropRefHandlers.begin(); it != it_end; ++it )
+    {
+        if ( it->getName() == rProcName )
+        {
+            pHandler = &(*it);
+            break;
+        }
+    }
+    return pHandler;
+}
+
 SbiImage::SbiImage()
 {
 	pStringOff = NULL;
@@ -486,6 +527,19 @@
 *    Accessing the image
 *
 **************************************************************************/
+short SbiImage::GetIDForString( const String& rName )
+{
+    short nRes = 0;
+    for ( short nId = 0; nId < nStrings; ++nId )
+    {
+        if ( rName == GetString( nId + 1 ) )
+        {
+            nRes = nId + 1;
+            break; 
+        }
+    }
+    return nRes;
+}
 
 // Note: IDs start with 1
 String SbiImage::GetString( short nId ) const
diff -r 869606102f87 basic/source/comp/codegen.cxx
--- a/basic/source/comp/codegen.cxx	Fri May 07 11:11:46 2010 +0100
+++ b/basic/source/comp/codegen.cxx	Fri May 07 15:08:07 2010 +0100
@@ -333,7 +333,8 @@
 	nCount = pParser->rEnumArray->Count();
 	for (i = 0; i < nCount; i++)
 		 p->AddEnum((SbxObject *)pParser->rEnumArray->Get(i));
-
+        // Set up local ref offsets for string ids
+        p->SetProcRefs( pParser->GetProcRefs() );
 	if( !p->IsError() )
 		rMod.pImage = p;
 	else
diff -r 869606102f87 basic/source/comp/dim.cxx
--- a/basic/source/comp/dim.cxx	Fri May 07 11:11:46 2010 +0100
+++ b/basic/source/comp/dim.cxx	Fri May 07 15:08:07 2010 +0100
@@ -352,10 +352,14 @@
 								nGblChain = 0;
 								bGblDefs = bNewGblDefs = TRUE;
 								break;
-				default:		eOp2 = _LOCAL;
+                default:		
+                                        eOp2 = _LOCAL; 
 			}
+        INT32 nId = pDef->GetId();
+        if ( eOp2 == _LOCAL && bVBASupportOn )
+            nId = GetProcRefOffset( pProc, pDef->GetId() );
 			aGen.Gen(
-                eOp2, pDef->GetId(),
+                eOp2, nId,
                 sal::static_int_cast< UINT16 >( pDef->GetType() ) );
 		}
 
diff -r 869606102f87 basic/source/comp/exprgen.cxx
--- a/basic/source/comp/exprgen.cxx	Fri May 07 11:11:46 2010 +0100
+++ b/basic/source/comp/exprgen.cxx	Fri May 07 15:08:07 2010 +0100
@@ -108,7 +108,9 @@
 				 		bTreatFunctionAsParam = false;
 				}
 				if( !bTreatFunctionAsParam )
+                                {
 					eOp = aVar.pDef->IsGlobal() ? _FIND_G : _FIND;
+                                }
 			}
         }
 		// AB: 17.12.1995, Spezialbehandlung fuer WITH
@@ -126,10 +128,9 @@
                 eOp = ( aVar.pDef->GetScope() == SbRTL ) ? _RTL : 
                     (aVar.pDef->IsGlobal() ? _FIND_G : _FIND);
 		}
-
 		if( eOp == _FIND )
 		{
-	
+
 			SbiProcDef* pProc = aVar.pDef->GetProcDef();
 			if ( pGen->GetParser()->bClassModule )
 				eOp = _FIND_CM;
@@ -137,6 +138,10 @@
 			{
 				eOp = _FIND_STATIC;
 			}
+            if ( pGen->GetParser()->IsVBASupportOn() && ( eOp == _FIND_STATIC || eOp == _FIND_CM || eOp == _FIND ) )
+            {
+                aVar.pDef->nLocalIndex = pGen->GetParser()->GetProcRefOffset( pGen->GetParser()->GetProc(), aVar.pDef->GetId() );
+            }
 		}
 		for( SbiExprNode* p = this; p; p = p->aVar.pNext )
 		{
@@ -179,6 +184,9 @@
 	// Falls das Bit 0x8000 gesetzt ist, hat die Variable
 	// eine Parameterliste.
 	USHORT nId = ( eOp == _PARAM ) ? pDef->GetPos() : pDef->GetId();
+        if ( pGen->GetParser()->IsVBASupportOn() && ( eOp == _FIND_STATIC || eOp == _FIND_CM || eOp == _FIND ) )
+            nId = aVar.pDef->nLocalIndex ;
+
 	// Parameterliste aufbauen
 	if( aVar.pPar && aVar.pPar->GetSize() )
 	{
@@ -197,7 +205,7 @@
 		if( pProc->GetAlias().Len() )
 			nId = ( nId & 0x8000 ) | pGen->GetParser()->aGblStrings.Add( pProc->GetAlias() );
 	}
-	pGen->Gen( eOp, nId, sal::static_int_cast< UINT16 >( GetType() ) );
+        pGen->Gen( eOp, nId, sal::static_int_cast< UINT16 >( GetType() ) );
 
 	if( aVar.pvMorePar )
 	{
diff -r 869606102f87 basic/source/comp/parser.cxx
--- a/basic/source/comp/parser.cxx	Fri May 07 11:11:46 2010 +0100
+++ b/basic/source/comp/parser.cxx	Fri May 07 15:08:07 2010 +0100
@@ -123,6 +123,27 @@
 // 'this' : used in base member initializer list
 #pragma warning( disable: 4355 )
 #endif
+
+UINT32 SbiParser::GetProcRefOffset( SbiProcDef* pProcedure, INT32 nOp )
+{
+    INT32 nOffset = 0;
+    // find the ProcRefHandler for Procedure
+    // no procedure means initialization code, just give then a empty procedure name
+        String pName;
+    if ( pProcedure )
+        pName = pProcedure->GetName();
+    vProcRefHandlers::iterator it_end = m_vPropRefHandlers.end();
+    for ( vProcRefHandlers::iterator it = m_vPropRefHandlers.begin(); it != it_end; ++it )
+    {
+        if ( it->getName() == pName )
+            return it->getProcRefOffset( nOp );
+    }
+    // not found create new ProcRefHandler for pProc
+    ProcRefHandler procOffsets( pName );
+    nOffset = procOffsets.getProcRefOffset( nOp );
+    m_vPropRefHandlers.push_back( procOffsets );
+    return  nOffset;
+}
 
 SbiParser::SbiParser( StarBASIC* pb, SbModule* pm )
 		: SbiTokenizer( pm->GetSource32(), pb ),
diff -r 869606102f87 basic/source/comp/symtbl.cxx
--- a/basic/source/comp/symtbl.cxx	Fri May 07 11:11:46 2010 +0100
+++ b/basic/source/comp/symtbl.cxx	Fri May 07 15:08:07 2010 +0100
@@ -309,6 +309,7 @@
 	pIn		 =
 	pPool	 = NULL;
 	nDefaultId = 0;
+    nLocalIndex = 0;
 }
 
 SbiSymDef::~SbiSymDef()
@@ -413,7 +414,7 @@
 		 : SbiSymDef( rName )
 		 , aParams( pParser->aGblStrings, SbPARAM )  // wird gedumpt
 		 , aLabels( pParser->aLclStrings, SbLOCAL )	 // wird nicht gedumpt
-		 , mbProcDecl( bProcDecl )
+         , mbProcDecl( bProcDecl )
 {
 	aParams.SetParent( &pParser->aPublics );
 	pPool = new SbiSymPool( pParser->aGblStrings, SbLOCAL ); // Locals
diff -r 869606102f87 basic/source/inc/image.hxx
--- a/basic/source/inc/image.hxx	Fri May 07 11:11:46 2010 +0100
+++ b/basic/source/inc/image.hxx	Fri May 07 15:08:07 2010 +0100
@@ -36,11 +36,32 @@
 #include <rtl/ustring.hxx>
 #endif
 #include <filefmt.hxx>
+#include <vector>
+#include <map>
 
 // Diese Klasse liest das vom Compiler erzeugte Image ein und verwaltet
 // den Zugriff auf die einzelnen Elemente.
 
 struct SbPublicEntry;
+
+typedef std::map< UINT32, UINT32 > INT32ToINT32;
+
+class ProcRefHandler
+{
+    INT32ToINT32 mOpToOffsetMap;
+    INT32ToINT32 mOffsetToOp;
+    String m_sName;
+    INT32 m_nOffsetGen;
+public:
+    ProcRefHandler( const String& procName );
+    UINT32 getProcRefOffset( UINT32 nOp );
+    UINT32 getIdForProcRefOffset( UINT32 nOffset );
+    bool hasProcRefOffset( UINT32 nOp ) { return mOpToOffsetMap.find( nOp ) !=  mOpToOffsetMap.end(); }
+    String getName(){ return m_sName; }
+    INT32  getMaxOffset() { return  m_nOffsetGen; }
+};
+
+typedef std::vector< ProcRefHandler > vProcRefHandlers;
 
 class SbiImage {
 	friend class SbiCodeGen;			// Compiler-Klassen, die die private-
@@ -69,7 +90,11 @@
 	void AddType(SbxObject *);      // User-Type mit aufnehmen
 	void AddEnum(SbxObject *);      // Register enum type
 
+        vProcRefHandlers m_vPropRefHandlers;
 public:
+    short GetIDForString( const String& rName );
+        void SetProcRefs( const vProcRefHandlers& rHandlers ) { m_vPropRefHandlers =  rHandlers; }
+        ProcRefHandler* GetProcRef( const String& rProcName );
 	String aName;					// Makroname
     ::rtl::OUString aOUSource;		// Quellcode
 	String aComment;				// Kommentar
diff -r 869606102f87 basic/source/inc/parser.hxx
--- a/basic/source/inc/parser.hxx	Fri May 07 11:11:46 2010 +0100
+++ b/basic/source/inc/parser.hxx	Fri May 07 15:08:07 2010 +0100
@@ -37,14 +37,15 @@
 
 
 #include <vector>
+#include "image.hxx"
 typedef ::std::vector< String > IfaceVector;
 
 struct SbiParseStack;
-
 class SbiParser : public SbiTokenizer
 {
 	friend class SbiExpression;
-
+        vProcRefHandlers m_vPropRefHandlers;
+        
 	SbiParseStack* pStack;   		// Block-Stack
 	SbiProcDef* pProc;				// aktuelle Prozedur
 	SbiExprNode*  pWithVar;			// aktuelle With-Variable
@@ -69,6 +70,9 @@
 	void DefDeclare( BOOL bPrivate );
 	void EnableCompatibility();	
 public:
+        vProcRefHandlers& GetProcRefs() { return m_vPropRefHandlers; }
+        UINT32 GetProcRefOffset( SbiProcDef*, INT32 nOp );
+        SbiProcDef* GetProc() { return pProc;}	
 	SbxArrayRef	  rTypeArray;		// das Type-Array
 	SbxArrayRef	  rEnumArray;		// Enum types
 	SbiStringPool aGblStrings;		// der String-Pool
diff -r 869606102f87 basic/source/inc/runtime.hxx
--- a/basic/source/inc/runtime.hxx	Fri May 07 11:11:46 2010 +0100
+++ b/basic/source/inc/runtime.hxx	Fri May 07 15:08:07 2010 +0100
@@ -312,6 +312,7 @@
 	String		  aLibName;			// Lib-Name fuer Declare-Call
 	SbxArrayRef   refParams;        // aktuelle Prozedur-Parameter
 	SbxArrayRef   refLocals;        // lokale Variable
+    std::vector< SbxVariableRef* >*  refLocalDefines;
 	SbxArrayRef   refArgv;          // aktueller Argv
 	// AB, 28.3.2000 #74254, Ein refSaveObj reicht nicht! Neu: pRefSaveList (s.u.)
 	//SbxVariableRef refSaveObj;      // #56368 Bei StepElem Referenz sichern
diff -r 869606102f87 basic/source/inc/symtbl.hxx
--- a/basic/source/inc/symtbl.hxx	Fri May 07 11:11:46 2010 +0100
+++ b/basic/source/inc/symtbl.hxx	Fri May 07 15:08:07 2010 +0100
@@ -137,6 +137,7 @@
 	BOOL	   bParamArray : 1;		// TRUE: ParamArray parameter
 	USHORT	   nDefaultId;			// Symbol number of default value
 public:
+    sal_Int32 nLocalIndex;
 	SbiSymDef( const String& );
 	virtual ~SbiSymDef();
 	virtual SbiProcDef* GetProcDef();
diff -r 869606102f87 basic/source/runtime/runtime.cxx
--- a/basic/source/runtime/runtime.cxx	Fri May 07 11:11:46 2010 +0100
+++ b/basic/source/runtime/runtime.cxx	Fri May 07 15:08:07 2010 +0100
@@ -584,6 +584,7 @@
 #endif
 	pRefSaveList = NULL;
 	pItemStoreList = NULL;
+        refLocalDefines = NULL;
 }
 
 SbiRuntime::~SbiRuntime()
@@ -599,6 +600,18 @@
 		RefSaveItem* pToDeleteItem = pItemStoreList;
 		pItemStoreList = pToDeleteItem->pNext;
 		delete pToDeleteItem;
+    }
+        if ( refLocalDefines )
+    {
+        std::vector< SbxVariableRef* >::iterator it_end = refLocalDefines->end();
+        for ( std::vector< SbxVariableRef* >::iterator it = refLocalDefines->begin(); it!=it_end; ++it )
+        {
+            if ( (*it) )
+                delete (*it);
+        }
+        refLocalDefines->clear();
+        delete refLocalDefines;
+        refLocalDefines = NULL;
 	}
 }
 
diff -r 869606102f87 basic/source/runtime/stdobj.cxx
--- a/basic/source/runtime/stdobj.cxx	Fri May 07 11:11:46 2010 +0100
+++ b/basic/source/runtime/stdobj.cxx	Fri May 07 15:08:07 2010 +0100
@@ -36,6 +36,7 @@
 #include <basic/sbstdobj.hxx>
 #include "rtlproto.hxx"
 #include "sbintern.hxx"
+#include <hash_map>
 
 // Das nArgs-Feld eines Tabelleneintrags ist wie folgt verschluesselt:
 // Zur Zeit wird davon ausgegangen, dass Properties keine Parameter
diff -r 869606102f87 basic/source/runtime/step2.cxx
--- a/basic/source/runtime/step2.cxx	Fri May 07 11:11:46 2010 +0100
+++ b/basic/source/runtime/step2.cxx	Fri May 07 15:08:07 2010 +0100
@@ -55,6 +55,17 @@
 using com::sun::star::uno::Reference;
 
 SbxVariable* getVBAConstant( const String& rName );
+void initRefDefines( SbiImage* pImage, SbMethod* pMeth, std::vector< SbxVariableRef* >*&  refLocalDefines )
+{
+    // pMeth == NULL ( means this is an initialisation routine running )
+    ProcRefHandler* pHandler = pImage->GetProcRef( pMeth ? pMeth->GetName() : String() );
+    if ( pHandler )
+    {
+    refLocalDefines = new std::vector< SbxVariableRef* >( pHandler->getMaxOffset() ); 	
+    }	
+    else
+       StarBASIC::FatalError( SbERR_INTERNAL_ERROR );
+}
 
 // Suchen eines Elements
 // Die Bits im String-ID:
@@ -63,14 +74,8 @@
 SbxVariable* SbiRuntime::FindElement
 	( SbxObject* pObj, UINT32 nOp1, UINT32 nOp2, SbError nNotFound, BOOL bLocal, BOOL bStatic )
 {
-	bool bIsVBAInterOp = SbiRuntime::isVBAEnabled();
-	if( bIsVBAInterOp )
-	{
-		StarBASIC* pMSOMacroRuntimeLib = GetSbData()->pMSOMacroRuntimLib;
-		if( pMSOMacroRuntimeLib != NULL )
-			pMSOMacroRuntimeLib->ResetFlag( SBX_EXTSEARCH );
-	}
-
+    UINT32 nOffSet = nOp1;
+    ProcRefHandler* pHandler = NULL;
 	SbxVariable* pElem = NULL;
 	if( !pObj )
 	{
@@ -81,36 +86,68 @@
 	{
 		BOOL bFatalError = FALSE;
 		SbxDataType t = (SbxDataType) nOp2;
-		String aName( pImg->GetString( static_cast<short>( nOp1 & 0x7FFF ) ) );
-		// Hacky capture of Evaluate [] syntax
-		// this should be tackled I feel at the pcode level
-		if ( bIsVBAInterOp && aName.Search('[') == 0 )
-		{
-			// emulate pcode here
-			StepARGC();
-			// psuedo StepLOADSC
-			String sArg = aName.Copy( 1, aName.Len() - 2 );
-			SbxVariable* p = new SbxVariable;
-			p->PutString( sArg );
-			PushVar( p );
-			//
-			StepARGV();
-			nOp1 = nOp1 | 0x8000; // indicate params are present
-			aName = String::CreateFromAscii("Evaluate");
-		}
+        String aName;
+
 		if( bLocal )
 		{
-			if ( bStatic )
-			{	
-				if ( pMeth )
+
+            SbxVariableRef* pRef = NULL;
+                        if ( bVBAEnabled )
+                        {
+                            pRef = (*refLocalDefines)[ nOp1 & 0x7FFF ];
+                if ( pRef )
+                                pElem = *pRef;
+                        }
+                        if ( !pElem ) // not locally defined
+            {
+                if ( bVBAEnabled )
+                {
+                        pHandler = pMod->pImage->GetProcRef( pMeth ? pMeth->GetName() : String() );
+                    if ( pHandler )
+                    {
+                        bool bHasParams = false;
+                        if ( nOp1 & 0x8000 )
+                            bHasParams = true;
+                        nOp1 = pHandler->getIdForProcRefOffset( nOp1 & 0x7FFF );
+                        if ( bHasParams )
+                            nOp1 = nOp1 | 0x8000;
+                    }
+                }
+                aName = pImg->GetString( static_cast<short>( nOp1 & 0x7FFF ) );
+                if ( bStatic && pMeth )
 					pElem = pMeth->GetStatics()->Find( aName, SbxCLASS_DONTCARE );
+                if ( pElem && bVBAEnabled )
+                    ( *refLocalDefines )[ nOffSet & 0x7FFF ] = new SbxVariableRef( pElem );
 			}
+        }
 
-			if ( !pElem )
-				pElem = refLocals->Find( aName, SbxCLASS_DONTCARE );
+        if( bVBAEnabled )
+        {
+            StarBASIC* pMSOMacroRuntimeLib = GetSbData()->pMSOMacroRuntimLib;
+            if( pMSOMacroRuntimeLib != NULL )
+                pMSOMacroRuntimeLib->ResetFlag( SBX_EXTSEARCH );
 		}
+
 		if( !pElem )
 		{
+            if ( aName.Len() == 0 ) 
+                aName = pImg->GetString( static_cast<short>( nOp1 & 0x7FFF ) );
+            // Hacky capture of Evaluate [] syntax
+            // this should be tackled I feel at the pcode level
+            if ( bVBAEnabled && aName.Len() && aName.GetBuffer()[0] == '[') 
+            {
+                // emulate pcode here
+                StepARGC();
+                // psuedo StepLOADSC
+                String sArg = aName.Copy( 1, aName.Len() - 2 );
+                SbxVariable* p = new SbxVariable;
+                p->PutString( sArg );
+                PushVar( p );
+                //
+                StepARGV();
+                nOp1 = nOp1 | 0x8000; // indicate params are present
+                aName = String::CreateFromAscii("Evaluate");
+            }
 			// Die RTL brauchen wir nicht mehr zu durchsuchen!
 			BOOL bSave = rBasic.bNoRtl;
 			rBasic.bNoRtl = TRUE;
@@ -171,7 +208,10 @@
 					// deklarierten Vars automatisch global !
 					if ( bSetName )
 						pElem->SetName( aName );
-					refLocals->Put( pElem, refLocals->Count() );
+                    if ( bVBAEnabled )
+                        ( *refLocalDefines )[ nOffSet & 0x7FFF ] = new SbxVariableRef( pElem );
+                    else
+                        refLocals->Put( pElem, refLocals->Count() );
 				}
 			}
 
@@ -217,7 +257,10 @@
 						if( t != SbxVARIANT )
 							pElem->SetFlag( SBX_FIXED );
 						pElem->SetName( aName );
-						refLocals->Put( pElem, refLocals->Count() );
+                        if ( bVBAEnabled )
+                            ( *refLocalDefines )[ nOffSet & 0x7FFF ] = new SbxVariableRef( pElem );
+                        else
+                            refLocals->Put( pElem, refLocals->Count() );
 					}
 				}
 			}
@@ -294,7 +337,21 @@
 		return NULL;
 
 	// Lokal suchen
-	if( refLocals )
+    if ( bVBAEnabled && refLocalDefines )
+    {
+        INT32 nOp1 = pMod->pImage->GetIDForString( rName );
+        ProcRefHandler* pHandler = pMod->pImage->GetProcRef( pMeth ? pMeth->GetName() : String() );
+        if ( pHandler )
+        {
+            if ( pHandler->hasProcRefOffset( nOp1 ) )
+            {
+                SbxVariableRef* pRef = (*refLocalDefines)[ pHandler->getProcRefOffset( nOp1 ) ];
+                if ( pRef )	
+                    pElem = *pRef;
+            }
+        }
+    }
+    else if( refLocals )
 		pElem = refLocals->Find( rName, SbxCLASS_DONTCARE );
 
 	// In Statics suchen
@@ -304,7 +361,10 @@
 		String aMethName = pMeth->GetName();
 		aMethName += ':';
 		aMethName += rName;
-		pElem = pMod->Find(aMethName, SbxCLASS_DONTCARE);
+        if ( !pElem )
+            pElem = pMeth->GetStatics()->Find( aMethName, SbxCLASS_DONTCARE );
+        if ( !pElem )
+            pElem = pMod->Find(aMethName, SbxCLASS_DONTCARE);
 	}
 
 	// In Parameter-Liste suchen
@@ -608,8 +668,11 @@
 void
 SbiRuntime::StepFIND_Impl( SbxObject* pObj, UINT32 nOp1, UINT32 nOp2, SbError nNotFound, BOOL bLocal, BOOL bStatic )
 {
+
 	if( !refLocals )
 		refLocals = new SbxArray;
+    if( bVBAEnabled && !refLocalDefines )
+        initRefDefines( pMod->pImage, pMeth, refLocalDefines );
 	PushVar( FindElement( pObj, nOp1, nOp2, nNotFound, bLocal, bStatic ) );
 }
 // Laden einer lokalen/globalen Variablen (+StringID+Typ)
@@ -1083,15 +1146,38 @@
 
 void SbiRuntime::StepLOCAL( UINT32 nOp1, UINT32 nOp2 )
 {
-	if( !refLocals.Is() )
-		refLocals = new SbxArray;
-	String aName( pImg->GetString( static_cast<short>( nOp1 ) ) );
-	if( refLocals->Find( aName, SbxCLASS_DONTCARE ) == NULL )
+    if ( bVBAEnabled )
 	{
+        if ( !refLocalDefines )
+        {
+            initRefDefines( pMod->pImage, pMeth, refLocalDefines );
+        }
 		SbxDataType t = (SbxDataType) nOp2;
-		SbxVariable* p = new SbxVariable( t );
-		p->SetName( aName );
-		refLocals->Put( p, refLocals->Count() );
+                (*refLocalDefines)[ nOp1 ] = new SbxVariableRef( new SbxVariable( t ) );
+        ProcRefHandler* pHandler = pMod->pImage->GetProcRef( pMeth ? pMeth->GetName() : String() );
+#if 0 // do we need to set the name ?
+        if ( pHandler )
+        {
+            UINT32 nTmpOp1 = pHandler->getIdForProcRefOffset( nOp1 & 0x7FFF );
+            String aName = pImg->GetString( static_cast<short>( nTmpOp1 ) );
+            SbxVariable* pElem = *(*refLocalDefines)[ nOp1 ];
+            pElem->SetName( aName );
+        }
+#endif
+        //p->SetName( aName );
+    }
+        else
+        {
+        if( !refLocals.Is() )
+            refLocals = new SbxArray;
+        String aName( pImg->GetString( static_cast<short>( nOp1 ) ) );
+        if( refLocals->Find( aName, SbxCLASS_DONTCARE ) == NULL )
+        {
+            SbxDataType t = (SbxDataType) nOp2;
+            SbxVariable* p = new SbxVariable( t );
+            p->SetName( aName );
+            refLocals->Put( p, refLocals->Count() );
+        }
 	}
 }
 
