Only in sc/inc: address.hxx~
diff -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/sc/inc/cell.hxx sc/inc/cell.hxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/sc/inc/cell.hxx	2006-09-22 15:39:57.000000000 +0100
+++ sc/inc/cell.hxx	2006-09-23 21:38:35.000000000 +0100
@@ -279,6 +279,9 @@
                         SCITP_CLOSE_ITERATION_CIRCLE
                     };
 	void			InterpretTail( ScInterpretTailParameter );
+	void            DoEnglishCompile( rtl::OUStringBuffer &rBuffer,
+									  const ScAddress &rPos,
+									  BOOL bCompileXML ) const;
 
 public:
 
Only in sc/inc: cell.hxx~
Only in sc/inc: compiler.hxx~
diff -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/core/data/cell2.cxx sc/source/core/data/cell2.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/core/data/cell2.cxx	2006-09-22 15:39:59.000000000 +0100
+++ sc/source/core/data/cell2.cxx	2006-09-25 18:01:29.000000000 +0100
@@ -245,59 +245,41 @@
 void ScFormulaCell::GetEnglishFormula( String& rFormula, BOOL bCompileXML,
 									   ScAddress::Convention conv ) const
 {
-    //! mit GetFormula zusammenfassen !!!
+	rtl::OUStringBuffer rBuffer( rFormula );
+	GetEnglishFormula( rBuffer, bCompileXML, conv );
+	rFormula = rBuffer;
+}
+
+static bool HasMissing( ScTokenArray *pCode );
+static ScTokenArray *ReWriteMissingForSXW( ScTokenArray *pCode );
+
+void ScFormulaCell::DoEnglishCompile( rtl::OUStringBuffer &rBuffer,
+									  const ScAddress &rPos, 
+									  BOOL bCompileXML ) const
+{
+	ScTokenArray *pCompileCode = pCode;
+	if (bCompileXML)
+	{
+		 /* Scan pCode [ token array ! ] for missing args &
+			re-write if present */
+		if ( HasMissing( pCode ) )
+			pCompileCode = ReWriteMissingForSXW( pCode );
+	}
+
+	ScCompiler aComp( pDocument, rPos, *pCompileCode );
+	aComp.SetCompileEnglish( TRUE );
+	aComp.SetCompileXML( bCompileXML );
+	aComp.CreateStringFromTokenArray( rBuffer );
+	if( bCompileXML )
+	{
+		rtl::OUStringBuffer aTmp( rBuffer );
+		fprintf( stderr, "English '%s'\n",
+				 rtl::OUStringToOString( aTmp.makeStringAndClear(),
+										 RTL_TEXTENCODING_UTF8 ).getStr() );
+	}
 
-    if( pCode->GetError() && !pCode->GetLen() )
-    {
-        rFormula = ScGlobal::GetErrorString( pCode->GetError() ); return;
-    }
-    else if( cMatrixFlag == MM_REFERENCE )
-    {
-        // Referenz auf eine andere Zelle, die eine Matrixformel enthaelt
-        pCode->Reset();
-        ScToken* p = pCode->GetNextReferenceRPN();
-        if( p )
-        {
-            ScBaseCell* pCell;
-            SingleRefData& rRef = p->GetSingleRef();
-            rRef.CalcAbsIfRel( aPos );
-            if ( rRef.Valid() )
-                pCell = pDocument->GetCell( ScAddress( rRef.nCol,
-                    rRef.nRow, rRef.nTab ) );
-            else
-                pCell = NULL;
-            if (pCell && pCell->GetCellType() == CELLTYPE_FORMULA)
-            {
-                ((ScFormulaCell*)pCell)->GetEnglishFormula(rFormula, bCompileXML, conv);
-                return;
-            }
-            else
-            {
-                ScCompiler aComp( pDocument, aPos, *pCode );
-                aComp.SetCompileEnglish( TRUE );
-                aComp.SetCompileXML( bCompileXML );
-                aComp.CreateStringFromTokenArray( rFormula );
-            }
-        }
-        else
-        {
-            DBG_ERROR("ScFormulaCell::GetEnglishFormula: Keine Matrix");
-        }
-    }
-    else
-    {
-        ScCompiler aComp( pDocument, aPos, *pCode );
-        aComp.SetCompileEnglish( TRUE );
-        aComp.SetCompileXML( bCompileXML );
-        aComp.CreateStringFromTokenArray( rFormula );
-    }
-
-    rFormula.Insert( '=',0 );
-    if( cMatrixFlag )
-    {
-        rFormula.Insert('{', 0);
-        rFormula += '}';
-    }
+	if ( pCompileCode != pCode )
+		delete pCompileCode;
 }
 
 void ScFormulaCell::GetEnglishFormula( rtl::OUStringBuffer& rBuffer, BOOL bCompileXML,
@@ -330,12 +312,7 @@
                 return;
             }
             else
-            {
-                ScCompiler aComp( pDocument, aPos, *pCode );
-                aComp.SetCompileEnglish( TRUE );
-                aComp.SetCompileXML( bCompileXML );
-                aComp.CreateStringFromTokenArray( rBuffer );
-            }
+				DoEnglishCompile( rBuffer, aPos, bCompileXML );
         }
         else
         {
@@ -343,12 +320,7 @@
         }
     }
     else
-    {
-        ScCompiler aComp( pDocument, aPos, *pCode );
-        aComp.SetCompileEnglish( TRUE );
-        aComp.SetCompileXML( bCompileXML );
-        aComp.CreateStringFromTokenArray( rBuffer );
-    }
+		DoEnglishCompile( rBuffer, aPos, bCompileXML );
 
     sal_Unicode ch('=');
     rBuffer.insert( 0, &ch, 1 );
@@ -1555,6 +1527,168 @@
 }
 
 
+// ---- Move me to a more sensible place ----
 
 
+static void DumpTokArr( ScTokenArray *pCode )
+{
+	fprintf (stderr, "HasMissing: ");
+	for ( ScToken *pCur = pCode->First(); pCur; pCur = pCode->Next() )
+		fprintf( stderr, "t%d,o%d ",
+				 pCur->GetType(), pCur->GetOpCode() );
+	fprintf (stderr, "\n");
+}
+
+static bool HasMissing( ScTokenArray *pCode )
+{
+	for ( ScToken *pCur = pCode->First(); pCur; pCur = pCode->Next() )
+		if (pCur->GetOpCode() == ocMissing)
+			return true;
+	return false;
+}
+
+struct MissingContext {
+		ScToken *pFunc;
+		int      nCurArg;
+};
+
+#define DEFAULT_ARG(arr,n,d) \
+		if (rCtx.nCurArg == (n)) \
+		{ \
+			(arr)->AddDouble( d ); \
+			return true; \
+		}
+
+static bool AddMissingExternal( const MissingContext &rCtx, ScTokenArray *pNewArr )
+{
+	const String &rName = rCtx.pFunc->GetExternal();
+
+	// initial (fast) check:
+	sal_Unicode nLastChar = rName.GetChar( rName.Len() - 1);
+	if ( nLastChar != 't' && nLastChar != 'm' )
+		return false;
+
+	if (rName.EqualsIgnoreCaseAscii(
+			"com.sun.star.sheet.addin.Analysis.getAccrint" ))
+	{
+		DEFAULT_ARG( pNewArr, 4, 1000.0 );
+	}
+	if (rName.EqualsIgnoreCaseAscii(
+			"com.sun.star.sheet.addin.Analysis.getAccrintm" ))
+	{
+		DEFAULT_ARG( pNewArr, 3, 1000.0 );
+	}
+// FIXME: when we implement EUROCONVERT
+//	if (rName.EqualsIgnoreCaseAscii( "EUROCONVERT" ))
+//		DEFAULT_ARG( pNewArr, 3, 0.0 );
+}
+
+static bool AddMissing( const MissingContext &rCtx,
+						ScTokenArray *pNewArr )
+{
+	if ( !rCtx.pFunc )
+		return false;
+
+	switch ( rCtx.pFunc->GetOpCode() ) 
+	{
+	case ocFixed:
+		DEFAULT_ARG( pNewArr, 1, 2.0 );
+		break;
+	case ocBetaDist:
+	case ocBetaInv:
+	case ocRMZ:  // PMT 
+		DEFAULT_ARG( pNewArr, 3, 0.0 );
+		break;
+	case ocZinsZ: // IPMT
+	case ocKapz:  // PPMT
+		DEFAULT_ARG( pNewArr, 4, 0.0 );
+		break;
+	case ocBW: // PV
+	case ocZW: // FV
+		DEFAULT_ARG( pNewArr, 2, 0.0 ); // pmt
+		DEFAULT_ARG( pNewArr, 3, 0.0 ); // [fp]v
+		break;
+	case ocZins: // RATE
+		DEFAULT_ARG( pNewArr, 1, 0.0 ); // pmt
+		DEFAULT_ARG( pNewArr, 3, 0.0 ); // fv
+		DEFAULT_ARG( pNewArr, 4, 0.0 ); // type
+		break;
+	case ocExternal:
+		return AddMissingExternal( rCtx, pNewArr );
+		break;
+
+	// --- more complex cases ---
+
+	case ocOffset:
+		// FIXME: rather tough.
+		// if arg 3 (height) ommitted, export arg1 (rows)
+		break;
+	case ocAdress:
+		// FIXME - should we adjust 'ADDRESS_XL(?)' at this point?
+		// (arg 4 -> 'TRUE' ? [ or no arg. 4 ;-] )
+		break;
+	default:
+		break;
+	}
+
+	return false;
+}
+
+static void AddMoreArgs( const MissingContext &rCtx,
+						 ScTokenArray *pNewArr )
+{
+	if ( !rCtx.pFunc )
+		return;
+
+	// Log
+	if ( rCtx.pFunc->GetOpCode() == ocLog &&
+		 rCtx.nCurArg < 1 )
+		pNewArr->AddDouble( 10.0 );
+}
+
+#undef EXPECT
+
+static ScTokenArray *ReWriteMissingForSXW( ScTokenArray *pCode )
+{
+	MissingContext aCtx[ pCode->GetLen() ];
+	int nFn = -1;
+
+	ScTokenArray *pNewArr = new ScTokenArray();
+
+	for ( ScToken *pCur = pCode->First(); pCur;
+		  pCur = pCode->NextNoSpaces() )
+	{
+		bool bAdd = true;
+		switch ( pCur->GetOpCode() )
+		{
+			case ocOpen:
+				aCtx[ ++nFn ].pFunc = pCode->PeekPrevNoSpaces();
+				aCtx[ nFn ].nCurArg = 0;
+				break;
+			case ocClose:
+				AddMoreArgs( aCtx[ nFn ], pNewArr );
+				--nFn;
+				break;
+			case ocSep:
+				aCtx[ nFn ].nCurArg++;
+				break;
+			case ocMissing:
+			{
+				fprintf( stderr, "Missing arg %d on fn t%d,o%d\n",
+						 aCtx[ nFn ].nCurArg, 
+						 aCtx[ nFn ].pFunc->GetType(),
+						 aCtx[ nFn ].pFunc->GetOpCode() );
+				// FIXME: if we didn't know about this, should we
+				// simply elide it [ a var-arg case ? ]
+				bAdd = !AddMissing( aCtx[ nFn ], pNewArr );
+				break;
+			}
+			default:
+				break;
+		}
+		if ( bAdd )
+			pNewArr->AddToken( *pCur );
+	}
 
+	return pNewArr;
+}
Only in sc/source/core/data: cell2.cxx~
diff -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/core/inc/interpre.hxx sc/source/core/inc/interpre.hxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/core/inc/interpre.hxx	2006-09-22 15:39:59.000000000 +0100
+++ sc/source/core/inc/interpre.hxx	2006-09-26 12:56:25.000000000 +0100
@@ -269,6 +269,7 @@
 // generiert aus DoubleRef positionsabhaengige SingleRef
 BOOL DoubleRefToPosSingleRef( const ScRange& rRange, ScAddress& rAdr );
 double GetDouble();
+BOOL IsMissing();
 BOOL GetBool() { return GetDouble() != 0.0; }
 const String& GetString();
 // pop matrix and obtain one element, upper left or according to jump matrix
Only in sc/source/core/inc: interpre.hxx~
diff -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/core/tool/compiler.cxx sc/source/core/tool/compiler.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/core/tool/compiler.cxx	2006-09-22 15:39:59.000000000 +0100
+++ sc/source/core/tool/compiler.cxx	2006-09-26 17:30:31.000000000 +0100
@@ -3117,14 +3117,10 @@
             SetError( errParameterExpected );
         }
         else if ( eOp == ocMissing )
-        {   // #84460# May occur if imported from Xcl.
-            // The real value for missing parameters depends on the function
-            // where it is used, interpreter would have to handle this.
-            // If it does remove this error case here, that could also be the
-            // time to generate ocMissing in between subsequent ocSep.
-            // Xcl import should map missings to values if possible.
-            SetError( errParameterExpected );
-        }
+		{
+			PutCode( pToken );
+			NextToken();
+		}
         else if ( eOp == ocSep )
         {   // Subsequent ocSep
             SetError( errParameterExpected );
Only in sc/source/core/tool: compiler.cxx~
diff -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/core/tool/interpr2.cxx sc/source/core/tool/interpr2.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/core/tool/interpr2.cxx	2006-09-22 15:39:57.000000000 +0100
+++ sc/source/core/tool/interpr2.cxx	2006-09-26 16:14:37.000000000 +0100
@@ -542,9 +542,14 @@
 
 void ScInterpreter::ScLog()
 {
-	if ( MustHaveParamCount( GetByte(), 2 ) )
+	BYTE nParamCount = GetByte();
+	if ( MustHaveParamCount( nParamCount, 1, 2 ) )
 	{
-		double nBase = GetDouble();
+		double nBase;
+		if (nParamCount == 2)
+			nBase = GetDouble();
+		else
+			nBase = 10.0;
 		double nVal = GetDouble();
 		if (nVal > 0.0 && nBase > 0.0 && nBase != 1.0)
 			PushDouble(log(nVal) / log(nBase));
@@ -1098,6 +1103,7 @@
 
 void ScInterpreter::ScRMZ()
 {
+	fprintf(stderr, "ScInterpreter::ScRMZ\n");
 	double nZins, nZzr, nBw, nZw = 0, nFlag = 0;
 	nFuncFmtType = NUMBERFORMAT_CURRENCY;
 	BYTE nParamCount = GetByte();
Only in sc/source/core/tool: interpr2.cxx~
diff -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/core/tool/interpr3.cxx sc/source/core/tool/interpr3.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/core/tool/interpr3.cxx	2006-09-22 15:39:57.000000000 +0100
+++ sc/source/core/tool/interpr3.cxx	2006-09-26 16:21:44.000000000 +0100
@@ -680,6 +680,7 @@
 
 void ScInterpreter::ScBetaDist()
 {
+	fprintf (stderr, "ScBetaDist!\n");
 	BYTE nParamCount = GetByte();
 	if ( !MustHaveParamCount( nParamCount, 3, 5 ) )
 		return;
Only in sc/source/core/tool: interpr3.cxx~
diff -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/core/tool/interpr4.cxx sc/source/core/tool/interpr4.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/core/tool/interpr4.cxx	2006-09-22 15:39:59.000000000 +0100
+++ sc/source/core/tool/interpr4.cxx	2006-09-26 16:20:38.000000000 +0100
@@ -1433,6 +1433,10 @@
 	return bOk;
 }
 
+BOOL ScInterpreter::IsMissing()
+{
+	return GetStackType() == svMissing;
+}
 
 double ScInterpreter::GetDouble()
 {
@@ -1497,6 +1501,9 @@
             }
         }
         break;
+		case svMissing:
+			nVal = 0.0;
+		break;
 		default:
 			Pop();
 			SetError(errIllegalParameter);
@@ -3158,6 +3165,8 @@
     // so reassure exceptions are really off.
     SAL_MATH_FPEXCEPTIONS_OFF();
 
+	fprintf (stderr, "--- Interpret ---\n");
+
 	aCode.Reset();
 	while( ( pCur = aCode.Next() ) != NULL
 			&& (!nGlobalError || nErrorFunction <= nErrorFunctionCount) )
@@ -3526,6 +3535,9 @@
                 default : SetError(errUnknownOpCode); PushInt(0);       break;
             }
 
+			fprintf (stderr, "Processed op %d (err %d)\n",
+					 eOp, nGlobalError);
+
             // Remember result matrix in case it could be reused.
             if (pTokenMatrixMap && sp && GetStackType() == svMatrix)
                 pTokenMatrixMap->insert( ScTokenMatrixMap::value_type( pCur,
Only in sc/source/core/tool: interpr4.cxx~
diff -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/filter/excel/excform.cxx sc/source/filter/excel/excform.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/filter/excel/excform.cxx	2006-09-22 15:39:59.000000000 +0100
+++ sc/source/filter/excel/excform.cxx	2006-09-25 18:21:21.000000000 +0100
@@ -1329,9 +1329,7 @@
 	TokenId					eParam[ 256 ];
 	INT32					nLauf;
 
-    if( eId == ocLog && nAnz == 1 )
-        eId = ocLog10;
-	else if( eId == ocCeil || eId == ocFloor )
+	if( eId == ocCeil || eId == ocFloor )
 	{
 		aStack << aPool.Store( 1.0 );	// default, da in Excel nicht vorhanden
 		nAnz++;
Only in sc/source/filter/excel: excform.cxx~
