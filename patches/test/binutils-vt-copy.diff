diff -u -r /usr/src/packages/BUILD/binutils-2.16.91.0.5/ld/ldmain.c binutils-2.16.91.0.5/ld/ldmain.c
--- /usr/src/packages/BUILD/binutils-2.16.91.0.5/ld/ldmain.c	2007-02-16 17:15:13.000000000 +0000
+++ binutils-2.16.91.0.5/ld/ldmain.c	2007-03-12 11:10:17.000000000 +0000
@@ -1101,6 +1101,7 @@
 	    asection *section,
 	    bfd_vma value)
 {
+  fprintf (stderr, "add_to_set '%s'\n", h->root.string);
   if (config.warn_constructors)
     einfo (_("%P: warning: global constructor %s used\n"),
 	   h->root.string);
Only in binutils-2.16.91.0.5/ld: ldmain.o
Only in binutils-2.16.91.0.5/ld: ldmisc.o
Only in binutils-2.16.91.0.5/ld: ld-new
Only in binutils-2.16.91.0.5/ld: ldscripts
Only in binutils-2.16.91.0.5/ld: ldver.o
Only in binutils-2.16.91.0.5/ld: ldver.texi
Only in binutils-2.16.91.0.5/ld: ldwrite.o
diff -u -r /usr/src/packages/BUILD/binutils-2.16.91.0.5/ld/lexsup.c binutils-2.16.91.0.5/ld/lexsup.c
--- /usr/src/packages/BUILD/binutils-2.16.91.0.5/ld/lexsup.c	2007-02-16 17:15:13.000000000 +0000
+++ binutils-2.16.91.0.5/ld/lexsup.c	2007-03-12 11:10:17.000000000 +0000
@@ -152,6 +152,7 @@
   OPTION_ACCEPT_UNKNOWN_INPUT_ARCH,
   OPTION_NO_ACCEPT_UNKNOWN_INPUT_ARCH,
   OPTION_PIE,
+  OPTION_VTRELOC,
   OPTION_UNRESOLVED_SYMBOLS,
   OPTION_WARN_UNRESOLVED_SYMBOLS,
   OPTION_ERROR_UNRESOLVED_SYMBOLS,
@@ -398,6 +399,8 @@
   { {"no-undefined", no_argument, NULL, OPTION_NO_UNDEFINED},
     '\0', NULL, N_("Do not allow unresolved references in object files"),
     TWO_DASHES },
+  { {"vtreloc", no_argument, NULL, OPTION_VTRELOC},
+    '\0', NULL, N_("Build vtable copy reloc data"), TWO_DASHES },
   { {"allow-shlib-undefined", no_argument, NULL, OPTION_ALLOW_SHLIB_UNDEFINED},
     '\0', NULL, N_("Allow unresolved references in shared libaries"),
     TWO_DASHES },
@@ -1131,6 +1134,9 @@
 	  parser_input = input_script;
 	  yyparse ();
 	  break;
+	case OPTION_VTRELOC:
+	  link_info.vtreloc = TRUE;
+	  break;
 	case OPTION_SECTION_START:
 	  {
 	    char *optarg2;
Only in binutils-2.16.91.0.5/ld: lexsup.o
Only in binutils-2.16.91.0.5/ld: .libs
Only in binutils-2.16.91.0.5/ld: libtool
Only in binutils-2.16.91.0.5/ld: Makefile
Only in binutils-2.16.91.0.5/ld: mri.o
Only in binutils-2.16.91.0.5/ld/po: Makefile
Only in binutils-2.16.91.0.5/ld/po: Makefile.in
Only in binutils-2.16.91.0.5/ld/po: POTFILES
diff -u -r /usr/src/packages/BUILD/binutils-2.16.91.0.5/ld/scripttempl/elf.sc binutils-2.16.91.0.5/ld/scripttempl/elf.sc
--- /usr/src/packages/BUILD/binutils-2.16.91.0.5/ld/scripttempl/elf.sc	2005-12-20 22:43:57.000000000 +0000
+++ binutils-2.16.91.0.5/ld/scripttempl/elf.sc	2007-03-14 14:54:53.000000000 +0000
@@ -275,6 +275,7 @@
 eval $COMBRELOCCAT <<EOF
   .rel.init     ${RELOCATING-0} : { *(.rel.init) }
   .rela.init    ${RELOCATING-0} : { *(.rela.init) }
+  .rel.suse.vtrelocs     ${RELOCATING-0} : { *(.rel.suse.vtrelocs) }
   .rel.text     ${RELOCATING-0} : { *(.rel.text${RELOCATING+ .rel.text.* .rel.gnu.linkonce.t.*}) }
   .rela.text    ${RELOCATING-0} : { *(.rela.text${RELOCATING+ .rela.text.* .rela.gnu.linkonce.t.*}) }
   .rel.fini     ${RELOCATING-0} : { *(.rel.fini) }
@@ -311,7 +312,7 @@
     {
 EOF
 sed -e '/^[ 	]*[{}][ 	]*$/d;/:[ 	]*$/d;/\.rela\./d;s/^.*: { *\(.*\)}$/      \1/' $COMBRELOC
-cat <<EOF
+cat <<EOF 
     }
   .rela.dyn     ${RELOCATING-0} :
     {
@@ -399,6 +400,13 @@
   ${SMALL_DATA_DTOR-${RELOCATING+${DTOR}}}
   .jcr          ${RELOCATING-0} : { KEEP (*(.jcr)) }
 
+  /* Virtual table copy relocation tables */
+  __vtrelocs = .;
+  .suse.vtrelocs  :
+  {
+    KEEP (*(.suse.vtrelocs))
+  }
+
   ${RELOCATING+${DATARELRO}}
   ${OTHER_RELRO_SECTIONS}
   ${TEXT_DYNAMIC-${DYNAMIC}}
Only in binutils-2.16.91.0.5/ld/scripttempl: elf.sc~
Only in binutils-2.16.91.0.5/ld: stamp-h1
Only in binutils-2.16.91.0.5/ld: stringify.sed
Only in binutils-2.16.91.0.5/ld: tdirs
Only in binutils-2.16.91.0.5/ld: tmpdir
Only in binutils-2.16.91.0.5/bfd: aout32.lo
Only in binutils-2.16.91.0.5/bfd: aout32.o
Only in binutils-2.16.91.0.5/bfd: archive64.lo
Only in binutils-2.16.91.0.5/bfd: archive64.o
Only in binutils-2.16.91.0.5/bfd: archive.lo
Only in binutils-2.16.91.0.5/bfd: archive.o
Only in binutils-2.16.91.0.5/bfd: archures.lo
Only in binutils-2.16.91.0.5/bfd: archures.o
Only in binutils-2.16.91.0.5/bfd: bfd.h
Only in binutils-2.16.91.0.5/bfd: bfd-in3.h
Only in binutils-2.16.91.0.5/bfd: bfdio.lo
Only in binutils-2.16.91.0.5/bfd: bfdio.o
Only in binutils-2.16.91.0.5/bfd: bfd.lo
Only in binutils-2.16.91.0.5/bfd: bfd.o
Only in binutils-2.16.91.0.5/bfd: bfdsort.lo
Only in binutils-2.16.91.0.5/bfd: bfdsort.o
Only in binutils-2.16.91.0.5/bfd: bfdver.h
Only in binutils-2.16.91.0.5/bfd: bfdwin.lo
Only in binutils-2.16.91.0.5/bfd: bfdwin.o
Only in binutils-2.16.91.0.5/bfd: binary.lo
Only in binutils-2.16.91.0.5/bfd: binary.o
Only in binutils-2.16.91.0.5/bfd: cache.lo
Only in binutils-2.16.91.0.5/bfd: cache.o
Only in binutils-2.16.91.0.5/bfd: coffgen.lo
Only in binutils-2.16.91.0.5/bfd: coffgen.o
Only in binutils-2.16.91.0.5/bfd: cofflink.lo
Only in binutils-2.16.91.0.5/bfd: cofflink.o
Only in binutils-2.16.91.0.5/bfd: config.cache
Only in binutils-2.16.91.0.5/bfd: config.h
Only in binutils-2.16.91.0.5/bfd: config.log
Only in binutils-2.16.91.0.5/bfd: config.status
diff -u -r /usr/src/packages/BUILD/binutils-2.16.91.0.5/bfd/configure binutils-2.16.91.0.5/bfd/configure
--- /usr/src/packages/BUILD/binutils-2.16.91.0.5/bfd/configure	2005-12-20 22:43:55.000000000 +0000
+++ binutils-2.16.91.0.5/bfd/configure	2007-03-12 11:10:17.000000000 +0000
@@ -12936,7 +12936,7 @@
 # Target backend .o files.
 tb=
 
-elf="elf.lo elflink.lo elf-strtab.lo elf-eh-frame.lo dwarf1.lo"
+elf="elf.lo elflink.lo elf-vtreloc.lo elf-strtab.lo elf-eh-frame.lo dwarf1.lo"
 
 for vec in $selvecs
 do
diff -u -r /usr/src/packages/BUILD/binutils-2.16.91.0.5/bfd/configure.in binutils-2.16.91.0.5/bfd/configure.in
--- /usr/src/packages/BUILD/binutils-2.16.91.0.5/bfd/configure.in	2005-12-20 22:43:55.000000000 +0000
+++ binutils-2.16.91.0.5/bfd/configure.in	2007-03-12 11:10:17.000000000 +0000
@@ -551,7 +551,7 @@
 # Target backend .o files.
 tb=
 
-elf="elf.lo elflink.lo elf-strtab.lo elf-eh-frame.lo dwarf1.lo"
+elf="elf.lo elflink.lo elf-vtreloc.lo elf-strtab.lo elf-eh-frame.lo dwarf1.lo"
 
 for vec in $selvecs
 do
diff -u -r /usr/src/packages/BUILD/binutils-2.16.91.0.5/bfd/elf-bfd.h binutils-2.16.91.0.5/bfd/elf-bfd.h
--- /usr/src/packages/BUILD/binutils-2.16.91.0.5/bfd/elf-bfd.h	2007-02-16 17:15:13.000000000 +0000
+++ binutils-2.16.91.0.5/bfd/elf-bfd.h	2007-03-12 11:10:17.000000000 +0000
@@ -1685,6 +1685,12 @@
 extern struct elf_link_hash_entry *_bfd_elf_define_linkage_sym
   (bfd *, struct bfd_link_info *, asection *, const char *);
 
+/* elf-vtreloc */
+extern bfd_boolean _bfd_elf_vtreloc_accumulate
+  (bfd *, struct bfd_link_info *);
+extern bfd_boolean _bfd_elf_vtreloc_fill
+  (bfd *, struct bfd_link_info *);
+
 extern bfd_boolean _bfd_elfcore_make_pseudosection
   (bfd *, char *, size_t, ufile_ptr);
 extern char *_bfd_elfcore_strndup
diff -u -r /usr/src/packages/BUILD/binutils-2.16.91.0.5/bfd/elf-bfd.h.orig binutils-2.16.91.0.5/bfd/elf-bfd.h.orig
--- /usr/src/packages/BUILD/binutils-2.16.91.0.5/bfd/elf-bfd.h.orig	2007-02-16 17:15:13.000000000 +0000
+++ binutils-2.16.91.0.5/bfd/elf-bfd.h.orig	2007-02-16 17:15:13.000000000 +0000
@@ -1177,6 +1177,10 @@
      the linker.  */
   asection *next_in_group;
 
+  /* The pointer to the real kept section. It is computed from the
+     kept_section field in asection due to section group.  */ 
+  asection *kept_section;
+
   /* A pointer used for various section optimizations.  */
   void *sec_info;
 };
@@ -1189,6 +1193,7 @@
 #define elf_group_id(sec)      (elf_section_data(sec)->group.id)
 #define elf_next_in_group(sec) (elf_section_data(sec)->next_in_group)
 #define elf_sec_group(sec)	(elf_section_data(sec)->sec_group)
+#define elf_kept_section(sec) (elf_section_data(sec)->kept_section)
 
 /* Return TRUE if section has been discarded.  */
 #define elf_discarded_section(sec)				\
diff -u -r /usr/src/packages/BUILD/binutils-2.16.91.0.5/bfd/elf.c binutils-2.16.91.0.5/bfd/elf.c
--- /usr/src/packages/BUILD/binutils-2.16.91.0.5/bfd/elf.c	2007-02-16 17:15:13.000000000 +0000
+++ binutils-2.16.91.0.5/bfd/elf.c	2007-03-12 11:10:17.000000000 +0000
@@ -1229,6 +1229,7 @@
 	    case DT_USED: name = "USED"; break;
 	    case DT_FILTER: name = "FILTER"; stringp = TRUE; break;
 	    case DT_SUSE_HASHVALS: name = "SUSE_HASHVALS"; break;
+        case DT_SUSE_VTRELOC: name = "SUSE_VTRELOC"; break;
 	    }
 
 	  fprintf (f, "  %-11s ", name);
Only in binutils-2.16.91.0.5/bfd: elf-eh-frame.lo
Only in binutils-2.16.91.0.5/bfd: elf-eh-frame.o
diff -u -r /usr/src/packages/BUILD/binutils-2.16.91.0.5/bfd/elflink.c binutils-2.16.91.0.5/bfd/elflink.c
--- /usr/src/packages/BUILD/binutils-2.16.91.0.5/bfd/elflink.c	2007-02-16 17:15:13.000000000 +0000
+++ binutils-2.16.91.0.5/bfd/elflink.c	2007-03-14 16:42:13.000000000 +0000
@@ -146,6 +146,34 @@
   return TRUE;
 }
 
+static int
+_bfd_elf_create_vtreloc_sections (struct bfd_link_info *info)
+{
+  bfd *abfd;
+  asection *s;
+  flagword flags;
+  const struct elf_backend_data *bed;
+
+  abfd = elf_hash_table (info)->dynobj;
+  bed = get_elf_backend_data (abfd);
+  flags = bed->dynamic_sec_flags;
+
+  s = bfd_make_section (abfd, ".suse.vtrelocs");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
+      || ! bfd_set_section_alignment (abfd, s, 2))
+    return FALSE;
+  s = bfd_make_section (abfd, ".rel.suse.vtrelocs");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY
+                                  | SEC_HAS_CONTENTS
+                                  | SEC_IN_MEMORY | SEC_LINKER_CREATED)
+      || ! bfd_set_section_alignment (abfd, s, 2))
+      return FALSE;
+
+  return TRUE;
+}
+
 /* Create some sections which will be filled in with dynamic linking
    information.  ABFD is an input file which requires dynamic sections
    to be created.  The dynamic sections take up virtual memory space
@@ -2148,6 +2176,7 @@
 	return FALSE;
 
       elf_section_data (o)->rel_hashes = p;
+      fprintf (stderr, "allocated rel_hashes for asec %p\n", o);
     }
 
   return TRUE;
@@ -3193,7 +3222,24 @@
   direct_data = NULL;
 
   if ((abfd->flags & DYNAMIC) == 0)
+  {
+    asection *vtrel_sec;
+
     dynamic = FALSE;
+
+    vtrel_sec = bfd_get_section_by_name (abfd, ".vtrelocs");
+    if (vtrel_sec)
+      {
+        fprintf (stderr, "Has vtrelocs ! %d\n", (int)vtrel_sec->size);
+        if (!info->vtreloc)
+          {
+            info->vtreloc = 1;
+            if (!_bfd_elf_create_vtreloc_sections (info))
+              goto error_return;
+          }
+        vtrel_sec->flags |= SEC_EXCLUDE;
+      }
+  }
   else
     {
       dynamic = TRUE;
@@ -3520,6 +3566,7 @@
   else
     hdr = &elf_tdata (abfd)->dynsymtab_hdr;
 
+/* FIXME: cut/paste this ! ....*/
   symcount = hdr->sh_size / bed->s->sizeof_sym;
 
   /* The sh_info field of the symtab header tells us where the
@@ -4771,8 +4818,14 @@
   switch (bfd_get_format (abfd))
     {
     case bfd_object:
+      fprintf (stderr, "add_symbols from %s object '%s'\n",
+               abfd->flags & DYNAMIC ? "dynamic" : "static",
+               abfd->filename);
+      // from an .o or .so file ...
       return elf_link_add_object_symbols (abfd, info);
     case bfd_archive:
+      fprintf (stderr, "add_symbols from archive '%s'\n", abfd->filename);
+      // from a .a file ...
       return elf_link_add_archive_symbols (abfd, info);
     default:
       bfd_set_error (bfd_error_wrong_format);
@@ -5180,6 +5233,8 @@
 	}
     }
 
+  _bfd_elf_vtreloc_accumulate (output_bfd, info);
+
   /* Any syms created from now on start with -1 in
      got.refcount/offset and plt.refcount/offset.  */
   elf_hash_table (info)->init_got_refcount
@@ -6056,6 +6111,8 @@
   size_t symbuf_size;
   /* And same for symshndxbuf.  */
   size_t shndxbuf_size;
+  /* .suse.vtreloc section.  */
+  asection *vtreloc_sec;
 };
 
 /* This struct is used to pass information to elf_link_output_extsym.  */
@@ -6086,6 +6143,8 @@
   bfd_vma r_type_mask;
   int r_sym_shift;
 
+  fprintf (stderr, "elf_link_adjust_relocs ... %p\n", rel_hash);
+
   if (rel_hdr->sh_entsize == bed->s->sizeof_rel)
     {
       swap_in = bed->s->swap_reloc_in;
@@ -8138,6 +8197,7 @@
       finfo.hash_sec = NULL;
       finfo.symver_sec = NULL;
       finfo.hashvals_sec = NULL;
+      finfo.vtreloc_sec = NULL;
     }
   else
     {
@@ -8148,6 +8208,7 @@
       finfo.symver_sec = bfd_get_section_by_name (dynobj, ".gnu.version");
       /* Note that it is OK if symver_sec is NULL.  */
       finfo.hashvals_sec = bfd_get_section_by_name (dynobj, ".suse.hashvals");
+      finfo.vtreloc_sec = bfd_get_section_by_name (dynobj, ".suse.vtrelocs");
     }
 
   finfo.contents = NULL;
@@ -8162,7 +8223,7 @@
   finfo.symshndxbuf = NULL;
   finfo.symbuf_count = 0;
   finfo.shndxbuf_size = 0;
-
+  
   /* Count up the number of relocations we will output for each output
      section, so that we know the sizes of the reloc sections.  We
      also figure out some maximum sizes.  */
@@ -8172,6 +8233,10 @@
   max_sym_count = 0;
   max_sym_shndx_count = 0;
   merged = FALSE;
+
+  if (dynobj && !info->relocatable)
+    _bfd_elf_vtreloc_fill (finfo.output_bfd, info);
+
   for (o = abfd->sections; o != NULL; o = o->next)
     {
       struct bfd_elf_section_data *esdo = elf_section_data (o);
@@ -8765,6 +8830,10 @@
       if ((o->flags & SEC_RELOC) == 0)
 	continue;
 
+      fprintf (stderr, "rel_hashes for asec %p is %d, %p\n", o,
+               (int)elf_section_data (o)->rel_count,
+               elf_section_data (o)->rel_hashes);
+
       elf_link_adjust_relocs (abfd, &elf_section_data (o)->rel_hdr,
 			      elf_section_data (o)->rel_count,
 			      elf_section_data (o)->rel_hashes);
@@ -8905,6 +8974,9 @@
 	    case DT_SUSE_DIRECT:
 	      name = ".suse.direct";
 	      goto get_vma;
+	    case DT_SUSE_VTRELOC:
+	      name = ".suse.vtreloc";
+	      goto get_vma;
 	    case DT_VERSYM:
 	      name = ".gnu.version";
 	    get_vma:
@@ -9103,6 +9175,8 @@
   bfd_boolean is_eh;
   asection *group_sec;
 
+/* #warning "Do we want to ignore relocs inside .suse.vtreloc ?" */
+
   sec->gc_mark = 1;
 
   /* Mark all the sections in the group.  */
Only in binutils-2.16.91.0.5/bfd: elflink.c~
diff -u -r /usr/src/packages/BUILD/binutils-2.16.91.0.5/bfd/elflink.c.orig binutils-2.16.91.0.5/bfd/elflink.c.orig
--- /usr/src/packages/BUILD/binutils-2.16.91.0.5/bfd/elflink.c.orig	2007-02-16 17:15:13.000000000 +0000
+++ binutils-2.16.91.0.5/bfd/elflink.c.orig	2007-02-16 17:15:13.000000000 +0000
@@ -8005,7 +8005,7 @@
   struct bfd_link_order *p;
   bfd *sub;
   const struct elf_backend_data *bed = get_elf_backend_data (abfd);
-  int elfsec;
+  unsigned elfsec;
   struct bfd_link_order **sections;
   asection *s, *other_sec, *linkorder_sec;
   bfd_vma offset;
@@ -8022,7 +8022,8 @@
 	  sub = s->owner;
 	  if (bfd_get_flavour (sub) == bfd_target_elf_flavour
 	      && elf_elfheader (sub)->e_ident[EI_CLASS] == bed->s->elfclass
-	      && (elfsec = _bfd_elf_section_from_bfd_section (sub, s)) != -1
+	      && (elfsec = _bfd_elf_section_from_bfd_section (sub, s))
+	      && elfsec < elf_numsections (sub)
 	      && elf_elfsections (sub)[elfsec]->sh_flags & SHF_LINK_ORDER)
 	    {
 	      seen_linkorder++;
Only in binutils-2.16.91.0.5/bfd: elflink.lo
Only in binutils-2.16.91.0.5/bfd: elflink.o
Only in binutils-2.16.91.0.5/bfd: elf.lo
Only in binutils-2.16.91.0.5/bfd: elf.o
Only in binutils-2.16.91.0.5/bfd: elf-strtab.lo
Only in binutils-2.16.91.0.5/bfd: elf-strtab.o
Only in binutils-2.16.91.0.5/bfd: elf-vtreloc.c
Only in binutils-2.16.91.0.5/bfd: elf-vtreloc.c~
Only in binutils-2.16.91.0.5/bfd: elf-vtreloc.lo
Only in binutils-2.16.91.0.5/bfd: elf-vtreloc.o
Only in binutils-2.16.91.0.5/bfd: elf-vxworks.lo
Only in binutils-2.16.91.0.5/bfd: elf-vxworks.o
Only in binutils-2.16.91.0.5/bfd: format.lo
Only in binutils-2.16.91.0.5/bfd: format.o
Only in binutils-2.16.91.0.5/bfd: hash.lo
Only in binutils-2.16.91.0.5/bfd: hash.o
Only in binutils-2.16.91.0.5/bfd: i386linux.lo
Only in binutils-2.16.91.0.5/bfd: i386linux.o
Only in binutils-2.16.91.0.5/bfd: ihex.lo
Only in binutils-2.16.91.0.5/bfd: ihex.o
Only in binutils-2.16.91.0.5/bfd: init.lo
Only in binutils-2.16.91.0.5/bfd: init.o
Only in binutils-2.16.91.0.5/bfd: libbfd.a
Only in binutils-2.16.91.0.5/bfd: libbfd.la
Only in binutils-2.16.91.0.5/bfd: libbfd.lo
Only in binutils-2.16.91.0.5/bfd: libbfd.o
Only in binutils-2.16.91.0.5/bfd: .libs
Only in binutils-2.16.91.0.5/bfd: libtool
Only in binutils-2.16.91.0.5/bfd: linker.lo
Only in binutils-2.16.91.0.5/bfd: linker.o
Only in binutils-2.16.91.0.5/bfd: Makefile
diff -u -r /usr/src/packages/BUILD/binutils-2.16.91.0.5/bfd/Makefile.am binutils-2.16.91.0.5/bfd/Makefile.am
--- /usr/src/packages/BUILD/binutils-2.16.91.0.5/bfd/Makefile.am	2007-02-16 17:15:13.000000000 +0000
+++ binutils-2.16.91.0.5/bfd/Makefile.am	2007-03-12 11:10:17.000000000 +0000
@@ -277,6 +277,7 @@
 	elf32-xtensa.lo \
 	elf32.lo \
 	elflink.lo \
+	elf-vtreloc.lo \
 	elf-strtab.lo \
 	elf-eh-frame.lo \
 	elf-vxworks.lo \
@@ -448,6 +449,7 @@
 	elf32-xtensa.c \
 	elf32.c \
 	elflink.c \
+	elf-vtreloc.c \
 	elf-strtab.c \
 	elf-eh-frame.c \
 	elf-vxworks.c \
@@ -1441,6 +1443,10 @@
   $(INCDIR)/hashtab.h elf-bfd.h $(INCDIR)/elf/common.h \
   $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h $(INCDIR)/safe-ctype.h \
   $(INCDIR)/libiberty.h
+elf-vtreloc.lo: elf-vtreloc.c $(INCDIR)/filenames.h $(INCDIR)/bfdlink.h \
+  $(INCDIR)/hashtab.h elf-bfd.h $(INCDIR)/elf/common.h \
+  $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h $(INCDIR)/safe-ctype.h \
+  $(INCDIR)/libiberty.h
 elf-strtab.lo: elf-strtab.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
   elf-bfd.h $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h \
   $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h $(INCDIR)/libiberty.h
diff -u -r /usr/src/packages/BUILD/binutils-2.16.91.0.5/bfd/Makefile.in binutils-2.16.91.0.5/bfd/Makefile.in
--- /usr/src/packages/BUILD/binutils-2.16.91.0.5/bfd/Makefile.in	2007-02-16 17:15:13.000000000 +0000
+++ binutils-2.16.91.0.5/bfd/Makefile.in	2007-03-12 11:10:17.000000000 +0000
@@ -515,6 +515,7 @@
 	elf32-xtensa.lo \
 	elf32.lo \
 	elflink.lo \
+	elf-vtreloc.lo \
 	elf-strtab.lo \
 	elf-eh-frame.lo \
 	elf-vxworks.lo \
@@ -686,6 +687,7 @@
 	elf32-xtensa.c \
 	elf32.c \
 	elflink.c \
+	elf-vtreloc.c \
 	elf-strtab.c \
 	elf-eh-frame.c \
 	elf-vxworks.c \
@@ -2010,6 +2012,10 @@
   $(INCDIR)/hashtab.h elf-bfd.h $(INCDIR)/elf/common.h \
   $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h $(INCDIR)/safe-ctype.h \
   $(INCDIR)/libiberty.h
+elf-vtreloc.lo: elf-vtreloc.c $(INCDIR)/filenames.h $(INCDIR)/bfdlink.h \
+  $(INCDIR)/hashtab.h elf-bfd.h $(INCDIR)/elf/common.h \
+  $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h $(INCDIR)/safe-ctype.h \
+  $(INCDIR)/libiberty.h
 elf-strtab.lo: elf-strtab.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
   elf-bfd.h $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h \
   $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h $(INCDIR)/libiberty.h
Only in binutils-2.16.91.0.5/bfd: merge.lo
Only in binutils-2.16.91.0.5/bfd: merge.o
Only in binutils-2.16.91.0.5/bfd: ofiles
Only in binutils-2.16.91.0.5/bfd: opncls.lo
Only in binutils-2.16.91.0.5/bfd: opncls.o
Only in binutils-2.16.91.0.5/bfd: peigen.c
Only in binutils-2.16.91.0.5/bfd: peigen.lo
Only in binutils-2.16.91.0.5/bfd: peigen.o
Only in binutils-2.16.91.0.5/bfd/po: BLD-POTFILES
Only in binutils-2.16.91.0.5/bfd/po: Makefile
Only in binutils-2.16.91.0.5/bfd/po: Makefile.in
Only in binutils-2.16.91.0.5/bfd/po: SRC-POTFILES
Only in binutils-2.16.91.0.5/bfd: reloc.lo
Only in binutils-2.16.91.0.5/bfd: reloc.o
Only in binutils-2.16.91.0.5/bfd: section.lo
Only in binutils-2.16.91.0.5/bfd: section.o
Only in binutils-2.16.91.0.5/bfd: simple.lo
Only in binutils-2.16.91.0.5/bfd: simple.o
Only in binutils-2.16.91.0.5/bfd: srec.lo
Only in binutils-2.16.91.0.5/bfd: srec.o
Only in binutils-2.16.91.0.5/bfd: stabs.lo
Only in binutils-2.16.91.0.5/bfd: stabs.o
Only in binutils-2.16.91.0.5/bfd: stab-syms.lo
Only in binutils-2.16.91.0.5/bfd: stab-syms.o
Only in binutils-2.16.91.0.5/bfd: stamp-h1
Only in binutils-2.16.91.0.5/bfd: stamp-lib
Only in binutils-2.16.91.0.5/bfd: stamp-ofiles
Only in binutils-2.16.91.0.5/bfd: stmp-bfd-h
Only in binutils-2.16.91.0.5/bfd: syms.lo
Only in binutils-2.16.91.0.5/bfd: syms.o
Only in binutils-2.16.91.0.5/bfd: targets.lo
Only in binutils-2.16.91.0.5/bfd: targets.o
Only in binutils-2.16.91.0.5/bfd: targmatch.h
Only in binutils-2.16.91.0.5/bfd: tekhex.lo
Only in binutils-2.16.91.0.5/bfd: tekhex.o
Only in binutils-2.16.91.0.5/bfd: trad-core.lo
Only in binutils-2.16.91.0.5/bfd: trad-core.o
--- /dev/null	2007-02-04 17:14:05.000000000 +0000
+++ binutils-2.16.91.0.5/bfd/elf-vtreloc.c	2007-03-15 11:02:28.000000000 +0000
@@ -0,0 +1,543 @@
+#include "bfd.h"
+#include "sysdep.h"
+#include "bfdlink.h"
+#include "libbfd.h"
+#define ARCH_SIZE 0
+#include "elf-bfd.h"
+#include "safe-ctype.h"
+#include "libiberty.h"
+
+typedef struct _CopyEntry CopyEntry;
+
+typedef struct {
+    bfd       *abfd;
+    CopyEntry *sorted;
+    CopyEntry *unsorted;
+} VtRelocs;
+
+struct _CopyEntry {
+    struct elf_link_hash_entry *src;
+    bfd_vma                     src_offset;
+    struct elf_link_hash_entry *dest;
+    bfd_vma                     dest_offset;
+    bfd_vma                     bitmask;
+
+    /* chain */
+    CopyEntry *next;
+};
+
+static void
+prepend (CopyEntry **list, CopyEntry *p)
+{
+    p->next = *list;
+    *list = p;
+}
+
+static int
+copy_entry_equal (const CopyEntry *a, const CopyEntry *b)
+{
+    return (a->src == b->src &&
+            a->src_offset == b->src_offset &&
+            a->dest == b->dest &&
+            a->dest_offset == b->dest_offset &&
+            a->bitmask == b->bitmask);
+}
+
+/*
+ * FIXME - should be a hash lookup / something fast.
+ */
+static CopyEntry *
+find_with_dest (CopyEntry *list,
+                struct elf_link_hash_entry *e)
+{
+    while (list)
+      {
+        if (list->dest == e)
+          break;
+        list = list->next;
+      }
+    return list;
+}
+
+static CopyEntry *
+find_equal_entry (CopyEntry *list, CopyEntry *e)
+{
+  while (list)
+    {
+      if (copy_entry_equal (list, e))
+        break;
+      list = list->next;
+    }
+  return list;
+}
+
+/*
+ * Transfer from unsorted -> sorted.
+ * NB. simple-minded algorithm, N^3 with degenerate case
+ */
+static void
+sort_relocs (VtRelocs *vtr)
+{
+    CopyEntry *p;
+    CopyEntry *pending;
+    CopyEntry *next;
+
+    fprintf (stderr, "Sorting ...");
+    do
+      {
+        pending = NULL;
+        
+        for (p = vtr->unsorted; p; p = next)
+          {
+            next = p->next;
+            if (!find_with_dest (vtr->unsorted, p->src))
+            {
+              /* FIXME: sorting by offset, to ensure as
+                 good as possible contiguous access will
+                 require a more complex node structure:
+                 with aggregation per 'dest', and
+                 internal sorting within that */
+              prepend (&vtr->sorted, p);
+            }
+            else
+              prepend (&pending, p);
+          }
+        vtr->unsorted = pending;
+      }
+    while (pending);
+    fprintf (stderr, " done\n");
+}
+
+static void
+check_reloc (Elf_Internal_Rela *rel, int type_mask)
+{
+  if ((rel->r_info & type_mask) != STT_OBJECT)
+      fprintf (stderr, "broken vtreloc type\n");
+  if (rel->r_addend != 0)
+      fprintf (stderr, "unexpected reloc addend\n");
+}
+
+static void
+print_rel (const char *type, 
+           struct elf_link_hash_entry *target)
+{
+  fprintf (stderr, "%s '%s' %d %d %d %d i:%ld\n",
+           type, target->root.root.string,
+           target->ref_regular, target->def_regular,
+           target->ref_dynamic, target->def_dynamic,
+           target->dynindx);
+}
+
+static void
+add_reloc (VtRelocs *vtr,
+           bfd      *inputobj,
+           Elf_Internal_Rela *src_rel,
+           Elf_Internal_Rela *dest_rel,
+           unsigned char     *data)
+{
+  unsigned r_sym_shift;
+  unsigned r_type_mask;
+  unsigned incr;
+  unsigned symidx;
+  const struct elf_backend_data *bed;
+  struct elf_link_hash_entry *dest, *src;
+  Elf_Internal_Shdr *hdr;
+  CopyEntry *e;
+
+  hdr = &elf_tdata (inputobj)->symtab_hdr;
+  bed = get_elf_backend_data (inputobj);
+  if (bed->s->arch_size == 32)
+    {
+      r_type_mask = 0xff;
+      r_sym_shift = 8;
+      incr = 4;
+    }
+  else
+    {
+      r_type_mask = 0xffffffff;
+      r_sym_shift = 32;
+      incr = 8;
+    }
+
+  check_reloc (src_rel, r_type_mask);
+  check_reloc (dest_rel, r_type_mask);
+
+  symidx = (dest_rel->r_info >> r_sym_shift) - hdr->sh_info;
+  dest = elf_sym_hashes (inputobj) [symidx];
+
+  /* Eliminate relocs to no longer present internal vtables. */
+  if (!dest->def_regular)
+    {
+      print_rel ("Abandoning dest", dest);
+      fprintf (stderr, "Ref count %ld %ld dynindx %d\n",
+               dest->got.refcount, dest->plt.refcount,
+               (int) dest->dynindx);
+      /* unref the symbol somehow (!?) */
+      return;
+    }
+
+  /* Consider: should we eliminate all internal -> internal
+     copies ? it's possible we are more space / time
+     efficient - so no for now. */
+
+  symidx = (src_rel->r_info >> r_sym_shift) - hdr->sh_info;
+  src = elf_sym_hashes (inputobj) [symidx];
+
+  print_rel ("Src", src);
+  print_rel ("Dst", dest);
+
+  e = bfd_zalloc (vtr->abfd, sizeof (CopyEntry));
+
+  e->src = src;
+  e->dest = dest;
+
+  if (dest_rel->r_offset - src_rel->r_offset != bed->s->arch_size / 8)
+      fprintf (stderr, "Mis-paired vtrelocs\n");
+
+  e->src_offset = bfd_get (bed->s->arch_size, inputobj, data);
+  data += incr;
+  e->dest_offset = bfd_get (bed->s->arch_size, inputobj, data);
+  data += incr;
+  e->bitmask = bfd_get (bed->s->arch_size, inputobj, data);
+
+  /* Simple minded dupliates elision */
+  if (find_equal_entry (vtr->unsorted, e))
+    bfd_release (vtr->abfd, e);          
+  else
+    {
+      prepend (&vtr->unsorted, e);  
+
+      fprintf (stderr, "Copy: '%s'+%d -> '%s'+%d (0x%x)\n",
+               e->src->root.root.string,
+               (int)e->src_offset,
+               e->dest->root.root.string,
+               (int)e->dest_offset,
+               (int)e->bitmask);
+    }
+}
+
+static VtRelocs *global_vtr;
+
+bfd_boolean _bfd_elf_vtreloc_accumulate (bfd *output_bfd,
+                                         struct bfd_link_info *info)
+{
+  bfd *dynobj;
+  dynobj = elf_hash_table (info)->dynobj;
+  if (info->vtreloc)
+    { // .vtrelocs
+      bfd_size_type sec_size = 0;
+      asection *vtreloc_sec;
+      asection *vtrelrel;
+      bfd *inputobj;
+      VtRelocs *vtr;
+      Elf_Internal_Rela last_rela;
+      bfd_size_type num_relocs;
+
+      vtr = bfd_zalloc (output_bfd, sizeof (VtRelocs));
+      vtr->abfd = output_bfd;
+      global_vtr = vtr;
+
+      /* FIXME: we need to elide relocs that turn out
+         to be purely internal:
+         eg. internal -> internal copy src / dest,
+         others are less troublesome - though removing
+         empty ones would be nice (?).
+         We want to trap every -named- reloc ...
+      */
+      for (inputobj = info->input_bfds;
+	   inputobj;
+	   inputobj = inputobj->link_next)
+	{
+	  asection *s;
+          struct bfd_elf_section_data *es; /* elf-bfd.h */
+          unsigned i;
+          Elf_Internal_Rela *relocs, *p;
+          unsigned char *sec_data;
+	  long storage_needed;
+	  asymbol **symtab;
+	  long number_of_symbols;
+	  const struct elf_backend_data *bed = get_elf_backend_data (inputobj);
+
+	  if (inputobj->flags & (DYNAMIC | BFD_LINKER_CREATED))
+	    continue;
+	  s = bfd_get_section_by_name (inputobj, ".vtrelocs");
+          if (!s)
+            continue;
+	  /* XXX Hmm, this seems to generate many NONE relocs, probably from
+	     the original relocs to this section.  Perhaps discard them
+	     earlier.  */
+	  s->flags |= SEC_EXCLUDE;
+          es = elf_section_data (s);
+          if (!es)
+            continue;
+
+          if (!s->reloc_count)
+            continue;
+
+          fprintf (stderr, "Relocs: size %d, count %d contents %p\n",
+                   (int)es->rel_hdr.sh_size, es->rel_count,
+                   s->contents);
+          
+
+          /* Can't find this info anywhere else for some reason: */
+          p = relocs = _bfd_elf_link_read_relocs (inputobj, s, NULL, NULL,
+                                                  info->keep_memory);
+
+	  /* Experimental stuff to get at the BFD relocs (translated back
+	     from the real ELF relocs.  */
+	  storage_needed = bfd_get_symtab_upper_bound (inputobj);
+	  if (storage_needed <= 0)
+	    return FALSE;
+	  symtab = xmalloc (storage_needed);
+	  number_of_symbols = bfd_canonicalize_symtab (inputobj, symtab);
+	  if (number_of_symbols < 0)
+	    return FALSE;
+
+	  if (! bed->s->slurp_reloc_table (inputobj, s, symtab, FALSE))
+	    return FALSE;
+          
+	  /* Now inputobj->relocation will contain BFD relocs.  */
+
+          sec_data = bfd_malloc (es->this_hdr.sh_size);
+          
+          /* Slurp the data */
+          if (bfd_seek (inputobj, es->this_hdr.sh_offset, SEEK_SET) != 0)
+            return FALSE;
+          if (bfd_bread (sec_data, es->this_hdr.sh_size, inputobj) != es->this_hdr.sh_size)
+            return FALSE;
+
+          if (es->this_hdr.sh_size % s->reloc_count != 0)
+              fprintf (stderr, "ERROR: mismatching vtreloc sec & reloc count\n");
+
+          /* Assumes an even number of relocs sorted by address ... */
+          for (i = 0; i < s->reloc_count / 2; i++)
+          {
+              unsigned int entry_size;
+              entry_size = (get_elf_backend_data (inputobj)->s->arch_size / 8) * 3;
+              
+	      last_rela = *p;
+              add_reloc (vtr, inputobj, p, p + 1,
+                         sec_data + i * entry_size);
+              p+=2;
+          }
+          free (sec_data);
+          if (es->relocs != relocs)
+              free (relocs);
+        }
+      /* So - we need to sort these guys as we work out the sizes */
+      /* We need to generate an internal list of XYZ type 
+           + eliminate all external -> external work ... 
+           + add all external -> internal copies to 'sorted' list
+              + [ fool-proof GC roots ]
+           + add other symbols to 'pending' list.
+           + read / generate src: [symbol + offset, dest: sym + offset, bitmask data]
+      */
+      sort_relocs (vtr);
+      num_relocs = 0;
+      sec_size = 0;
+      {
+        CopyEntry *e;
+	for (e = vtr->sorted; e; e = e->next)
+	  {
+	    sec_size += 3;  /* Word entries.  */
+	    num_relocs += 2;
+	  }
+      }
+      /*
+         Finally:
+           + build new custom section
+           + emit new relocations for it ...
+      */
+      
+      vtreloc_sec = bfd_get_section_by_name (dynobj, ".suse.vtrelocs");
+      if (vtreloc_sec)
+        {
+	  bfd_size_type rel_size;
+	  bfd_size_type size;
+	  const struct elf_backend_data *bed = get_elf_backend_data (dynobj);
+	  vtrelrel = bfd_get_section_by_name (dynobj, ".rel.suse.vtrelocs");
+	  if (!vtrelrel)
+	    return FALSE;
+
+          {
+              unsigned int entry_size;
+              entry_size = (bed->s->arch_size / 8);
+              /* + 1 for null termination */
+              vtreloc_sec->size = (sec_size + 1) * entry_size;
+              vtreloc_sec->contents = bfd_zalloc (dynobj, vtreloc_sec->size);
+          }
+
+	  rel_size = bed->s->sizeof_rel;
+	  if (bed->default_use_rela_p)
+	    {
+	      rel_size = bed->s->sizeof_rela;
+	    }
+
+	  size = rel_size * num_relocs;
+	  fprintf (stderr, "Need %ld bytes of relocs rel-size %ld\n",
+                   size, rel_size);
+	  vtrelrel->size = size;
+        }
+      else
+        fprintf (stderr, "Horrendous error ! - no .suse.vtrelocs\n");
+
+    }
+  else
+    {
+      asection *vtreloc_sec;
+      fprintf (stderr, "TESTME: exclude .vtrelocs if none present\n");
+      vtreloc_sec = bfd_get_section_by_name (dynobj, ".vtrelocs");
+      if (vtreloc_sec)
+        vtreloc_sec->flags |= SEC_EXCLUDE;
+    }
+  return TRUE;
+}
+
+static void
+generate_reloc (bfd                        *dynobj,
+                struct elf_link_hash_entry *target,
+                asection                   *vtreloc_sec,
+                asection                   *vtrelrel,
+                bfd_vma                     num_entry,
+                int                         is_dest,
+                bfd_size_type              *adjust_relative)
+{
+    bfd_size_type sym_idx, rel_size;
+    reloc_howto_type *howto;
+    void (*swap_out) (bfd *, const Elf_Internal_Rela *, bfd_byte *);
+    bfd_byte *loc;
+    Elf_Internal_Rela outrel;
+    const struct elf_backend_data *bed;
+
+    bed = get_elf_backend_data (dynobj);
+
+    rel_size = bed->s->sizeof_rel;
+    swap_out = bed->s->swap_reloc_out;
+    if (bed->default_use_rela_p)
+    {
+        rel_size = bed->s->sizeof_rela;
+        swap_out = bed->s->swap_reloca_out;
+    }
+
+    /* XXX: unwind this goodness etc. */
+    while (target->root.type == bfd_link_hash_indirect
+           || target->root.type == bfd_link_hash_warning)
+      target = (struct elf_link_hash_entry *) target->root.u.i.link;
+
+    fprintf (stderr, "Reloc '%s' %d %d %d %d i:%ld ",
+             target->root.root.string,
+             target->ref_regular, target->def_regular,
+             target->ref_dynamic, target->def_dynamic,
+             target->dynindx);
+    if (is_dest /* force relative */ || target->dynindx <= 0)
+      fprintf (stderr, "'%s' vma 0x%lx offset %ld output off %ld\n",
+               target->root.u.def.section->name,
+               target->root.u.def.section->output_section->vma,
+               target->root.u.def.value,
+               target->root.u.def.section->output_offset);
+    else
+      fprintf (stderr, "\n");
+
+    /* XXX: RELOC64 too */
+    if (is_dest /* force relative */ || target->dynindx <= 0)
+      { /* do a relative reloc ... */
+        howto = bfd_reloc_type_lookup (dynobj, BFD_RELOC_386_RELATIVE);
+        sym_idx = 0;
+        BFD_ASSERT (target->root.type == bfd_link_hash_defweak);
+        *adjust_relative = (target->root.u.def.section->output_section->vma +
+                            target->root.u.def.section->output_offset);
+      }
+    else
+      {
+        howto = bfd_reloc_type_lookup (dynobj, BFD_RELOC_32);
+        sym_idx = target->dynindx;
+        *adjust_relative = 0;
+      }
+
+    /* generate relocation */
+    outrel.r_offset = vtreloc_sec->output_section->vma;
+    outrel.r_offset += num_entry * 3 * 4; // XXX: 4 ?
+    if (is_dest) outrel.r_offset += 4; // XXX: 4
+    outrel.r_info = ELF32_R_INFO (sym_idx, howto->type);
+    outrel.r_addend = 0;
+
+    loc = vtrelrel->contents + (vtrelrel->reloc_count++ * rel_size);
+    swap_out (dynobj, &outrel, loc);
+}
+
+bfd_boolean _bfd_elf_vtreloc_fill (bfd *output_bfd,
+                                   struct bfd_link_info *info)
+{
+  bfd *dynobj;
+  dynobj = elf_hash_table (info)->dynobj;
+
+  fprintf (stderr, "Foo: generate .suse.vtrelocs relocs\n");
+
+  if (info->vtreloc)
+    {
+      asection *vtreloc_sec;
+      asection *vtrelrel;
+
+      vtreloc_sec = bfd_get_section_by_name (dynobj, ".suse.vtrelocs");
+      if (vtreloc_sec)
+        {
+	  CopyEntry *e;
+	  bfd_size_type entries, adjust_relative, entry_size;
+	  const struct elf_backend_data *bed = get_elf_backend_data (dynobj);
+          bfd_byte *data;
+
+          entry_size = (bed->s->arch_size / 8);
+
+	  vtrelrel = bfd_get_section_by_name (dynobj, ".rel.suse.vtrelocs");
+	  if (!vtrelrel)
+	    return FALSE;
+	  if (!vtrelrel->contents)
+	    {
+	      fprintf (stderr, "Nothing allocated for relocs\n");
+	      return FALSE;
+	    }
+
+	  BFD_ASSERT (vtreloc_sec->output_offset == 0);
+	  entries = 0;
+	  vtrelrel->reloc_count = 0;
+          data = vtreloc_sec->contents;
+	  for (e = global_vtr->sorted; e; e = e->next)
+	    {
+	      /* Source */
+              generate_reloc (output_bfd, e->src, vtreloc_sec, vtrelrel,
+                              entries, FALSE, &adjust_relative);
+              bfd_put(bed->s->arch_size, output_bfd,
+                      e->src_offset + adjust_relative, data);
+              data += entry_size;
+
+              /* Dest */
+              generate_reloc (output_bfd, e->dest, vtreloc_sec, vtrelrel,
+                              entries, TRUE, &adjust_relative);
+              bfd_put(bed->s->arch_size, output_bfd,
+                      e->dest_offset + adjust_relative, data);
+              data += entry_size;
+
+              bfd_put(bed->s->arch_size, dynobj, e->bitmask, data);
+              data += entry_size;
+
+              entries++;
+            }
+          BFD_ASSERT (vtrelrel->reloc_count * (bed->default_use_rela_p ? bed->s->sizeof_rela : bed->s->sizeof_rel)
+                      == vtrelrel->size);
+        }
+      else
+        fprintf (stderr, "Horrendous error ! - no .suse.vtrelocs\n");
+    }
+  else
+    {
+      asection *vtreloc_sec;
+      fprintf (stderr, "TESTME: exclude .vtrelocs if none present\n");
+      vtreloc_sec = bfd_get_section_by_name (dynobj, ".suse.vtrelocs");
+      if (vtreloc_sec)
+        vtreloc_sec->flags |= SEC_EXCLUDE;
+      vtreloc_sec = bfd_get_section_by_name (dynobj, ".rel.suse.vtrelocs");
+      if (vtreloc_sec)
+        vtreloc_sec->flags |= SEC_EXCLUDE;
+    }
+  return TRUE;
+}
diff -u -r /usr/src/packages/BUILD/binutils-2.16.91.0.5/include/bfdlink.h binutils-2.16.91.0.5/include/bfdlink.h
--- /usr/src/packages/BUILD/binutils-2.16.91.0.5/include/bfdlink.h	2007-02-16 17:15:13.000000000 +0000
+++ binutils-2.16.91.0.5/include/bfdlink.h	2007-03-12 11:10:17.000000000 +0000
@@ -297,6 +297,10 @@
   /* TRUE if the new ELF dynamic tags are enabled. */
   unsigned int new_dtags: 1;
 
+  /* TRUE if we want to produce copy-based vtable relocation
+     data. This saves both space and time.  */
+  unsigned int vtreloc: 1;
+
   /* TRUE if non-PLT relocs should be merged into one reloc section
      and sorted so that relocs against the same symbol come together.  */
   unsigned int combreloc: 1;
diff -u -r /usr/src/packages/BUILD/binutils-2.16.91.0.5/include/elf/common.h binutils-2.16.91.0.5/include/elf/common.h
--- /usr/src/packages/BUILD/binutils-2.16.91.0.5/include/elf/common.h	2007-02-16 17:15:13.000000000 +0000
+++ binutils-2.16.91.0.5/include/elf/common.h	2007-03-12 11:10:17.000000000 +0000
@@ -608,6 +608,7 @@
 #define DT_SUSE_LO 0x6cbdd030
 #define DT_SUSE_HASHVALS DT_SUSE_LO
 #define DT_SUSE_DIRECT DT_SUSE_LO + 1
+#define DT_SUSE_VTRELOC DT_SUSE_LO + 2
 #define DT_SUSE_HI 0x6cbdd040
 
 /* Values used in DT_FEATURE .dynamic entry.  */
