--- /dev/null	2004-08-25 18:34:59.000000000 +0100
+++ canvas/workben/canvasdemo.cxx	2005-03-29 16:00:41.064835960 +0100
@@ -0,0 +1,442 @@
+// This code strongly inspired by Miguel / Federico's Gnome Canvas demo code.
+
+#include <stdio.h>
+#include <unistd.h>
+#include <math.h>
+
+#include <comphelper/processfactory.hxx>
+#include <comphelper/regpathhelper.hxx>
+#include <cppuhelper/servicefactory.hxx>
+#include <cppuhelper/bootstrap.hxx>
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/lang/XInitialization.hpp>
+#include <com/sun/star/registry/XSimpleRegistry.hpp>
+
+#include <ucbhelper/contentbroker.hxx>
+#include <ucbhelper/configurationkeys.hxx>
+
+#include <vcl/window.hxx>
+#include <vcl/svapp.hxx>
+#include <vcl/msgbox.hxx>
+#include <vcl/canvastools.hxx>
+
+#include <rtl/bootstrap.hxx>
+
+#include <com/sun/star/rendering/XCanvas.hpp>
+#include <com/sun/star/rendering/FillRule.hpp>
+#include <com/sun/star/rendering/ViewState.hpp>
+#include <com/sun/star/rendering/RenderState.hpp>
+#include <com/sun/star/rendering/PathCapType.hpp>
+#include <com/sun/star/rendering/PathJoinType.hpp>
+#include <com/sun/star/rendering/XSpriteCanvas.hpp>
+#include <com/sun/star/rendering/XGraphicDevice.hpp>
+#include <com/sun/star/rendering/CompositeOperation.hpp>
+
+// never import whole leaf namespaces, since this will result in
+// absolutely weird effects during (Koenig) name lookup
+using namespace ::com::sun::star;
+
+
+class GalApp : public Application
+{
+public:
+	virtual void Main();
+};
+
+static void PrintHelp()
+{
+	fprintf( stdout, "canvasdemo - Exercise the new canvas impl\n" );
+}
+
+class TestWindow : public Dialog
+{
+	public:
+		TestWindow() : Dialog( (Window *) NULL )
+		{
+			SetText( rtl::OUString::createFromAscii( "Canvas test" ) );
+			SetSizePixel( Size( 600, 450 ) );
+			EnablePaint( true );
+			Show();
+		}
+		virtual ~TestWindow() {}
+		virtual void MouseButtonUp( const MouseEvent& rMEvt )
+		{ 
+            EndDialog(); 
+        }
+		virtual void Paint( const Rectangle& rRect );
+};
+
+class DemoRenderer
+{
+	public:
+		Size maSize;
+		Size maBox;
+		rendering::ViewState   maViewState;
+		rendering::RenderState maRenderState;
+    	uno::Sequence< double > maColorBlack;
+		uno::Sequence< double > maColorWhite;
+		uno::Sequence< double > maColorRed;
+		uno::Reference< rendering::XCanvas > mxCanvas;
+		uno::Reference< rendering::XCanvasFont > mxDefaultFont;
+		uno::Reference< rendering::XGraphicDevice > mxDevice;
+
+		DemoRenderer( uno::Reference< rendering::XGraphicDevice > xDevice,
+					  uno::Reference< rendering::XCanvas > xCanvas,
+					  Size aSize ) :
+				mxDevice( xDevice ), mxCanvas( xCanvas ), maSize( aSize )
+		{
+			// Color init
+			maColorBlack = ::vcl::unotools::colorToDoubleSequence( xDevice, Color( COL_BLACK ) );
+			maColorWhite = ::vcl::unotools::colorToDoubleSequence( xDevice, Color( COL_WHITE ) );
+			maColorRed = ::vcl::unotools::colorToDoubleSequence( xDevice, Color( COL_RED ) );
+			// Geometry init
+			geometry::AffineMatrix2D aUnit( 1,0, 0,
+											0,1, 0 );
+			maViewState.AffineTransform = aUnit;
+			maRenderState.AffineTransform = aUnit;
+			maRenderState.DeviceColor = maColorBlack;
+			maRenderState.CompositeOperation = rendering::CompositeOperation::OVER;
+			maBox.Width() = aSize.Width() / 3;
+			maBox.Height() = aSize.Height() / 3;
+
+			lang::Locale aLocale;
+			rendering::FontInfo aFontInfo;
+			aFontInfo.FamilyName = ::rtl::OUString::createFromAscii( "Swiss" );
+			aFontInfo.StyleName = ::rtl::OUString::createFromAscii( "SansSerif" );
+			geometry::Matrix2D aFontMatrix( 1, 0,
+											0, 1 );
+			rendering::FontRequest aFontRequest( aFontInfo, 12.0, 12.0, aLocale );
+			uno::Sequence< beans::PropertyValue > aExtraFontProperties;
+ 			mxDefaultFont = xCanvas->createFont( aFontRequest, aExtraFontProperties, aFontMatrix );
+			if( !mxDefaultFont.is() )
+				fprintf( stderr, "Failed to create font\n" );
+		}
+
+		void drawGrid()
+		{
+			double d, dIncr = maSize.Width() / 3;
+			for ( d = 0; d <= maSize.Width(); d += dIncr )
+				mxCanvas->drawLine( geometry::RealPoint2D( d, 0 ),
+									geometry::RealPoint2D( d, maSize.Height() ),
+									maViewState, maRenderState );
+			dIncr = maSize.Height() / 3;
+			for ( d = 0; d <= maSize.Height(); d += dIncr )
+				mxCanvas->drawLine( geometry::RealPoint2D( 0, d ),
+									geometry::RealPoint2D( maSize.Width(), d ),
+									maViewState, maRenderState );
+		}
+
+    	void drawStringAt( ::rtl::OString aString, double x, double y )
+		{
+			rendering::StringContext aText;
+			aText.Text = ::rtl::OStringToOUString( aString, RTL_TEXTENCODING_UTF8 );
+			aText.StartPosition = 0;
+			aText.Length = aString.getLength();
+			rendering::RenderState aRenderState( maRenderState );
+			aRenderState.AffineTransform.m02 += x;
+			aRenderState.AffineTransform.m12 += y;
+
+			mxCanvas->drawText( aText, mxDefaultFont, maViewState, aRenderState, 0);
+		}
+
+		void drawRect( Rectangle rRect, uno::Sequence< double > &aColor, int nWidth )
+		{
+			uno::Sequence< geometry::RealPoint2D > aPoints(4);
+			uno::Reference< rendering::XLinePolyPolygon2D > xPoly;
+
+			aPoints[0] = geometry::RealPoint2D( rRect.Left(),  rRect.Top() );
+			aPoints[1] = geometry::RealPoint2D( rRect.Left(),  rRect.Bottom() );
+			aPoints[2] = geometry::RealPoint2D( rRect.Right(), rRect.Bottom() );
+			aPoints[3] = geometry::RealPoint2D( rRect.Right(), rRect.Top() );
+
+			uno::Sequence< uno::Sequence< geometry::RealPoint2D > > aPolys(1);
+			aPolys[0] = aPoints;
+			xPoly = mxDevice->createCompatibleLinePolyPolygon( aPolys );
+			xPoly->setClosed( 0, true );
+			uno::Reference< rendering::XPolyPolygon2D> xPP( xPoly, uno::UNO_QUERY );
+			
+			rendering::RenderState aRenderState( maRenderState );
+			aRenderState.DeviceColor = aColor;
+			mxCanvas->drawPolyPolygon( xPP, maViewState, aRenderState );
+		}
+
+		void translate( double x, double y)
+		{
+			maRenderState.AffineTransform.m02 += x;
+			maRenderState.AffineTransform.m12 += y;
+		}
+
+		void drawPolishDiamond( double center_x, double center_y)
+		{
+			const int    VERTICES = 10;
+			const double RADIUS = 60.0;
+			int i, j;
+			double a;
+
+			rendering::RenderState maOldRenderState = maRenderState; // push
+			translate( center_x, center_y );
+
+			for (i = 0; i < VERTICES; i++)
+			{
+				a = 2.0 * M_PI * i / VERTICES;
+				geometry::RealPoint2D aSrc( RADIUS * cos (a), RADIUS * sin (a) );
+
+				for (j = i + 1; j < VERTICES; j++)
+				{
+					a = 2.0 * M_PI * j / VERTICES;
+
+//					FIXME: set cap_style to 'ROUND'
+					mxCanvas->drawLine( aSrc,
+										geometry::RealPoint2D( RADIUS * cos (a),
+															   RADIUS * sin (a) ),
+										maViewState, maRenderState );
+				}
+			}
+
+			maRenderState = maOldRenderState; // pop
+		}
+
+		void drawHilbert( double anchor_x, double anchor_y )
+		{
+			const double SCALE=7.0;
+			const char hilbert[] = "urdrrulurulldluuruluurdrurddldrrruluurdrurddldrddlulldrdldrrurd";
+			char *c;
+			double *pp, *p;
+			int nLength = sizeof( hilbert ) / sizeof (hilbert [0]);
+
+			uno::Sequence< geometry::RealPoint2D > aPoints( nLength );
+			uno::Reference< rendering::XLinePolyPolygon2D > xPoly;
+		
+			aPoints[0] = geometry::RealPoint2D( anchor_x, anchor_y );
+			for (int i = 0; i < nLength; i++ )
+			{
+				switch( hilbert[i] )
+				{
+					case 'u':
+						aPoints[i+1] = geometry::RealPoint2D( aPoints[i].X,
+															aPoints[i].Y - SCALE );
+						break;
+					case 'd':
+						aPoints[i+1] = geometry::RealPoint2D( aPoints[i].X,
+															aPoints[i].Y + SCALE );
+						break;
+					case 'l':
+						aPoints[i+1] = geometry::RealPoint2D( aPoints[i].X - SCALE,
+															aPoints[i].Y );
+						break;
+					case 'r':
+						aPoints[i+1] = geometry::RealPoint2D( aPoints[i].X + SCALE,
+															aPoints[i].Y );
+						break;
+				}
+			}
+
+			uno::Sequence< uno::Sequence< geometry::RealPoint2D > > aPolys(1);
+			aPolys[0] = aPoints;
+
+			xPoly = mxDevice->createCompatibleLinePolyPolygon( aPolys );
+			xPoly->setClosed( 0, false );
+			uno::Reference< rendering::XPolyPolygon2D> xPP( xPoly, uno::UNO_QUERY );
+
+			rendering::RenderState aRenderState( maRenderState );
+			aRenderState.DeviceColor = maColorRed;
+//			aRenderState.DeviceColor[3] = 0.5;
+			rendering::StrokeAttributes aStrokeAttrs;
+			aStrokeAttrs.StrokeWidth = 4.0;
+			aStrokeAttrs.MiterLimit = 2.0; // ?
+			aStrokeAttrs.StartCapType = rendering::PathCapType::BUTT;
+			aStrokeAttrs.EndCapType = rendering::PathCapType::BUTT;
+			aStrokeAttrs.JoinType = rendering::PathJoinType::MITER;
+			fprintf( stderr, "FIXME: stroking a PolyPolygon doesn't show up\n" );
+			mxCanvas->strokePolyPolygon( xPP, maViewState, aRenderState, aStrokeAttrs );
+			// FIXME: do this instead:
+			mxCanvas->drawPolyPolygon( xPP, maViewState, aRenderState );
+		}
+
+		void drawTitle( rtl::OString aTitle )
+		{
+			// FIXME: text anchoring to be done
+			double nStringWidth = aTitle.getLength() * 8.0;
+			drawStringAt ( aTitle, (maBox.Width() - nStringWidth) / 2, 15 );
+		}
+
+		void drawRectangles()
+		{
+			rendering::RenderState maOldRenderState = maRenderState; // push
+
+			drawTitle( ::rtl::OString( "Rectangles" ) );
+			
+			drawRect( Rectangle( 20, 30, 70, 60 ), maColorRed, 8 );
+			// color mediumseagreen, stipple fill, outline black
+			drawRect( Rectangle( 90, 40, 180, 100 ), maColorBlack, 4 );
+			// color steelblue, filled, no outline
+			drawRect( Rectangle( 10, 80, 80, 140 ), maColorBlack, 1 );
+
+			maRenderState = maOldRenderState; // pop
+		}
+
+		void drawEllipses()
+		{
+			rendering::RenderState maOldRenderState = maRenderState; // push
+			translate( maBox.Width(), 0.0 );
+
+			drawTitle( ::rtl::OString( "Ellipses" ) );
+
+			maRenderState = maOldRenderState; // pop
+		}
+
+		void drawText()
+		{
+			rendering::RenderState maOldRenderState = maRenderState; // push
+			translate( maBox.Width() * 2.0, 0.0 );
+
+			drawTitle( ::rtl::OString( "Text" ) );
+
+			maRenderState = maOldRenderState; // pop
+		}
+
+		void drawImages()
+		{
+			rendering::RenderState maOldRenderState = maRenderState; // push
+			translate( 0.0, maBox.Height() );
+
+			drawTitle( ::rtl::OString( "Images" ) );
+
+			maRenderState = maOldRenderState; // pop
+		}
+
+		void drawLines()
+		{
+			rendering::RenderState maOldRenderState = maRenderState; // push
+			translate( maBox.Width(), maBox.Height() );
+
+			drawTitle( ::rtl::OString( "Lines" ) );
+
+			drawPolishDiamond( 70.0, 80.0 );
+			drawHilbert( 140.0, 140.0 );
+
+			maRenderState = maOldRenderState; // pop
+		}
+
+		void drawCurves()
+		{
+			rendering::RenderState maOldRenderState = maRenderState; // push
+			translate( maBox.Width() * 2.0, maBox.Height() );
+
+			drawTitle( ::rtl::OString( "Curves" ) );
+
+			maRenderState = maOldRenderState; // pop
+		}
+
+		void drawArcs()
+		{
+			rendering::RenderState maOldRenderState = maRenderState; // push
+			translate( 0.0, maBox.Height() * 2.0 );
+
+			drawTitle( ::rtl::OString( "Arcs" ) );
+
+			maRenderState = maOldRenderState; // pop
+		}
+
+		void drawPolygons()
+		{
+			rendering::RenderState maOldRenderState = maRenderState; // push
+			translate( maBox.Width() * 1.0, maBox.Height() * 2.0 );
+
+			drawTitle( ::rtl::OString( "Polgyons" ) );
+
+			maRenderState = maOldRenderState; // pop
+		}
+
+		void drawWidgets() // FIXME: prolly makes no sense
+		{
+			rendering::RenderState maOldRenderState = maRenderState; // push
+			translate( maBox.Width() * 2.0, maBox.Height() * 2.0 );
+
+			drawTitle( ::rtl::OString( "Widgets" ) );
+
+			maRenderState = maOldRenderState; // pop
+		}
+};
+
+
+void TestWindow::Paint( const Rectangle& rRect )
+{
+	try
+	{
+		uno::Reference< rendering::XCanvas > xCanvas( GetCanvas(),
+                                                      uno::UNO_QUERY_THROW );
+		uno::Reference< rendering::XGraphicDevice > xDevice( xCanvas->getDevice(),
+                                                             uno::UNO_QUERY_THROW );
+
+		DemoRenderer aRenderer( xDevice, xCanvas, GetSizePixel() );
+		aRenderer.drawGrid();
+        aRenderer.drawRectangles();
+		aRenderer.drawEllipses();
+		aRenderer.drawText();
+		aRenderer.drawImages();
+        aRenderer.drawLines();
+        aRenderer.drawCurves();
+        aRenderer.drawArcs();
+        aRenderer.drawPolygons();
+        aRenderer.drawWidgets();
+
+		uno::Reference< rendering::XSpriteCanvas > xSpriteCanvas( xCanvas, uno::UNO_QUERY_THROW );
+		xSpriteCanvas->updateScreen( sal_True );
+	}
+	catch (const uno::Exception &e)
+	{
+		fprintf( stderr, "Exception '%s' thrown\n" ,
+				 (const sal_Char *) ::rtl::OUStringToOString( e.Message, RTL_TEXTENCODING_UTF8 ) );
+	}
+}
+
+static void basicInit()
+{
+    uno::Reference< lang::XMultiServiceFactory >
+		xMSF = cppu::createRegistryServiceFactory(
+				rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "canvasdemo.rdb" ) ), sal_True );
+	::comphelper::setProcessServiceFactory( xMSF );
+
+	// Without this no file access works ...
+	::ucb::ContentProviderDataList aData;
+	::ucb::ContentProviderData aFileProvider(
+			rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.ucb.FileContentProvider" ) ),
+			rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "file" ) ),
+			rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "" ) ) );
+	aData.push_back( aFileProvider );
+	::ucb::ContentBroker::initialize( xMSF, aData );
+}
+
+void GalApp::Main()
+{
+	bool bHelp = false;
+
+	for( USHORT i = 0; i < GetCommandLineParamCount(); i++ )
+	{
+		::rtl::OUString aParam = GetCommandLineParam( i );
+
+		if( aParam.equalsAscii( "--help" ) ||
+			aParam.equalsAscii( "-h" ) )
+				bHelp = true;
+	}
+
+	if( bHelp )
+	{
+		PrintHelp();
+		return;
+	}
+
+	basicInit();
+
+	TestWindow pWindow;
+	pWindow.Execute();
+}
+
+GalApp aGalApp;
+
+// TODO
+//   - bouncing clip-rectangle mode - bounce a clip-rect around the window ...
+//   - complete all of pre-existing canvas bits
+//   - affine transform tweakage ...
+
