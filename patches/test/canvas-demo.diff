--- /dev/null	2004-07-26 12:51:14.000000000 +0100
+++ canvas/workben/canvasdemo.cxx	2005-03-24 16:16:38.955068464 +0000
@@ -0,0 +1,248 @@
+#include <stdio.h>
+#include <unistd.h>
+
+#include <comphelper/processfactory.hxx>
+#include <comphelper/regpathhelper.hxx>
+#include <cppuhelper/servicefactory.hxx>
+#include <cppuhelper/bootstrap.hxx>
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/lang/XInitialization.hpp>
+#include <com/sun/star/registry/XSimpleRegistry.hpp>
+
+#include <ucbhelper/contentbroker.hxx>
+#include <ucbhelper/configurationkeys.hxx>
+
+#include <vcl/window.hxx>
+#include <vcl/svapp.hxx>
+#include <vcl/msgbox.hxx>
+#include <vcl/canvastools.hxx>
+
+#include <rtl/bootstrap.hxx>
+
+#include <com/sun/star/rendering/XCanvas.hpp>
+#include <com/sun/star/rendering/FillRule.hpp>
+#include <com/sun/star/rendering/ViewState.hpp>
+#include <com/sun/star/rendering/RenderState.hpp>
+#include <com/sun/star/rendering/XSpriteCanvas.hpp>
+#include <com/sun/star/rendering/XGraphicDevice.hpp>
+#include <com/sun/star/rendering/CompositeOperation.hpp>
+
+using namespace ::vos;
+using namespace ::rtl;
+using namespace ::com::sun::star;
+using namespace ::com::sun::star::uno;
+using namespace ::com::sun::star::registry;
+using namespace ::com::sun::star::lang;
+
+class GalApp : public Application
+{
+public:
+	virtual void Main();
+};
+
+static void PrintHelp()
+{
+	fprintf( stdout, "canvasdemo - Exercise the new canvas impl\n" );
+}
+
+class TestWindow : public Dialog
+{
+	public:
+		TestWindow() : Dialog( (Window *) NULL )
+		{
+			SetText( rtl::OUString::createFromAscii( "Canvas test" ) );
+			SetSizePixel( Size( 640, 480 ) );
+			EnablePaint( true );
+			Show();
+		}
+		virtual ~TestWindow() {}
+		virtual void MouseButtonUp( const MouseEvent& rMEvt )
+		{ EndDialog(); }
+		virtual void Paint( const Rectangle& rRect );
+};
+
+class DemoRenderer
+{
+	public:
+		Size maSize;
+		Size maBox;
+		rendering::ViewState   maViewState;
+		rendering::RenderState maRenderState;
+		Sequence< double > maColorBlack;
+		Sequence< double > maColorWhite;
+		Sequence< double > maColorRed;
+		Reference< rendering::XCanvas > mxCanvas;
+		Reference< rendering::XCanvasFont > mxDefaultFont;
+		Reference< rendering::XGraphicDevice > mxDevice;
+
+		DemoRenderer( Reference< rendering::XGraphicDevice > xDevice,
+					  Reference< rendering::XCanvas > xCanvas,
+					  Size aSize ) :
+				mxDevice( xDevice ), mxCanvas( xCanvas ), maSize( aSize )
+		{
+			// Color init
+			maColorBlack = ::vcl::unotools::colorToDoubleSequence( xDevice, Color( COL_BLACK ) );
+			maColorWhite = ::vcl::unotools::colorToDoubleSequence( xDevice, Color( COL_WHITE ) );
+			maColorRed = ::vcl::unotools::colorToDoubleSequence( xDevice, Color( COL_RED ) );
+			// Geometry init
+			geometry::AffineMatrix2D aUnit( 1,0, 1,
+											0,1, 1 );
+			maViewState.AffineTransform = aUnit;
+			maRenderState.AffineTransform = aUnit;
+			maRenderState.DeviceColor = maColorBlack;
+			maRenderState.CompositeOperation = rendering::CompositeOperation::OVER;
+			maBox.Width() = aSize.Width() / 3;
+			maBox.Height() = aSize.Height() / 3;
+
+			lang::Locale aLocale;
+			rendering::FontInfo aFontInfo;
+			aFontInfo.FamilyName = OUString::createFromAscii( "Swiss" );
+			aFontInfo.StyleName = OUString::createFromAscii( "SansSerif" );
+			geometry::Matrix2D aFontMatrix( 1, 0,
+											0, 1 );
+			rendering::FontRequest aFontRequest( aFontInfo, 12.0, 12.0, aLocale );
+			Sequence< beans::PropertyValue > aExtraFontProperties;
+ 			mxDefaultFont = xCanvas->createFont( aFontRequest, aExtraFontProperties, aFontMatrix );
+			if( !mxDefaultFont.is() )
+				fprintf( stderr, "Failed to create font\n" );
+		}
+		void drawGrid()
+		{
+			double d, dIncr = maSize.Width() / 3;
+			for ( d = 0; d <= maSize.Width(); d += dIncr )
+				mxCanvas->drawLine( geometry::RealPoint2D( d, 0 ),
+									geometry::RealPoint2D( d, maSize.Height() ),
+									maViewState, maRenderState );
+			dIncr = maSize.Height() / 3;
+			for ( d = 0; d <= maSize.Height(); d += dIncr )
+				mxCanvas->drawLine( geometry::RealPoint2D( 0, d ),
+									geometry::RealPoint2D( maSize.Width(), d ),
+									maViewState, maRenderState );
+		}
+		void drawStringAt( OString aString, sal_Int32 x, sal_Int32 y )
+		{
+			rendering::StringContext aText;
+			aText.Text = OStringToOUString( aString, RTL_TEXTENCODING_UTF8 );
+			aText.StartPosition = 0;
+			aText.Length = aString.getLength();
+			rendering::RenderState aRenderState( maRenderState );
+			aRenderState.AffineTransform.m02 = x;
+			aRenderState.AffineTransform.m12 = y;
+
+			mxCanvas->drawText( aText, mxDefaultFont, maViewState, aRenderState, 0);
+		}
+		void drawRect( Rectangle rRect, Sequence< double > &aColor, int nWidth )
+		{
+			Sequence< geometry::RealPoint2D > aPoints(4);
+			Reference< rendering::XLinePolyPolygon2D > xPoly;
+
+			aPoints[0] = geometry::RealPoint2D( rRect.Top(), rRect.Left() );
+			aPoints[1] = geometry::RealPoint2D( rRect.Top(), rRect.Right() );
+			aPoints[2] = geometry::RealPoint2D( rRect.Bottom(), rRect.Right() );
+			aPoints[3] = geometry::RealPoint2D( rRect.Bottom(), rRect.Left() );
+
+			Sequence< Sequence< geometry::RealPoint2D > > aPolys(1);
+			aPolys[0] = aPoints;
+			xPoly = mxDevice->createCompatibleLinePolyPolygon( aPolys );
+			xPoly->setClosed( 0, true );
+			Reference< rendering::XPolyPolygon2D> xPP( xPoly, UNO_QUERY );
+			if( !xPP.is() )
+				fprintf( stderr, "Polygon conversion oddness\n" );
+			
+			rendering::RenderState aRenderState( maRenderState );
+			aRenderState.DeviceColor = aColor;
+			mxCanvas->drawPolyPolygon( xPP, maViewState, aRenderState );
+		}
+		void drawRectangles()
+		{
+			Point aWhere( 0, 0 );
+			Size  aBound( maBox );
+
+			drawStringAt ( OString( "Rectangles" ),
+						   aWhere.X() + aBound.Width() / 2,
+						   aWhere.Y() + 15 );
+
+			drawRect( Rectangle( 20, 30, 70, 60 ), maColorRed, 8 );
+			// color mediumseagreen, stipple fill, outline black
+			drawRect( Rectangle( 90, 40, 180, 100 ), maColorBlack, 4 );
+			// color steelblue, filled, no outline
+			drawRect( Rectangle( 10, 80, 80, 140 ), maColorBlack, 1 );
+
+			mxCanvas->drawLine( geometry::RealPoint2D( 20, 30 ),
+								geometry::RealPoint2D( 70, 60 ),
+								maViewState, maRenderState );
+		}
+};
+
+
+void TestWindow::Paint( const Rectangle& rRect )
+{
+	try
+	{
+		Reference< rendering::XCanvas > xCanvas( GetCanvas(),
+												 uno::UNO_QUERY_THROW );
+		Reference< rendering::XGraphicDevice > xDevice( xCanvas->getDevice(),
+														uno::UNO_QUERY_THROW );
+
+		DemoRenderer aRenderer( xDevice, xCanvas, GetSizePixel() );
+		aRenderer.drawGrid();
+
+		Reference< rendering::XSpriteCanvas > xSpriteCanvas( xCanvas, uno::UNO_QUERY_THROW );
+		xSpriteCanvas->updateScreen( sal_True );
+	}
+	catch (const uno::Exception &e)
+	{
+		fprintf( stderr, "Exception '%s' thrown\n" ,
+				 (const sal_Char *) OUStringToOString( e.Message, RTL_TEXTENCODING_UTF8 ) );
+	}
+}
+
+static void basicInit()
+{
+    Reference< XMultiServiceFactory >
+		xMSF = cppu::createRegistryServiceFactory(
+				rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "canvasdemo.rdb" ) ), sal_True );
+	::comphelper::setProcessServiceFactory( xMSF );
+
+	// Without this no file access works ...
+	::ucb::ContentProviderDataList aData;
+	::ucb::ContentProviderData aFileProvider(
+			rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.ucb.FileContentProvider" ) ),
+			rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "file" ) ),
+			rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "" ) ) );
+	aData.push_back( aFileProvider );
+	::ucb::ContentBroker::initialize( xMSF, aData );
+}
+
+void GalApp::Main()
+{
+	bool bHelp = false;
+
+	for( USHORT i = 0; i < GetCommandLineParamCount(); i++ )
+	{
+		OUString aParam = GetCommandLineParam( i );
+
+		if( aParam.equalsAscii( "--help" ) ||
+			aParam.equalsAscii( "-h" ) )
+				bHelp = true;
+	}
+
+	if( bHelp )
+	{
+		PrintHelp();
+		return;
+	}
+
+	basicInit();
+
+	TestWindow pWindow;
+	pWindow.Execute();
+}
+
+GalApp aGalApp;
+
+// TODO
+//   - bouncing clip-rectangle mode - bounce a clip-rect around the window ...
+//   - complete all of pre-existing canvas bits
+//   - affine transform tweakage ...
+
