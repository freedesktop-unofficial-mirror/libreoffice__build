--- /dev/null	
+++ accessibility/unx/atkbridge.cxx	
@@ -0,0 +1,180 @@
+#include "atkbridge.hxx"
+
+#include <com/sun/star/registry/XRegistryKey.hpp>
+#include <com/sun/star/lang/XSingleServiceFactory.hpp>
+
+using namespace ::rtl;
+using namespace ::osl;
+using namespace ::cppu;
+using namespace a11y;
+
+#define IMPLNAME "a11y::AtkBridge"
+#define SERVICENAME "com.sun.star.accessibility.AccessBridge"
+
+AtkBridge::AtkBridge(const uno::Reference< lang::XMultiServiceFactory >& rSMgr )
+{
+}
+AtkBridge::~AtkBridge()
+{
+}
+
+// XInterface implementation
+
+uno::Any AtkBridge::queryInterface( const uno::Type & rType ) throw (uno::RuntimeException)
+{
+	return cppu::queryInterface
+		(rType, 
+		 static_cast< uno::XInterface * >( static_cast< lang::XServiceInfo * >( this ) ),
+		 static_cast< awt::XTopWindowListener * >( this ),
+		 static_cast< lang::XInitialization * >( this ),
+		 static_cast< lang::XComponent * >( this ),
+		 static_cast< lang::XServiceInfo * >( this ) );
+}
+
+// XServiceInfo implementation
+
+rtl::OUString AtkBridge::getImplementationName()
+	throw(uno::RuntimeException)
+{
+	return OUString( RTL_CONSTASCII_USTRINGPARAM( IMPLNAME ) );
+}	
+
+sal_Bool AtkBridge::supportsService( const rtl::OUString& ServiceName ) 
+	throw(uno::RuntimeException)
+{
+	uno::Sequence< rtl::OUString > aSNL = getSupportedServiceNames();
+	const rtl::OUString * pArray = aSNL.getArray();
+	for( sal_Int32 i = 0; i < aSNL.getLength(); i++ )
+		if( pArray[i] == ServiceName )
+			return sal_True;
+	return sal_False;
+}	
+uno::Sequence< rtl::OUString > AtkBridge::getSupportedServiceNames() 
+	throw(uno::RuntimeException)
+{
+	return getSupportedServiceNames_Static();
+}	
+uno::Sequence<rtl::OUString> SAL_CALL AtkBridge::getSupportedServiceNames_Static(  ) 
+{
+	rtl::OUString aName( RTL_CONSTASCII_USTRINGPARAM(SERVICENAME) );
+	return uno::Sequence< rtl::OUString >( &aName, 1 );
+}	
+
+// XTopWindowListener implementation
+// XTopWindowListener
+void AtkBridge::windowOpened( const lang::EventObject& e ) throw (uno::RuntimeException)
+{
+}
+void AtkBridge::windowClosing( const lang::EventObject& e ) throw (uno::RuntimeException)
+{
+}
+void AtkBridge::windowClosed( const lang::EventObject& e ) throw (uno::RuntimeException)
+{
+}
+void AtkBridge::windowMinimized( const lang::EventObject& e ) throw (uno::RuntimeException)
+{
+}
+void AtkBridge::windowNormalized( const lang::EventObject& e ) throw (uno::RuntimeException)
+{
+}
+void AtkBridge::windowActivated( const lang::EventObject& e ) throw (uno::RuntimeException)
+{
+}
+void AtkBridge::windowDeactivated( const lang::EventObject& e ) throw (uno::RuntimeException)
+{
+}
+
+// XInitialization implementation
+
+void AtkBridge::initialize( const uno::Sequence< uno::Any >& aArguments ) throw (uno::Exception, uno::RuntimeException)
+{
+}
+
+// XComponent implementation
+
+void AtkBridge::dispose() throw (uno::RuntimeException)
+{
+}
+void AtkBridge::addEventListener( const uno::Reference< lang::XEventListener >& xListener ) throw (uno::RuntimeException)
+{
+}
+void AtkBridge::removeEventListener( const uno::Reference< lang::XEventListener >& aListener ) throw (uno::RuntimeException)
+{
+}
+
+// XEventListener implementation
+void AtkBridge::disposing( const lang::EventObject& Source ) throw (uno::RuntimeException)
+{
+}
+
+
+static uno::Reference< uno::XInterface > SAL_CALL AtkBridge_create(
+		const uno::Reference< lang::XMultiServiceFactory > & xMgr )
+{
+	return uno::Reference<uno::XInterface>(static_cast<awt::XTopWindowListener*>(new AtkBridge(xMgr)));
+}
+
+//============================ shlib entry points =============================================
+
+extern "C" void component_getImplementationEnvironment(const sal_Char ** ppEnvTypeName, uno_Environment ** ppEnv)
+{
+	*ppEnvTypeName = CPPU_CURRENT_LANGUAGE_BINDING_NAME;
+}
+
+extern "C" sal_Bool component_writeInfo (void *pServiceManager, void * pRegistryKey)
+{
+	sal_Bool result = sal_False;
+
+	if (pRegistryKey)
+	{
+		try
+		{
+			uno::Reference< registry::XRegistryKey > xNewKey(
+				reinterpret_cast< registry::XRegistryKey * >( pRegistryKey )->createKey(
+					rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("/" IMPLNAME "/UNO/SERVICES") ) ) );
+			
+			const uno::Sequence< rtl::OUString > & rSNL =
+				AtkBridge::getSupportedServiceNames_Static();
+			const rtl::OUString * pArray = rSNL.getConstArray();
+			for ( sal_Int32 nPos = rSNL.getLength(); nPos--; )
+				xNewKey->createKey( pArray[nPos] );
+			
+			return sal_True;
+		}
+		catch (registry::InvalidRegistryException &)
+		{
+			// we should not ignore exceptions
+		}
+	}
+	return result;
+}
+
+/**
+ * This function is called to get service factories for an implementation.
+ *
+ * @param pImplName       name of implementation
+ * @param pServiceManager a service manager, need for component creation
+ * @param pRegistryKey    the registry key for this component, need for persistent data
+ * @return a component factory 
+ */
+extern "C" void * component_getFactory(const sal_Char * pImplName, void * pServiceManager, void * pRegistryKey)
+{
+	void * pRet = 0;
+	
+	if (rtl_str_compare( pImplName, IMPLNAME ) == 0)
+	{
+		uno::Reference< lang::XSingleServiceFactory > xFactory( createSingleFactory(
+			reinterpret_cast< lang::XMultiServiceFactory * >( pServiceManager ),
+			rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(IMPLNAME) ),
+			AtkBridge_create,
+			AtkBridge::getSupportedServiceNames_Static() ) );
+		
+		if (xFactory.is())
+		{
+			xFactory->acquire();
+			pRet = xFactory.get();
+		}
+	}
+	
+	return pRet;
+}
