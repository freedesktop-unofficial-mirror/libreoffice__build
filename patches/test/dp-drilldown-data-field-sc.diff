? sc/sc.vpj
? sc/inc/dpcachetable.hxx
? sc/source/core/data/dpcachetable.cxx
Index: sc/inc/dpgroup.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dpgroup.hxx,v
retrieving revision 1.4
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.4 dpgroup.hxx
--- sc/inc/dpgroup.hxx	8 Sep 2005 17:34:35 -0000	1.4
+++ sc/inc/dpgroup.hxx	14 Sep 2007 03:32:55 -0000
@@ -212,6 +212,7 @@
     virtual UINT32                  GetNumberFormat(long nDim);
     virtual void                    DisposeData();
     virtual void                    SetEmptyFlags( BOOL bIgnoreEmptyRows, BOOL bRepeatIfEmpty );
+    virtual void                    CreateCacheTable();
 
     virtual void                    ResetIterator();
     virtual BOOL                    GetNextRow( const ScDPTableIteratorParam& rParam );
Index: sc/inc/dpobject.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dpobject.hxx,v
retrieving revision 1.12
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.12 dpobject.hxx
--- sc/inc/dpobject.hxx	27 Jun 2007 13:41:57 -0000	1.12
+++ sc/inc/dpobject.hxx	14 Sep 2007 03:32:55 -0000
@@ -78,7 +78,7 @@
 class StrCollection;
 class TypedStrCollection;
 struct PivotField;
-
+class ScDPCacheTable;
 
 struct ScDPServiceDesc
 {
@@ -223,6 +223,8 @@
 	BOOL				RefsEqual( const ScDPObject& r ) const;
 	void				WriteRefsTo( ScDPObject& r ) const;
 
+    void                GetDrillDownData(const ScAddress& rPos, ScDPCacheTable& rTableData);
+
 	// apply drop-down attribute, initialize nHeaderRows, without accessing the source
 	// (button attribute must be present)
 	void				RefreshAfterLoad();
Index: sc/inc/dpoutput.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dpoutput.hxx,v
retrieving revision 1.8
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.8 dpoutput.hxx
--- sc/inc/dpoutput.hxx	27 Jun 2007 13:42:13 -0000	1.8
+++ sc/inc/dpoutput.hxx	14 Sep 2007 03:32:55 -0000
@@ -60,6 +60,7 @@
 #include "address.hxx"
 #endif
 
+#include "dpcachetable.hxx"
 #include <vector>
 
 class Rectangle;
@@ -166,6 +167,11 @@
 	BOOL			HasError();			// range overflow or exception from source
 
 	void			GetPositionData( ScDPPositionData& rData, const ScAddress& rPos );
+
+    /** Get filtering criteria based on the position of the cell within data
+        field region. */
+    void            GetDataFieldCellData(::std::vector<ScDPCacheTable::Filter>& rFilters, const ScAddress& rPos);
+
     BOOL            GetPivotData( ScDPGetPivotDataField& rTarget, /* returns result */
                                   const std::vector< ScDPGetPivotDataField >& rFilters );
 	long			GetHeaderDim( const ScAddress& rPos, USHORT& rOrient );
Index: sc/inc/dpsdbtab.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dpsdbtab.hxx,v
retrieving revision 1.3
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.3 dpsdbtab.hxx
--- sc/inc/dpsdbtab.hxx	8 Sep 2005 17:35:48 -0000	1.3
+++ sc/inc/dpsdbtab.hxx	14 Sep 2007 03:32:55 -0000
@@ -50,6 +50,8 @@
 #include "dptabdat.hxx"
 #endif
 
+class ScDPCacheTable;
+
 // --------------------------------------------------------------------
 //
 //	implementation of ScDPTableData with database data
@@ -93,6 +95,7 @@
 	virtual BOOL					IsDateDimension(long nDim);
 	virtual void					DisposeData();
 	virtual void					SetEmptyFlags( BOOL bIgnoreEmptyRows, BOOL bRepeatIfEmpty );
+    virtual void                    CreateCacheTable();
 
 	virtual void					ResetIterator();
 	virtual BOOL					GetNextRow( const ScDPTableIteratorParam& rParam );
Index: sc/inc/dpshttab.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dpshttab.hxx,v
retrieving revision 1.4
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.4 dpshttab.hxx
--- sc/inc/dpshttab.hxx	8 Sep 2005 17:36:03 -0000	1.4
+++ sc/inc/dpshttab.hxx	14 Sep 2007 03:32:55 -0000
@@ -48,6 +48,7 @@
 #include "address.hxx"
 #endif
 
+#include <vector>
 
 // --------------------------------------------------------------------
 //
@@ -85,6 +86,10 @@
 	virtual void					DisposeData();
 	virtual void					SetEmptyFlags( BOOL bIgnoreEmptyRows, BOOL bRepeatIfEmpty );
 
+    virtual void                    CreateCacheTable();
+    virtual void                    GetDrillDownData(const ::std::vector<ScDPCacheTable::Filter>& rFilters, ScDPCacheTable& rData);
+    virtual sal_Int32               GetFieldIndex(const String& rStr);
+
 	virtual void					ResetIterator();
 	virtual BOOL					GetNextRow( const ScDPTableIteratorParam& rParam );
 };
Index: sc/inc/dptabdat.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dptabdat.hxx,v
retrieving revision 1.6
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.6 dptabdat.hxx
--- sc/inc/dptabdat.hxx	25 Jan 2007 11:03:15 -0000	1.6
+++ sc/inc/dptabdat.hxx	14 Sep 2007 03:32:55 -0000
@@ -40,10 +40,14 @@
 #include "address.hxx"
 #endif
 
+#include "dpoutput.hxx"
+
 #ifndef _STRING_HXX
 #include <tools/string.hxx>
 #endif
 
+#include <vector>
+
 class TypedStrCollection;
 
 // -----------------------------------------------------------------------
@@ -155,6 +159,10 @@
 	virtual void					DisposeData() = 0;
 	virtual void					SetEmptyFlags( BOOL bIgnoreEmptyRows, BOOL bRepeatIfEmpty ) = 0;
 
+    virtual void                    CreateCacheTable() = 0;
+    virtual void                    GetDrillDownData(const ::std::vector<ScDPCacheTable::Filter>& rFilters, ScDPCacheTable& rTableData);
+    virtual sal_Int32               GetFieldIndex(const String& rStr);
+
 	virtual void					ResetIterator() = 0;
 	virtual BOOL					GetNextRow( const ScDPTableIteratorParam& rParam ) = 0;
 
Index: sc/source/core/data/dpgroup.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dpgroup.cxx,v
retrieving revision 1.7
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.7 dpgroup.cxx
--- sc/source/core/data/dpgroup.cxx	27 Feb 2007 12:03:31 -0000	1.7
+++ sc/source/core/data/dpgroup.cxx	14 Sep 2007 03:32:55 -0000
@@ -51,6 +51,7 @@
 #include "collect.hxx"
 #include "global.hxx"
 #include "document.hxx"
+#include "dpcachetable.hxx"
 
 #ifndef _COM_SUN_STAR_SHEET_DATAPILOTFIELDGROUPBY_HPP_
 #include <com/sun/star/sheet/DataPilotFieldGroupBy.hpp>
@@ -972,6 +973,10 @@
     pSourceData->SetEmptyFlags( bIgnoreEmptyRows, bRepeatIfEmpty );
 }
 
+void ScDPGroupTableData::CreateCacheTable()
+{
+}
+
 void ScDPGroupTableData::ResetIterator()
 {
     pSourceData->ResetIterator();
Index: sc/source/core/data/dpobject.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dpobject.cxx,v
retrieving revision 1.21
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.21 dpobject.cxx
--- sc/source/core/data/dpobject.cxx	27 Jun 2007 13:43:19 -0000	1.21
+++ sc/source/core/data/dpobject.cxx	14 Sep 2007 03:32:56 -0000
@@ -73,7 +73,10 @@
 #include <tools/debug.hxx>
 #include <svtools/zforlist.hxx>		// IsNumberFormat
 
+#include <vector>
+
 using namespace com::sun::star;
+using ::std::vector;
 
 // -----------------------------------------------------------------------
 
@@ -601,6 +604,18 @@
 		r.SetSheetDesc( *pSheetDesc );
 }
 
+void ScDPObject::GetDrillDownData(const ScAddress& rPos, ScDPCacheTable& rTableData)
+{
+    CreateOutput();
+
+    vector<ScDPCacheTable::Filter> aFilters;
+    pOutput->GetDataFieldCellData(aFilters, rPos);
+
+    ScDPSource* pSource = static_cast<ScDPSource*>(xSource.get());
+    ScDPTableData* pData = pSource->GetData();
+    pData->GetDrillDownData(aFilters, rTableData);
+}
+
 BOOL ScDPObject::IsDimNameInUse( const String& rName ) const
 {
 	if ( xSource.is() )
Index: sc/source/core/data/dpoutput.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dpoutput.cxx,v
retrieving revision 1.15
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.15 dpoutput.cxx
--- sc/source/core/data/dpoutput.cxx	27 Jun 2007 13:43:33 -0000	1.15
+++ sc/source/core/data/dpoutput.cxx	14 Sep 2007 03:32:56 -0000
@@ -36,7 +36,7 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
-
+#include <stdio.h>
 
 // INCLUDE ---------------------------------------------------------------
 
@@ -48,6 +48,8 @@
 #include <unotools/transliterationwrapper.hxx>
 
 #include "dpoutput.hxx"
+#include "dptabsrc.hxx"
+#include "dpcachetable.hxx"
 #include "document.hxx"
 #include "patattr.hxx"
 #include "docpool.hxx"
@@ -73,7 +75,10 @@
 #include <com/sun/star/sheet/GeneralFunction.hpp>
 #include <com/sun/star/container/XNamed.hpp>
 
+#include <vector>
+
 using namespace com::sun::star;
+using ::std::vector;
 
 // -----------------------------------------------------------------------
 
@@ -995,6 +1000,72 @@
 	}
 }
 
+void ScDPOutput::GetDataFieldCellData(vector<ScDPCacheTable::Filter>& rFilters, const ScAddress& rPos)
+{
+	SCCOL nCol = rPos.Col();
+	SCROW nRow = rPos.Row();
+	SCTAB nTab = rPos.Tab();
+	if ( nTab != aStartPos.Tab() )
+		return;										// wrong sheet
+
+	CalcSizes();
+
+    fprintf(stdout, "ScDPOutput::GetDataFieldCellData: table (%d, %ld) - (%d, %ld); data start (%d, %ld)\n",
+            nTabStartCol, nTabStartRow, nTabEndCol, nTabEndRow, nDataStartCol, nDataStartRow);fflush(stdout);
+
+    // test for data area.
+    if (nCol < nDataStartCol || nCol > nTabEndCol || nRow < nDataStartRow || nRow > nTabEndRow)
+        // Cell is outside the data field area.
+        return;
+
+    ScDPSource* pSource = static_cast<ScDPSource*>(xSource.get());
+    ScDPTableData* pData = pSource->GetData();
+
+    // column fields
+    for (SCCOL nColField = 0; nColField < nColFieldCount; ++nColField)
+    {
+        ScDPCacheTable::Filter aFilter;
+        aFilter.mnFieldIndex = pData->GetFieldIndex(pColFields[nColField].aCaption);
+
+        const uno::Sequence<sheet::MemberResult> rSequence = pColFields[nColField].aResult;
+        long nThisColCount = rSequence.getLength();
+        const sheet::MemberResult* pArray = rSequence.getConstArray();
+
+        DBG_ASSERT(nDataStartCol + nThisColCount - 1 == nTabEndCol, "ScDPOutput::GetDataFieldCellData: error in geometric assumption");
+
+        long nItem = nCol - nDataStartCol;
+                //	get origin of "continue" fields
+        while ( nItem > 0 && (pArray[nItem].Flags & sheet::MemberResultFlags::CONTINUE) )
+            --nItem;
+
+        aFilter.maMatchValue = pArray[nItem].Name;
+        if (aFilter.maMatchValue.Len() > 0 && !aFilter.maMatchValue.EqualsAscii("Total"))
+            rFilters.push_back(aFilter);
+    }
+
+    // row fields
+    for (SCROW nRowField = 0; nRowField < nRowFieldCount; ++nRowField)
+    {
+        ScDPCacheTable::Filter aFilter;
+        aFilter.mnFieldIndex = pData->GetFieldIndex(pRowFields[nRowField].aCaption);
+
+        const uno::Sequence<sheet::MemberResult> rSequence = pRowFields[nRowField].aResult;
+        long nThisRowCount = rSequence.getLength();
+        const sheet::MemberResult* pArray = rSequence.getConstArray();
+
+        DBG_ASSERT(nDataStartRow + nThisRowCount - 1 == nTabEndRow, "ScDPOutput::GetDataFieldCellData: error in geometric assumption");
+
+        long nItem = nRow - nDataStartRow;
+			//	get origin of "continue" fields
+        while ( nItem > 0 && (pArray[nItem].Flags & sheet::MemberResultFlags::CONTINUE) )
+            --nItem;
+
+        aFilter.maMatchValue = pArray[nItem].Name;
+        if (aFilter.maMatchValue.Len() > 0 && !aFilter.maMatchValue.EqualsAscii("Total"))
+            rFilters.push_back(aFilter);
+    }
+}
+
 //
 //  helper functions for ScDPOutput::GetPivotData
 //
Index: sc/source/core/data/dpsdbtab.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dpsdbtab.cxx,v
retrieving revision 1.12
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.12 dpsdbtab.cxx
--- sc/source/core/data/dpsdbtab.cxx	27 Feb 2007 12:04:37 -0000	1.12
+++ sc/source/core/data/dpsdbtab.cxx	14 Sep 2007 03:32:56 -0000
@@ -60,6 +60,7 @@
 #include "collect.hxx"
 #include "global.hxx"
 #include "globstr.hrc"
+#include "dpcachetable.hxx"
 
 using namespace com::sun::star;
 
@@ -500,6 +501,10 @@
 	//!	disable flags
 }
 
+void ScDatabaseDPData::CreateCacheTable()
+{
+}
+
 void ScDatabaseDPData::ResetIterator()
 {
 	try
Index: sc/source/core/data/dpshttab.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dpshttab.cxx,v
retrieving revision 1.9
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.9 dpshttab.cxx
--- sc/source/core/data/dpshttab.cxx	27 Feb 2007 12:04:49 -0000	1.9
+++ sc/source/core/data/dpshttab.cxx	14 Sep 2007 03:32:56 -0000
@@ -36,7 +36,7 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
-
+#include <stdio.h>
 
 // INCLUDE --------------------------------------------------------------
 
@@ -47,8 +47,13 @@
 #include "document.hxx"
 #include "collect.hxx"
 #include "cell.hxx"
+#include "dpcachetable.hxx"
 #include "globstr.hrc"
 
+#include <vector>
+
+using ::std::vector;
+
 // -----------------------------------------------------------------------
 
 class ScSheetDPData_Impl
@@ -57,13 +62,15 @@
 	ScDocument*		pDoc;
 	ScRange			aRange;
 	ScQueryParam	aQuery;
-	long			nColCount;
+	long			nColCount;          // number of columns
 	BOOL			bIgnoreEmptyRows;
 	BOOL			bRepeatIfEmpty;
-	TypedStrCollection**	ppStrings;
+	TypedStrCollection**	ppStrings;  // array of unique column entries.
 	BOOL*			pDateDim;
 	SCROW			nNextRow;		// for iterator, within range
 
+    ScDPCacheTable  aCacheTable;
+
 	ScSheetDPData_Impl() {}
 };
 
@@ -295,6 +302,41 @@
 	pImpl->bRepeatIfEmpty   = bRepeatIfEmpty;
 }
 
+void ScSheetDPData::CreateCacheTable()
+{
+    sal_Int32 nCacheRowSize = pImpl->aCacheTable.getRowSize();
+    if (nCacheRowSize > 0)
+        // source data already cached.
+        return;
+
+    // Scan and store the data from the source range.
+    pImpl->aCacheTable.fillTable(pImpl->pDoc, pImpl->aRange);
+}
+
+void ScSheetDPData::GetDrillDownData(const vector<ScDPCacheTable::Filter>& rFilters,
+                                     ScDPCacheTable& rData)
+{
+    sal_Int32 nRowSize = pImpl->aCacheTable.getRowSize();
+    if (!nRowSize)
+        return;
+
+#if 0
+    vector<ScDPCacheTable::Filter>::const_iterator itr, itrEnd = rFilters.end();
+    for (itr = rFilters.begin(); itr != itrEnd; ++itr)
+    {
+        fprintf(stdout, "ScSheetDPData::GetDrillDownData: %ld\t%s\n",
+                itr->mnFieldIndex, OUStringToOString(rtl::OUString(itr->maMatchValue), RTL_TEXTENCODING_UTF8).getStr());fflush(stdout);
+    }
+#endif
+
+    pImpl->aCacheTable.filterTable(rFilters, rData);
+}
+
+sal_Int32 ScSheetDPData::GetFieldIndex(const String& rStr)
+{
+    return pImpl->aCacheTable.getFieldIndex(rStr);
+}
+
 void ScSheetDPData::ResetIterator()
 {
 	pImpl->nNextRow = pImpl->aRange.aStart.Row() + 1;
Index: sc/source/core/data/dptabdat.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dptabdat.cxx,v
retrieving revision 1.12
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.12 dptabdat.cxx
--- sc/source/core/data/dptabdat.cxx	27 Feb 2007 12:05:02 -0000	1.12
+++ sc/source/core/data/dptabdat.cxx	14 Sep 2007 03:32:56 -0000
@@ -36,7 +36,7 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
-
+#include <stdio.h>
 
 // INCLUDE ---------------------------------------------------------------
 
@@ -53,6 +53,8 @@
 #include "dptabdat.hxx"
 #include "global.hxx"
 
+using ::std::vector;
+
 // -----------------------------------------------------------------------
 
 BOOL ScDPItemData::IsCaseInsEqual( const ScDPItemData& r ) const
@@ -193,6 +195,15 @@
 	return nRet;
 }
 
+void ScDPTableData::GetDrillDownData(const vector<ScDPCacheTable::Filter>& rFilters, ScDPCacheTable& rTableData)
+{
+}
+
+sal_Int32 ScDPTableData::GetFieldIndex(const String& rStr)
+{
+    return -1;
+}
+
 UINT32 ScDPTableData::GetNumberFormat(long)
 {
 	return 0;			// default format
Index: sc/source/core/data/dptabsrc.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dptabsrc.cxx,v
retrieving revision 1.19
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.19 dptabsrc.cxx
--- sc/source/core/data/dptabsrc.cxx	5 Mar 2007 14:40:18 -0000	1.19
+++ sc/source/core/data/dptabsrc.cxx	14 Sep 2007 03:32:57 -0000
@@ -795,6 +795,7 @@
 						nDataDimCount,   nDataSrcCols,   aValues );
 
 			pData->ResetIterator();
+            pData->CreateCacheTable();
 			while ( pData->GetNextRow( aIterPar ) )
 			{
 				// test page fields ----------------------------
Index: sc/source/core/data/makefile.mk
===================================================================
RCS file: /cvs/sc/sc/source/core/data/makefile.mk,v
retrieving revision 1.21
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.21 makefile.mk
--- sc/source/core/data/makefile.mk	27 Feb 2007 12:06:42 -0000	1.21
+++ sc/source/core/data/makefile.mk	14 Sep 2007 03:32:57 -0000
@@ -77,6 +77,7 @@
 	$(SLO)$/documen8.obj \
 	$(SLO)$/documen9.obj \
 	$(SLO)$/document.obj \
+        $(SLO)$/dpcachetable.obj \
         $(SLO)$/dpdimsave.obj \
         $(SLO)$/dpgroup.obj \
 	$(SLO)$/dpobject.obj \
Index: sc/source/ui/view/gridwin.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/view/gridwin.cxx,v
retrieving revision 1.83
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.83 gridwin.cxx
--- sc/source/ui/view/gridwin.cxx	21 Aug 2007 12:27:31 -0000	1.83
+++ sc/source/ui/view/gridwin.cxx	14 Sep 2007 03:32:58 -0000
@@ -36,7 +36,7 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
-
+#include <stdio.h>
 
 //------------------------------------------------------------------
 
@@ -2178,11 +2178,16 @@
 		Point aPos = rMEvt.GetPosPixel();
         SCsCOL nPosX;
         SCsROW nPosY;
+        SCTAB nTab = pViewData->GetTabNo();
         pViewData->GetPosFromPixel( aPos.X(), aPos.Y(), eWhich, nPosX, nPosY );
-		ScDPObject*	pDPObj	= pDoc->GetDPAtCursor( nPosX, nPosY, pViewData->GetTabNo() );
+		ScDPObject*	pDPObj	= pDoc->GetDPAtCursor( nPosX, nPosY, nTab );
 		if ( pDPObj && pDPObj->GetSaveData()->GetDrillDown() )
 		{
-			ScAddress aCellPos( nPosX, nPosY, pViewData->GetTabNo() );
+            fprintf(stdout, "ScGridWindow::MouseButtonUp: *---------- pivot table hit (name = '%s'; tag = '%s') ----------*\n",
+                    OUStringToOString(rtl::OUString(pDPObj->GetName()), RTL_TEXTENCODING_UTF8).getStr(),
+                    OUStringToOString(rtl::OUString(pDPObj->GetTag()), RTL_TEXTENCODING_UTF8).getStr());fflush(stdout);
+
+			ScAddress aCellPos( nPosX, nPosY, nTab );
 			ScDPPositionData aData;
 			pDPObj->GetPositionData( aData, aCellPos );
 
@@ -2206,7 +2211,30 @@
                 }
 			}
 			else
-				Sound::Beep();		// nothing to expand/collapse
+            {
+                // Check if the data area is double-clicked.
+                ScDPCacheTable aArrayData;
+                pDPObj->GetDrillDownData(aCellPos, aArrayData);
+                ScTabViewShell* pViewShell = pViewData->GetViewShell();
+                String aNewTabName;
+                pViewData->GetDocument()->CreateValidTabName(aNewTabName);
+                if ( pViewShell->InsertTable(aNewTabName, nTab+1, false) )
+                {
+                    sal_Int32 nRowSize = aArrayData.getRowSize();
+                    sal_Int32 nColSize = aArrayData.getColSize();
+                    for (sal_Int32 nRow = 0; nRow < nRowSize; ++nRow)
+                    {
+                        for (sal_Int32 nCol = 0; nCol < nColSize; ++nCol)
+                        {
+                            const ScDPCacheTable::Cell* pCell = aArrayData.getCell(nCol, nRow);
+                            if (pCell->mbNumeric)
+                                pDoc->SetValue(nCol, nRow, nTab+1, pCell->mfValue);
+                            else
+                                pDoc->SetString(nCol, nRow, nTab+1, pCell->maStrValue);
+                        }
+                    }
+                }
+            }
 
 			return;
 		}
--- /dev/null	2007-05-04 06:54:36.000000000 -0400
+++ sc/inc/dpcachetable.hxx	2007-09-13 22:24:34.000000000 -0400
@@ -0,0 +1,99 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: dpobject.hxx,v $
+ *
+ *  $Revision: 1.12 $
+ *
+ *  last change: $Author: hr $ $Date: 2007/06/27 13:41:57 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef SC_DPCACHETABLE_HXX
+#define SC_DPCACHETABLE_HXX
+
+#include "sal/types.h"
+#include "global.hxx"
+
+#include <vector>
+
+class ScDocument;
+class ScRange;
+
+class ScDPCacheTable
+{
+public:
+    /** individual cell within table. */
+    struct Cell
+    {
+        String  maStrValue;
+        double  mfValue;
+        bool    mbNumeric;
+
+        Cell();
+    };
+
+    /** filtering criteria */
+    struct Filter
+    {
+        sal_Int32   mnFieldIndex;
+        String      maMatchValue;
+
+        Filter();
+    };
+
+    ScDPCacheTable();
+    ~ScDPCacheTable();
+
+    sal_Int32 getRowSize() const;
+    sal_Int32 getColSize() const;
+
+    /** Fill the internal table from the cell range provided.  This function
+        assumes that the first row is the column header. */
+    void fillTable(ScDocument* pDoc, const ScRange& rRange);
+
+    /** Get the cell instance at specified location.  Don't delete the returned
+        object! */
+    const ::ScDPCacheTable::Cell* getCell(SCCOL nCol, SCROW nRow) const;
+
+    /** Get the field index (i.e. column ID in the original data source) based
+        on the string value. */
+    sal_Int32 getFieldIndex(const String& rStr) const;
+
+    /** Get a new table that contains filtered version of the original table. */
+    void filterTable(const ::std::vector<Filter>& rFilters, ScDPCacheTable& rNewTable) const;
+
+    void clear();
+    void swap(ScDPCacheTable& rOther);
+
+private:
+    ::std::vector< ::std::vector< ::ScDPCacheTable::Cell > > maTable;
+    ::std::vector<String> maHeader; // a list of header labels.
+};
+
+
+#endif
--- /dev/null	2007-05-04 06:54:36.000000000 -0400
+++ sc/source/core/data/dpcachetable.cxx	2007-09-13 21:50:31.000000000 -0400
@@ -0,0 +1,217 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: dpobject.hxx,v $
+ *
+ *  $Revision: 1.12 $
+ *
+ *  last change: $Author: hr $ $Date: 2007/06/27 13:41:57 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "dpcachetable.hxx"
+#include "document.hxx"
+#include "address.hxx"
+#include "cell.hxx"
+
+using ::std::vector;
+
+#include <stdio.h>
+
+ScDPCacheTable::Cell::Cell() :
+    mfValue(0.0),
+    mbNumeric(false)
+{
+}
+
+ScDPCacheTable::Filter::Filter()
+{
+}
+
+ScDPCacheTable::ScDPCacheTable()
+{
+}
+
+ScDPCacheTable::~ScDPCacheTable()
+{
+}
+
+sal_Int32 ScDPCacheTable::getRowSize() const
+{
+    return maTable.size();
+}
+
+sal_Int32 ScDPCacheTable::getColSize() const
+{
+    return maTable.empty() ? 0 : maTable[0].size();
+}
+
+void ScDPCacheTable::fillTable(ScDocument* pDoc, const ScRange& rRange)
+{
+    SCTAB nTab = rRange.aStart.Tab();
+    SCCOL nStartCol = rRange.aStart.Col();
+    SCROW nStartRow = rRange.aStart.Row();
+    SCCOL nColCount = rRange.aEnd.Col() - rRange.aStart.Col() + 1;
+    SCROW nRowCount = rRange.aEnd.Row() - rRange.aStart.Row() + 1;
+
+    maTable.clear();
+    maTable.reserve(nRowCount);
+    maHeader.clear();
+    maHeader.reserve(nColCount);
+
+    for (SCROW nRow = 0; nRow < nRowCount; ++nRow)
+    {
+        maTable.push_back( vector<Cell>() );
+        maTable.back().reserve(nColCount);
+
+        for (SCCOL nCol = 0; nCol < nColCount; ++nCol)
+        {
+            if (nRow == 0)
+                // insert empty string into header array.
+                maHeader.push_back(String());
+
+            maTable.back().push_back( ScDPCacheTable::Cell() );
+            Cell& rCell = maTable.back().back();
+
+            ScAddress aPos(nStartCol + nCol, nStartRow + nRow, nTab);
+            ScBaseCell* pCell = pDoc->GetCell(aPos);
+            if ( !pCell )
+                continue;
+
+            // This call converts a number to string if necessary.
+            pDoc->GetString(nCol, nRow, nTab, rCell.maStrValue);
+
+            if (nRow == 0)
+                // grab the header value.
+                maHeader.back().Append(rCell.maStrValue);
+
+            if ( pCell->HasValueData() )
+            {
+                CellType eType = pCell->GetCellType();
+                if (eType == CELLTYPE_VALUE)
+                {
+                    // value cell
+                    rCell.mfValue = static_cast<ScValueCell*>(pCell)->GetValue();
+                }
+                else if (eType == CELLTYPE_FORMULA)
+                {
+                    // formula cell
+                    rCell.mfValue = static_cast<ScFormulaCell*>(pCell)->GetValue();
+                }
+                rCell.mbNumeric = true;
+            }
+        }
+    }
+}
+
+const ::ScDPCacheTable::Cell* ScDPCacheTable::getCell(SCCOL nCol, SCROW nRow) const
+{
+    if ( nRow >= maTable.size() )
+        return NULL;
+
+    const vector<Cell>& rRow = maTable[nRow];
+    if ( nCol >= rRow.size() )
+        return NULL;
+
+    return &rRow[nCol];
+}
+
+sal_Int32 ScDPCacheTable::getFieldIndex(const String& rStr) const
+{
+    sal_Int32 n = maHeader.size();
+    for (sal_Int32 i = 0; i < n; ++i)
+    {
+        if (maHeader[i].Equals(rStr))
+            return i;
+    }
+
+    return -1;
+}
+
+void ScDPCacheTable::filterTable(const vector<Filter>& rFilters, ScDPCacheTable& rNewTable) const
+{
+    sal_Int32 nRowSize = getRowSize();
+    sal_Int32 nColSize = getColSize();
+
+    if (!nRowSize)
+        // no data to filter.
+        return;
+
+    ScDPCacheTable aNewTable;
+    aNewTable.maTable.reserve(nRowSize);
+
+    // Copy the header first.
+    aNewTable.maTable.push_back( vector<Cell>() );
+    for (sal_Int32 nCol = 0; nCol < nColSize; ++nCol)
+        aNewTable.maTable.back().push_back( maTable[0][nCol] );
+
+    aNewTable.maHeader = maHeader;
+
+    for (sal_Int32 nRow = 1; nRow < nRowSize; ++nRow)
+    {
+        bool bRetainRow = true;
+        vector<Filter>::const_iterator itr, itrEnd = rFilters.end();
+        for (itr = rFilters.begin(); itr != itrEnd; ++itr)
+        {
+            if (itr->mnFieldIndex >= nColSize)
+            {
+                // specified field is outside the source data columns.
+                bRetainRow = false;
+                break;
+            }
+
+            if ( !maTable[nRow][itr->mnFieldIndex].maStrValue.Equals(itr->maMatchValue) )
+            {
+                // The string value does not match.
+                bRetainRow = false;
+                break;
+            }
+        }
+
+        if (bRetainRow)
+        {
+            aNewTable.maTable.push_back( vector<Cell>() );
+            for (sal_Int32 nCol = 0; nCol < nColSize; ++nCol)
+                aNewTable.maTable.back().push_back( maTable[nRow][nCol] );
+        }
+    }
+
+    // All good.  Commit.
+    rNewTable.swap(aNewTable);
+}
+
+void ScDPCacheTable::clear()
+{
+    maTable.clear();
+    maHeader.clear();
+}
+
+void ScDPCacheTable::swap(ScDPCacheTable& rOther)
+{
+    maTable.swap(rOther.maTable);
+    maHeader.swap(rOther.maHeader);
+}
