? sc/runtime.log
? sc/sc.vpj
? sc/inc/dpcachetable.hxx
? sc/source/core/data/dpcachetable.cxx
? sc/source/ui/inc/autofiltercontrol.hxx
? sc/source/ui/miscdlgs/autofiltercontrol.cxx
Index: sc/inc/addincol.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/addincol.hxx,v
retrieving revision 1.9
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.9 addincol.hxx
--- sc/inc/addincol.hxx	4 Aug 2006 12:10:52 -0000	1.9
+++ sc/inc/addincol.hxx	24 Sep 2007 02:43:56 -0000
@@ -36,6 +36,7 @@
 #ifndef SC_ADDINCOL_HXX
 #define SC_ADDINCOL_HXX
 
+#include "global.hxx"
 
 #ifndef _COM_SUN_STAR_SHEET_XVOLATILERESULT_HPP_
 #include <com/sun/star/sheet/XVolatileResult.hpp>
@@ -87,14 +88,7 @@
 class ScFuncDesc;
 
 
-struct ScAddInStringHashCode
-{
-    size_t operator()( const String& rStr ) const
-	{
-        return rtl_ustr_hashCode_WithLength( rStr.GetBuffer(), rStr.Len() );
-	}
-};
-typedef ::std::hash_map< String, const ScUnoAddInFuncData*, ScAddInStringHashCode, ::std::equal_to< String > > ScAddInHashMap;
+typedef ::std::hash_map< String, const ScUnoAddInFuncData*, ScStringHashCode, ::std::equal_to< String > > ScAddInHashMap;
 
 
 enum ScAddInArgumentType
Index: sc/inc/autonamecache.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/autonamecache.hxx,v
retrieving revision 1.2
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.2 autonamecache.hxx
--- sc/inc/autonamecache.hxx	31 Jan 2006 18:34:36 -0000	1.2
+++ sc/inc/autonamecache.hxx	24 Sep 2007 02:43:56 -0000
@@ -42,17 +42,10 @@
 #ifndef SC_ADDRESS_HXX
 #include "address.hxx"
 #endif
-
-struct ScAutoNameHashCode
-{
-    size_t operator()( const String& rStr ) const
-	{
-        return rtl_ustr_hashCode_WithLength( rStr.GetBuffer(), rStr.Len() );
-	}
-};
+#include "global.hxx"
 
 typedef ::std::vector< ScAddress > ScAutoNameAddresses;
-typedef ::std::hash_map< String, ScAutoNameAddresses, ScAutoNameHashCode, ::std::equal_to< String > > ScAutoNameHashMap;
+typedef ::std::hash_map< String, ScAutoNameAddresses, ScStringHashCode, ::std::equal_to< String > > ScAutoNameHashMap;
 
 //
 //  Cache for faster lookup of automatic names during CompileXML
Index: sc/inc/dpobject.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dpobject.hxx,v
retrieving revision 1.12
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.12 dpobject.hxx
--- sc/inc/dpobject.hxx	27 Jun 2007 13:41:57 -0000	1.12
+++ sc/inc/dpobject.hxx	24 Sep 2007 02:43:56 -0000
@@ -78,7 +78,7 @@
 class StrCollection;
 class TypedStrCollection;
 struct PivotField;
-
+class ScDPCacheTable;
 
 struct ScDPServiceDesc
 {
@@ -223,6 +223,8 @@
 	BOOL				RefsEqual( const ScDPObject& r ) const;
 	void				WriteRefsTo( ScDPObject& r ) const;
 
+    void                GetDrillDownData(const ScAddress& rPos, ScDPCacheTable& rTableData);
+
 	// apply drop-down attribute, initialize nHeaderRows, without accessing the source
 	// (button attribute must be present)
 	void				RefreshAfterLoad();
Index: sc/inc/dpoutput.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dpoutput.hxx,v
retrieving revision 1.8
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.8 dpoutput.hxx
--- sc/inc/dpoutput.hxx	27 Jun 2007 13:42:13 -0000	1.8
+++ sc/inc/dpoutput.hxx	24 Sep 2007 02:43:56 -0000
@@ -60,6 +60,7 @@
 #include "address.hxx"
 #endif
 
+#include "dpcachetable.hxx"
 #include <vector>
 
 class Rectangle;
@@ -166,6 +167,11 @@
 	BOOL			HasError();			// range overflow or exception from source
 
 	void			GetPositionData( ScDPPositionData& rData, const ScAddress& rPos );
+
+    /** Get filtering criteria based on the position of the cell within data
+        field region. */
+    bool            GetDataFieldPositionData(::std::vector<ScDPCacheTable::Filter>& rFilters, const ScAddress& rPos);
+
     BOOL            GetPivotData( ScDPGetPivotDataField& rTarget, /* returns result */
                                   const std::vector< ScDPGetPivotDataField >& rFilters );
 	long			GetHeaderDim( const ScAddress& rPos, USHORT& rOrient );
Index: sc/inc/dpsdbtab.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dpsdbtab.hxx,v
retrieving revision 1.3
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.3 dpsdbtab.hxx
--- sc/inc/dpsdbtab.hxx	8 Sep 2005 17:35:48 -0000	1.3
+++ sc/inc/dpsdbtab.hxx	24 Sep 2007 02:43:56 -0000
@@ -50,6 +50,8 @@
 #include "dptabdat.hxx"
 #endif
 
+class ScDPCacheTable;
+
 // --------------------------------------------------------------------
 //
 //	implementation of ScDPTableData with database data
Index: sc/inc/dpshttab.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dpshttab.hxx,v
retrieving revision 1.4
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.4 dpshttab.hxx
--- sc/inc/dpshttab.hxx	8 Sep 2005 17:36:03 -0000	1.4
+++ sc/inc/dpshttab.hxx	24 Sep 2007 02:43:56 -0000
@@ -48,6 +48,9 @@
 #include "address.hxx"
 #endif
 
+#include <vector>
+
+class ScDPDimension;
 
 // --------------------------------------------------------------------
 //
@@ -70,7 +73,6 @@
 {
 private:
 	ScSheetDPData_Impl* pImpl;
-    BOOL* pSpecial;
 
 public:
 					ScSheetDPData( ScDocument* pD, const ScSheetSourceDesc& rDesc );
@@ -85,6 +87,10 @@
 	virtual void					DisposeData();
 	virtual void					SetEmptyFlags( BOOL bIgnoreEmptyRows, BOOL bRepeatIfEmpty );
 
+    virtual void                    CreateCacheTable(const ::std::vector<ScDPDimension*>& rPageDims);
+    virtual void                    GetDrillDownData(const ::std::vector<ScDPCacheTable::Filter>& rFilters, ScDPCacheTable& rData);
+    virtual sal_Int32               GetFieldIndex(const String& rStr);
+
 	virtual void					ResetIterator();
 	virtual BOOL					GetNextRow( const ScDPTableIteratorParam& rParam );
 };
Index: sc/inc/dptabdat.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dptabdat.hxx,v
retrieving revision 1.6
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.6 dptabdat.hxx
--- sc/inc/dptabdat.hxx	25 Jan 2007 11:03:15 -0000	1.6
+++ sc/inc/dptabdat.hxx	24 Sep 2007 02:43:56 -0000
@@ -40,11 +40,16 @@
 #include "address.hxx"
 #endif
 
+#include "dpoutput.hxx"
+
 #ifndef _STRING_HXX
 #include <tools/string.hxx>
 #endif
 
+#include <vector>
+
 class TypedStrCollection;
+class ScDPDimension;
 
 // -----------------------------------------------------------------------
 
@@ -110,16 +115,16 @@
 {
 	//	all pointers are just copied
 
-	SCSIZE			nColCount;
+	SCSIZE			nColCount;      // # column fields
 	const long*		pCols;
 	ScDPItemData*	pColData;
-	SCSIZE			nRowCount;
+	SCSIZE			nRowCount;      // # row fields
 	const long*		pRows;
 	ScDPItemData*	pRowData;
-	SCSIZE			nPageCount;
+	SCSIZE			nPageCount;     // # page fields
 	const long*		pPages;
 	ScDPItemData*	pPageData;
-	SCSIZE			nDatCount;
+	SCSIZE			nDatCount;      // # data fields
 	const long*		pDats;
 	ScDPValueData*	pValues;
 
@@ -155,6 +160,10 @@
 	virtual void					DisposeData() = 0;
 	virtual void					SetEmptyFlags( BOOL bIgnoreEmptyRows, BOOL bRepeatIfEmpty ) = 0;
 
+    virtual void                    CreateCacheTable(const ::std::vector<ScDPDimension*>& rPageDims);
+    virtual void                    GetDrillDownData(const ::std::vector<ScDPCacheTable::Filter>& rFilters, ScDPCacheTable& rTableData);
+    virtual sal_Int32               GetFieldIndex(const String& rStr);
+
 	virtual void					ResetIterator() = 0;
 	virtual BOOL					GetNextRow( const ScDPTableIteratorParam& rParam ) = 0;
 
Index: sc/inc/dptabsrc.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dptabsrc.hxx,v
retrieving revision 1.8
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.8 dptabsrc.hxx
--- sc/inc/dptabsrc.hxx	25 Jan 2007 11:03:43 -0000	1.8
+++ sc/inc/dptabsrc.hxx	24 Sep 2007 02:43:56 -0000
@@ -358,7 +358,7 @@
 {
 private:
 	ScDPSource*			pSource;
-	long				nDim;
+	long				nDim;               // dimension index (== column ID)
 	ScDPHierarchies*	pHierarchies;
 	long				nUsedHier;
 	USHORT				nFunction;			// enum GeneralFunction
Index: sc/source/core/data/dpgroup.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dpgroup.cxx,v
retrieving revision 1.7
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.7 dpgroup.cxx
--- sc/source/core/data/dpgroup.cxx	27 Feb 2007 12:03:31 -0000	1.7
+++ sc/source/core/data/dpgroup.cxx	24 Sep 2007 02:43:57 -0000
@@ -51,6 +51,7 @@
 #include "collect.hxx"
 #include "global.hxx"
 #include "document.hxx"
+#include "dpcachetable.hxx"
 
 #ifndef _COM_SUN_STAR_SHEET_DATAPILOTFIELDGROUPBY_HPP_
 #include <com/sun/star/sheet/DataPilotFieldGroupBy.hpp>
Index: sc/source/core/data/dpobject.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dpobject.cxx,v
retrieving revision 1.21
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.21 dpobject.cxx
--- sc/source/core/data/dpobject.cxx	27 Jun 2007 13:43:19 -0000	1.21
+++ sc/source/core/data/dpobject.cxx	24 Sep 2007 02:43:57 -0000
@@ -36,7 +36,7 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
-
+#include <stdio.h>
 
 // INCLUDE ---------------------------------------------------------------
 
@@ -73,7 +73,10 @@
 #include <tools/debug.hxx>
 #include <svtools/zforlist.hxx>		// IsNumberFormat
 
+#include <vector>
+
 using namespace com::sun::star;
+using ::std::vector;
 
 // -----------------------------------------------------------------------
 
@@ -601,6 +604,21 @@
 		r.SetSheetDesc( *pSheetDesc );
 }
 
+void ScDPObject::GetDrillDownData(const ScAddress& rPos, ScDPCacheTable& rTableData)
+{
+    CreateOutput();
+
+    vector<ScDPCacheTable::Filter> aFilters;
+    if ( !pOutput->GetDataFieldPositionData(aFilters, rPos) )
+        return;
+
+    ScDPSource* pSource = static_cast<ScDPSource*>(xSource.get());
+    ScDPTableData* pData = pSource->GetData();
+    pData->GetDrillDownData(aFilters, rTableData);
+
+    fprintf(stdout, "ScDPObject::GetDrillDownData: header size = %ld\n", rTableData.getHeaderSize());fflush(stdout);
+}
+
 BOOL ScDPObject::IsDimNameInUse( const String& rName ) const
 {
 	if ( xSource.is() )
Index: sc/source/core/data/dpoutput.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dpoutput.cxx,v
retrieving revision 1.15
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.15 dpoutput.cxx
--- sc/source/core/data/dpoutput.cxx	27 Jun 2007 13:43:33 -0000	1.15
+++ sc/source/core/data/dpoutput.cxx	24 Sep 2007 02:43:57 -0000
@@ -36,7 +36,7 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
-
+#include <stdio.h>
 
 // INCLUDE ---------------------------------------------------------------
 
@@ -48,6 +48,8 @@
 #include <unotools/transliterationwrapper.hxx>
 
 #include "dpoutput.hxx"
+#include "dptabsrc.hxx"
+#include "dpcachetable.hxx"
 #include "document.hxx"
 #include "patattr.hxx"
 #include "docpool.hxx"
@@ -73,7 +75,10 @@
 #include <com/sun/star/sheet/GeneralFunction.hpp>
 #include <com/sun/star/container/XNamed.hpp>
 
+#include <vector>
+
 using namespace com::sun::star;
+using ::std::vector;
 
 // -----------------------------------------------------------------------
 
@@ -995,6 +1000,73 @@
 	}
 }
 
+bool ScDPOutput::GetDataFieldPositionData(vector<ScDPCacheTable::Filter>& rFilters, const ScAddress& rPos)
+{
+    SCCOL nCol = rPos.Col();
+    SCROW nRow = rPos.Row();
+    SCTAB nTab = rPos.Tab();
+    if ( nTab != aStartPos.Tab() )
+        return false;                                     // wrong sheet
+
+    CalcSizes();
+
+    // test for data area.
+    if (nCol < nDataStartCol || nCol > nTabEndCol || nRow < nDataStartRow || nRow > nTabEndRow)
+    {
+        fprintf(stdout, "ScDPOutput::GetDataFieldPositionData: cell is outside the data field area.\n");fflush(stdout);
+        // Cell is outside the data field area.
+        return false;
+    }
+
+    ScDPSource* pSource = static_cast<ScDPSource*>(xSource.get());
+    ScDPTableData* pData = pSource->GetData();
+
+    // column fields
+    for (SCCOL nColField = 0; nColField < nColFieldCount; ++nColField)
+    {
+        ScDPCacheTable::Filter aFilter;
+        aFilter.mnFieldIndex = pData->GetFieldIndex(pColFields[nColField].aCaption);
+
+        const uno::Sequence<sheet::MemberResult> rSequence = pColFields[nColField].aResult;
+        long nThisColCount = rSequence.getLength();
+        const sheet::MemberResult* pArray = rSequence.getConstArray();
+
+        DBG_ASSERT(nDataStartCol + nThisColCount - 1 == nTabEndCol, "ScDPOutput::GetDataFieldCellData: error in geometric assumption");
+
+        long nItem = nCol - nDataStartCol;
+                //	get origin of "continue" fields
+        while ( nItem > 0 && (pArray[nItem].Flags & sheet::MemberResultFlags::CONTINUE) )
+            --nItem;
+
+        aFilter.mnMatchStrId = ScDPCacheTable::getStringId(pArray[nItem].Name);
+        if (pArray[nItem].Name.getLength() > 0 && !pArray[nItem].Name.equalsAscii("Total"))
+            rFilters.push_back(aFilter);
+    }
+
+    // row fields
+    for (SCROW nRowField = 0; nRowField < nRowFieldCount; ++nRowField)
+    {
+        ScDPCacheTable::Filter aFilter;
+        aFilter.mnFieldIndex = pData->GetFieldIndex(pRowFields[nRowField].aCaption);
+
+        const uno::Sequence<sheet::MemberResult> rSequence = pRowFields[nRowField].aResult;
+        long nThisRowCount = rSequence.getLength();
+        const sheet::MemberResult* pArray = rSequence.getConstArray();
+
+        DBG_ASSERT(nDataStartRow + nThisRowCount - 1 == nTabEndRow, "ScDPOutput::GetDataFieldCellData: error in geometric assumption");
+
+        long nItem = nRow - nDataStartRow;
+			//	get origin of "continue" fields
+        while ( nItem > 0 && (pArray[nItem].Flags & sheet::MemberResultFlags::CONTINUE) )
+            --nItem;
+
+        aFilter.mnMatchStrId = ScDPCacheTable::getStringId(pArray[nItem].Name);
+        if (pArray[nItem].Name.getLength() > 0 && !pArray[nItem].Name.equalsAscii("Total"))
+            rFilters.push_back(aFilter);
+    }
+    return true;
+}
+
 //
 //  helper functions for ScDPOutput::GetPivotData
 //
Index: sc/source/core/data/dpsdbtab.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dpsdbtab.cxx,v
retrieving revision 1.12
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.12 dpsdbtab.cxx
--- sc/source/core/data/dpsdbtab.cxx	27 Feb 2007 12:04:37 -0000	1.12
+++ sc/source/core/data/dpsdbtab.cxx	24 Sep 2007 02:43:57 -0000
@@ -60,6 +60,7 @@
 #include "collect.hxx"
 #include "global.hxx"
 #include "globstr.hrc"
+#include "dpcachetable.hxx"
 
 using namespace com::sun::star;
 
Index: sc/source/core/data/dpshttab.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dpshttab.cxx,v
retrieving revision 1.9
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.9 dpshttab.cxx
--- sc/source/core/data/dpshttab.cxx	27 Feb 2007 12:04:49 -0000	1.9
+++ sc/source/core/data/dpshttab.cxx	24 Sep 2007 02:43:57 -0000
@@ -47,8 +47,13 @@
 #include "document.hxx"
 #include "collect.hxx"
 #include "cell.hxx"
+#include "dpcachetable.hxx"
 #include "globstr.hrc"
 
+#include <vector>
+
+using ::std::vector;
+
 // -----------------------------------------------------------------------
 
 class ScSheetDPData_Impl
@@ -57,20 +62,25 @@
 	ScDocument*		pDoc;
 	ScRange			aRange;
 	ScQueryParam	aQuery;
-	long			nColCount;
+    BOOL*           pSpecial;           // to flag special handling of query parameters in ValidQuery.
+	long			nColCount;          // number of columns
 	BOOL			bIgnoreEmptyRows;
 	BOOL			bRepeatIfEmpty;
-	TypedStrCollection**	ppStrings;
+	TypedStrCollection**	ppStrings;  // array of unique column entries.
 	BOOL*			pDateDim;
 	SCROW			nNextRow;		// for iterator, within range
 
-	ScSheetDPData_Impl() {}
+    ScDPCacheTable  aCacheTable;
+
+	ScSheetDPData_Impl() :
+        pSpecial(NULL)
+    {
+    }
 };
 
 // -----------------------------------------------------------------------
 
 ScSheetDPData::ScSheetDPData( ScDocument* pD, const ScSheetSourceDesc& rDesc )
-    : pSpecial(NULL)
 {
 	long nCount = rDesc.aSourceRange.aEnd.Col() - rDesc.aSourceRange.aStart.Col() + 1;
 	pImpl = new ScSheetDPData_Impl;
@@ -88,18 +98,18 @@
 	pImpl->nNextRow = pImpl->aRange.aStart.Row() + 1;
 
     SCSIZE nEntryCount(pImpl->aQuery.GetEntryCount());
-    pSpecial = new BOOL[nEntryCount];
+    pImpl->pSpecial = new BOOL[nEntryCount];
     for (SCSIZE j = 0; j < nEntryCount; ++j )
     {
         ScQueryEntry& rEntry = pImpl->aQuery.GetEntry(j);
         if (rEntry.bDoQuery)
         {
-            pSpecial[j] = false;
+            pImpl->pSpecial[j] = false;
             if (!rEntry.bQueryByString)
             {
                 if (*rEntry.pStr == EMPTY_STRING &&
                    ((rEntry.nVal == SC_EMPTYFIELDS) || (rEntry.nVal == SC_NONEMPTYFIELDS)))
-                    pSpecial[j] = true;
+                    pImpl->pSpecial[j] = true;
             }
             else
             {
@@ -118,8 +128,8 @@
 		delete pImpl->ppStrings[i];
 	delete[] pImpl->ppStrings;
 	delete[] pImpl->pDateDim;
+    delete[] pImpl->pSpecial;
 	delete pImpl;
-    delete[] pSpecial;
 }
 
 void ScSheetDPData::DisposeData()
@@ -172,7 +182,7 @@
 				//	ignore empty member (if it's not the first row)
 			}
 			else if ( lcl_HasQuery(pImpl->aQuery) &&
-						!pImpl->pDoc->ValidQuery( nRow, nDocTab, pImpl->aQuery, pSpecial ) )
+						!pImpl->pDoc->ValidQuery( nRow, nDocTab, pImpl->aQuery, pImpl->pSpecial ) )
 			{
 				//	this row is filtered out
 			}
@@ -295,8 +305,36 @@
 	pImpl->bRepeatIfEmpty   = bRepeatIfEmpty;
 }
 
+void ScSheetDPData::CreateCacheTable(const vector<ScDPDimension*>& rPageDims)
+{
+//  sal_Int32 nCacheRowSize = pImpl->aCacheTable.getRowSize();
+//  if (nCacheRowSize > 0)
+//      // source data already cached.
+//      return;
+
+    // Scan and store the data from the source range.
+    pImpl->aCacheTable.fillTable(pImpl->pDoc, pImpl->aRange, pImpl->aQuery, pImpl->pSpecial, rPageDims);
+}
+
+void ScSheetDPData::GetDrillDownData(const vector<ScDPCacheTable::Filter>& rFilters,
+                                     ScDPCacheTable& rData)
+{
+    sal_Int32 nRowSize = pImpl->aCacheTable.getRowSize();
+    if (!nRowSize)
+        return;
+
+    pImpl->aCacheTable.filterTable(rFilters, rData);
+    fprintf(stdout, "ScSheetDPData::GetDrillDownData: header size = %ld\n", rData.getHeaderSize());fflush(stdout);
+}
+
+sal_Int32 ScSheetDPData::GetFieldIndex(const String& rStr)
+{
+    return pImpl->aCacheTable.getFieldIndex(rStr);
+}
+
 void ScSheetDPData::ResetIterator()
 {
+    // skipping the header row?
 	pImpl->nNextRow = pImpl->aRange.aStart.Row() + 1;
 }
 
@@ -324,6 +362,10 @@
 
 BOOL ScSheetDPData::GetNextRow( const ScDPTableIteratorParam& rParam )
 {
+//  fprintf(stdout, "ScSheetDPData::GetNextRow: col count = %d  row count = %d  page count = %d  data count = %d\n",
+//          rParam.nColCount, rParam.nRowCount, rParam.nPageCount,
+//          rParam.nDatCount);fflush(stdout);
+
 	if ( pImpl->nNextRow > pImpl->aRange.aEnd.Row() )
 		return FALSE;
 
@@ -348,7 +390,7 @@
 		}
 
 		bFilteredOut = ( lcl_HasQuery(pImpl->aQuery) && 
-				!pImpl->pDoc->ValidQuery( pImpl->nNextRow, nDocTab, pImpl->aQuery, pSpecial ) );
+				!pImpl->pDoc->ValidQuery( pImpl->nNextRow, nDocTab, pImpl->aQuery, pImpl->pSpecial ) );
 		if ( bFilteredOut )
 		{
 			++pImpl->nNextRow;
@@ -360,6 +402,7 @@
 
 	//!	use more efficient iterators
 
+    // Populate column field information.
 	for (i=0; i<rParam.nColCount; i++)
 	{
 		long nDim = rParam.pCols[i];
@@ -371,6 +414,7 @@
 									pImpl->bRepeatIfEmpty, nFirstDataRow );
 	}
 
+    // Populate row field information.
 	for (i=0; i<rParam.nRowCount; i++)
 	{
 		long nDim = rParam.pRows[i];
@@ -382,17 +426,23 @@
 									pImpl->bRepeatIfEmpty, nFirstDataRow );
 	}
 
+    // Populate page dimension information from the sheet.
 	for (i=0; i<rParam.nPageCount; i++)
 	{
 		long nDim = rParam.pPages[i];
 		if ( getIsDataLayoutDimension(nDim) )
 			rParam.pPageData[i].SetString( String::CreateFromAscii(RTL_CONSTASCII_STRINGPARAM("x")) );
 		else
+        {
 			lcl_GetStringOrValue( rParam.pPageData[i], pImpl->pDoc,
 									(USHORT)(nStartCol+nDim), pImpl->nNextRow, nDocTab,
 									pImpl->bRepeatIfEmpty, nFirstDataRow );
+//          fprintf(stdout, "ScSheetDPData::GetNextRow: page field = '%s'\n",
+//                  OUStringToOString(rtl::OUString(rParam.pPageData[i].aString), RTL_TEXTENCODING_UTF8).getStr());fflush(stdout);
+        }
 	}
 
+    // Populate data dimension information from the row.
 	for (i=0; i<rParam.nDatCount; i++)
 	{
 		long nDim = rParam.pDats[i];
Index: sc/source/core/data/dptabdat.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dptabdat.cxx,v
retrieving revision 1.12
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.12 dptabdat.cxx
--- sc/source/core/data/dptabdat.cxx	27 Feb 2007 12:05:02 -0000	1.12
+++ sc/source/core/data/dptabdat.cxx	24 Sep 2007 02:43:57 -0000
@@ -53,6 +53,8 @@
 #include "dptabdat.hxx"
 #include "global.hxx"
 
+using ::std::vector;
+
 // -----------------------------------------------------------------------
 
 BOOL ScDPItemData::IsCaseInsEqual( const ScDPItemData& r ) const
@@ -193,6 +195,19 @@
 	return nRet;
 }
 
+void ScDPTableData::CreateCacheTable(const vector<ScDPDimension*>& rPageDims)
+{
+}
+
+void ScDPTableData::GetDrillDownData(const vector<ScDPCacheTable::Filter>& rFilters, ScDPCacheTable& rTableData)
+{
+}
+
+sal_Int32 ScDPTableData::GetFieldIndex(const String& rStr)
+{
+    return -1;
+}
+
 UINT32 ScDPTableData::GetNumberFormat(long)
 {
 	return 0;			// default format
Index: sc/source/core/data/dptabsrc.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dptabsrc.cxx,v
retrieving revision 1.19
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.19 dptabsrc.cxx
--- sc/source/core/data/dptabsrc.cxx	5 Mar 2007 14:40:18 -0000	1.19
+++ sc/source/core/data/dptabsrc.cxx	24 Sep 2007 02:43:58 -0000
@@ -36,11 +36,12 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
-
+#include <stdio.h>
 
 // INCLUDE ---------------------------------------------------------------
 
 #include <algorithm>
+#include <vector>
 
 #include <tools/debug.hxx>
 #include <rtl/math.hxx>
@@ -72,6 +73,7 @@
 #endif
 
 using namespace com::sun::star;
+using ::std::vector;
 
 // -----------------------------------------------------------------------
 
@@ -573,6 +575,7 @@
 {
 	if ( !pResData )
 	{
+        fprintf(stdout, "ScDPSource::CreateRes_Impl: \n");fflush(stdout);
 		USHORT nDataOrient = GetDataLayoutOrientation();
         if ( nDataDimCount > 1 && ( nDataOrient != sheet::DataPilotFieldOrientation_COLUMN &&
                                     nDataOrient != sheet::DataPilotFieldOrientation_ROW ) )
@@ -795,6 +798,18 @@
 						nDataDimCount,   nDataSrcCols,   aValues );
 
 			pData->ResetIterator();
+            vector<ScDPDimension*> aPageDims;
+            aPageDims.reserve(nPageDimCount);
+            for (i = 0; i < nPageDimCount; ++i)
+            {
+                ScDPDimension* pDim = GetDimensionsObject()->getByIndex( nPageDims[i] );
+                if (pDim)
+                {
+                    fprintf(stdout, "ScDPSource::CreateRes_Impl: page field index = %d\n", nPageDims[i]);fflush(stdout);
+                    aPageDims.push_back(pDim);
+                }
+            }
+            pData->CreateCacheTable(aPageDims);
 			while ( pData->GetNextRow( aIterPar ) )
 			{
 				// test page fields ----------------------------
@@ -824,6 +839,8 @@
 
 						pRowResRoot->ProcessData( aRowData, pColResRoot->GetChildDimension(), aColData, aValues );
 					}
+
+                    // TODO (?): the row needs to be inserted into cache table here.
 				}
 			}
 
@@ -1464,6 +1481,8 @@
 				if ( rField.Field == 0 && rField.Operator == sheet::FilterOperator_EQUAL && !rField.IsNumeric )
 				{
 					aSelectedPage = rField.StringValue;
+                    fprintf(stdout, "ScDPDimension::setPropertyValue: page set to '%s'\n",
+                            OUStringToOString(rtl::OUString(aSelectedPage), RTL_TEXTENCODING_UTF8).getStr());fflush(stdout);
 					bHasSelectedPage = TRUE;
 					bDone = TRUE;
 				}
Index: sc/source/core/data/makefile.mk
===================================================================
RCS file: /cvs/sc/sc/source/core/data/makefile.mk,v
retrieving revision 1.21
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.21 makefile.mk
--- sc/source/core/data/makefile.mk	27 Feb 2007 12:06:42 -0000	1.21
+++ sc/source/core/data/makefile.mk	24 Sep 2007 02:43:58 -0000
@@ -77,6 +77,7 @@
 	$(SLO)$/documen8.obj \
 	$(SLO)$/documen9.obj \
 	$(SLO)$/document.obj \
+        $(SLO)$/dpcachetable.obj \
         $(SLO)$/dpdimsave.obj \
         $(SLO)$/dpgroup.obj \
 	$(SLO)$/dpobject.obj \
Index: sc/source/ui/docshell/docsh5.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/docshell/docsh5.cxx,v
retrieving revision 1.17
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.17 docsh5.cxx
--- sc/source/ui/docshell/docsh5.cxx	27 Feb 2007 13:07:51 -0000	1.17
+++ sc/source/ui/docshell/docsh5.cxx	24 Sep 2007 02:43:58 -0000
@@ -417,6 +417,8 @@
 
 void ScDocShell::RefreshPivotTables( const ScRange& rSource )
 {
+    fprintf(stdout, "ScDocShell::RefreshPivotTables: *---------- begins ----------*\n");fflush(stdout);
+
 	//!	rename to RefreshDataPilotTables?
 
 	ScDPCollection* pColl = aDocument.GetDPCollection();
Index: sc/source/ui/miscdlgs/makefile.mk
===================================================================
RCS file: /cvs/sc/sc/source/ui/miscdlgs/makefile.mk,v
retrieving revision 1.8
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.8 makefile.mk
--- sc/source/ui/miscdlgs/makefile.mk	22 May 2007 20:09:23 -0000	1.8
+++ sc/source/ui/miscdlgs/makefile.mk	24 Sep 2007 02:43:58 -0000
@@ -54,6 +54,7 @@
 # --- Files --------------------------------------------------------
 
 SLOFILES =  \
+	$(SLO)$/autofiltercontrol.obj		\
 	$(SLO)$/delcldlg.obj		\
 	$(SLO)$/inscldlg.obj		\
 	$(SLO)$/delcodlg.obj		\
Index: sc/source/ui/view/gridwin.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/view/gridwin.cxx,v
retrieving revision 1.83
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.83 gridwin.cxx
--- sc/source/ui/view/gridwin.cxx	21 Aug 2007 12:27:31 -0000	1.83
+++ sc/source/ui/view/gridwin.cxx	24 Sep 2007 02:44:00 -0000
@@ -36,7 +36,7 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
-
+#include <stdio.h>
 
 //------------------------------------------------------------------
 
@@ -572,6 +572,7 @@
 
 	ScDocument* pDoc = pViewData->GetDocument();
 	SCTAB nTab = pViewData->GetTabNo();
+    fprintf(stdout, "ScGridWindow::ExecPageFieldSelect: *---------- sheet %d; (%d, %ld) ----------*\n", nTab, nCol, nRow);fflush(stdout);
 	ScDPObject*	pDPObj = pDoc->GetDPAtCursor(nCol, nRow, nTab);
 	if ( pDPObj && nCol > 0 )
 	{
@@ -584,6 +585,8 @@
 
 			BOOL bIsDataLayout;
 			String aDimName = pDPObj->GetDimName( nField, bIsDataLayout );
+            fprintf(stdout, "ScGridWindow::ExecPageFieldSelect: dimension name = %s\n",
+                    OUStringToOString(rtl::OUString(aDimName), RTL_TEXTENCODING_UTF8).getStr());fflush(stdout);
 			if ( !bIsDataLayout )
 			{
 				ScDPSaveDimension* pDim = aSaveData.GetDimensionByName(aDimName);
@@ -2178,11 +2181,16 @@
 		Point aPos = rMEvt.GetPosPixel();
         SCsCOL nPosX;
         SCsROW nPosY;
+        SCTAB nTab = pViewData->GetTabNo();
         pViewData->GetPosFromPixel( aPos.X(), aPos.Y(), eWhich, nPosX, nPosY );
-		ScDPObject*	pDPObj	= pDoc->GetDPAtCursor( nPosX, nPosY, pViewData->GetTabNo() );
+		ScDPObject*	pDPObj	= pDoc->GetDPAtCursor( nPosX, nPosY, nTab );
 		if ( pDPObj && pDPObj->GetSaveData()->GetDrillDown() )
 		{
-			ScAddress aCellPos( nPosX, nPosY, pViewData->GetTabNo() );
+            fprintf(stdout, "ScGridWindow::MouseButtonUp: *---------- pivot table hit (name = '%s'; tag = '%s') ----------*\n",
+                    OUStringToOString(rtl::OUString(pDPObj->GetName()), RTL_TEXTENCODING_UTF8).getStr(),
+                    OUStringToOString(rtl::OUString(pDPObj->GetTag()), RTL_TEXTENCODING_UTF8).getStr());fflush(stdout);
+
+			ScAddress aCellPos( nPosX, nPosY, nTab );
 			ScDPPositionData aData;
 			pDPObj->GetPositionData( aData, aCellPos );
 
@@ -2206,7 +2214,51 @@
                 }
 			}
 			else
-				Sound::Beep();		// nothing to expand/collapse
+            {
+                // Check if the data area is double-clicked.
+                ScDPCacheTable aArrayData;
+                pDPObj->GetDrillDownData(aCellPos, aArrayData);
+                if ( aArrayData.empty() )
+                {
+                    // TODO: beep.
+                }
+                else
+                {
+                    ScTabViewShell* pViewShell = pViewData->GetViewShell();
+                    String aNewTabName;
+                    pViewData->GetDocument()->CreateValidTabName(aNewTabName);
+                    SCTAB nNewTab = nTab + 1;
+                    if ( pViewShell->InsertTable(aNewTabName, nNewTab, false) )
+                    {
+                        sal_Int32 nRowSize = aArrayData.getRowSize();
+                        sal_Int32 nColSize = aArrayData.getColSize();
+       
+                        for (sal_Int32 nCol = 0; nCol < nColSize; ++nCol)
+                        {
+                            const String* pHeaderStr = aArrayData.getFieldName(nCol);
+                            if (pHeaderStr)
+                                pDoc->SetString(nCol, 0, nNewTab, *pHeaderStr);
+                        }
+                        
+                        // data rows
+                        for (sal_Int32 nRow = 0; nRow < nRowSize; ++nRow)
+                        {
+                            for (sal_Int32 nCol = 0; nCol < nColSize; ++nCol)
+                            {
+                                const ScDPCacheTable::Cell* pCell = aArrayData.getCell(nCol, nRow);
+                                if (pCell->mbNumeric)
+                                    pDoc->SetValue(nCol, nRow+1, nNewTab, pCell->mfValue);
+                                else
+                                {
+                                    const String* pStr = ScDPCacheTable::getString(pCell->mnStrId);
+                                    if (pStr)
+                                        pDoc->SetString(nCol, nRow+1, nNewTab, *pStr);
+                                }
+                            }
+                        }
+                    }
+                }
+            }
 
 			return;
 		}
--- /dev/null	2007-05-04 06:54:36.000000000 -0400
+++ sc/inc/dpcachetable.hxx	2007-09-23 19:04:53.000000000 -0400
@@ -0,0 +1,142 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: dpobject.hxx,v $
+ *
+ *  $Revision: 1.12 $
+ *
+ *  last change: $Author: hr $ $Date: 2007/06/27 13:41:57 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef SC_DPCACHETABLE_HXX
+#define SC_DPCACHETABLE_HXX
+
+#include "sal/types.h"
+#include "osl/mutex.hxx"
+#include "global.hxx"
+
+#include <vector>
+#include <hash_map>
+
+class ScDocument;
+class ScRange;
+class ScDPDimension;
+
+void checkQueryParam(const ScQueryParam& rParam);
+
+class ScSharedStringTable
+{
+public:
+    sal_Int32 insertString(const String& aStr);
+    sal_Int32 getStringId(const String& aStr);
+    const String* getString(sal_Int32 nId) const;
+
+    ScSharedStringTable();
+    ~ScSharedStringTable();
+
+private:
+    typedef ::std::hash_map< String, sal_Int32, ScStringHashCode, ::std::equal_to< String > > SharedStrMap;
+
+    ::std::vector<String> maSharedStrings;
+    SharedStrMap maSharedStringIds;
+    sal_Int32 mnStrCount;
+};
+
+// ----------------------------------------------------------------------------
+
+class ScDPCacheTable
+{
+public:
+    /** individual cell within table. */
+    struct Cell
+    {
+        sal_Int32 mnStrId;
+        double  mfValue;
+        bool    mbNumeric;
+
+        Cell();
+    };
+
+    /** filtering criteria */
+    struct Filter
+    {
+        sal_Int32   mnFieldIndex;
+        sal_Int32   mnMatchStrId;
+
+        Filter();
+    };
+
+    ScDPCacheTable();
+    ~ScDPCacheTable();
+
+    sal_Int32 getHeaderSize() const;
+    sal_Int32 getRowSize() const;
+    sal_Int32 getColSize() const;
+
+    /** Fill the internal table from the cell range provided.  This function
+        assumes that the first row is the column header. */
+    void fillTable(ScDocument* pDoc, const ScRange& rRange, const ScQueryParam& rQuery, BOOL* pSpecial, 
+                   const ::std::vector<ScDPDimension*>& rPageDims);
+
+    /** Get the cell instance at specified location within the data grid. Note
+        that the data grid doesn't include the header row.  Don't delete the
+        returned object! */
+    const ::ScDPCacheTable::Cell* getCell(SCCOL nCol, SCROW nRow) const;
+
+    const String* getFieldName(sal_Int32 nIndex) const;
+
+    /** Get the field index (i.e. column ID in the original data source) based
+        on the string value. */
+    sal_Int32 getFieldIndex(const String& rStr) const;
+
+    /** Get a new table that contains filtered version of the original table. */
+    void filterTable(const ::std::vector<Filter>& rFilters, ScDPCacheTable& rNewTable) const;
+
+    void clear();
+    void swap(ScDPCacheTable& rOther);
+    bool empty() const;
+
+    static const String* getString(sal_Int32 nId);
+    static sal_Int32 getStringId(const String& aStr);
+
+private:
+    void getValueData(ScDocument* pDoc, const ScAddress& rPos, Cell& rCell);
+    ScDPCacheTable::Cell getSelectedDimension(ScDPDimension* pDim) const;
+
+private:
+    ::std::vector< ::std::vector< ::ScDPCacheTable::Cell > > maTable;
+    ::std::vector<sal_Int32> maHeaderStrings;
+
+    static sal_Int32 insertString(const String& aStr);
+
+    static ::osl::Mutex maStrMutex;
+    static ScSharedStringTable maStringTable;
+};
+
+
+#endif
--- /dev/null	2007-05-04 06:54:36.000000000 -0400
+++ sc/source/core/data/dpcachetable.cxx	2007-09-23 19:05:25.000000000 -0400
@@ -0,0 +1,363 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: dpobject.hxx,v $
+ *
+ *  $Revision: 1.12 $
+ *
+ *  last change: $Author: hr $ $Date: 2007/06/27 13:41:57 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "dpcachetable.hxx"
+#include "document.hxx"
+#include "address.hxx"
+#include "cell.hxx"
+#include "dptabdat.hxx"
+#include "dptabsrc.hxx"
+
+using ::std::vector;
+
+extern BOOL lcl_HasQuery( const ScQueryParam& rParam );
+//{
+//    return rParam.GetEntryCount() > 0 &&
+//            rParam.GetEntry(0).bDoQuery;
+//}
+
+ScSharedStringTable::ScSharedStringTable() :
+    mnStrCount(0)
+{
+    maSharedStrings.push_back(String());
+    maSharedStringIds.insert( SharedStrMap::value_type(String(), mnStrCount++) );
+}
+
+ScSharedStringTable::~ScSharedStringTable()
+{
+}
+
+sal_Int32 ScSharedStringTable::insertString(const String& aStr)
+{
+    SharedStrMap::const_iterator itr = maSharedStringIds.find(aStr), 
+        itrEnd = maSharedStringIds.end();
+
+    if (itr == itrEnd)
+    {
+        // new string.
+        maSharedStrings.push_back(aStr);
+        maSharedStringIds.insert( SharedStrMap::value_type(aStr, mnStrCount) );
+        return mnStrCount++;
+    }
+
+    // existing string.
+    return itr->second;
+}
+
+sal_Int32 ScSharedStringTable::getStringId(const String& aStr)
+{
+    SharedStrMap::const_iterator itr = maSharedStringIds.find(aStr), 
+        itrEnd = maSharedStringIds.end();
+    if (itr == itrEnd)
+    {
+        // string not found.
+        return insertString(aStr);
+    }
+    return itr->second;
+}
+
+const String* ScSharedStringTable::getString(sal_Int32 nId) const
+{
+    if (nId >= mnStrCount)
+        return NULL;
+
+    return &maSharedStrings[nId];
+}
+
+// ----------------------------------------------------------------------------
+
+ScDPCacheTable::Cell::Cell() :
+    mfValue(0.0),
+    mbNumeric(false)
+{
+}
+
+ScDPCacheTable::Filter::Filter()
+{
+}
+
+::osl::Mutex ScDPCacheTable::maStrMutex;
+ScSharedStringTable ScDPCacheTable::maStringTable;
+
+ScDPCacheTable::ScDPCacheTable()
+{
+}
+
+ScDPCacheTable::~ScDPCacheTable()
+{
+}
+
+sal_Int32 ScDPCacheTable::getHeaderSize() const
+{
+    return maHeaderStrings.size();
+}
+
+sal_Int32 ScDPCacheTable::getRowSize() const
+{
+    return maTable.size();
+}
+
+sal_Int32 ScDPCacheTable::getColSize() const
+{
+    return maTable.empty() ? 0 : maTable[0].size();
+}
+
+void ScDPCacheTable::fillTable(ScDocument* pDoc, const ScRange& rRange, const ScQueryParam& rQuery, BOOL* pSpecial,
+                               const vector<ScDPDimension*>& rPageDims)
+{
+    SCTAB nTab = rRange.aStart.Tab();
+    SCCOL nStartCol = rRange.aStart.Col();
+    SCROW nStartRow = rRange.aStart.Row();
+    SCCOL nColCount = rRange.aEnd.Col() - rRange.aStart.Col() + 1;
+    SCROW nRowCount = rRange.aEnd.Row() - rRange.aStart.Row() + 1;
+
+    if (nRowCount <= 1 || nColCount <= 0)
+        return;
+
+    maTable.clear();
+    maTable.reserve(nRowCount);
+    maHeaderStrings.clear();
+    maHeaderStrings.reserve(nColCount);
+
+    // Header row
+    for (SCCOL nCol = 0; nCol < nColCount; ++nCol)
+    {
+        String aStr;
+        pDoc->GetString(nCol, 0, nTab, aStr);
+        sal_Int32 nStrId = maStringTable.insertString(aStr);
+        maHeaderStrings.push_back(nStrId);
+    }
+
+    // Data rows
+    for (SCROW nRow = 1; nRow < nRowCount; ++nRow)
+    {
+        if ( lcl_HasQuery(rQuery) && !pDoc->ValidQuery(nRow + nStartRow, nTab, rQuery, pSpecial) )
+            continue;
+
+        bool bSkipRow = false;
+        vector<ScDPDimension*>::const_iterator itr = rPageDims.begin(), itrEnd = rPageDims.end();
+        for (; itr != itrEnd; ++itr)
+        {
+            ScDPDimension* pDim = *itr;
+            ScDPCacheTable::Cell aDimCell = getSelectedDimension(pDim);
+
+            const String* pDimStr = getString(aDimCell.mnStrId);
+            if (pDimStr)
+            {
+                String aStr;
+                pDoc->GetString(pDim->GetDimension(), nRow, nTab, aStr);
+                if ( pDimStr->Len() && !pDimStr->Equals(aStr) )
+                {
+                    // Selected page dimension value does not match the current value.  Skip it (note: when
+                    // the selected page dimension value is empty, '- all -' is selected.
+                    bSkipRow = true;
+                    break;
+                }
+            }
+        }
+        if (bSkipRow)
+            continue;
+
+        // Insert a new row into cache table.
+        maTable.push_back( vector<Cell>() );
+        maTable.back().reserve(nColCount);
+
+        for (SCCOL nCol = 0; nCol < nColCount; ++nCol)
+        {
+            maTable.back().push_back( ScDPCacheTable::Cell() );
+            Cell& rCell = maTable.back().back();
+                
+            String aStr;
+            pDoc->GetString(nCol, nRow, nTab, aStr);
+            rCell.mnStrId = maStringTable.insertString(aStr);
+            ScAddress aPos(nStartCol + nCol, nStartRow + nRow, nTab);
+            getValueData(pDoc, aPos, rCell);
+        }
+    }
+}
+
+const ::ScDPCacheTable::Cell* ScDPCacheTable::getCell(SCCOL nCol, SCROW nRow) const
+{
+    if ( nRow >= maTable.size() )
+        return NULL;
+
+    const vector<Cell>& rRow = maTable[nRow];
+    if ( nCol >= rRow.size() )
+        return NULL;
+
+    return &rRow[nCol];
+}
+
+const String* ScDPCacheTable::getFieldName(sal_Int32 nIndex) const
+{
+    if (nIndex >= maHeaderStrings.size())
+        return NULL;
+
+    return getString(maHeaderStrings[nIndex]);
+}
+
+sal_Int32 ScDPCacheTable::getFieldIndex(const String& rStr) const
+{
+    sal_Int32 nStrId = getStringId(rStr);
+    if (nStrId < 0)
+        // string not found.
+        return nStrId;
+
+    sal_Int32 n = maHeaderStrings.size();
+    for (sal_Int32 i = 0; i < n; ++i)
+    {
+        if (maHeaderStrings[i] == nStrId)
+            return i;
+    }
+
+    return -1;
+}
+
+void ScDPCacheTable::filterTable(const vector<Filter>& rFilters, ScDPCacheTable& rNewTable) const
+{
+    sal_Int32 nRowSize = getRowSize();
+    sal_Int32 nColSize = getColSize();
+
+    if (!nRowSize)
+        // no data to filter.
+        return;
+
+    ScDPCacheTable aNewTable;
+    aNewTable.maTable.reserve(nRowSize);
+
+    // Copy the header first.
+    aNewTable.maHeaderStrings = maHeaderStrings;
+
+    for (sal_Int32 nRow = 0; nRow < nRowSize; ++nRow)
+    {
+        bool bRetainRow = true;
+        vector<Filter>::const_iterator itr, itrEnd = rFilters.end();
+        for (itr = rFilters.begin(); itr != itrEnd; ++itr)
+        {
+            if (itr->mnFieldIndex >= nColSize)
+            {
+                // specified field is outside the source data columns.
+                bRetainRow = false;
+                break;
+            }
+
+            if ( maTable[nRow][itr->mnFieldIndex].mnStrId != itr->mnMatchStrId )
+            {
+                // The string value does not match.
+                bRetainRow = false;
+                break;
+            }
+        }
+
+        if (bRetainRow)
+        {
+            aNewTable.maTable.push_back( vector<Cell>() );
+            for (sal_Int32 nCol = 0; nCol < nColSize; ++nCol)
+                aNewTable.maTable.back().push_back( maTable[nRow][nCol] );
+        }
+    }
+
+    // All good.  Commit.
+    rNewTable.swap(aNewTable);
+}
+
+void ScDPCacheTable::clear()
+{
+    maTable.clear();
+    maHeaderStrings.clear();
+}
+
+void ScDPCacheTable::swap(ScDPCacheTable& rOther)
+{
+    maTable.swap(rOther.maTable);
+    maHeaderStrings.swap(rOther.maHeaderStrings);
+}
+
+bool ScDPCacheTable::empty() const
+{
+    return maTable.empty();
+}
+
+void ScDPCacheTable::getValueData(ScDocument* pDoc, const ScAddress& rPos, Cell& rCell)
+{
+    ScBaseCell* pCell = pDoc->GetCell(rPos);
+    if ( !pCell )
+        return;
+
+    if ( pCell->HasValueData() )
+    {
+        CellType eType = pCell->GetCellType();
+        if (eType == CELLTYPE_VALUE)
+        {
+            // value cell
+            rCell.mfValue = static_cast<ScValueCell*>(pCell)->GetValue();
+        }
+        else if (eType == CELLTYPE_FORMULA)
+        {
+            // formula cell
+            rCell.mfValue = static_cast<ScFormulaCell*>(pCell)->GetValue();
+        }
+        rCell.mbNumeric = true;
+    }
+}
+
+ScDPCacheTable::Cell ScDPCacheTable::getSelectedDimension(ScDPDimension* pDim) const
+{
+    const ScDPItemData& rData = pDim->GetSelectedData();
+    Cell aCell;
+    aCell.mfValue = rData.fValue;
+    aCell.mbNumeric = rData.bHasValue;
+    aCell.mnStrId = getStringId(rData.aString);
+    return aCell;
+}
+
+// static 
+sal_Int32 ScDPCacheTable::insertString(const String& aStr)
+{
+    ::osl::MutexGuard aGuard(maStrMutex);
+    return maStringTable.insertString(aStr);
+}
+
+const String* ScDPCacheTable::getString(sal_Int32 nId)
+{
+    ::osl::MutexGuard aGuard(maStrMutex);
+    return maStringTable.getString(nId);
+}
+
+sal_Int32 ScDPCacheTable::getStringId(const String& aStr)
+{
+    ::osl::MutexGuard aGuard(maStrMutex);
+    return maStringTable.getStringId(aStr);
+}
