Index: sc/inc/datauno.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/datauno.hxx,v
retrieving revision 1.7
retrieving revision 1.7.114.2
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.7 -r1.7.114.2
--- sc/inc/datauno.hxx	27 Feb 2007 11:54:55 -0000	1.7
+++ sc/inc/datauno.hxx	13 Aug 2007 23:48:19 -0000	1.7.114.2
@@ -113,6 +113,7 @@
 #include <cppuhelper/implbase6.hxx>
 #endif
 
+
 class ScDBData;
 class ScDocShell;
 
@@ -476,7 +477,7 @@
 };
 
 
-//	ScFilterDescriptor - dummer Container zur Benutzung mit XFilterable
+//	ScFilterDescriptor - stupid container for use with XFilterable
 
 class ScFilterDescriptor : public ScFilterDescriptorBase
 {
@@ -497,7 +498,7 @@
 };
 
 
-//	ScRangeFilterDescriptor - FilterDescriptor eines Datenbank-Bereichs
+//	ScRangeFilterDescriptor - FilterDescriptor of a data base range
 
 class ScRangeFilterDescriptor : public ScFilterDescriptorBase
 {
@@ -584,8 +585,6 @@
     						getSubTotalDescriptor() throw(::com::sun::star::uno::RuntimeException);
     virtual ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue > SAL_CALL
     						getImportDescriptor() throw(::com::sun::star::uno::RuntimeException);
-// implemented for the XRefreshable Interface
-//    virtual void SAL_CALL	refresh() throw(::com::sun::star::uno::RuntimeException);
 
 							// XRefreshable
 	virtual void SAL_CALL	refresh() throw(::com::sun::star::uno::RuntimeException);
Index: sc/inc/dbcolect.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dbcolect.hxx,v
retrieving revision 1.12
retrieving revision 1.12.84.1
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.12 -r1.12.84.1
--- sc/inc/dbcolect.hxx	25 Apr 2007 15:56:28 -0000	1.12
+++ sc/inc/dbcolect.hxx	25 Jul 2007 03:40:44 -0000	1.12.84.1
@@ -113,6 +113,7 @@
 	String*			pQueryStr[MAXQUERY];
 	double			nQueryVal[MAXQUERY];
 	ScQueryConnect  eQueryConnect[MAXQUERY];
+    ScHashOUStringSet aStrValues[MAXQUERY];
 	BOOL			bIsAdvanced;		// TRUE if created by advanced filter
 	ScRange			aAdvSource;			// source range
 	// SubTotalParam
Index: sc/inc/filterglobal.hxx
===================================================================
RCS file: sc/inc/filterglobal.hxx
diff -N sc/inc/filterglobal.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/inc/filterglobal.hxx	15 Aug 2007 19:21:14 -0000	1.1.2.2
@@ -0,0 +1,66 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: filterglobal.hxx,v $
+ *
+ *  $Revision: 1.1.2.2 $
+ *
+ *  last change: $Author: kohei $ $Date: 2007/08/15 19:21:14 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef SC_FILTERGLOBAL_HXX
+#define SC_FILTERGLOBAL_HXX
+
+#include <sal/types.h>
+#include <com/sun/star/uno/Any.h>
+
+#include <boost/shared_ptr.hpp>
+
+namespace com { namespace sun { namespace star { namespace sheet {
+    struct SheetFilterField;
+    struct SheetFilterFieldValue;
+    struct SheetFilterFieldMultiString;
+}}}}
+
+struct ScSheetFilterFieldItem
+{
+    typedef ::boost::shared_ptr< ::com::sun::star::sheet::SheetFilterField > SheetFilterFieldRef;
+
+    static const ::com::sun::star::uno::Type VALUE;
+    static const ::com::sun::star::uno::Type MULTI_STRING;
+
+    sal_Int16           mnType;
+    SheetFilterFieldRef mpField;
+
+    ::com::sun::star::sheet::SheetFilterFieldValue*         getFieldValue() const;
+    ::com::sun::star::sheet::SheetFilterFieldMultiString*   getFieldMultiString() const;
+
+    ScSheetFilterFieldItem();
+};
+
+#endif
Index: sc/inc/global.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/global.hxx,v
retrieving revision 1.50
retrieving revision 1.49.12.2
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.50 -r1.49.12.2
--- sc/inc/global.hxx	24 Jul 2007 09:22:45 -0000	1.50
+++ sc/inc/global.hxx	1 Oct 2007 15:29:08 -0000	1.49.12.2
@@ -58,6 +58,8 @@
 #include "scdllapi.h"
 #endif
 
+#include <hash_set>
+
 class ImageList;
 class Bitmap;
 class SfxItemSet;
@@ -887,6 +889,8 @@
 	class TextSearch;
 }
 
+typedef ::std::hash_set< ::rtl::OUString, ::rtl::OUStringHash, ::std::equal_to<rtl::OUString> > ScHashOUStringSet;
+
 struct ScQueryEntry
 {
 	BOOL			bDoQuery;
@@ -899,6 +903,8 @@
 	utl::SearchParam*	pSearchParam;		// falls RegExp, nicht gespeichert
 	utl::TextSearch*	pSearchText;		// falls RegExp, nicht gespeichert
 
+    ScHashOUStringSet aStrValues;
+
 	ScQueryEntry();
 	ScQueryEntry(const ScQueryEntry& r);
 	~ScQueryEntry();
Index: sc/source/core/data/filterglobal.cxx
===================================================================
RCS file: sc/source/core/data/filterglobal.cxx
diff -N sc/source/core/data/filterglobal.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/core/data/filterglobal.cxx	15 Aug 2007 19:21:14 -0000	1.1.2.2
@@ -0,0 +1,64 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: filterglobal.cxx,v $
+ *
+ *  $Revision: 1.1.2.2 $
+ *
+ *  last change: $Author: kohei $ $Date: 2007/08/15 19:21:14 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "filterglobal.hxx"
+
+#include <com/sun/star/sheet/SheetFilterField.hpp>
+#include <com/sun/star/sheet/SheetFilterFieldType.hpp>
+#include <com/sun/star/sheet/SheetFilterFieldValue.hpp>
+#include <com/sun/star/sheet/SheetFilterFieldMultiString.hpp>
+
+using namespace ::com::sun::star;
+
+const uno::Type ScSheetFilterFieldItem::VALUE = getCppuType( static_cast<sheet::SheetFilterFieldValue*>(NULL) );
+const uno::Type ScSheetFilterFieldItem::MULTI_STRING = getCppuType( static_cast<sheet::SheetFilterFieldMultiString*>(NULL) );
+
+sheet::SheetFilterFieldValue* ScSheetFilterFieldItem::getFieldValue() const
+{
+    sheet::SheetFilterFieldValue* p = static_cast<sheet::SheetFilterFieldValue*>(mpField.get());
+    return p;
+}
+
+sheet::SheetFilterFieldMultiString* ScSheetFilterFieldItem::getFieldMultiString() const
+{
+    sheet::SheetFilterFieldMultiString* p = static_cast<sheet::SheetFilterFieldMultiString*>(mpField.get());
+    return p;
+}
+
+ScSheetFilterFieldItem::ScSheetFilterFieldItem() :
+    mnType(sheet::SheetFilterFieldType::NONE),
+    mpField(static_cast<sheet::SheetFilterField*>(NULL))
+{
+}
Index: sc/source/core/data/global2.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/global2.cxx,v
retrieving revision 1.21
retrieving revision 1.21.114.1
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.21 -r1.21.114.1
--- sc/source/core/data/global2.cxx	27 Feb 2007 12:06:31 -0000	1.21
+++ sc/source/core/data/global2.cxx	25 Jul 2007 03:40:45 -0000	1.21.114.1
@@ -176,6 +176,7 @@
 	pStr			= new String(*r.pStr);
 	pSearchParam	= NULL;
 	pSearchText		= NULL;
+    aStrValues = r.aStrValues;
 }
 
 ScQueryEntry::~ScQueryEntry()
@@ -205,6 +206,8 @@
 	pSearchParam	= NULL;
 	pSearchText		= NULL;
 
+    aStrValues = r.aStrValues;
+
 	return *this;
 }
 
@@ -224,6 +227,7 @@
 	}
 	pSearchParam	= NULL;
 	pSearchText		= NULL;
+    aStrValues.clear();
 }
 
 BOOL ScQueryEntry::operator==( const ScQueryEntry& r ) const
@@ -234,7 +238,8 @@
 		&& eConnect			== r.eConnect
 		&& nField			== r.nField
 		&& nVal				== r.nVal
-		&& *pStr			== *r.pStr;
+		&& *pStr			== *r.pStr
+        && aStrValues == r.aStrValues;
 	//! pSearchParam und pSearchText nicht vergleichen
 }
 
Index: sc/source/core/data/makefile.mk
===================================================================
RCS file: /cvs/sc/sc/source/core/data/makefile.mk,v
retrieving revision 1.21
retrieving revision 1.21.114.1
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.21 -r1.21.114.1
--- sc/source/core/data/makefile.mk	27 Feb 2007 12:06:42 -0000	1.21
+++ sc/source/core/data/makefile.mk	14 Aug 2007 22:10:11 -0000	1.21.114.1
@@ -90,6 +90,7 @@
 	$(SLO)$/drawpage.obj \
 	$(SLO)$/drwlayer.obj \
 	$(SLO)$/fillinfo.obj \
+	$(SLO)$/filterglobal.obj \
 	$(SLO)$/global.obj \
 	$(SLO)$/global2.obj \
 	$(SLO)$/globalx.obj \
Index: sc/source/core/data/table3.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/table3.cxx,v
retrieving revision 1.29
retrieving revision 1.28.104.2
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.29 -r1.28.104.2
--- sc/source/core/data/table3.cxx	21 Sep 2007 09:23:09 -0000	1.29
+++ sc/source/core/data/table3.cxx	1 Oct 2007 15:29:18 -0000	1.28.104.2
@@ -36,7 +36,7 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
-
+#include <stdio.h>
 
 // INCLUDE ---------------------------------------------------------------
 
@@ -1036,6 +1036,18 @@
             else
                 GetInputString( static_cast<SCCOL>(rEntry.nField), nRow, aCellStr );
 
+            if ( !rEntry.aStrValues.empty() )
+            {
+                // Filter by individual string values.
+                rtl::OUString aCellStr2(aCellStr);
+                ScHashOUStringSet::const_iterator pos = rEntry.aStrValues.find(aCellStr2);
+                if (pos == rEntry.aStrValues.end())
+                    bOk = FALSE;
+                else
+                    bOk = TRUE;
+            }
+            else
+            {
             BOOL bRealRegExp = (rParam.bRegExp && ((rEntry.eOp == SC_EQUAL)
                 || (rEntry.eOp == SC_NOT_EQUAL)));
             BOOL bTestRegExp = (pbTestEqualCondition && rParam.bRegExp
@@ -1113,6 +1125,7 @@
 				}
 			}
 		}
+		}
         else if (rParam.bMixedComparison)
         {
             if (rEntry.bQueryByString &&
@@ -1304,7 +1317,11 @@
         ScQueryEntry& rEntry = rParam.GetEntry(i);
         if ( rEntry.bDoQuery )
         {
-            if ( rEntry.bQueryByString )
+            if ( !rEntry.aStrValues.empty() )
+            {
+                // Do nothing.
+            }
+            else if ( rEntry.bQueryByString )
             {
                 sal_uInt32 nIndex = 0;
                 rEntry.bQueryByString = !( pDoc->GetFormatTable()->
Index: sc/source/core/tool/dbcolect.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/tool/dbcolect.cxx,v
retrieving revision 1.16
retrieving revision 1.16.114.1
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.16 -r1.16.114.1
--- sc/source/core/tool/dbcolect.cxx	27 Feb 2007 12:14:19 -0000	1.16
+++ sc/source/core/tool/dbcolect.cxx	25 Jul 2007 03:40:45 -0000	1.16.114.1
@@ -544,6 +544,7 @@
 		*pQueryStr[i]		= *rData.pQueryStr[i];
 		nQueryVal[i]		= rData.nQueryVal[i];
 		eQueryConnect[i]	= rData.eQueryConnect[i];
+        aStrValues[i] = rData.aStrValues[i];
 	}
 	for (i=0; i<MAXSUBTOTAL; i++)
 	{
@@ -812,6 +813,7 @@
 		*rEntry.pStr = *pQueryStr[i];
 		rEntry.nVal = nQueryVal[i];
 		rEntry.eConnect = eQueryConnect[i];
+        rEntry.aStrValues = aStrValues[i];
 	}
 }
 
@@ -843,6 +845,7 @@
 		*pQueryStr[i] = *rEntry.pStr;
 		nQueryVal[i] = rEntry.nVal;
 		eQueryConnect[i] = rEntry.eConnect;
+        aStrValues[i] = rEntry.aStrValues;
 	}
 }
 
Index: sc/source/filter/xml/XMLExportDatabaseRanges.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/xml/XMLExportDatabaseRanges.cxx,v
retrieving revision 1.22
retrieving revision 1.22.74.6
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.22 -r1.22.74.6
--- sc/source/filter/xml/XMLExportDatabaseRanges.cxx	22 May 2007 20:02:49 -0000	1.22
+++ sc/source/filter/xml/XMLExportDatabaseRanges.cxx	15 Aug 2007 23:14:50 -0000	1.22.74.6
@@ -36,7 +36,7 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
-
+#include <stdio.h>
 
 // INCLUDE ---------------------------------------------------------------
 
@@ -85,6 +85,8 @@
 #include "rangeutl.hxx"
 #endif
 
+#include "filterglobal.hxx"
+
 #ifndef _COM_SUN_STAR_SHEET_DATAIMPORTMODE_HPP_
 #include <com/sun/star/sheet/DataImportMode.hpp>
 #endif
@@ -107,6 +109,12 @@
 #include <com/sun/star/table/TableOrientation.hpp>
 #endif
 
+#include <com/sun/star/sheet/XSheetFilterFieldAccess.hpp>
+#include <com/sun/star/sheet/SheetFilterFieldValue.hpp>
+#include <com/sun/star/sheet/SheetFilterFieldMultiString.hpp>
+#include <com/sun/star/sheet/SheetFilterFieldType.hpp>
+#include <com/sun/star/sheet/SheetFilterOperator.hpp>
+
 #ifndef _TOOLS_DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
@@ -114,14 +122,27 @@
 #include <comphelper/extract.hxx>
 #endif
 
+#include <boost/shared_ptr.hpp>
+#include <vector>
+
 //! not found in unonames.hxx
 #define SC_USERLIST "UserList"
 #define SC_SORTASCENDING "SortAscending"
 #define SC_ENABLEUSERSORTLIST "EnableUserSortList"
 #define SC_USERSORTLISTINDEX "UserSortListIndex"
 
+#define CREATE_OUSTRING( ascii )    ::rtl::OUString::intern( RTL_CONSTASCII_USTRINGPARAM( ascii ) )
+
+using ::com::sun::star::uno::Reference;
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::uno::Any;
+using ::com::sun::star::uno::Type;
+using ::com::sun::star::sheet::SheetFilterFieldMultiString;
+using ::com::sun::star::sheet::SheetFilterFieldValue;
+
 using namespace com::sun::star;
 using namespace xmloff::token;
+using ::boost::shared_ptr;
 
 ScXMLExportDatabaseRanges::ScXMLExportDatabaseRanges(ScXMLExport& rTempExport)
 	: rExport(rTempExport),
@@ -259,43 +280,43 @@
 	}
 }
 
-rtl::OUString ScXMLExportDatabaseRanges::getOperatorXML(const sheet::FilterOperator aFilterOperator, const sal_Bool bUseRegularExpressions) const
+rtl::OUString ScXMLExportDatabaseRanges::getOperatorXML(const sal_Int16 nOperator, const sal_Bool bUseRegularExpressions) const
 {
-	switch (aFilterOperator)
+	switch (nOperator)
 	{
-		case sheet::FilterOperator_EQUAL :
+        case sheet::SheetFilterOperator::EQUAL :
 		{
 			if (bUseRegularExpressions)
 				return GetXMLToken(XML_MATCH);
 			else
 				return rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("="));
 		}
-		case sheet::FilterOperator_NOT_EQUAL :
+		case sheet::SheetFilterOperator::NOT_EQUAL :
 		{
 			if (bUseRegularExpressions)
 				return GetXMLToken(XML_NOMATCH);
 			else
 				return rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("!="));
 		}
-		case sheet::FilterOperator_BOTTOM_PERCENT :
+		case sheet::SheetFilterOperator::BOTTOM_PERCENT :
 			return GetXMLToken(XML_BOTTOM_PERCENT);
-		case sheet::FilterOperator_BOTTOM_VALUES :
+		case sheet::SheetFilterOperator::BOTTOM_VALUES :
 			return GetXMLToken(XML_BOTTOM_VALUES);
-		case sheet::FilterOperator_EMPTY :
+		case sheet::SheetFilterOperator::EMPTY :
 			return GetXMLToken(XML_EMPTY);
-		case sheet::FilterOperator_GREATER :
+		case sheet::SheetFilterOperator::GREATER :
 			return rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(">"));
-		case sheet::FilterOperator_GREATER_EQUAL :
+		case sheet::SheetFilterOperator::GREATER_EQUAL :
 			return rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(">="));
-		case sheet::FilterOperator_LESS :
+		case sheet::SheetFilterOperator::LESS :
 			return rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("<"));
-		case sheet::FilterOperator_LESS_EQUAL :
+		case sheet::SheetFilterOperator::LESS_EQUAL :
 			return rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("<="));
-		case sheet::FilterOperator_NOT_EMPTY :
+		case sheet::SheetFilterOperator::NOT_EMPTY :
 			return GetXMLToken(XML_NOEMPTY);
-		case sheet::FilterOperator_TOP_PERCENT :
+		case sheet::SheetFilterOperator::TOP_PERCENT :
 			return GetXMLToken(XML_TOP_PERCENT);
-		case sheet::FilterOperator_TOP_VALUES :
+		case sheet::SheetFilterOperator::TOP_VALUES :
 			return GetXMLToken(XML_TOP_VALUES);
         default:
         {
@@ -305,6 +326,166 @@
 	return rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("="));
 }
 
+void ScXMLExportDatabaseRanges::WriteFilterCondition(const ScSheetFilterFieldItem& aFieldItem, sal_Bool bIsCaseSensitive, sal_Bool bUseRegularExpressions)
+{
+    rExport.AddAttribute(XML_NAMESPACE_TABLE, XML_FIELD_NUMBER, 
+                         rtl::OUString::valueOf(aFieldItem.mpField->Field));
+
+    if (bIsCaseSensitive)
+        rExport.AddAttribute(XML_NAMESPACE_TABLE, XML_CASE_SENSITIVE, XML_TRUE);
+
+    switch (aFieldItem.mnType)
+    {
+        case sheet::SheetFilterFieldType::VALUE:
+        {
+            SheetFilterFieldValue* pField = aFieldItem.getFieldValue();
+
+            if (pField->IsNumeric)
+            {
+                rExport.AddAttribute(XML_NAMESPACE_TABLE, XML_DATA_TYPE, XML_NUMBER);
+                rtl::OUStringBuffer sBuffer;
+                rExport.GetMM100UnitConverter().convertDouble(sBuffer, pField->NumericValue);
+                rExport.AddAttribute(XML_NAMESPACE_TABLE, XML_VALUE, sBuffer.makeStringAndClear());
+            }
+            else
+                rExport.AddAttribute(XML_NAMESPACE_TABLE, XML_VALUE, pField->StringValue);
+
+            rExport.AddAttribute(XML_NAMESPACE_TABLE, XML_OPERATOR, 
+                                 getOperatorXML(pField->Operator, bUseRegularExpressions));
+
+            SvXMLElementExport aElem(rExport, XML_NAMESPACE_TABLE, XML_FILTER_CONDITION, true, true);
+        }
+        break;
+        case sheet::SheetFilterFieldType::MULTI_STRING:
+        {
+            SheetFilterFieldMultiString* pField = aFieldItem.getFieldMultiString();
+            size_t nSize = pField->StringSet.getLength();
+            OSL_ENSURE(nSize > 0, "ScXMLExportDatabaseRanges::WriteFilterCondition: no string set items");
+
+            rExport.AddAttribute(XML_NAMESPACE_TABLE, XML_DATA_TYPE, XML_TEXT);
+            rExport.AddAttribute(XML_NAMESPACE_TABLE, XML_VALUE, pField->StringSet[0]);
+            rExport.AddAttribute(XML_NAMESPACE_TABLE, XML_OPERATOR, CREATE_OUSTRING("="));
+            SvXMLElementExport aElem(rExport, XML_NAMESPACE_TABLE, XML_FILTER_CONDITION, true, true);
+
+            for ( size_t i = 0; i < nSize; ++i )
+            {
+                rExport.AddAttribute(XML_NAMESPACE_TABLE, XML_VALUE, pField->StringSet[i]);
+                SvXMLElementExport aElemItem(rExport, XML_NAMESPACE_TABLE, XML_FILTER_SET_ITEM, true, true);
+            }
+        }
+        break;
+        default:
+            OSL_ENSURE(false, "ScXMLExportDatabaseRanges::WriteCondition: unknown field type");
+    }
+}
+
+void ScXMLExportDatabaseRanges::WriteFilterDescriptor(const uno::Reference <sheet::XSheetFilterFieldAccess>& xFilterAccess, 
+                                                      const rtl::OUString sDatabaseRangeName)
+{
+    typedef shared_ptr<SvXMLElementExport> SvXMLElementExportRef;
+
+    if ( !xFilterAccess.is() )
+    {
+        OSL_ENSURE(false, "ScXMLExportDatabaseRanges::WriteFilterDescriptor: extended filter descriptor is null.");
+        return;
+    }
+
+    Sequence<Any> aFields;
+    aFields = xFilterAccess->getFields();
+    sal_Int32 nFieldCount = aFields.getLength();
+    fprintf(stdout, "ScXMLExportDatabaseRanges::WriteFilterDescriptor: count = %ld\n", nFieldCount);fflush(stdout);
+    if (nFieldCount == 0)
+        return;
+
+    uno::Reference <beans::XPropertySet> xPropertySet (xFilterAccess, uno::UNO_QUERY);
+    if ( !xPropertySet.is() )
+    {
+        OSL_ENSURE(false, "ScXMLExportDatabaseRanges::WriteFilterDescriptor: property set is empty");
+        return;
+    }
+
+    // Advanced filter settings.
+    ScDBCollection* pDBCollection = pDoc->GetDBCollection();
+    sal_uInt16 nIndex;
+    pDBCollection->SearchName(sDatabaseRangeName, nIndex);
+    ScDBData* pDBData = (*pDBCollection)[nIndex];
+    ScRange aAdvSource;
+    if (pDBData->GetAdvancedQuerySource(aAdvSource))
+    {
+        rtl::OUString sOUCellAddress;
+        ScRangeStringConverter::GetStringFromRange( sOUCellAddress, aAdvSource, pDoc );
+        rExport.AddAttribute(XML_NAMESPACE_TABLE, XML_CONDITION_SOURCE_RANGE_ADDRESS, sOUCellAddress);
+    }
+
+    // Skip duplicates.
+    if ( ::cppu::any2bool(xPropertySet->getPropertyValue( CREATE_OUSTRING(SC_UNONAME_SKIPDUP) )) )
+        rExport.AddAttribute(XML_NAMESPACE_TABLE, XML_DISPLAY_DUPLICATES, XML_FALSE);
+
+    // Case sensitivity
+    sal_Bool bIsCaseSensitive = ::cppu::any2bool(
+        xPropertySet->getPropertyValue( CREATE_OUSTRING(SC_UNONAME_ISCASE) ) );
+    // Regular expression
+    sal_Bool bUseRegularExpressions = ::cppu::any2bool(
+        xPropertySet->getPropertyValue( CREATE_OUSTRING(SC_UNONAME_USEREGEX) ) );
+
+    // This 'table:filter' element will be the root for this filter sub-tree.
+    SvXMLElementExport aElemFilter(rExport, XML_NAMESPACE_TABLE, XML_FILTER, sal_True, sal_True);
+
+    // Keep track of the stack of AND/OR elements.  The filter-condition 
+    // elements always come below one of AND/OR elements.
+    ::std::vector<SvXMLElementExportRef> aElementStack;
+    aElementStack.reserve(10);
+
+    bool bFirstItem = true;
+    ScSheetFilterFieldItem aLastField;
+    for (sal_Int32 i = 0; i < nFieldCount; ++i)
+    {
+        sal_Int16 nType = sheet::SheetFilterFieldType::NONE;
+        Type eUnoType = aFields[i].getValueType();
+        ScSheetFilterFieldItem::SheetFilterFieldRef pField;
+        if (eUnoType == ScSheetFilterFieldItem::VALUE)
+        {
+            pField.reset(new SheetFilterFieldValue);
+            SheetFilterFieldValue* p = static_cast<SheetFilterFieldValue*>(pField.get());
+            aFields[i] >>= *p;
+            nType = sheet::SheetFilterFieldType::VALUE;
+        }
+        else if (eUnoType == ScSheetFilterFieldItem::MULTI_STRING)
+        {
+            pField.reset(new SheetFilterFieldMultiString);
+            SheetFilterFieldMultiString* p = static_cast<SheetFilterFieldMultiString*>(pField.get());
+            aFields[i] >>= *p;
+            nType = sheet::SheetFilterFieldType::MULTI_STRING;
+        }
+
+        if (!bFirstItem)
+        {
+            XMLTokenEnum eToken = pField->Connection == sheet::FilterConnection_OR ? XML_FILTER_OR : XML_FILTER_AND;
+            SvXMLElementExportRef pElem(new SvXMLElementExport(rExport, XML_NAMESPACE_TABLE, eToken, true, true));
+            aElementStack.push_back(pElem);
+    
+            OSL_ENSURE(aLastField.mpField.get(), "ScXMLExportDatabaseRanges::WriteFilterDescriptor: last field is empty!");
+            WriteFilterCondition(aLastField, bIsCaseSensitive, bUseRegularExpressions);
+        }
+        else
+            bFirstItem = false;
+
+        // Store this field for insertion in the next iteration.
+        aLastField.mnType = nType;
+        aLastField.mpField = pField;
+    }
+
+    // Don't forget to add the last item!
+    OSL_ENSURE(!bFirstItem, "ScXMLExportDatabaseRanges::WriteFilterDescriptor: first item!?");
+    OSL_ENSURE(aLastField.mpField.get(), "ScXMLExportDatabaseRanges::WriteFilterDescriptor: last field is empty!");
+    WriteFilterCondition(aLastField, bIsCaseSensitive, bUseRegularExpressions);
+
+    // Pop all elements before exiting...
+    size_t nSize = aElementStack.size();
+    for ( size_t i = 0; i < nSize; ++i )
+        aElementStack.pop_back();
+}
+
 void ScXMLExportDatabaseRanges::WriteCondition(const sheet::TableFilterField& aFilterField, sal_Bool bIsCaseSensitive, sal_Bool bUseRegularExpressions)
 {
 	rExport.AddAttribute(XML_NAMESPACE_TABLE, XML_FIELD_NUMBER, rtl::OUString::valueOf(aFilterField.Field));
@@ -323,7 +504,9 @@
 	SvXMLElementExport aElemC(rExport, XML_NAMESPACE_TABLE, XML_FILTER_CONDITION, sal_True, sal_True);
 }
 
-void ScXMLExportDatabaseRanges::WriteFilterDescriptor(const uno::Reference <sheet::XSheetFilterDescriptor>& xSheetFilterDescriptor, const rtl::OUString sDatabaseRangeName)
+#if 0
+void ScXMLExportDatabaseRanges::WriteFilterDescriptor(const uno::Reference <sheet::XSheetFilterDescriptor>& xSheetFilterDescriptor, 
+                                                      const rtl::OUString sDatabaseRangeName)
 {
 	uno::Sequence <sheet::TableFilterField> aTableFilterFields(xSheetFilterDescriptor->getFilterFields());
 	sal_Int32 nTableFilterFields = aTableFilterFields.getLength();
@@ -334,14 +517,18 @@
 		{
 			if (::cppu::any2bool(xPropertySet->getPropertyValue(rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(SC_UNONAME_COPYOUT)))))
             {
+                // CopyOutputData
 				table::CellAddress aOutputPosition;
 				if (xPropertySet->getPropertyValue(rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(SC_UNONAME_OUTPOS))) >>= aOutputPosition)
 				{
+                    // OutputPosition
 					rtl::OUString sOUCellAddress;
 					ScRangeStringConverter::GetStringFromAddress( sOUCellAddress, aOutputPosition, pDoc );
 					rExport.AddAttribute(XML_NAMESPACE_TABLE, XML_TARGET_RANGE_ADDRESS, sOUCellAddress);
 				}
 			}
+
+            // Advanced filter settings.
 			ScDBCollection* pDBCollection = pDoc->GetDBCollection();
 			sal_uInt16 nIndex;
 			pDBCollection->SearchName(sDatabaseRangeName, nIndex);
@@ -354,8 +541,11 @@
 				rExport.AddAttribute(XML_NAMESPACE_TABLE, XML_CONDITION_SOURCE_RANGE_ADDRESS, sOUCellAddress);
 			}
 
+            // SkipDuplicates
 			if (::cppu::any2bool(xPropertySet->getPropertyValue(rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(SC_UNONAME_SKIPDUP)))))
 				rExport.AddAttribute(XML_NAMESPACE_TABLE, XML_DISPLAY_DUPLICATES, XML_FALSE);
+
+            // Add table:filter element as a child of the current element (table:database-range).
 			SvXMLElementExport aElemF(rExport, XML_NAMESPACE_TABLE, XML_FILTER, sal_True, sal_True);
 			rExport.CheckAttrList();
 			sal_Bool bIsCaseSensitive = ::cppu::any2bool(xPropertySet->getPropertyValue(rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(SC_UNONAME_ISCASE))));
@@ -396,6 +586,8 @@
 				sheet::FilterConnection aConnection = aTableFilterFields[1].Connection;
 				sal_Bool bOpenAndElement;
 				rtl::OUString aName = rExport.GetNamespaceMap().GetQNameByKey(XML_NAMESPACE_TABLE, GetXMLToken(XML_FILTER_AND));
+                fprintf(stdout, "ScXMLExportDatabaseRanges::WriteFilterDescriptor: aName = %s\n",
+                        OUStringToOString(aName, RTL_TEXTENCODING_UTF8).getStr());fflush(stdout);
 				if (aConnection == sheet::FilterConnection_AND)
 				{
 					rExport.StartElement( aName, sal_True);
@@ -450,6 +642,7 @@
 		}
 	}
 }
+#endif
 
 void ScXMLExportDatabaseRanges::WriteSortDescriptor(const uno::Sequence <beans::PropertyValue> aSortProperties)
 {
@@ -688,11 +881,16 @@
 								if (::cppu::any2bool(xPropertySetDatabaseRange->getPropertyValue(rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(SC_UNONAME_STRIPDAT)))))
 									rExport.AddAttribute(XML_NAMESPACE_TABLE, XML_HAS_PERSISTENT_DATA, XML_FALSE);
 							}
-							uno::Reference <sheet::XSheetFilterDescriptor> xSheetFilterDescriptor(xDatabaseRange->getFilterDescriptor());
+
+                            Reference<beans::XPropertySet> xPropSet(xDatabaseRange, uno::UNO_QUERY);
+                            Any any = xPropSet->getPropertyValue( CREATE_OUSTRING("SheetFilterFieldAccess") );
+                            Reference<sheet::XSheetFilterFieldAccess> xFilterAccess;
+                            any >>= xFilterAccess;
+
 							uno::Sequence <beans::PropertyValue> aSortProperties(xDatabaseRange->getSortDescriptor());
-							if (xSheetFilterDescriptor.is())
+							if (xFilterAccess.is())
 							{
-								uno::Reference <beans::XPropertySet> xFilterProperties (xSheetFilterDescriptor, uno::UNO_QUERY);
+								uno::Reference <beans::XPropertySet> xFilterProperties (xFilterAccess, uno::UNO_QUERY);
 								if (xFilterProperties.is())
 								{
 									if (!::cppu::any2bool(xFilterProperties->getPropertyValue(rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(SC_UNONAME_CONTHDR)))))
@@ -731,8 +929,10 @@
 							SvXMLElementExport aElemDR(rExport, XML_NAMESPACE_TABLE, XML_DATABASE_RANGE, sal_True, sal_True);
 							rExport.CheckAttrList();
 							WriteImportDescriptor(xDatabaseRange->getImportDescriptor());
-							if (xSheetFilterDescriptor.is())
-								WriteFilterDescriptor(xSheetFilterDescriptor, sDatabaseRangeName);
+
+							if (xFilterAccess.is())
+                                WriteFilterDescriptor(xFilterAccess, sDatabaseRangeName);
+
 							WriteSortDescriptor(aSortProperties);
 							WriteSubTotalDescriptor(xDatabaseRange->getSubTotalDescriptor(), sDatabaseRangeName);
 						}
Index: sc/source/filter/xml/XMLExportDatabaseRanges.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/xml/XMLExportDatabaseRanges.hxx,v
retrieving revision 1.2
retrieving revision 1.2.484.4
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.2 -r1.2.484.4
--- sc/source/filter/xml/XMLExportDatabaseRanges.hxx	8 Sep 2005 19:55:16 -0000	1.2
+++ sc/source/filter/xml/XMLExportDatabaseRanges.hxx	15 Aug 2007 19:21:14 -0000	1.2.484.4
@@ -58,9 +58,12 @@
 #include <com/sun/star/sheet/XSpreadsheetDocument.hpp>
 #endif
 
+#include <com/sun/star/sheet/XSheetFilterFieldAccess.hpp>
+
 class ScXMLExport;
 class ScDocument;
 class ScMyEmptyDatabaseRangesContainer;
+struct ScSheetFilterFieldItem;
 
 class ScXMLExportDatabaseRanges
 {
@@ -68,9 +71,11 @@
 	ScDocument*		pDoc;
 
 	void WriteImportDescriptor(const com::sun::star::uno::Sequence <com::sun::star::beans::PropertyValue> aImportDescriptor);
-	rtl::OUString getOperatorXML(const com::sun::star::sheet::FilterOperator aFilterOperator, const sal_Bool bUseRegularExpressions) const;
+	rtl::OUString getOperatorXML(const sal_Int16 nOperator, const sal_Bool bUseRegularExpressions) const;
+    void WriteFilterCondition(const ScSheetFilterFieldItem& aFieldItem, sal_Bool bIsCaseSensitive, sal_Bool bUseRegularExpressions);
+	void WriteFilterDescriptor(const com::sun::star::uno::Reference <com::sun::star::sheet::XSheetFilterFieldAccess>& xFilterAccess, const rtl::OUString sDatabaseRangeName);
 	void WriteCondition(const com::sun::star::sheet::TableFilterField& aFilterField, sal_Bool bIsCaseSensitive, sal_Bool bUseRegularExpressions);
-	void WriteFilterDescriptor(const com::sun::star::uno::Reference <com::sun::star::sheet::XSheetFilterDescriptor>& xSheetFilterDescriptor, const rtl::OUString sDatabaseRangeName);
+// 	void WriteFilterDescriptor(const com::sun::star::uno::Reference <com::sun::star::sheet::XSheetFilterDescriptor>& xSheetFilterDescriptor, const rtl::OUString sDatabaseRangeName);
 	void WriteSortDescriptor(const com::sun::star::uno::Sequence <com::sun::star::beans::PropertyValue> aSortProperties);
 	void WriteSubTotalDescriptor(const com::sun::star::uno::Reference <com::sun::star::sheet::XSubTotalDescriptor> xSubTotalDescriptor, const rtl::OUString sDatabaseRangeName);
 public:
Index: sc/source/filter/xml/makefile.mk
===================================================================
RCS file: /cvs/sc/sc/source/filter/xml/makefile.mk,v
retrieving revision 1.32
retrieving revision 1.32.484.2
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.32 -r1.32.484.2
Index: sc/source/filter/xml/xmldrani.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/xml/xmldrani.cxx,v
retrieving revision 1.30
retrieving revision 1.30.74.4
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.30 -r1.30.74.4
--- sc/source/filter/xml/xmldrani.cxx	22 May 2007 20:03:45 -0000	1.30
+++ sc/source/filter/xml/xmldrani.cxx	15 Aug 2007 05:05:07 -0000	1.30.74.4
@@ -36,7 +36,7 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
-
+#include <stdio.h>
 
 // INCLUDE ---------------------------------------------------------------
 
@@ -44,6 +44,7 @@
 #include "xmlimprt.hxx"
 #include "xmlfilti.hxx"
 #include "xmlsorti.hxx"
+#include "filterglobal.hxx"
 #include "document.hxx"
 #include "globstr.hrc"
 #include "docuno.hxx"
@@ -83,6 +84,10 @@
 #include <com/sun/star/sheet/XSpreadsheetDocument.hpp>
 #include <com/sun/star/sheet/XDatabaseRanges.hpp>
 #include <com/sun/star/sheet/XDatabaseRange.hpp>
+#include <com/sun/star/sheet/SheetFilterFieldType.hpp>
+#include <com/sun/star/sheet/SheetFilterFieldValue.hpp>
+#include <com/sun/star/sheet/SheetFilterFieldMultiString.hpp>
+#include <com/sun/star/sheet/XSheetFilterFieldAccess.hpp>
 #include <com/sun/star/table/CellRangeAddress.hpp>
 #ifndef _COMPHELPER_EXTRACT_HXX_
 #include <comphelper/extract.hxx>
@@ -94,13 +99,22 @@
 #include <com/sun/star/xml/sax/XLocator.hpp>
 #endif
 
+
+
 #define SC_ENABLEUSERSORTLIST	"EnableUserSortList"
 #define SC_USERSORTLISTINDEX	"UserSortListIndex"
 #define SC_USERLIST				"UserList"
 
+#define CREATE_OUSTRING( ascii )    ::rtl::OUString::intern( RTL_CONSTASCII_USTRINGPARAM( ascii ) )
+
 using namespace com::sun::star;
 using namespace xmloff::token;
 
+using ::com::sun::star::uno::UNO_QUERY;
+using ::com::sun::star::uno::Reference;
+using ::com::sun::star::uno::Any;
+using ::com::sun::star::uno::Sequence;
+
 //------------------------------------------------------------------
 
 ScXMLDatabaseRangesContext::ScXMLDatabaseRangesContext( ScXMLImport& rImport,
@@ -147,6 +161,70 @@
 {
 }
 
+// ----------------------------------------------------------------------------
+
+void ScXMLDatabaseRangeContext::WriteTableFilterFields(
+    const Reference<sheet::XSheetFilterFieldAccess>& xFilterAccess, ScDBData* pDBData)
+{
+    using uno::makeAny;
+
+    if ( !xFilterAccess.is() )
+        return;
+
+    Reference<beans::XPropertySet> xPS(xFilterAccess, UNO_QUERY);
+    if ( !xPS.is() )
+    {
+        OSL_ENSURE(false, "ScXMLDatabaseRangeContext::WriteTableFilterFields: property set is null");
+        return;
+    }
+
+    // Write properties first.
+    sal_Bool bOrientation = (table::TableOrientation_COLUMNS == eOrientation);
+    xPS->setPropertyValue(CREATE_OUSTRING(SC_UNONAME_ORIENT),   makeAny(bOrientation));
+    xPS->setPropertyValue(CREATE_OUSTRING(SC_UNONAME_CONTHDR),  makeAny(bContainsHeader));
+    xPS->setPropertyValue(CREATE_OUSTRING(SC_UNONAME_COPYOUT),  makeAny(bFilterCopyOutputData));
+    xPS->setPropertyValue(CREATE_OUSTRING(SC_UNONAME_ISCASE),   makeAny(bFilterIsCaseSensitive));
+    xPS->setPropertyValue(CREATE_OUSTRING(SC_UNONAME_SKIPDUP),  makeAny(bFilterSkipDuplicates));
+    xPS->setPropertyValue(CREATE_OUSTRING(SC_UNONAME_USEREGEX), makeAny(bFilterUseRegularExpressions));
+    xPS->setPropertyValue(CREATE_OUSTRING(SC_UNONAME_OUTPOS),   makeAny(aFilterOutputPosition));
+
+    // Write fields.
+    sal_Int32 nSize = aFilterFieldItems.size();
+    Sequence<Any> aAnyFields(nSize);
+    Any any;
+    for (sal_Int32 i = 0; i < nSize; ++i)
+    {
+        switch (aFilterFieldItems[i].mnType)
+        {
+            case com::sun::star::sheet::SheetFilterFieldType::VALUE:
+            {
+                sheet::SheetFilterFieldValue* p = aFilterFieldItems[i].getFieldValue();
+                any <<= *p;
+                aAnyFields[i] = any;
+            }
+            break;
+            case com::sun::star::sheet::SheetFilterFieldType::MULTI_STRING:
+            {
+                sheet::SheetFilterFieldMultiString* p = aFilterFieldItems[i].getFieldMultiString();
+                any <<= *p;
+                aAnyFields[i] = any;
+            }
+            break;
+            case com::sun::star::sheet::SheetFilterFieldType::NONE:
+            default:
+                OSL_ENSURE(false, "ScXMLDatabaseRangeContext::WriteTableFilterFields: unknown or unhandled filter type");
+        }
+    }
+    xFilterAccess->setFields(aAnyFields);
+
+    if (bFilterConditionSourceRange)
+    {
+        ScRange aAdvSource;
+        ScUnoConversion::FillScRange( aAdvSource, aFilterConditionSourceRangeAddress );
+        pDBData->SetAdvancedQuerySource(&aAdvSource);
+    }
+}
+
 ScXMLDatabaseRangeContext::ScXMLDatabaseRangeContext( ScXMLImport& rImport,
 									  USHORT nPrfx,
 									  const ::rtl::OUString& rLName,
@@ -411,6 +489,14 @@
 
 								pDBData->SetSortParam(aSortParam);
 							}
+#if 1
+                            Reference<beans::XPropertySet> xPropSet(xDatabaseRange, uno::UNO_QUERY);
+                            Any any = xPropSet->getPropertyValue( CREATE_OUSTRING("SheetFilterFieldAccess") );
+                            Reference<sheet::XSheetFilterFieldAccess> xFilterAccess;
+                            any >>= xFilterAccess;
+
+                            WriteTableFilterFields(xFilterAccess, pDBData);
+#else
 							uno::Reference <sheet::XSheetFilterDescriptor> xSheetFilterDescriptor(xDatabaseRange->getFilterDescriptor());
 							if (xSheetFilterDescriptor.is())
 							{
@@ -434,6 +520,7 @@
 									pDBData->SetAdvancedQuerySource(&aAdvSource);
 								}
 							}
+#endif
 							if (bContainsSubTotal)
 							{
 								uno::Reference <sheet::XSubTotalDescriptor> xSubTotalDescriptor(xDatabaseRange->getSubTotalDescriptor());
@@ -476,6 +563,11 @@
 	}
 }
 
+void ScXMLDatabaseRangeContext::AddFilterField(const ScSheetFilterFieldItem& aItem)
+{
+    aFilterFieldItems.push_back(aItem);
+}
+
 ScXMLSourceSQLContext::ScXMLSourceSQLContext( ScXMLImport& rImport,
 									  USHORT nPrfx,
 									  const ::rtl::OUString& rLName,
Index: sc/source/filter/xml/xmldrani.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/xml/xmldrani.hxx,v
retrieving revision 1.11
retrieving revision 1.11.484.2
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.11 -r1.11.484.2
--- sc/source/filter/xml/xmldrani.hxx	8 Sep 2005 20:07:09 -0000	1.11
+++ sc/source/filter/xml/xmldrani.hxx	13 Aug 2007 23:48:20 -0000	1.11.484.2
@@ -66,7 +66,19 @@
 #include <com/sun/star/table/TableOrientation.hpp>
 #endif
 
+#include <com/sun/star/sheet/XSheetFilterFieldAccess.hpp>
+
+#include <vector>
+
+class ScDBData;
 class ScXMLImport;
+struct ScSheetFilterFieldItem;
+
+namespace com { namespace sun { namespace star { namespace sheet {
+    struct SheetFilterFieldValue;
+    struct SheetFilterFieldMultiString;
+    class XSheetFilterDescriptor;
+}}}}
 
 class ScXMLDatabaseRangesContext : public SvXMLImportContext
 {
@@ -104,7 +116,7 @@
 	rtl::OUString	sDatabaseName;
 	rtl::OUString	sSourceObject;
 	com::sun::star::uno::Sequence <com::sun::star::beans::PropertyValue> aSortSequence;
-	com::sun::star::uno::Sequence <com::sun::star::sheet::TableFilterField> aFilterFields;
+    ::std::vector<ScSheetFilterFieldItem> aFilterFieldItems;
     std::vector < ScSubTotalRule > aSubTotalRules;
 	com::sun::star::table::CellAddress aFilterOutputPosition;
 	com::sun::star::table::CellRangeAddress aFilterConditionSourceRangeAddress;
@@ -137,6 +149,10 @@
 	const ScXMLImport& GetScImport() const { return (const ScXMLImport&)GetImport(); }
 	ScXMLImport& GetScImport() { return (ScXMLImport&)GetImport(); }
 
+    void WriteTableFilterFields(
+        const ::com::sun::star::uno::Reference< ::com::sun::star::sheet::XSheetFilterFieldAccess >& xFilterAccess,
+        ScDBData* pDBData);
+
 public:
 
 	ScXMLDatabaseRangeContext( ScXMLImport& rImport, USHORT nPrfx,
@@ -171,10 +187,11 @@
 	void SetFilterIsCaseSensitive(const sal_Bool bTemp) { bFilterIsCaseSensitive = bTemp; }
 	void SetFilterSkipDuplicates(const sal_Bool bTemp) { bFilterSkipDuplicates = bTemp; }
 	void SetFilterUseRegularExpressions(const sal_Bool bTemp) { bFilterUseRegularExpressions = bTemp; }
-	void SetFilterFields(const com::sun::star::uno::Sequence <com::sun::star::sheet::TableFilterField>& aTemp) { aFilterFields = aTemp; }
 	void SetFilterOutputPosition(const com::sun::star::table::CellAddress& aTemp) { aFilterOutputPosition = aTemp; }
 	void SetFilterConditionSourceRangeAddress(const com::sun::star::table::CellRangeAddress& aTemp) { aFilterConditionSourceRangeAddress = aTemp;
 																									bFilterConditionSourceRange = sal_True; }
+
+    void AddFilterField(const ScSheetFilterFieldItem& aItem);
 };
 
 class ScXMLSourceSQLContext : public SvXMLImportContext
Index: sc/source/filter/xml/xmlfilti.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/xml/xmlfilti.cxx,v
retrieving revision 1.16
retrieving revision 1.16.74.3
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.16 -r1.16.74.3
--- sc/source/filter/xml/xmlfilti.cxx	22 May 2007 20:04:07 -0000	1.16
+++ sc/source/filter/xml/xmlfilti.cxx	14 Aug 2007 22:10:11 -0000	1.16.74.3
@@ -36,11 +36,13 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
+#include <stdio.h>
 
 // INCLUDE ---------------------------------------------------------------
 
 #include "xmlfilti.hxx"
 #include "xmlimprt.hxx"
+#include "filterglobal.hxx"
 #include "docuno.hxx"
 
 #ifndef SC_CONVUNO_HXX
@@ -59,6 +61,12 @@
 #include <xmloff/xmltoken.hxx>
 #endif
 
+#include <com/sun/star/sheet/SheetFilterFieldValue.hpp>
+#include <com/sun/star/sheet/SheetFilterFieldMultiString.hpp>
+#include <com/sun/star/sheet/SheetFilterFieldType.hpp>
+#include <com/sun/star/sheet/SheetFilterConnection.hpp>
+#include <com/sun/star/sheet/SheetFilterOperator.hpp>
+
 using namespace com::sun::star;
 using namespace xmloff::token;
 
@@ -72,7 +80,6 @@
 										ScXMLDatabaseRangeContext* pTempDatabaseRangeContext) :
 	SvXMLImportContext( rImport, nPrfx, rLName ),
 	pDatabaseRangeContext(pTempDatabaseRangeContext),
-	aFilterFields(),
 	bSkipDuplicates(sal_False),
 	bCopyOutputData(sal_False),
 	bUseRegularExpressions(sal_False),
@@ -178,11 +185,17 @@
 		pDatabaseRangeContext->SetFilterCopyOutputData(sal_False);
 	pDatabaseRangeContext->SetFilterIsCaseSensitive(bIsCaseSensitive);
 	pDatabaseRangeContext->SetFilterSkipDuplicates(bSkipDuplicates);
-	pDatabaseRangeContext->SetFilterFields(aFilterFields);
 	if (bConditionSourceRange)
 		pDatabaseRangeContext->SetFilterConditionSourceRangeAddress(aConditionSourceRangeAddress);
 }
 
+void ScXMLFilterContext::AddFilterField(const ScSheetFilterFieldItem& aItem) const
+{
+    pDatabaseRangeContext->AddFilterField(aItem);
+}
+
+// ----------------------------------------------------------------------------
+
 ScXMLAndContext::ScXMLAndContext( ScXMLImport& rImport,
 									  USHORT nPrfx,
 									  const ::rtl::OUString& rLName,
@@ -292,6 +305,7 @@
 										ScXMLFilterContext* pTempFilterContext) :
 	SvXMLImportContext( rImport, nPrfx, rLName ),
 	pFilterContext(pTempFilterContext),
+    nFieldType(sheet::SheetFilterFieldType::VALUE),
 	bIsCaseSensitive(sal_False)
 {
 	sDataType = GetXMLToken(XML_TEXT);
@@ -325,7 +339,7 @@
 			break;
 			case XML_TOK_CONDITION_ATTR_VALUE :
 			{
-				sConditionValue = sValue;
+                aConditionValues.push_back(sValue);
 			}
 			break;
 			case XML_TOK_CONDITION_ATTR_OPERATOR :
@@ -341,79 +355,169 @@
 {
 }
 
-SvXMLImportContext *ScXMLConditionContext::CreateChildContext( USHORT nPrefix,
-											const ::rtl::OUString& rLName,
-											const ::com::sun::star::uno::Reference<
-                                        ::com::sun::star::xml::sax::XAttributeList>& /* xAttrList */ )
+SvXMLImportContext *ScXMLConditionContext::CreateChildContext( USHORT nPrefix, const ::rtl::OUString& rLName,
+                                                               const uno::Reference<xml::sax::XAttributeList>& xAttrList )
 {
+    const SvXMLTokenMap& rTokenMap(GetScImport().GetFilterElemTokenMap());
+    if ( rTokenMap.Get(nPrefix,rLName) == XML_TOK_FILTER_SET_ITEM )
+    {
+        // By virtue of presence of filter-set-item child context(s), declare this 
+        // filter condition as multi-string type.
+        if ( nFieldType != sheet::SheetFilterFieldType::MULTI_STRING )
+        {
+            nFieldType = sheet::SheetFilterFieldType::MULTI_STRING;
+            aConditionValues.clear();
+        }
+        return new ScXMLSetItemContext( GetScImport(), nPrefix, rLName, xAttrList, this );
+    }
+
 	return new SvXMLImportContext( GetImport(), nPrefix, rLName );
 }
 
-void ScXMLConditionContext::getOperatorXML(const rtl::OUString sTempOperator, sheet::FilterOperator& aFilterOperator, sal_Bool& bUseRegularExpressions) const
+void ScXMLConditionContext::getOperatorXML(const rtl::OUString sTempOperator, sal_Int16& rnFilterOperator, sal_Bool& bUseRegularExpressions) const
 {
 	bUseRegularExpressions = sal_False;
 	if (IsXMLToken(sTempOperator, XML_MATCH))
 	{
 		bUseRegularExpressions = sal_True;
-		aFilterOperator = sheet::FilterOperator_EQUAL;
+        rnFilterOperator = sheet::SheetFilterOperator::EQUAL;
 	}
 	else if (IsXMLToken(sTempOperator, XML_NOMATCH))
 	{
 		bUseRegularExpressions = sal_True;
-		aFilterOperator = sheet::FilterOperator_NOT_EQUAL;
+        rnFilterOperator = sheet::SheetFilterOperator::NOT_EQUAL;
 	}
 	else if (sTempOperator.compareToAscii("=") == 0)
-		aFilterOperator = sheet::FilterOperator_EQUAL;
+        rnFilterOperator = sheet::SheetFilterOperator::EQUAL;
 	else if (sTempOperator.compareToAscii("!=") == 0)
-		aFilterOperator = sheet::FilterOperator_NOT_EQUAL;
+        rnFilterOperator = sheet::SheetFilterOperator::NOT_EQUAL;
 	else if (IsXMLToken(sTempOperator, XML_BOTTOM_PERCENT))
-		aFilterOperator = sheet::FilterOperator_BOTTOM_PERCENT;
+        rnFilterOperator = sheet::SheetFilterOperator::BOTTOM_PERCENT;
 	else if (IsXMLToken(sTempOperator, XML_BOTTOM_VALUES))
-		aFilterOperator = sheet::FilterOperator_BOTTOM_VALUES;
+        rnFilterOperator = sheet::SheetFilterOperator::BOTTOM_VALUES;
 	else if (IsXMLToken(sTempOperator, XML_EMPTY))
-		aFilterOperator = sheet::FilterOperator_EMPTY;
+        rnFilterOperator = sheet::SheetFilterOperator::EMPTY;
 	else if (sTempOperator.compareToAscii(">") == 0)
-		aFilterOperator = sheet::FilterOperator_GREATER;
+        rnFilterOperator = sheet::SheetFilterOperator::GREATER;
 	else if (sTempOperator.compareToAscii(">=") == 0)
-		aFilterOperator = sheet::FilterOperator_GREATER_EQUAL;
+        rnFilterOperator = sheet::SheetFilterOperator::GREATER_EQUAL;
 	else if (sTempOperator.compareToAscii("<") == 0)
-		aFilterOperator = sheet::FilterOperator_LESS;
+        rnFilterOperator = sheet::SheetFilterOperator::LESS;
 	else if (sTempOperator.compareToAscii("<=") == 0)
-		aFilterOperator = sheet::FilterOperator_LESS_EQUAL;
+        rnFilterOperator = sheet::SheetFilterOperator::LESS_EQUAL;
 	else if (IsXMLToken(sTempOperator, XML_NOEMPTY))
-		aFilterOperator = sheet::FilterOperator_NOT_EMPTY;
+        rnFilterOperator = sheet::SheetFilterOperator::NOT_EMPTY;
 	else if (IsXMLToken(sTempOperator, XML_TOP_PERCENT))
-		aFilterOperator = sheet::FilterOperator_TOP_PERCENT;
+        rnFilterOperator = sheet::SheetFilterOperator::TOP_PERCENT;
 	else if (IsXMLToken(sTempOperator, XML_TOP_VALUES))
-		aFilterOperator = sheet::FilterOperator_TOP_VALUES;
+        rnFilterOperator = sheet::SheetFilterOperator::TOP_VALUES;
 }
 
 void ScXMLConditionContext::EndElement()
 {
-	sheet::TableFilterField aFilterField;
-	if (pFilterContext->GetConnection())
-		aFilterField.Connection = sheet::FilterConnection_OR;
-	else
-		aFilterField.Connection = sheet::FilterConnection_AND;
 	pFilterContext->SetIsCaseSensitive(bIsCaseSensitive);
+
+    ScSheetFilterFieldItem aItem;
+    aItem.mnType = nFieldType;
+
+    switch ( nFieldType )
+    {
+        case sheet::SheetFilterFieldType::VALUE:
+        {
+            if ( aConditionValues.empty() )
+                return;
+
+            aItem.mpField.reset(new sheet::SheetFilterFieldValue);
+            sheet::SheetFilterFieldValue* pField = aItem.getFieldValue();
+
 	sal_Bool bUseRegularExpressions;
-	getOperatorXML(sOperator, aFilterField.Operator, bUseRegularExpressions);
+            getOperatorXML(sOperator, pField->Operator, bUseRegularExpressions);
 	pFilterContext->SetUseRegularExpressions(bUseRegularExpressions);
-	aFilterField.Field = nField;
 	if (IsXMLToken(sDataType, XML_NUMBER))
 	{
-		aFilterField.NumericValue = sConditionValue.toDouble();
-		aFilterField.IsNumeric = sal_True;
+                pField->NumericValue = aConditionValues[0].toDouble();
+                pField->IsNumeric = sal_True;
 	}
 	else
 	{
-		aFilterField.StringValue = sConditionValue;
-		aFilterField.IsNumeric = sal_False;
+                pField->StringValue = aConditionValues[0];
+                pField->IsNumeric = sal_False;
 	}
-	pFilterContext->AddFilterField(aFilterField);
+        }
+        break;
+        case sheet::SheetFilterFieldType::MULTI_STRING:
+        {
+            aItem.mpField.reset(new sheet::SheetFilterFieldMultiString);
+            sheet::SheetFilterFieldMultiString* pField = aItem.getFieldMultiString();
+
+            size_t nSize = aConditionValues.size();
+            uno::Sequence<rtl::OUString> aStrings(nSize);
+            for ( size_t i = 0; i < nSize; ++i )
+                aStrings[i] = aConditionValues[i];
+            pField->StringSet = aStrings;
+        }
+        break;
+        case sheet::SheetFilterFieldType::NONE:
+        default:
+            OSL_ENSURE(false, "ScXMLConditionContext::EndElement: unknown type");
+            return;
+    }
+
+    // Common fields.
+    aItem.mpField->Connection = pFilterContext->GetConnection() ?
+        sheet::SheetFilterConnection::OR : sheet::SheetFilterConnection::AND;
+    aItem.mpField->Field = nField;
+
+    pFilterContext->AddFilterField(aItem);
+}
+
+void ScXMLConditionContext::AddConditionValue(const rtl::OUString& sValue)
+{
+    aConditionValues.push_back(sValue);
+}
+
+// ----------------------------------------------------------------------------
+
+ScXMLSetItemContext::ScXMLSetItemContext( ScXMLImport& rImport, USHORT nPrfx, const ::rtl::OUString& rLName,
+                                          const uno::Reference<xml::sax::XAttributeList>& xAttrList,
+                                          ScXMLConditionContext* pParentContext ) :
+    SvXMLImportContext( rImport, nPrfx, rLName ),
+    pConditionContext(pParentContext)
+{
+	sal_Int16 nAttrCount(xAttrList.is() ? xAttrList->getLength() : 0);
+	const SvXMLTokenMap& rAttrTokenMap(GetScImport().GetFilterConditionAttrTokenMap());
+    const SvXMLNamespaceMap& rNSMap = GetScImport().GetNamespaceMap();
+
+	for ( sal_Int16 i = 0; i < nAttrCount; ++i )
+	{
+		const rtl::OUString& sAttrName(xAttrList->getNameByIndex(i));
+		rtl::OUString aKey;
+		USHORT nPrefix = rNSMap.GetKeyByAttrName(sAttrName, &aKey);
+
+        if ( rAttrTokenMap.Get(nPrefix, aKey) == XML_TOK_CONDITION_ATTR_VALUE )
+        {
+            sConditionValue = xAttrList->getValueByIndex(i);
+        }
+	}
+}
+
+ScXMLSetItemContext::~ScXMLSetItemContext()
+{
+}
+
+SvXMLImportContext* ScXMLSetItemContext::CreateChildContext( USHORT nPrefix, const ::rtl::OUString& rLName, 
+                                                             const uno::Reference<xml::sax::XAttributeList>& /*xAttrList*/ )
+{
+    // There should not be any child context.
+	return new SvXMLImportContext( GetImport(), nPrefix, rLName );
+}
+
+void ScXMLSetItemContext::EndElement()
+{
+    pConditionContext->AddConditionValue(sConditionValue);
 }
 
-//==========================================================================
+//=============================================================================
 
 ScXMLDPFilterContext::ScXMLDPFilterContext( ScXMLImport& rImport,
 									  USHORT nPrfx,
Index: sc/source/filter/xml/xmlfilti.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/xml/xmlfilti.hxx,v
retrieving revision 1.6
retrieving revision 1.6.484.2
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.6 -r1.6.484.2
--- sc/source/filter/xml/xmlfilti.hxx	8 Sep 2005 20:08:27 -0000	1.6
+++ sc/source/filter/xml/xmlfilti.hxx	13 Aug 2007 23:48:20 -0000	1.6.484.2
@@ -52,6 +52,7 @@
 #ifndef _COM_SUN_STAR_SHEET_TABLEFILTERFIELD_HPP_
 #include <com/sun/star/sheet/TableFilterField.hpp>
 #endif
+
 #ifndef _STACK_HXX
 #include <tools/stack.hxx>
 #endif
@@ -59,13 +60,17 @@
 #include "xmldrani.hxx"
 #include "xmldpimp.hxx"
 
+namespace com { namespace sun { namespace star { namespace sheet {
+    struct SheetFilterField;
+}}}}
+
+class ScSheetFilterFieldItem;
 class ScXMLImport;
 
 class ScXMLFilterContext : public SvXMLImportContext
 {
 	ScXMLDatabaseRangeContext* pDatabaseRangeContext;
 
-	com::sun::star::uno::Sequence <com::sun::star::sheet::TableFilterField> aFilterFields;
 	com::sun::star::table::CellAddress aOutputPosition;
 	com::sun::star::table::CellRangeAddress aConditionSourceRangeAddress;
 	sal_Int16	nUserListIndex;
@@ -106,10 +111,12 @@
 							aConnectionOrStack.Push(pTemp);}
 	void CloseConnection() { sal_Bool* pTemp = static_cast <sal_Bool*> (aConnectionOrStack.Pop()); bConnectionOr = *pTemp; bNextConnectionOr = *pTemp; delete pTemp;}
 	sal_Bool GetConnection() { sal_Bool bTemp = bConnectionOr; bConnectionOr = bNextConnectionOr; return bTemp; }
-	void AddFilterField (const com::sun::star::sheet::TableFilterField aFilterField) { aFilterFields.realloc(aFilterFields.getLength() + 1);
-																				aFilterFields[aFilterFields.getLength() - 1] = aFilterField; }
+
+    void AddFilterField(const ScSheetFilterFieldItem& aItem) const;
 };
 
+// ----------------------------------------------------------------------------
+
 class ScXMLAndContext : public SvXMLImportContext
 {
 	ScXMLFilterContext* pFilterContext;
@@ -164,9 +171,10 @@
 {
 	ScXMLFilterContext* pFilterContext;
 
+    ::std::vector<rtl::OUString> aConditionValues;
 	rtl::OUString sDataType;
-	rtl::OUString sConditionValue;
 	rtl::OUString sOperator;
+    sal_Int16   nFieldType;
 	sal_Int32	nField;
 	sal_Bool	bIsCaseSensitive;
 
@@ -188,7 +196,33 @@
 									 const ::com::sun::star::uno::Reference<
 									  	::com::sun::star::xml::sax::XAttributeList>& xAttrList );
 
-	void getOperatorXML(const rtl::OUString sTempOperator, com::sun::star::sheet::FilterOperator& aFilterOperator, sal_Bool& bUseRegularExpressions) const;
+    void getOperatorXML(const rtl::OUString sTempOperator, sal_Int16& rnFilterOperator, sal_Bool& bUseRegularExpressions) const;
+	virtual void EndElement();
+
+    void AddConditionValue(const rtl::OUString& sValue);
+};
+
+class ScXMLSetItemContext : public SvXMLImportContext
+{
+    ScXMLConditionContext* pConditionContext;
+    ::rtl::OUString sConditionValue;
+
+    const ScXMLImport& GetScImport() const { return (const ScXMLImport&)GetImport(); }
+    ScXMLImport& GetScImport() { return (ScXMLImport&)GetImport(); }
+
+public:
+
+    ScXMLSetItemContext( ScXMLImport& rImport, USHORT nPrfx, const ::rtl::OUString& rLName,
+                         const ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XAttributeList >& xAttrList,
+                         ScXMLConditionContext* pParentContext );
+
+    virtual ~ScXMLSetItemContext();
+
+    virtual SvXMLImportContext *CreateChildContext( USHORT nPrefix,
+                                                    const ::rtl::OUString& rLocalName,
+                                                    const ::com::sun::star::uno::Reference<
+                                                    ::com::sun::star::xml::sax::XAttributeList>& xAttrList );
+
 	virtual void EndElement();
 };
 
Index: sc/source/filter/xml/xmlimprt.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/xml/xmlimprt.cxx,v
retrieving revision 1.127
retrieving revision 1.127.12.1
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.127 -r1.127.12.1
--- sc/source/filter/xml/xmlimprt.cxx	6 Jul 2007 12:40:45 -0000	1.127
+++ sc/source/filter/xml/xmlimprt.cxx	25 Jul 2007 03:40:45 -0000	1.127.12.1
@@ -643,6 +643,7 @@
 	{ XML_NAMESPACE_TABLE, XML_FILTER_AND,		    XML_TOK_FILTER_AND 			},
 	{ XML_NAMESPACE_TABLE, XML_FILTER_OR,			XML_TOK_FILTER_OR			},
 	{ XML_NAMESPACE_TABLE, XML_FILTER_CONDITION,	XML_TOK_FILTER_CONDITION	},
+    { XML_NAMESPACE_TABLE, XML_FILTER_SET_ITEM,	    XML_TOK_FILTER_SET_ITEM	    },
 	XML_TOKEN_MAP_END
 };
 
Index: sc/source/filter/xml/xmlimprt.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/xml/xmlimprt.hxx,v
retrieving revision 1.92
retrieving revision 1.92.346.1
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.92 -r1.92.346.1
--- sc/source/filter/xml/xmlimprt.hxx	20 Apr 2006 13:26:00 -0000	1.92
+++ sc/source/filter/xml/xmlimprt.hxx	25 Jul 2007 03:40:46 -0000	1.92.346.1
@@ -423,7 +423,8 @@
 {
 	XML_TOK_FILTER_AND,
 	XML_TOK_FILTER_OR,
-	XML_TOK_FILTER_CONDITION
+	XML_TOK_FILTER_CONDITION,
+    XML_TOK_FILTER_SET_ITEM
 };
 
 enum ScXMLFilterAttrTokens
Index: sc/source/ui/dbgui/filtdlg.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/dbgui/filtdlg.cxx,v
retrieving revision 1.14
retrieving revision 1.14.114.1
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.14 -r1.14.114.1
--- sc/source/ui/dbgui/filtdlg.cxx	27 Feb 2007 13:03:15 -0000	1.14
+++ sc/source/ui/dbgui/filtdlg.cxx	25 Jul 2007 03:40:46 -0000	1.14.114.1
@@ -586,6 +586,10 @@
             rEntry.nField = nField ? (theQueryData.nCol1 +
                     static_cast<SCCOL>(nField) - 1) : static_cast<SCCOL>(0);
 			rEntry.eOp	  = eOp;
+
+            // Disable multi-string matching until we have the UI implemented.
+            // TODO: Implement it in the UI (kohei).
+            rEntry.aStrValues.clear();
 		}
 	}
 
Index: sc/source/ui/unoobj/datauno.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/unoobj/datauno.cxx,v
retrieving revision 1.28
retrieving revision 1.28.104.2
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.28 -r1.28.104.2
--- sc/source/ui/unoobj/datauno.cxx	5 Mar 2007 14:45:54 -0000	1.28
+++ sc/source/ui/unoobj/datauno.cxx	13 Aug 2007 23:48:20 -0000	1.28.104.2
@@ -36,7 +36,7 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
-
+#include <stdio.h>
 
 #include <tools/debug.hxx>
 #include <svtools/smplhint.hxx>
@@ -52,6 +52,7 @@
 #include <com/sun/star/sheet/DataImportMode.hpp>
 
 #include "datauno.hxx"
+#include "sheetfilterfieldaccess.hxx"
 #include "dapiuno.hxx"
 #include "cellsuno.hxx"
 #include "miscuno.hxx"
@@ -80,6 +81,8 @@
 #include <svx/dataaccessdescriptor.hxx>
 #endif
 
+#include "sheetfilterfieldaccess.hxx"
+
 using namespace com::sun::star;
 
 SV_IMPL_PTRARR( XDBRefreshListenerArr_Impl, XDBRefreshListenerPtr );
@@ -2054,6 +2057,10 @@
         else if (aString.EqualsAscii( SC_UNONAME_CONRES ))
         {
         }
+        else if (aString.EqualsAscii("SheetFilterFieldAccess"))
+        {
+            aRet <<= uno::Reference<sheet::XSheetFilterFieldAccess>( new ScSheetFilterFieldAccess(pDocShell, this) );
+        }
 	}
 	return aRet;
 }
Index: sc/source/ui/unoobj/extfilterdescriptor.cxx
===================================================================
RCS file: sc/source/ui/unoobj/extfilterdescriptor.cxx
diff -N sc/source/ui/unoobj/extfilterdescriptor.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/unoobj/extfilterdescriptor.cxx	25 Jul 2007 03:42:07 -0000	1.1.2.1
@@ -0,0 +1,303 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: extfilterdescriptor.cxx,v $
+ *
+ *  $Revision: 1.1.2.1 $
+ *
+ *  last change: $Author: kohei $ $Date: 2007/07/25 03:42:07 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "extfilterdescriptor.hxx"
+
+#include <com/sun/star/sheet/TableFilterFieldNormal.hpp>
+#include <com/sun/star/sheet/TableFilterFieldMultiString.hpp>
+#include <com/sun/star/sheet/FilterConnection.hpp>
+#include <com/sun/star/sheet/FilterOperator.hpp>
+
+#include "document.hxx"
+#include "datauno.hxx"
+
+#include <stdio.h>
+
+using namespace ::com::sun::star;
+
+ScExtendedFilterDescriptor::ScExtendedFilterDescriptor(ScFilterDescriptorBase* pParent, ScDocument& rDoc) :
+    mpParent(pParent),
+    mrDoc(rDoc)
+{
+}
+
+ScExtendedFilterDescriptor::~ScExtendedFilterDescriptor() throw()
+{
+}
+
+void lclTranslateOperator(ScQueryEntry& rEntry, const sheet::FilterOperator eOp)
+{
+    using namespace ::com::sun::star::sheet;
+
+    switch ( eOp )
+    {
+        case FilterOperator_EMPTY:
+            rEntry.eOp = SC_EQUAL;
+            rEntry.nVal = SC_EMPTYFIELDS;
+            rEntry.bQueryByString = false;
+            *rEntry.pStr = EMPTY_STRING;
+        break;
+        case FilterOperator_NOT_EMPTY:
+            rEntry.eOp = SC_EQUAL;
+            rEntry.nVal = SC_NONEMPTYFIELDS;
+            rEntry.bQueryByString = FALSE;
+            *rEntry.pStr = EMPTY_STRING;
+        break;
+        case FilterOperator_EQUAL:
+            rEntry.eOp = SC_EQUAL;
+        break;
+        case FilterOperator_NOT_EQUAL:
+            rEntry.eOp = SC_NOT_EQUAL;
+        break;
+        case FilterOperator_GREATER:
+            rEntry.eOp = SC_GREATER;
+        break;
+        case FilterOperator_GREATER_EQUAL:
+            rEntry.eOp = SC_GREATER_EQUAL;
+        break;
+        case FilterOperator_LESS:
+            rEntry.eOp = SC_LESS;
+        break;
+        case FilterOperator_LESS_EQUAL:
+            rEntry.eOp = SC_LESS_EQUAL;
+        break;
+        case FilterOperator_TOP_VALUES:
+            rEntry.eOp = SC_TOPVAL;
+        break;
+        case FilterOperator_TOP_PERCENT:
+            rEntry.eOp = SC_TOPPERC;
+        break;
+        case FilterOperator_BOTTOM_VALUES:
+            rEntry.eOp = SC_BOTVAL;
+        break;
+        case FilterOperator_BOTTOM_PERCENT:
+            rEntry.eOp = SC_BOTPERC;
+        break;
+        default:
+            DBG_ERROR("lclTranslateOperator: unexpected enum value");
+            rEntry.eOp = SC_EQUAL;
+    }
+}
+
+void ScExtendedFilterDescriptor::addFieldNormal( const sheet::TableFilterFieldNormal& aField )
+{
+    ScQueryEntry aEntry;
+    aEntry.pStr = new String;
+    aEntry.bDoQuery = true;
+    aEntry.eConnect = (aField.Connection == sheet::FilterConnection_AND) ? SC_AND : SC_OR;
+    aEntry.nField = aField.Field;
+    aEntry.bQueryByString = !aField.IsNumeric;
+    *aEntry.pStr = String( aField.StringValue );
+    aEntry.nVal = aField.NumericValue;
+
+    if ( !aEntry.bQueryByString )
+        mrDoc.GetFormatTable()->GetInputLineString(aEntry.nVal, 0, *aEntry.pStr);
+
+    lclTranslateOperator(aEntry, aField.Operator);
+
+    maParamList.push_back(aEntry);
+}
+
+void ScExtendedFilterDescriptor::addFieldMultiString( const sheet::TableFilterFieldMultiString& aField )
+{
+    sal_Int32 nSize = aField.StringSet.getLength();
+
+    if ( !nSize )
+        return;
+
+    ScQueryEntry aEntry;
+    aEntry.pStr = new String;
+    aEntry.bDoQuery = true;
+    aEntry.eConnect = (aField.Connection == sheet::FilterConnection_AND) ? SC_AND : SC_OR;
+    aEntry.nField = aField.Field;
+    aEntry.bQueryByString = true;
+    *aEntry.pStr = String( aField.StringSet[0] );
+    aEntry.nVal = 0;
+    aEntry.eOp = SC_EQUAL;
+
+    for ( sal_Int32 i = 0; i < nSize; ++i )
+        aEntry.aStrValues.insert( aField.StringSet[i] );
+
+    maParamList.push_back(aEntry);
+}
+
+void ScExtendedFilterDescriptor::commit()
+{
+	ScQueryParam aParam;
+	mpParent->GetData(aParam);
+    size_t nSize = maParamList.size();
+    aParam.Resize(nSize);
+    ::std::list<ScQueryEntry>::const_iterator itr = maParamList.begin(), itrEnd = maParamList.end();
+    for ( size_t i = 0; i < MAXQUERY; ++i, ++itr )
+    {
+        if ( itr == itrEnd )
+            break;
+        aParam.GetEntry(i) = *itr;
+    }
+
+	SCSIZE nParamCount = aParam.GetEntryCount();
+	for ( size_t i = nSize; i < nParamCount; ++i )
+        aParam.GetEntry(i).bDoQuery = false;
+
+    mpParent->PutData(aParam);
+}
+
+//=============================================================================
+
+ScExtendedFilterIterator::ScExtendedFilterIterator(ScFilterDescriptorBase* pParent, ScDocument& rDoc) :
+    mpParent(pParent),
+    mrDoc(rDoc)
+{
+}
+
+ScExtendedFilterIterator::~ScExtendedFilterIterator() throw()
+{
+}
+
+sheet::TableFilterFieldType lclGetFilterType(const ScQueryEntry& rEntry)
+{
+    if ( rEntry.aStrValues.empty() )
+        // normal filter type
+        return sheet::TableFilterFieldType_NORMAL;
+    else
+        return sheet::TableFilterFieldType_MULTI_STRING;
+}
+
+sheet::TableFilterFieldType ScExtendedFilterIterator::getFirstType()
+{
+	mpParent->GetData(mrParam);
+    mnPos = 0;
+    const ScQueryEntry& rEntry = mrParam.GetEntry(mnPos);
+    if ( !rEntry.bDoQuery )
+        return sheet::TableFilterFieldType_NONE;
+
+    return lclGetFilterType(rEntry);
+}
+
+sheet::TableFilterFieldType ScExtendedFilterIterator::getNextType()
+{
+    if ( ++mnPos >= MAXQUERY )
+    {
+        mnPos = MAXQUERY;
+        return sheet::TableFilterFieldType_NONE;
+    }
+
+    const ScQueryEntry& rEntry = mrParam.GetEntry(mnPos);
+    if ( !rEntry.bDoQuery )
+        return sheet::TableFilterFieldType_NONE;
+
+    return lclGetFilterType(rEntry);
+}
+
+bool ScExtendedFilterIterator::getFieldNormal( sheet::TableFilterFieldNormal& rField )
+{
+    const ScQueryEntry& rEntry = mrParam.GetEntry(mnPos);
+    if ( !rEntry.bDoQuery )
+        return false;
+
+    if ( !rEntry.aStrValues.empty() )
+        return false;
+
+    rtl::OUString aStringValue;
+    if (rEntry.pStr)
+        aStringValue = *rEntry.pStr;
+
+    rField.Connection	 = (rEntry.eConnect == SC_AND) ? sheet::FilterConnection_AND :
+                                                         sheet::FilterConnection_OR;
+    rField.Field		 = rEntry.nField;
+    rField.IsNumeric	 = !rEntry.bQueryByString;
+    rField.StringValue	 = aStringValue;
+    rField.NumericValue	 = rEntry.nVal;
+
+    switch (rEntry.eOp)				// ScQueryOp
+    {
+        case SC_EQUAL:
+            {
+                rField.Operator = sheet::FilterOperator_EQUAL;
+                if (!rEntry.bQueryByString && *rEntry.pStr == EMPTY_STRING)
+                {
+                    if (rEntry.nVal == SC_EMPTYFIELDS)
+                    {
+                        rField.Operator = sheet::FilterOperator_EMPTY;
+                        rField.NumericValue = 0;
+                    }
+                    else if (rEntry.nVal == SC_NONEMPTYFIELDS)
+                    {
+                        rField.Operator = sheet::FilterOperator_NOT_EMPTY;
+                        rField.NumericValue = 0;
+                    }
+                }
+            }
+            break;
+        case SC_LESS:			rField.Operator = sheet::FilterOperator_LESS;			  break;
+        case SC_GREATER:		rField.Operator = sheet::FilterOperator_GREATER;		  break;
+        case SC_LESS_EQUAL:		rField.Operator = sheet::FilterOperator_LESS_EQUAL;	  break;
+        case SC_GREATER_EQUAL:	rField.Operator = sheet::FilterOperator_GREATER_EQUAL;  break;
+        case SC_NOT_EQUAL:		rField.Operator = sheet::FilterOperator_NOT_EQUAL;	  break;
+        case SC_TOPVAL:			rField.Operator = sheet::FilterOperator_TOP_VALUES;	  break;
+        case SC_BOTVAL:			rField.Operator = sheet::FilterOperator_BOTTOM_VALUES;  break;
+        case SC_TOPPERC:		rField.Operator = sheet::FilterOperator_TOP_PERCENT;	  break;
+        case SC_BOTPERC:		rField.Operator = sheet::FilterOperator_BOTTOM_PERCENT; break;
+        default:
+            DBG_ERROR("Falscher Filter-enum");
+            rField.Operator = sheet::FilterOperator_EMPTY;
+    }
+    return true;
+}
+
+bool ScExtendedFilterIterator::getFieldMultiString( sheet::TableFilterFieldMultiString& rField )
+{
+    const ScQueryEntry& rEntry = mrParam.GetEntry(mnPos);
+    if ( !rEntry.bDoQuery )
+        return false;
+
+    if ( rEntry.aStrValues.empty() )
+        return false;
+
+    rField.Connection	 = (rEntry.eConnect == SC_AND) ? sheet::FilterConnection_AND :
+                                                         sheet::FilterConnection_OR;
+    rField.Field		 = rEntry.nField;
+
+    size_t nSize = rEntry.aStrValues.size();
+    uno::Sequence<rtl::OUString> aList(nSize);
+    ScHashOUStringSet::const_iterator itr = rEntry.aStrValues.begin(), 
+        itrEnd = rEntry.aStrValues.end();
+
+    for ( size_t i = 0; itr != itrEnd; ++itr, ++i )
+        aList[i] = *itr;
+    rField.StringSet = aList;
+
+    return true;
+}
Index: sc/source/ui/unoobj/extfilterdescriptor.hxx
===================================================================
RCS file: sc/source/ui/unoobj/extfilterdescriptor.hxx
diff -N sc/source/ui/unoobj/extfilterdescriptor.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/unoobj/extfilterdescriptor.hxx	25 Jul 2007 03:42:07 -0000	1.1.2.1
@@ -0,0 +1,89 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: extfilterdescriptor.hxx,v $
+ *
+ *  $Revision: 1.1.2.1 $
+ *
+ *  last change: $Author: kohei $ $Date: 2007/07/25 03:42:07 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef SC_EXTFILTER_DESCRIPTOR_HXX
+#define SC_EXTFILTER_DESCRIPTOR_HXX
+
+#include "global.hxx"
+
+#include <com/sun/star/sheet/TableFilterFieldType.hpp>
+#include <list>
+
+namespace com { namespace sun { namespace star { namespace sheet {
+    class TableFilterFieldNormal;
+    class TableFilterFieldMultiString;
+}}}}
+
+class ScDocument;
+class ScFilterDescriptorBase;
+
+class ScExtendedFilterDescriptor
+{
+public:
+    ScExtendedFilterDescriptor(ScFilterDescriptorBase* pParent, ScDocument& rDoc);
+    ~ScExtendedFilterDescriptor() throw();
+
+    void addFieldNormal( const ::com::sun::star::sheet::TableFilterFieldNormal& aField );
+    void addFieldMultiString( const ::com::sun::star::sheet::TableFilterFieldMultiString& aField );
+    void commit();
+
+private:
+    ScFilterDescriptorBase* mpParent;
+    ScDocument& mrDoc;
+    ::std::list<ScQueryEntry>   maParamList;
+};
+
+//=============================================================================
+
+class ScExtendedFilterIterator
+{
+public:
+    ScExtendedFilterIterator(ScFilterDescriptorBase* pParent, ScDocument& rDoc);
+    ~ScExtendedFilterIterator() throw();
+
+    ::com::sun::star::sheet::TableFilterFieldType getFirstType();
+    ::com::sun::star::sheet::TableFilterFieldType getNextType();
+
+    bool getFieldNormal( ::com::sun::star::sheet::TableFilterFieldNormal& rField );
+    bool getFieldMultiString( ::com::sun::star::sheet::TableFilterFieldMultiString& rField );
+
+private:
+    ScFilterDescriptorBase* mpParent;
+    ScDocument& mrDoc;
+    ScQueryParam mrParam;
+    SCSIZE mnPos;
+};
+
+#endif
Index: sc/source/ui/unoobj/makefile.mk
===================================================================
RCS file: /cvs/sc/sc/source/ui/unoobj/makefile.mk,v
retrieving revision 1.18
retrieving revision 1.18.72.2
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.18 -r1.18.72.2
--- sc/source/ui/unoobj/makefile.mk	22 May 2007 20:11:40 -0000	1.18
+++ sc/source/ui/unoobj/makefile.mk	13 Aug 2007 23:48:20 -0000	1.18.72.2
@@ -97,6 +97,7 @@
         $(SLO)$/celllistsource.obj \
         $(SLO)$/warnpassword.obj \
         $(SLO)$/unoreflist.obj \
+        $(SLO)$/sheetfilterfieldaccess.obj \
         $(SLO)$/ChartRangeSelectionListener.obj
 
 SLO2FILES = \
Index: sc/source/ui/unoobj/sheetfilterfieldaccess.cxx
===================================================================
RCS file: sc/source/ui/unoobj/sheetfilterfieldaccess.cxx
diff -N sc/source/ui/unoobj/sheetfilterfieldaccess.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/unoobj/sheetfilterfieldaccess.cxx	15 Aug 2007 19:21:15 -0000	1.1.2.4
@@ -0,0 +1,432 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: sheetfilterfieldaccess.cxx,v $
+ *
+ *  $Revision: 1.1.2.4 $
+ *
+ *  last change: $Author: kohei $ $Date: 2007/08/15 19:21:15 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "sheetfilterfieldaccess.hxx"
+#include "unoguard.hxx"
+#include "docsh.hxx"
+
+#include <stdio.h>
+
+#include <com/sun/star/sheet/SheetFilterFieldValue.hpp>
+#include <com/sun/star/sheet/SheetFilterFieldMultiString.hpp>
+#include <com/sun/star/sheet/SheetFilterFieldType.hpp>
+#include <com/sun/star/sheet/SheetFilterConnection.hpp>
+#include <com/sun/star/sheet/SheetFilterOperator.hpp>
+
+using ::com::sun::star::sheet::SheetFilterFieldValue;
+using ::com::sun::star::sheet::SheetFilterFieldMultiString;
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::uno::Any;
+
+using ::rtl::OUString;
+using ::std::vector;
+
+using namespace ::com::sun::star;
+
+#define CREATE_OUSTRING( ascii )    ::rtl::OUString::intern( RTL_CONSTASCII_USTRINGPARAM( ascii ) )
+
+// ----------------------------------------------------------------------------
+
+void lclTranslateOperator(ScQueryEntry& rEntry, const sal_Int16 nOp)
+{
+    using namespace ::com::sun::star::sheet;
+
+    switch ( nOp )
+    {
+        case SheetFilterOperator::EMPTY:
+            rEntry.eOp = SC_EQUAL;
+            rEntry.nVal = SC_EMPTYFIELDS;
+            rEntry.bQueryByString = false;
+            *rEntry.pStr = EMPTY_STRING;
+        break;
+        case SheetFilterOperator::NOT_EMPTY:
+            rEntry.eOp = SC_EQUAL;
+            rEntry.nVal = SC_NONEMPTYFIELDS;
+            rEntry.bQueryByString = FALSE;
+            *rEntry.pStr = EMPTY_STRING;
+        break;
+        case SheetFilterOperator::EQUAL:
+            rEntry.eOp = SC_EQUAL;
+        break;
+        case SheetFilterOperator::NOT_EQUAL:
+            rEntry.eOp = SC_NOT_EQUAL;
+        break;
+        case SheetFilterOperator::GREATER:
+            rEntry.eOp = SC_GREATER;
+        break;
+        case SheetFilterOperator::GREATER_EQUAL:
+            rEntry.eOp = SC_GREATER_EQUAL;
+        break;
+        case SheetFilterOperator::LESS:
+            rEntry.eOp = SC_LESS;
+        break;
+        case SheetFilterOperator::LESS_EQUAL:
+            rEntry.eOp = SC_LESS_EQUAL;
+        break;
+        case SheetFilterOperator::TOP_VALUES:
+            rEntry.eOp = SC_TOPVAL;
+        break;
+        case SheetFilterOperator::TOP_PERCENT:
+            rEntry.eOp = SC_TOPPERC;
+        break;
+        case SheetFilterOperator::BOTTOM_VALUES:
+            rEntry.eOp = SC_BOTVAL;
+        break;
+        case SheetFilterOperator::BOTTOM_PERCENT:
+            rEntry.eOp = SC_BOTPERC;
+        break;
+        default:
+            DBG_ERROR("lclTranslateOperator: unexpected enum value");
+            rEntry.eOp = SC_EQUAL;
+    }
+}
+
+// ----------------------------------------------------------------------------
+
+const sal_Int32 ScSheetFilterFieldAccess::MAX_FILTER_FIELD = MAXQUERY;
+
+const uno::Type ScSheetFilterFieldAccess::VALUE = 
+    getCppuType(static_cast<sheet::SheetFilterFieldValue*>(NULL));
+const uno::Type ScSheetFilterFieldAccess::MULTI_STRING = 
+    getCppuType(static_cast<sheet::SheetFilterFieldMultiString*>(NULL));
+
+ScSheetFilterFieldAccess::ScSheetFilterFieldAccess(ScDocShell* pDocShell, ScDatabaseRangeObj* pParent) :
+    mpFilterDescriptor(new ScRangeFilterDescriptor(pDocShell, pParent)),
+    mnMaxIndex(0),
+    mpDocShell(pDocShell),
+    mpParent(pParent)
+{
+}
+
+ScSheetFilterFieldAccess::~ScSheetFilterFieldAccess()
+{
+}
+
+void SAL_CALL ScSheetFilterFieldAccess::setFields(const Sequence<Any>& aFields)
+    throw (uno::RuntimeException)
+{
+    sal_Int32 nSize = aFields.getLength();
+
+    ScQueryParam aParam;
+    mpFilterDescriptor->GetData(aParam);
+    aParam.Resize(nSize);
+
+    for (sal_Int32 i = 0; i < nSize; ++i)
+    {
+        const Any& rAny = aFields[i];
+        uno::Type eType = rAny.getValueType();
+
+		ScQueryEntry& rEntry = aParam.GetEntry(i);
+        rEntry.nField = static_cast<SCCOLROW>(i);
+        if (eType == VALUE)
+        {
+            fprintf(stdout, "ScSheetFilterFieldAccess::setFields: VALUE\n");fflush(stdout);
+            SheetFilterFieldValue aField;
+            rAny >>= aField;
+            rEntry.bDoQuery = true;
+            rEntry.eConnect = aField.Connection == sheet::SheetFilterConnection::AND ? SC_AND : SC_OR;
+            rEntry.bQueryByString = aField.IsNumeric;
+            rEntry.pStr = new String(aField.StringValue);
+            rEntry.nVal = aField.NumericValue;
+            lclTranslateOperator(rEntry, aField.Operator);
+            if (!rEntry.bQueryByString && mpDocShell)
+                mpDocShell->GetDocument()->GetFormatTable()->GetInputLineString(rEntry.nVal, 0, *rEntry.pStr);
+        }
+        else if (eType == MULTI_STRING)
+        {
+            fprintf(stdout, "ScSheetFilterFieldAccess::setFields: MULTI_STRING\n");fflush(stdout);
+            SheetFilterFieldMultiString aField;
+            rAny >>= aField;
+            rEntry.bDoQuery = true;
+            rEntry.eConnect = aField.Connection == sheet::SheetFilterConnection::AND ? SC_AND : SC_OR;
+            sal_Int32 nStrLen = aField.StringSet.getLength();
+            for (sal_Int32 j = 0; j < nStrLen; ++j)
+            {
+                fprintf(stdout, "ScSheetFilterFieldAccess::refresh: value = %s\n",
+                        OUStringToOString(aField.StringSet[j], RTL_TEXTENCODING_UTF8).getStr());fflush(stdout);
+                rEntry.aStrValues.insert(aField.StringSet[j]);
+            }
+        }
+    }
+
+	SCSIZE nParamCount = aParam.GetEntryCount();
+	for (SCSIZE i = nSize; i < nParamCount; ++i)
+        aParam.GetEntry(i).bDoQuery = false;
+
+    mpFilterDescriptor->PutData(aParam);
+}
+
+Sequence<Any> SAL_CALL ScSheetFilterFieldAccess::getFields()
+    throw (uno::RuntimeException)
+{
+	ScUnoGuard aGuard;
+	ScQueryParam aParam;
+	mpFilterDescriptor->GetData(aParam);
+
+	SCSIZE nEntries = aParam.GetEntryCount();	// allozierte Eintraege im Param
+	SCSIZE nCount = 0;							// aktive
+
+	while (nCount < nEntries && aParam.GetEntry(nCount).bDoQuery)
+		++nCount;
+
+	Sequence<Any> aSeq(static_cast<sal_Int32>(nCount));
+	Any* pAny = aSeq.getArray();
+    Any any;
+	for (SCSIZE i = 0; i < nCount; ++i)
+	{
+		const ScQueryEntry& rEntry = aParam.GetEntry(i);
+        if ( !rEntry.aStrValues.empty() )
+        {
+            // This is a multi-string filter.
+            SheetFilterFieldMultiString aField;
+            aField.Field = rEntry.nField;
+            aField.Connection = (rEntry.eConnect == SC_AND) ? 
+                sheet::SheetFilterConnection::AND : sheet::SheetFilterConnection::OR;
+
+            size_t nSize = rEntry.aStrValues.size();
+            Sequence<OUString> aList(nSize);
+            ScHashOUStringSet::const_iterator itr = rEntry.aStrValues.begin(), 
+                itrEnd = rEntry.aStrValues.end();
+
+            for (size_t j = 0; itr != itrEnd; ++itr, ++j)
+                aList[j] = *itr;
+
+            aField.StringSet = aList;
+            any <<= aField;
+        }
+        else
+        {
+            SheetFilterFieldValue aField;
+            OUString aStringValue;
+            if (rEntry.pStr)
+                aStringValue = *rEntry.pStr;
+
+            aField.Field = rEntry.nField;
+            aField.Connection = (rEntry.eConnect == SC_AND) ? 
+                sheet::SheetFilterConnection::AND : sheet::SheetFilterConnection::OR;
+            aField.IsNumeric	 = !rEntry.bQueryByString;
+            aField.StringValue	 = aStringValue;
+            aField.NumericValue	 = rEntry.nVal;
+
+            switch (rEntry.eOp)				// ScQueryOp
+            {
+                case SC_EQUAL:
+                {
+                    aField.Operator = sheet::SheetFilterOperator::EQUAL;
+                    if (!rEntry.bQueryByString && *rEntry.pStr == EMPTY_STRING)
+                    {
+                        if (rEntry.nVal == SC_EMPTYFIELDS)
+                        {
+                            aField.Operator = sheet::SheetFilterOperator::EMPTY;
+                            aField.NumericValue = 0;
+                        }
+                        else if (rEntry.nVal == SC_NONEMPTYFIELDS)
+                        {
+                            aField.Operator = sheet::SheetFilterOperator::NOT_EMPTY;
+                            aField.NumericValue = 0;
+                        }
+                    }
+                }
+                break;
+                case SC_LESS:			aField.Operator = sheet::SheetFilterOperator::LESS;			  break;
+                case SC_GREATER:		aField.Operator = sheet::SheetFilterOperator::GREATER;		  break;
+                case SC_LESS_EQUAL:		aField.Operator = sheet::SheetFilterOperator::LESS_EQUAL;	  break;
+                case SC_GREATER_EQUAL:	aField.Operator = sheet::SheetFilterOperator::GREATER_EQUAL;  break;
+                case SC_NOT_EQUAL:		aField.Operator = sheet::SheetFilterOperator::NOT_EQUAL;	  break;
+                case SC_TOPVAL:			aField.Operator = sheet::SheetFilterOperator::TOP_VALUES;	  break;
+                case SC_BOTVAL:			aField.Operator = sheet::SheetFilterOperator::BOTTOM_VALUES;  break;
+                case SC_TOPPERC:		aField.Operator = sheet::SheetFilterOperator::TOP_PERCENT;	  break;
+                case SC_BOTPERC:		aField.Operator = sheet::SheetFilterOperator::BOTTOM_PERCENT; break;
+                default:
+                    DBG_ERROR("Falscher Filter-enum");
+                    aField.Operator = sheet::FilterOperator_EMPTY;
+            }
+            any <<= aField;
+        }
+        pAny[i] = any;
+	}
+	return aSeq;
+}
+
+#if 0
+void SAL_CALL ScSheetFilterFieldAccess::setField(sal_Int32 nIndex, const uno::Any& aAnyField) 
+    throw (uno::RuntimeException)
+{
+    if (nIndex >= MAX_FILTER_FIELD)
+        // TODO: throw an exception.
+        return;
+
+    ScSheetFilterFieldItem& rField = maFieldList[nIndex];
+
+    uno::Type eType = aAnyField.getValueType();
+    if (eType == VALUE)
+    {
+        fprintf(stdout, "ScSheetFilterFieldAccess::setField: Value\n");fflush(stdout);
+        rField.mpField.reset(new SheetFilterFieldValue);
+        SheetFilterFieldValue* p = rField.getFieldValue();
+        aAnyField >>= *p;
+        rField.mnType = sheet::SheetFilterFieldType::VALUE;
+        if (nIndex > mnMaxIndex)
+            mnMaxIndex = nIndex;
+    }
+    else if (eType == MULTI_STRING)
+    {
+        fprintf(stdout, "ScSheetFilterFieldAccess::setField: Multistring\n");fflush(stdout);
+        rField.mpField.reset(new SheetFilterFieldMultiString);
+        SheetFilterFieldMultiString* p = rField.getFieldMultiString();
+        aAnyField >>= *p;
+        rField.mnType = sheet::SheetFilterFieldType::MULTI_STRING;
+        if (nIndex > mnMaxIndex)
+            mnMaxIndex = nIndex;
+    }
+    else
+    {
+        fprintf(stdout, "ScSheetFilterFieldAccess::setField: unknown field type\n");fflush(stdout);
+    }
+}
+
+uno::Any SAL_CALL ScSheetFilterFieldAccess::getField(sal_Int32 nIndex) 
+    throw (uno::RuntimeException)
+{
+    fprintf(stdout, "ScSheetFilterFieldAccess::getField: \n");fflush(stdout);
+    uno::Any any;
+    if (nIndex >= MAX_FILTER_FIELD)
+        // TODO: throw an exception.
+        return any;
+
+    return any;
+}
+
+sal_Int32 SAL_CALL ScSheetFilterFieldAccess::getMaxFieldCount()
+    throw (uno::RuntimeException)
+{
+    return MAX_FILTER_FIELD;
+}
+
+void SAL_CALL ScSheetFilterFieldAccess::refresh() 
+    throw (uno::RuntimeException)
+{
+    fprintf(stdout, "ScSheetFilterFieldAccess::refresh: max index = %ld\n",mnMaxIndex);fflush(stdout);
+    ScQueryParam aParam;
+    mpFilterDescriptor->GetData(aParam);
+    aParam.Resize(mnMaxIndex+1);
+
+    for (sal_Int32 i = 0; i < mnMaxIndex+1; ++i)
+    {
+        ScSheetFilterFieldItem& rItem = maFieldList[i];
+		ScQueryEntry& rEntry = aParam.GetEntry(i);
+        rEntry.bDoQuery = !(rItem.mnType == sheet::SheetFilterFieldType::NONE);
+        if (!rEntry.bDoQuery)
+            continue;
+
+        rEntry.eConnect = rItem.mpField->Connection == sheet::SheetFilterConnection::AND ? SC_AND : SC_OR;
+        rEntry.nField = static_cast<SCCOLROW>(i);
+        switch (rItem.mnType)
+        {
+            case sheet::SheetFilterFieldType::VALUE:
+            {
+                fprintf(stdout, "ScSheetFilterFieldAccess::refresh: VALUE\n");fflush(stdout);
+                sheet::SheetFilterFieldValue* p = rItem.getFieldValue();
+                rEntry.bQueryByString = !p->IsNumeric;
+                rEntry.pStr = new String(p->StringValue);
+                rEntry.nVal = p->NumericValue;
+                lclTranslateOperator(rEntry, p->Operator);
+                if (!rEntry.bQueryByString && mpDocShell)
+                    mpDocShell->GetDocument()->GetFormatTable()->GetInputLineString(rEntry.nVal, 0, *rEntry.pStr);
+            }
+            break;
+            case sheet::SheetFilterFieldType::MULTI_STRING:
+            {
+                fprintf(stdout, "ScSheetFilterFieldAccess::refresh: MULTI_STRING\n");fflush(stdout);
+                rEntry.bQueryByString = true;
+                rEntry.pStr = new String(CREATE_OUSTRING("MULTISTRING"));
+                rEntry.eOp = SC_EQUAL;
+                sheet::SheetFilterFieldMultiString* p = rItem.getFieldMultiString();
+                sal_Int32 nSize = p->StringSet.getLength();
+                for (sal_Int32 j = 0; j < nSize; ++j)
+                {
+                    fprintf(stdout, "ScSheetFilterFieldAccess::refresh: value = %s\n",
+                            OUStringToOString(p->StringSet[j], RTL_TEXTENCODING_UTF8).getStr());fflush(stdout);
+                    rEntry.aStrValues.insert(p->StringSet[j]);
+                }
+            }
+            break;
+            case sheet::SheetFilterFieldType::NONE:
+            default:
+            break;
+        }
+    }
+
+	SCSIZE nParamCount = aParam.GetEntryCount();
+	for (SCSIZE i = mnMaxIndex+1; i < nParamCount; ++i)
+        aParam.GetEntry(i).bDoQuery = false;
+
+    mpFilterDescriptor->PutData(aParam);
+}
+#endif
+
+uno::Reference<beans::XPropertySetInfo> SAL_CALL ScSheetFilterFieldAccess::getPropertySetInfo()
+														throw(uno::RuntimeException)
+{
+    return mpFilterDescriptor->getPropertySetInfo();
+}
+
+void SAL_CALL ScSheetFilterFieldAccess::setPropertyValue(
+						const rtl::OUString& aPropertyName, const uno::Any& aValue )
+				throw(beans::UnknownPropertyException, beans::PropertyVetoException,
+						lang::IllegalArgumentException, lang::WrappedTargetException,
+						uno::RuntimeException)
+{
+    fprintf(stdout, "ScSheetFilterFieldAccess::setPropertyValue: name = %s\n",
+            OUStringToOString(aPropertyName, RTL_TEXTENCODING_UTF8).getStr());fflush(stdout);
+
+    mpFilterDescriptor->setPropertyValue(aPropertyName, aValue);
+}
+
+uno::Any SAL_CALL ScSheetFilterFieldAccess::getPropertyValue( const rtl::OUString& aPropertyName )
+				throw(beans::UnknownPropertyException, lang::WrappedTargetException,
+						uno::RuntimeException)
+{
+    fprintf(stdout, "ScSheetFilterFieldAccess::getPropertyValue: name = %s\n",
+            OUStringToOString(aPropertyName, RTL_TEXTENCODING_UTF8).getStr());fflush(stdout);
+
+    return mpFilterDescriptor->getPropertyValue(aPropertyName);
+}
+
+SC_IMPL_DUMMY_PROPERTY_LISTENER( ScSheetFilterFieldAccess )
+
+SC_SIMPLE_SERVICE_INFO(ScSheetFilterFieldAccess, "ScSheetFilterFieldAccess",
+                       "com.sun.star.sheet.SheetFilterFieldAccess")
+
Index: sc/source/ui/unoobj/sheetfilterfieldaccess.hxx
===================================================================
RCS file: sc/source/ui/unoobj/sheetfilterfieldaccess.hxx
diff -N sc/source/ui/unoobj/sheetfilterfieldaccess.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/unoobj/sheetfilterfieldaccess.hxx	15 Aug 2007 19:21:15 -0000	1.1.2.4
@@ -0,0 +1,151 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: sheetfilterfieldaccess.hxx,v $
+ *
+ *  $Revision: 1.1.2.4 $
+ *
+ *  last change: $Author: kohei $ $Date: 2007/08/15 19:21:15 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef SC_SHEET_FILTER_FIELD_ACCESS_HXX
+#define SC_SHEET_FILTER_FIELD_ACCESS_HXX
+
+#include "global.hxx"
+#include "filterglobal.hxx"
+#include "miscuno.hxx"
+#include "datauno.hxx"
+
+#include "cppuhelper/implbase3.hxx"
+#include "svtools/itemprop.hxx"
+
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/beans/XPropertySetInfo.hpp>
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#include <com/sun/star/sheet/XSheetFilterFieldAccess.hpp>
+#include <com/sun/star/sheet/SheetFilterField.hpp>
+
+#include <memory>
+#include <boost/shared_ptr.hpp>
+#include <vector>
+
+class ScDocShell;
+
+class ScSheetFilterFieldAccess : public cppu::WeakImplHelper3<
+                            ::com::sun::star::sheet::XSheetFilterFieldAccess, 
+                            ::com::sun::star::beans::XPropertySet,
+                            ::com::sun::star::lang::XServiceInfo >
+{
+    typedef ::boost::shared_ptr< ::com::sun::star::sheet::SheetFilterField > SheetFilterFieldRef;
+
+    static const sal_Int32 MAX_FILTER_FIELD;
+    static const ::com::sun::star::uno::Type VALUE;
+    static const ::com::sun::star::uno::Type MULTI_STRING;
+
+public:
+    ScSheetFilterFieldAccess(ScDocShell* pDocShell, ScDatabaseRangeObj* pParent);
+    ~ScSheetFilterFieldAccess();
+
+    // XSheetFilterFieldAccess
+    virtual void SAL_CALL setFields(const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aFields)
+        throw (::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any > SAL_CALL getFields()
+        throw (::com::sun::star::uno::RuntimeException);
+        
+#if 0
+    virtual void SAL_CALL setField(sal_Int32 nIndex, const ::com::sun::star::uno::Any& aAnyField) 
+        throw (::com::sun::star::uno::RuntimeException);
+
+    virtual ::com::sun::star::uno::Any SAL_CALL getField(sal_Int32 nIndex) 
+        throw (::com::sun::star::uno::RuntimeException);
+
+    virtual sal_Int32 SAL_CALL getMaxFieldCount()
+        throw (::com::sun::star::uno::RuntimeException);
+
+    virtual void SAL_CALL refresh() 
+        throw (::com::sun::star::uno::RuntimeException);
+#endif
+
+	// XPropertySet
+	virtual ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySetInfo >
+							SAL_CALL getPropertySetInfo()
+								throw(::com::sun::star::uno::RuntimeException);
+	virtual void SAL_CALL	setPropertyValue( const ::rtl::OUString& aPropertyName,
+									const ::com::sun::star::uno::Any& aValue )
+								throw(::com::sun::star::beans::UnknownPropertyException,
+									::com::sun::star::beans::PropertyVetoException,
+									::com::sun::star::lang::IllegalArgumentException,
+									::com::sun::star::lang::WrappedTargetException,
+									::com::sun::star::uno::RuntimeException);
+	virtual ::com::sun::star::uno::Any SAL_CALL getPropertyValue(
+									const ::rtl::OUString& PropertyName )
+								throw(::com::sun::star::beans::UnknownPropertyException,
+									::com::sun::star::lang::WrappedTargetException,
+									::com::sun::star::uno::RuntimeException);
+	virtual void SAL_CALL	addPropertyChangeListener( const ::rtl::OUString& aPropertyName,
+									const ::com::sun::star::uno::Reference<
+										::com::sun::star::beans::XPropertyChangeListener >& xListener )
+								throw(::com::sun::star::beans::UnknownPropertyException,
+									::com::sun::star::lang::WrappedTargetException,
+									::com::sun::star::uno::RuntimeException);
+	virtual void SAL_CALL	removePropertyChangeListener( const ::rtl::OUString& aPropertyName,
+									const ::com::sun::star::uno::Reference<
+										::com::sun::star::beans::XPropertyChangeListener >& aListener )
+								throw(::com::sun::star::beans::UnknownPropertyException,
+									::com::sun::star::lang::WrappedTargetException,
+									::com::sun::star::uno::RuntimeException);
+	virtual void SAL_CALL	addVetoableChangeListener( const ::rtl::OUString& PropertyName,
+									const ::com::sun::star::uno::Reference<
+										::com::sun::star::beans::XVetoableChangeListener >& aListener )
+								throw(::com::sun::star::beans::UnknownPropertyException,
+									::com::sun::star::lang::WrappedTargetException,
+									::com::sun::star::uno::RuntimeException);
+	virtual void SAL_CALL	removeVetoableChangeListener( const ::rtl::OUString& PropertyName,
+									const ::com::sun::star::uno::Reference<
+										::com::sun::star::beans::XVetoableChangeListener >& aListener )
+								throw(::com::sun::star::beans::UnknownPropertyException,
+									::com::sun::star::lang::WrappedTargetException,
+									::com::sun::star::uno::RuntimeException);
+
+    // XServiceInfo
+    virtual ::rtl::OUString SAL_CALL getImplementationName()
+                                throw(::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsService( const ::rtl::OUString& ServiceName )
+                                throw(::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames()
+                                throw(::com::sun::star::uno::RuntimeException);
+
+private:
+    ::std::auto_ptr<ScRangeFilterDescriptor>    mpFilterDescriptor;
+    sal_Int32 mnMaxIndex;
+
+    ScDocShell* mpDocShell;
+    ScDatabaseRangeObj* mpParent;
+};
+
+#endif
Index: sc/source/ui/view/gridwin.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/view/gridwin.cxx,v
retrieving revision 1.85
retrieving revision 1.82.14.2
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.85 -r1.82.14.2
--- sc/source/ui/view/gridwin.cxx	27 Sep 2007 13:56:11 -0000	1.85
+++ sc/source/ui/view/gridwin.cxx	1 Oct 2007 15:29:14 -0000	1.82.14.2
@@ -1127,6 +1127,10 @@
 		ScQueryParam aParam;
 		pDBData->GetQueryParam( aParam );		// kann nur MAXQUERY Eintraege ergeben
 
+        // Disable multi-string match flag until we implement it in the UI.
+        for (SCSIZE i = 0; i < MAXQUERY; ++i)
+            aParam.GetEntry(i).aStrValues.clear();
+
 		if (SC_AUTOFILTER_CUSTOM == nSel)
 		{
 			pViewData->GetView()->SetCursor(nCol,nRow);		//! auch ueber Slot ??
