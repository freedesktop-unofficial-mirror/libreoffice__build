A hackweek project - doing XCanvas API natively in OpenGL

From: Thorsten Behrens <thb@openoffice.org>


---

 canvas/prj/build.lst                               |    1 
 canvas/prj/d.lst                                   |    2 
 canvas/source/cairo/cairo_canvashelper.hxx         |    1 
 canvas/source/directx/dx_bitmapcanvashelper.hxx    |    1 
 canvas/source/null/null_canvashelper.hxx           |    1 
 canvas/source/opengl/exports.dxp                   |    3 
 canvas/source/opengl/exports.map                   |    8 
 canvas/source/opengl/makefile.mk                   |   65 ++
 canvas/source/opengl/ogl_bitmapcanvashelper.cxx    |  108 +++
 canvas/source/opengl/ogl_bitmapcanvashelper.hxx    |  107 ++
 canvas/source/opengl/ogl_canvasbitmap.cxx          |   63 +
 canvas/source/opengl/ogl_canvasbitmap.hxx          |   82 ++
 canvas/source/opengl/ogl_canvascustomsprite.cxx    |  154 ++++
 canvas/source/opengl/ogl_canvascustomsprite.hxx    |  101 ++
 canvas/source/opengl/ogl_canvasfont.cxx            |   88 ++
 canvas/source/opengl/ogl_canvasfont.hxx            |   72 ++
 canvas/source/opengl/ogl_canvashelper.cxx          |  860 ++++++++++++++++++++
 canvas/source/opengl/ogl_canvashelper.hxx          |  237 ++++++
 canvas/source/opengl/ogl_spritecanvas.cxx          |  202 +++++
 canvas/source/opengl/ogl_spritecanvas.hxx          |  126 +++
 canvas/source/opengl/ogl_spritedevicehelper.cxx    |  658 +++++++++++++++
 canvas/source/opengl/ogl_spritedevicehelper.hxx    |  134 +++
 canvas/source/opengl/ogl_textlayout.cxx            |  222 +++++
 canvas/source/opengl/ogl_textlayout.hxx            |   83 ++
 canvas/source/opengl/ogl_tools.hxx                 |   35 +
 canvas/source/tools/canvastools.cxx                |   10 
 canvas/source/vcl/canvashelper.hxx                 |    1 
 cppcanvas/inc/cppcanvas/spritecanvas.hxx           |    4 
 cppcanvas/source/wrapper/implspritecanvas.cxx      |    4 
 cppcanvas/source/wrapper/implspritecanvas.hxx      |    4 
 .../com/sun/star/presentation/XSlideShowView.idl   |   10 
 offapi/com/sun/star/rendering/XSpriteCanvas.idl    |   13 
 .../registry/data/org/openoffice/Office/Canvas.xcu |    1 
 scp2/source/canvas/makefile.mk                     |    1 
 scp2/source/canvas/openglcanvas.scp                |   28 +
 scp2/util/makefile.mk                              |    4 
 sd/source/ui/slideshow/slideshowviewimpl.cxx       |   13 
 sd/source/ui/slideshow/slideshowviewimpl.hxx       |    1 
 sdext/source/presenter/PresenterSlideShowView.cxx  |   48 +
 sdext/source/presenter/PresenterSlideShowView.hxx  |    7 
 slideshow/source/engine/waitsymbol.cxx             |   13 
 41 files changed, 3526 insertions(+), 50 deletions(-)
 create mode 100644 canvas/source/opengl/exports.dxp
 create mode 100644 canvas/source/opengl/exports.map
 create mode 100644 canvas/source/opengl/makefile.mk
 create mode 100644 canvas/source/opengl/ogl_bitmapcanvashelper.cxx
 create mode 100644 canvas/source/opengl/ogl_bitmapcanvashelper.hxx
 create mode 100644 canvas/source/opengl/ogl_canvasbitmap.cxx
 create mode 100644 canvas/source/opengl/ogl_canvasbitmap.hxx
 create mode 100644 canvas/source/opengl/ogl_canvascustomsprite.cxx
 create mode 100644 canvas/source/opengl/ogl_canvascustomsprite.hxx
 create mode 100644 canvas/source/opengl/ogl_canvasfont.cxx
 create mode 100644 canvas/source/opengl/ogl_canvasfont.hxx
 create mode 100644 canvas/source/opengl/ogl_canvashelper.cxx
 create mode 100644 canvas/source/opengl/ogl_canvashelper.hxx
 create mode 100644 canvas/source/opengl/ogl_spritecanvas.cxx
 create mode 100644 canvas/source/opengl/ogl_spritecanvas.hxx
 create mode 100644 canvas/source/opengl/ogl_spritedevicehelper.cxx
 create mode 100644 canvas/source/opengl/ogl_spritedevicehelper.hxx
 create mode 100644 canvas/source/opengl/ogl_textlayout.cxx
 create mode 100644 canvas/source/opengl/ogl_textlayout.hxx
 create mode 100644 canvas/source/opengl/ogl_tools.hxx
 create mode 100644 scp2/source/canvas/openglcanvas.scp


diff --git canvas/prj/build.lst canvas/prj/build.lst
index df1f8e9..3f94041 100644
--- canvas/prj/build.lst
+++ canvas/prj/build.lst
@@ -6,6 +6,7 @@ cv	canvas\source\vcl								 nmake	-	all	cv_vcl cv_tools cv_inc NULL
 cv	canvas\source\simplecanvas						 nmake	-	all	cv_simplecanvas cv_tools cv_inc NULL
 cv	canvas\source\cairo								 nmake	-	all	cv_cairo cv_tools cv_inc NULL
 cv	canvas\source\directx							 nmake	-	w	cv_directx cv_tools cv_inc NULL
+cv	canvas\source\opengl							 nmake	-	all	cv_opengl cv_tools cv_inc NULL
 cv	canvas\source\null								 nmake	-	all	cv_null cv_tools cv_inc NULL
 cv	canvas\source\java								 nmake	-	all cv_java cv_inc NULL
 cv	canvas\source\factory							 nmake	-	all cv_factory cv_inc NULL
diff --git canvas/prj/d.lst canvas/prj/d.lst
index 986253a..dbffabf 100644
--- canvas/prj/d.lst
+++ canvas/prj/d.lst
@@ -1,5 +1,6 @@
 ..\%__SRC%\bin\canvasto*.dll %_DEST%\bin%_EXT%\canvasto*.dll
 ..\%__SRC%\bin\cairocan*.dll %_DEST%\bin%_EXT%\cairocan*.dll
+..\%__SRC%\bin\oglcanvas*.dll %_DEST%\bin%_EXT%\oglcanvas*.dll
 ..\%__SRC%\bin\directx*.dll  %_DEST%\bin%_EXT%\directx*.dll
 ..\%__SRC%\bin\gdiplus*.dll  %_DEST%\bin%_EXT%\gdiplus*.dll
 ..\%__SRC%\bin\vclcanva*.dll %_DEST%\bin%_EXT%\vclcanva*.dll
@@ -9,6 +10,7 @@
 ..\%__SRC%\lib\icanvastools.lib %_DEST%\lib%_EXT%\icanvastools.lib
 ..\%__SRC%\lib\libcanvastools*.so %_DEST%\lib%_EXT%\
 ..\%__SRC%\lib\cairocanvas.uno.so %_DEST%\lib%_EXT%\cairocanvas.uno.so
+..\%__SRC%\lib\oglcanvas.uno.so %_DEST%\lib%_EXT%\oglcanvas.uno.so
 ..\%__SRC%\lib\vclcanvas.uno.so %_DEST%\lib%_EXT%\vclcanvas.uno.so
 ..\%__SRC%\lib\nullcanvas.uno.so %_DEST%\lib%_EXT%\nullcanvas.uno.so
 ..\%__SRC%\lib\simplecanvas.uno.so %_DEST%\lib%_EXT%\simplecanvas.uno.so
diff --git canvas/source/cairo/cairo_canvashelper.hxx canvas/source/cairo/cairo_canvashelper.hxx
index 3bbcf6c..a1f6a12 100644
--- canvas/source/cairo/cairo_canvashelper.hxx
+++ canvas/source/cairo/cairo_canvashelper.hxx
@@ -32,6 +32,7 @@
 #define _CAIROCANVAS_CANVASHELPER_HXX_
 
 #include <com/sun/star/rendering/XCanvas.hpp>
+#include <com/sun/star/rendering/XBitmapCanvas.hpp>
 #include <com/sun/star/rendering/XIntegerBitmap.hpp>
 
 #include <basegfx/vector/b2isize.hxx>
diff --git canvas/source/directx/dx_bitmapcanvashelper.hxx canvas/source/directx/dx_bitmapcanvashelper.hxx
index 0d9c0b7..cd47368 100755
--- canvas/source/directx/dx_bitmapcanvashelper.hxx
+++ canvas/source/directx/dx_bitmapcanvashelper.hxx
@@ -32,6 +32,7 @@
 #define _DXCANVAS_BITMAPCANVASHELPER_HXX_
 
 #include <com/sun/star/rendering/XCanvas.hpp>
+#include <com/sun/star/rendering/XBitmapCanvas.hpp>
 
 #include <basegfx/vector/b2isize.hxx>
 #include <basegfx/vector/b2dsize.hxx>
diff --git canvas/source/null/null_canvashelper.hxx canvas/source/null/null_canvashelper.hxx
index 30c8ab6..5923814 100644
--- canvas/source/null/null_canvashelper.hxx
+++ canvas/source/null/null_canvashelper.hxx
@@ -32,6 +32,7 @@
 #define _NULLCANVAS_CANVASHELPER_HXX_
 
 #include <com/sun/star/rendering/XCanvas.hpp>
+#include <com/sun/star/rendering/XBitmapCanvas.hpp>
 #include <com/sun/star/rendering/XIntegerBitmap.hpp>
 
 #include <basegfx/vector/b2isize.hxx>
diff --git canvas/source/opengl/exports.dxp canvas/source/opengl/exports.dxp
new file mode 100644
index 0000000..9630d7e
--- /dev/null
+++ canvas/source/opengl/exports.dxp
@@ -0,0 +1,3 @@
+component_getImplementationEnvironment
+component_writeInfo
+component_getFactory
diff --git canvas/source/opengl/exports.map canvas/source/opengl/exports.map
new file mode 100644
index 0000000..ff8f9ed
--- /dev/null
+++ canvas/source/opengl/exports.map
@@ -0,0 +1,8 @@
+CAN_1_0 {
+	global:
+		component_getImplementationEnvironment;
+		component_writeInfo;
+		component_getFactory;
+	local:
+		*;
+};
diff --git canvas/source/opengl/makefile.mk canvas/source/opengl/makefile.mk
new file mode 100644
index 0000000..59973e6
--- /dev/null
+++ canvas/source/opengl/makefile.mk
@@ -0,0 +1,65 @@
+#*************************************************************************
+#
+#    OpenOffice.org - a multi-platform office productivity suite
+#
+#    Author:
+#      Thorsten Behrens <tbehrens@novell.com>	   	
+#
+#      Copyright (C) 2008, Novell Inc.
+#      Parts copyright 2005 by Sun Microsystems, Inc.
+#
+#   The Contents of this file are made available subject to
+#   the terms of GNU Lesser General Public License Version 2.1.
+#
+#*************************************************************************
+
+PRJ=..$/..
+
+PRJNAME=canvas
+TARGET=oglcanvas
+ENABLE_EXCEPTIONS=TRUE
+
+# --- Settings -----------------------------------------------------------
+
+.INCLUDE :	settings.mk
+DLLPRE =
+
+# --- Common ----------------------------------------------------------
+
+.IF "$(verbose)"!="" || "$(VERBOSE)"!=""
+CDEFS+= -DVERBOSE
+.ENDIF
+
+SLOFILES =	$(SLO)$/ogl_spritecanvas.obj \
+			$(SLO)$/ogl_spritedevicehelper.obj \
+			$(SLO)$/ogl_canvashelper.obj \
+			$(SLO)$/ogl_canvasfont.obj \
+			$(SLO)$/ogl_canvasbitmap.obj \
+			$(SLO)$/ogl_bitmapcanvashelper.obj \
+			$(SLO)$/ogl_canvascustomsprite.obj \
+			$(SLO)$/ogl_textlayout.obj
+
+
+SHL1TARGET=$(TARGET).uno
+SHL1STDLIBS= $(VCLLIB) $(TOOLSLIB) $(TKLIB) $(CPPULIB) $(SALLIB) $(COMPHELPERLIB) $(CPPUHELPERLIB) $(BASEGFXLIB) $(CANVASTOOLSLIB)
+
+.IF "$(GUI)"=="UNX"
+	SHL1STDLIBS += -lGL -lGLU -lX11
+.ELIF "$(GUI)"=="WNT"
+	SHL1STDLIBS += opengl32.lib glu32.lib gdi32.lib
+.ELSE
+	.ERROR "Add your system OpenGL libs here"
+.ENDIF
+
+SHL1IMPLIB=i$(TARGET)
+SHL1LIBS=$(SLB)$/$(TARGET).lib
+SHL1DEF=$(MISC)$/$(SHL1TARGET).def
+
+SHL1VERSIONMAP=exports.map
+
+DEF1NAME=$(SHL1TARGET)
+DEF1EXPORTFILE=exports.dxp
+
+# ==========================================================================
+
+.INCLUDE :	target.mk
diff --git canvas/source/opengl/ogl_bitmapcanvashelper.cxx canvas/source/opengl/ogl_bitmapcanvashelper.cxx
new file mode 100644
index 0000000..e3f516e
--- /dev/null
+++ canvas/source/opengl/ogl_bitmapcanvashelper.cxx
@@ -0,0 +1,108 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_canvas.hxx"
+
+#include "ogl_bitmapcanvashelper.hxx"
+
+#include <canvas/debug.hxx>
+#include <canvas/canvastools.hxx>
+#include <tools/diagnose_ex.h>
+
+
+using namespace ::com::sun::star;
+
+namespace oglcanvas
+{
+    BitmapCanvasHelper::BitmapCanvasHelper()
+    {}
+
+    void BitmapCanvasHelper::disposing()
+    {
+        CanvasHelper::disposing();
+    }
+
+    void BitmapCanvasHelper::init( rendering::XGraphicDevice&     rDevice,
+                                   SpriteDeviceHelper&            rDeviceHelper,
+                                   const geometry::IntegerSize2D& rSize )
+    {
+        maSize = rSize;
+        CanvasHelper::init(rDevice,rDeviceHelper);
+    }
+
+    void BitmapCanvasHelper::copyRect( const rendering::XCanvas*                            /*pCanvas*/, 
+                                       const uno::Reference< rendering::XBitmapCanvas >&    /*sourceCanvas*/, 
+                                       const geometry::RealRectangle2D&                     /*sourceRect*/, 
+                                       const rendering::ViewState&                          /*sourceViewState*/, 
+                                       const rendering::RenderState&                        /*sourceRenderState*/, 
+                                       const geometry::RealRectangle2D&                     /*destRect*/, 
+                                       const rendering::ViewState&                          /*destViewState*/, 
+                                       const rendering::RenderState&                        /*destRenderState*/ )
+    {
+        // TODO(F2): copyRect NYI
+    }
+
+    geometry::IntegerSize2D BitmapCanvasHelper::getSize()
+    {
+        return maSize;
+    }
+
+    uno::Reference< rendering::XBitmap > BitmapCanvasHelper::getScaledBitmap( const geometry::RealSize2D& /*newSize*/, 
+                                                                              sal_Bool                    /*beFast*/ )
+    {
+        // TODO(F1):
+        return uno::Reference< rendering::XBitmap >();
+    }
+
+    uno::Sequence< sal_Int8 > BitmapCanvasHelper::getData( rendering::IntegerBitmapLayout&     /*bitmapLayout*/, 
+                                                           const geometry::IntegerRectangle2D& /*rect*/ )
+    {
+        // TODO(F2): NYI - and improbable to ever be
+        return uno::Sequence< sal_Int8 >();
+    }
+
+    void BitmapCanvasHelper::setData( const uno::Sequence< sal_Int8 >&      /*data*/, 
+                                      const rendering::IntegerBitmapLayout& /*bitmapLayout*/, 
+                                      const geometry::IntegerRectangle2D&   /*rect*/ )
+    {
+        // TODO(F2): NYI - and improbable to ever be
+    }
+
+    void BitmapCanvasHelper::setPixel( const uno::Sequence< sal_Int8 >&       /*color*/, 
+                                       const rendering::IntegerBitmapLayout&  /*bitmapLayout*/, 
+                                       const geometry::IntegerPoint2D&        /*pos*/ )
+    {
+        // TODO(F2): NYI - and improbable to ever be
+    }
+
+    uno::Sequence< sal_Int8 > BitmapCanvasHelper::getPixel( rendering::IntegerBitmapLayout&   /*bitmapLayout*/, 
+                                                            const geometry::IntegerPoint2D&   /*pos*/ )
+    {
+        // TODO(F2): NYI - and improbable to ever be
+        return uno::Sequence< sal_Int8 >();
+    }
+
+    rendering::IntegerBitmapLayout BitmapCanvasHelper::getMemoryLayout()
+    {
+        return ::canvas::tools::getStdMemoryLayout(getSize());
+    }
+
+    bool BitmapCanvasHelper::hasAlpha() const
+    {
+        return true;
+    }
+
+}
diff --git canvas/source/opengl/ogl_bitmapcanvashelper.hxx canvas/source/opengl/ogl_bitmapcanvashelper.hxx
new file mode 100644
index 0000000..2d2faeb
--- /dev/null
+++ canvas/source/opengl/ogl_bitmapcanvashelper.hxx
@@ -0,0 +1,107 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+#ifndef OGL_BITMAPCANVASHELPER_HXX_
+#define OGL_BITMAPCANVASHELPER_HXX_
+
+#include <com/sun/star/rendering/XBitmapCanvas.hpp>
+#include <com/sun/star/rendering/XIntegerBitmap.hpp>
+
+#include <basegfx/vector/b2isize.hxx>
+#include <basegfx/vector/b2dsize.hxx>
+
+#include <boost/utility.hpp>
+#include <boost/shared_ptr.hpp>
+#include <vector>
+
+#include "ogl_canvashelper.hxx"
+
+
+namespace oglcanvas
+{
+    /** Helper class for basic canvas functionality. */
+    class BitmapCanvasHelper : public CanvasHelper
+    {
+    public:
+        BitmapCanvasHelper();
+
+        /// Release all references
+        void disposing();
+
+        /** Initialize canvas helper
+
+            This method late-initializes the canvas helper, providing
+            it with the necessary device and output objects. Note that
+            the CanvasHelper does <em>not</em> take ownership of the
+            passed rDevice reference, nor does it perform any
+            reference counting. Thus, to prevent the reference counted
+            SpriteCanvas object from deletion, the user of this class
+            is responsible for holding ref-counted references itself!
+
+            @param rDevice
+            Reference device this canvas is associated with
+
+         */
+        void init( ::com::sun::star::rendering::XGraphicDevice&     rDevice,
+                   SpriteDeviceHelper&                              rDeviceHelper,
+                   const ::com::sun::star::geometry::IntegerSize2D& rSize );
+
+        // BitmapCanvasHelper functionality
+        // ================================
+
+        void copyRect( const ::com::sun::star::rendering::XCanvas*          rCanvas,
+                       const ::com::sun::star::uno::Reference< 
+                            ::com::sun::star::rendering::XBitmapCanvas >&   sourceCanvas, 
+                       const ::com::sun::star::geometry::RealRectangle2D&   sourceRect, 
+                       const ::com::sun::star::rendering::ViewState&        sourceViewState, 
+                       const ::com::sun::star::rendering::RenderState&      sourceRenderState, 
+                       const ::com::sun::star::geometry::RealRectangle2D&   destRect, 
+                       const ::com::sun::star::rendering::ViewState&        destViewState, 
+                       const ::com::sun::star::rendering::RenderState&      destRenderState );
+            
+        ::com::sun::star::geometry::IntegerSize2D getSize();
+
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmapCanvas > queryBitmapCanvas();
+
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmap > 
+            getScaledBitmap( const ::com::sun::star::geometry::RealSize2D&  newSize, 
+                             sal_Bool                                               beFast );
+
+        ::com::sun::star::uno::Sequence< sal_Int8 > 
+            getData( ::com::sun::star::rendering::IntegerBitmapLayout&      bitmapLayout,
+                     const ::com::sun::star::geometry::IntegerRectangle2D&  rect );
+
+        void setData( const ::com::sun::star::uno::Sequence< sal_Int8 >&        data, 
+                      const ::com::sun::star::rendering::IntegerBitmapLayout&   bitmapLayout, 
+                      const ::com::sun::star::geometry::IntegerRectangle2D&     rect );
+
+        void setPixel( const ::com::sun::star::uno::Sequence< sal_Int8 >&       color, 
+                       const ::com::sun::star::rendering::IntegerBitmapLayout&  bitmapLayout, 
+                       const ::com::sun::star::geometry::IntegerPoint2D&        pos );
+
+        ::com::sun::star::uno::Sequence< sal_Int8 > 
+            getPixel( ::com::sun::star::rendering::IntegerBitmapLayout& bitmapLayout, 
+                      const ::com::sun::star::geometry::IntegerPoint2D& pos );
+
+        ::com::sun::star::rendering::IntegerBitmapLayout getMemoryLayout();
+
+        bool hasAlpha() const;
+
+    private:
+        ::com::sun::star::geometry::IntegerSize2D maSize;
+    };
+}
+
+#endif
diff --git canvas/source/opengl/ogl_canvasbitmap.cxx canvas/source/opengl/ogl_canvasbitmap.cxx
new file mode 100644
index 0000000..9853461
--- /dev/null
+++ canvas/source/opengl/ogl_canvasbitmap.cxx
@@ -0,0 +1,63 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *      Parts copyright 2004 David Reveman, Peter Nilsson
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_canvas.hxx"
+
+#include "ogl_canvasbitmap.hxx"
+
+#include <canvas/debug.hxx>
+#include <canvas/canvastools.hxx>
+#include <tools/diagnose_ex.h>
+
+
+using namespace ::com::sun::star;
+
+namespace oglcanvas
+{
+    CanvasBitmap::CanvasBitmap( const geometry::IntegerSize2D& rSize,
+                                const SpriteCanvasRef&         rDevice,
+                                SpriteDeviceHelper&            rDeviceHelper,
+                                bool                           bHasAlpha ) :
+        mpDevice( rDevice ),
+        mbHasAlpha( bHasAlpha )
+    {
+        ENSURE_OR_THROW( mpDevice.is(),
+                         "CanvasBitmap::CanvasBitmap(): Invalid surface or device" );
+
+        maCanvasHelper.init( *mpDevice.get(), rDeviceHelper, rSize );
+    }
+
+    CanvasBitmap::CanvasBitmap( const CanvasBitmap& rSrc ) :
+        mpDevice( rSrc.mpDevice ),
+        mbHasAlpha( rSrc.mbHasAlpha )
+    {
+        maCanvasHelper = rSrc.maCanvasHelper;
+    }
+
+    void SAL_CALL CanvasBitmap::disposing()
+    {
+        mpDevice.clear();
+
+        // forward to parent
+        CanvasBitmapBaseT::disposing();
+    }
+
+    bool CanvasBitmap::renderRecordedActions() const
+    {
+        return maCanvasHelper.renderRecordedActions();
+    }
+}
diff --git canvas/source/opengl/ogl_canvasbitmap.hxx canvas/source/opengl/ogl_canvasbitmap.hxx
new file mode 100644
index 0000000..aa0d242
--- /dev/null
+++ canvas/source/opengl/ogl_canvasbitmap.hxx
@@ -0,0 +1,82 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *      Parts copyright 2004 David Reveman, Peter Nilsson
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+#ifndef OGL_CANVASBITMAP_HXX
+#define OGL_CANVASBITMAP_HXX
+
+#include <cppuhelper/compbase2.hxx>
+
+#include <com/sun/star/rendering/XBitmapCanvas.hpp>
+#include <com/sun/star/rendering/XIntegerBitmap.hpp>
+
+#include <canvas/base/integerbitmapbase.hxx>
+#include <canvas/base/basemutexhelper.hxx>
+#include <basegfx/vector/b2isize.hxx>
+
+#include <boost/shared_ptr.hpp>
+
+#include "ogl_bitmapcanvashelper.hxx"
+#include "ogl_spritecanvas.hxx"
+
+
+/* Definition of CanvasBitmap class */
+
+namespace oglcanvas
+{
+    typedef ::cppu::WeakComponentImplHelper2< ::com::sun::star::rendering::XBitmapCanvas,
+                                              ::com::sun::star::rendering::XIntegerBitmap > CanvasBitmapBase_Base;
+    typedef ::canvas::IntegerBitmapBase< ::canvas::BaseMutexHelper< CanvasBitmapBase_Base >, 
+                                         BitmapCanvasHelper, 
+                                         ::osl::MutexGuard,
+                                         ::cppu::OWeakObject >                          CanvasBitmapBaseT;
+
+    class CanvasBitmap : public CanvasBitmapBaseT
+    {
+    public:
+        /** Create a canvas bitmap for the given surface
+
+            @param rSize
+            Size of the bitmap
+        
+            @param rDevice
+            Reference device, with which bitmap should be compatible
+         */
+        CanvasBitmap( const ::com::sun::star::geometry::IntegerSize2D& rSize,
+                      const SpriteCanvasRef&                           rDevice,
+                      SpriteDeviceHelper&                              rDeviceHelper,
+                      bool                                             bHasAlpha );
+
+        /** Create verbatim copy (including all recorded actions)
+         */
+        CanvasBitmap( const CanvasBitmap& rSrc );
+
+        /// Dispose all internal references
+        virtual void SAL_CALL disposing();
+
+        /** Write out recorded actions
+         */
+        bool renderRecordedActions() const;
+
+    private:
+        /** MUST hold here, too, since CanvasHelper only contains a
+            raw pointer (without refcounting) 
+        */
+        SpriteCanvasRef mpDevice;
+        bool            mbHasAlpha;
+    };
+}
+
+#endif
diff --git canvas/source/opengl/ogl_canvascustomsprite.cxx canvas/source/opengl/ogl_canvascustomsprite.cxx
new file mode 100644
index 0000000..2d88417
--- /dev/null
+++ canvas/source/opengl/ogl_canvascustomsprite.cxx
@@ -0,0 +1,154 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_canvas.hxx"
+
+#include "ogl_canvascustomsprite.hxx"
+#include "ogl_tools.hxx"
+
+#include <canvas/debug.hxx>
+#include <canvas/verbosetrace.hxx>
+#include <canvas/verifyinput.hxx>
+#include <tools/diagnose_ex.h>
+
+#include <canvas/canvastools.hxx>
+
+#include <basegfx/matrix/b2dhommatrix.hxx>
+#include <basegfx/point/b2dpoint.hxx>
+#include <basegfx/tools/canvastools.hxx>
+
+#include <GL/gl.h>
+#include <GL/glu.h>
+#include <GL/glext.h>
+
+
+using namespace ::com::sun::star;
+
+namespace oglcanvas
+{
+    CanvasCustomSprite::CanvasCustomSprite( const ::com::sun::star::geometry::RealSize2D& rSpriteSize,
+                                            const SpriteCanvasRef&                        rRefDevice,
+                                            SpriteDeviceHelper&                           rDeviceHelper ) :
+        mpSpriteCanvas( rRefDevice ),
+        maSize(rSpriteSize),
+        maTransformation(),
+        maPosition(),
+        mfAlpha(0.0),
+        mfPriority(0.0)
+    {
+        ENSURE_OR_THROW( rRefDevice.get(),
+                         "CanvasCustomSprite::CanvasCustomSprite(): Invalid sprite canvas" );
+
+        maCanvasHelper.init( *rRefDevice.get(),
+                             rDeviceHelper );
+    }
+    
+    void SAL_CALL CanvasCustomSprite::disposing()
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        mpSpriteCanvas.clear();
+    }
+
+    void SAL_CALL CanvasCustomSprite::setAlpha( double alpha ) throw (lang::IllegalArgumentException, 
+                                                                      uno::RuntimeException)
+    {
+        canvas::tools::verifyRange( alpha, 0.0, 1.0 );
+
+        ::osl::MutexGuard aGuard( m_aMutex );
+        mfAlpha = alpha;
+    }
+
+    void SAL_CALL CanvasCustomSprite::move( const geometry::RealPoint2D&  aNewPos, 
+                                            const rendering::ViewState&   viewState, 
+                                            const rendering::RenderState& renderState ) throw (lang::IllegalArgumentException, 
+                                                                                               uno::RuntimeException)
+    {
+        canvas::tools::verifyArgs(aNewPos, viewState, renderState, 
+                                  BOOST_CURRENT_FUNCTION,
+                                  static_cast< ::cppu::OWeakObject* >(this));
+        
+        ::osl::MutexGuard aGuard( m_aMutex );
+        ::basegfx::B2DHomMatrix aTransform;
+        ::canvas::tools::mergeViewAndRenderTransform(aTransform,
+                                                     viewState, 
+                                                     renderState);
+
+        // convert position to device pixel
+        maPosition = ::basegfx::unotools::b2DPointFromRealPoint2D(aNewPos);
+        maPosition *= aTransform;
+    }
+
+    void SAL_CALL CanvasCustomSprite::transform( const geometry::AffineMatrix2D& aTransformation ) throw (lang::IllegalArgumentException, 
+                                                                                                          uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+        maTransformation = aTransformation;
+    }
+
+    void SAL_CALL CanvasCustomSprite::clip( const uno::Reference< rendering::XPolyPolygon2D >& /*aClip*/ ) throw (uno::RuntimeException)
+    {
+        // TODO(F3)
+    }
+
+    void SAL_CALL CanvasCustomSprite::setPriority( double nPriority ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+        mfPriority = nPriority;
+    }
+
+    void SAL_CALL CanvasCustomSprite::show() throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+        if( mpSpriteCanvas.is() )
+            mpSpriteCanvas->show(this);
+    }
+
+    void SAL_CALL CanvasCustomSprite::hide() throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+        if( mpSpriteCanvas.is() )
+            mpSpriteCanvas->hide(this);
+    }
+
+    uno::Reference< rendering::XCanvas > SAL_CALL CanvasCustomSprite::getContentCanvas() throw (uno::RuntimeException)
+    {
+        return this;
+    }
+
+    bool CanvasCustomSprite::renderSprite() const
+    {
+        TransformationPreserver aPreserver;
+
+        // translate sprite to output position
+        glTranslated(maPosition.getX(), maPosition.getY(), 0);
+
+        // apply sprite content transformation matrix
+        double aGLTransform[] = 
+            {
+                maTransformation.m00, maTransformation.m10, 0, 0,
+                maTransformation.m01, maTransformation.m11, 0, 0,
+                0,                    0,                    1, 0,
+                maTransformation.m02, maTransformation.m12, 0, 1
+            };
+        glMultMatrixd(aGLTransform);
+
+        if( !maCanvasHelper.renderRecordedActions() )
+            return false;
+
+        return true;
+    }
+}
diff --git canvas/source/opengl/ogl_canvascustomsprite.hxx canvas/source/opengl/ogl_canvascustomsprite.hxx
new file mode 100644
index 0000000..7d0b4bf
--- /dev/null
+++ canvas/source/opengl/ogl_canvascustomsprite.hxx
@@ -0,0 +1,101 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+#ifndef OGL_CANVASCUSTOMSPRITE_HXX
+#define OGL_CANVASCUSTOMSPRITE_HXX
+
+#include <cppuhelper/compbase2.hxx>
+#include <comphelper/uno3.hxx>
+
+#include <com/sun/star/lang/XComponent.hpp>
+#include <com/sun/star/rendering/XCustomSprite.hpp>
+#include <com/sun/star/rendering/XPolyPolygon2D.hpp>
+
+#include <basegfx/point/b2dpoint.hxx>
+#include <basegfx/vector/b2isize.hxx>
+#include <basegfx/matrix/b2dhommatrix.hxx>
+
+#include <canvas/base/basemutexhelper.hxx>
+
+#include "ogl_spritecanvas.hxx"
+#include "ogl_canvashelper.hxx"
+
+
+namespace oglcanvas
+{
+    typedef ::cppu::WeakComponentImplHelper2< ::com::sun::star::rendering::XCustomSprite,
+                                              ::com::sun::star::rendering::XCanvas > CanvasCustomSpriteBase_Base;
+    typedef ::canvas::CanvasBase< ::canvas::BaseMutexHelper< CanvasCustomSpriteBase_Base >, 
+                                    CanvasHelper, 
+                                    ::osl::MutexGuard,
+                                    ::cppu::OWeakObject >                          CanvasCustomSpriteBaseT;
+
+    /* Definition of CanvasCustomSprite class */
+
+    class CanvasCustomSprite : public CanvasCustomSpriteBaseT
+    {
+    public:
+        /** Create a custom sprite
+
+            @param rSpriteSize
+            Size of the sprite in pixel
+
+            @param rRefDevice
+            Associated output device
+
+            @param rSpriteCanvas
+            Target canvas
+
+            @param rDevice
+            Target DX device
+         */
+        CanvasCustomSprite( const ::com::sun::star::geometry::RealSize2D&   rSpriteSize,
+                            const SpriteCanvasRef&                          rRefDevice,
+                            SpriteDeviceHelper&                             rDeviceHelper );
+
+        virtual void SAL_CALL disposing();
+
+        // XSprite
+        virtual void SAL_CALL setAlpha( double alpha ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual void SAL_CALL move( const ::com::sun::star::geometry::RealPoint2D&  aNewPos, const ::com::sun::star::rendering::ViewState&  viewState, const ::com::sun::star::rendering::RenderState& renderState ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual void SAL_CALL transform( const ::com::sun::star::geometry::AffineMatrix2D& aTransformation ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual void SAL_CALL clip( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >& aClip ) throw (::com::sun::star::uno::RuntimeException);
+        virtual void SAL_CALL setPriority( double nPriority ) throw (::com::sun::star::uno::RuntimeException);
+        virtual void SAL_CALL show() throw (::com::sun::star::uno::RuntimeException);
+        virtual void SAL_CALL hide() throw (::com::sun::star::uno::RuntimeException);
+
+        // XCustomSprite
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCanvas > SAL_CALL getContentCanvas() throw (::com::sun::star::uno::RuntimeException);
+
+        double getPriority() const { return mfPriority; }
+
+        /// Render sprite content at sprite position
+        bool renderSprite() const;
+
+    private:
+        /** MUST hold here, too, since CanvasHelper only contains a
+            raw pointer (without refcounting) 
+        */
+        SpriteCanvasRef                              mpSpriteCanvas;
+        const ::com::sun::star::geometry::RealSize2D maSize;
+
+        ::com::sun::star::geometry::AffineMatrix2D   maTransformation;
+        ::basegfx::B2DPoint                          maPosition;
+        double                                       mfAlpha;
+        double                                       mfPriority;
+    };
+}
+
+#endif
diff --git canvas/source/opengl/ogl_canvasfont.cxx canvas/source/opengl/ogl_canvasfont.cxx
new file mode 100644
index 0000000..9473fb3
--- /dev/null
+++ canvas/source/opengl/ogl_canvasfont.cxx
@@ -0,0 +1,88 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_canvas.hxx"
+
+#include "ogl_canvasfont.hxx"
+#include "ogl_textlayout.hxx"
+
+#include <com/sun/star/rendering/XSpriteCanvas.hpp>
+#include <com/sun/star/rendering/PanoseWeight.hpp>
+
+
+using namespace ::com::sun::star;
+
+namespace oglcanvas
+{
+    CanvasFont::CanvasFont( const rendering::FontRequest&                   rFontRequest,
+                            const uno::Sequence< beans::PropertyValue >&    /*extraFontProperties*/, 
+                            const geometry::Matrix2D&                       fontMatrix ) :
+        CanvasFontBaseT( m_aMutex ),
+        maFontRequest( rFontRequest ),
+        maFontMatrix( fontMatrix )
+    {
+    }
+
+    void SAL_CALL CanvasFont::disposing()
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+    }
+
+    uno::Reference< rendering::XTextLayout > SAL_CALL CanvasFont::createTextLayout( const rendering::StringContext& aText, 
+                                                                                    sal_Int8                        nDirection, 
+                                                                                    sal_Int64                       nRandomSeed ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        return new TextLayout( aText, nDirection, nRandomSeed, ImplRef( this ) );
+    }
+
+    uno::Sequence< double > SAL_CALL CanvasFont::getAvailableSizes(  ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // TODO
+        return uno::Sequence< double >();
+    }
+
+    uno::Sequence< beans::PropertyValue > SAL_CALL CanvasFont::getExtraFontProperties(  ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // TODO
+        return uno::Sequence< beans::PropertyValue >();
+    }
+
+    rendering::FontRequest SAL_CALL CanvasFont::getFontRequest(  ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        return maFontRequest;
+    }
+
+    rendering::FontMetrics SAL_CALL CanvasFont::getFontMetrics(  ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // TODO
+        return rendering::FontMetrics();
+    }
+
+    const ::com::sun::star::geometry::Matrix2D& CanvasFont::getFontMatrix() const
+    {
+        return maFontMatrix;
+    }
+}
diff --git canvas/source/opengl/ogl_canvasfont.hxx canvas/source/opengl/ogl_canvasfont.hxx
new file mode 100644
index 0000000..3c84f11
--- /dev/null
+++ canvas/source/opengl/ogl_canvasfont.hxx
@@ -0,0 +1,72 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+#ifndef OGL_CANVASFONT_HXX
+#define OGL_CANVASFONT_HXX
+
+#include <comphelper/implementationreference.hxx>
+
+#include <cppuhelper/compbase1.hxx>
+#include <comphelper/broadcasthelper.hxx>
+
+#include <com/sun/star/rendering/XCanvas.hpp>
+#include <com/sun/star/rendering/XCanvasFont.hpp>
+
+#include <rtl/ref.hxx>
+
+#include <boost/shared_ptr.hpp>
+#include <boost/utility.hpp>
+
+
+/* Definition of CanvasFont class */
+
+namespace oglcanvas
+{
+    class SpriteCanvas;
+
+    typedef ::cppu::WeakComponentImplHelper1< ::com::sun::star::rendering::XCanvasFont > CanvasFontBaseT;
+
+    class CanvasFont : public ::comphelper::OBaseMutex, 
+                       public CanvasFontBaseT,
+                       private ::boost::noncopyable
+    {
+    public:
+        typedef ::comphelper::ImplementationReference< 
+            CanvasFont, 
+            ::com::sun::star::rendering::XCanvasFont > ImplRef;
+
+        CanvasFont( const ::com::sun::star::rendering::FontRequest&                                     fontRequest,
+                    const ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue >& 	extraFontProperties, 
+                    const ::com::sun::star::geometry::Matrix2D&                                         fontMatrix );
+
+        /// Dispose all internal references
+        virtual void SAL_CALL disposing();
+
+        // XCanvasFont
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XTextLayout > SAL_CALL createTextLayout( const ::com::sun::star::rendering::StringContext& aText, sal_Int8 nDirection, sal_Int64 nRandomSeed ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::rendering::FontRequest SAL_CALL getFontRequest(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::rendering::FontMetrics SAL_CALL getFontMetrics(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Sequence< double > SAL_CALL getAvailableSizes(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue > SAL_CALL getExtraFontProperties(  ) throw (::com::sun::star::uno::RuntimeException);
+
+		const ::com::sun::star::geometry::Matrix2D& getFontMatrix() const;
+
+    private:
+        ::com::sun::star::rendering::FontRequest	maFontRequest;
+		::com::sun::star::geometry::Matrix2D		maFontMatrix;
+    };
+}
+
+#endif
diff --git canvas/source/opengl/ogl_canvashelper.cxx canvas/source/opengl/ogl_canvashelper.cxx
new file mode 100644
index 0000000..b827c8e
--- /dev/null
+++ canvas/source/opengl/ogl_canvashelper.cxx
@@ -0,0 +1,860 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *      Parts copyright 2004 David Reveman, Peter Nilsson
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_canvas.hxx"
+
+#include "ogl_canvashelper.hxx"
+
+#include <canvas/debug.hxx>
+#include <tools/diagnose_ex.h>
+#include <basegfx/tools/canvastools.hxx>
+#include <basegfx/polygon/b2dpolypolygon.hxx>
+#include <basegfx/polygon/b2dpolygontriangulator.hxx>
+
+#include <com/sun/star/rendering/TexturingMode.hpp>
+#include <com/sun/star/rendering/CompositeOperation.hpp>
+#include <com/sun/star/rendering/RepaintResult.hpp>
+#include <com/sun/star/rendering/PathCapType.hpp>
+#include <com/sun/star/rendering/PathJoinType.hpp>
+
+#include <vcl/virdev.hxx>
+#include <vcl/metric.hxx>
+#include <vcl/font.hxx>
+
+#include "ogl_canvasfont.hxx"
+#include "ogl_canvasbitmap.hxx"
+#include "ogl_spritecanvas.hxx"
+#include "ogl_tools.hxx"
+
+#include <GL/gl.h>
+#include <GL/glu.h>
+#include <GL/glext.h>
+
+#include <boost/scoped_array.hpp>
+
+
+using namespace ::com::sun::star;
+
+namespace oglcanvas
+{
+    /* Concepts:
+       =========
+
+       This OpenGL canvas implementation tries to keep all render
+       output as high-level as possible, i.e. geometry data and
+       externally-provided bitmaps. Therefore, calls at the
+       XCanvas-interfaces are not immediately transformed into colored
+       pixel inside some GL buffer, but are retained simply with their
+       call parameters. Only after XSpriteCanvas::updateScreen() has
+       been called, this all gets transferred to the OpenGL subsystem
+       and converted to a visible scene. The big advantage is, this
+       makes sprite modifications practically zero-overhead, and saves
+       a lot on texture memory (compared to the directx canvas, which
+       immediately dumps every render call into a texture).
+
+       The drawback, of course, is that complex images churn a lot of
+       GPU cycles on every re-rendering.
+
+       For the while, I'll be using immediate mode, i.e. transfer data
+       over and over again to the OpenGL subsystem. Alternatively,
+       there are display lists, which at least keep the data on the
+       server, or even better, vertex buffers, which copy geometry
+       data over en bloc.
+
+       Text: http://www.opengl.org/resources/features/fontsurvey/
+     */
+
+    struct CanvasHelper::Action
+    {
+        ::basegfx::B2DHomMatrix         maTransform;
+        GLenum                          meSrcBlendMode;
+        GLenum                          meDstBlendMode;
+        rendering::ARGBColor            maARGBColor;
+        ::basegfx::B2DPolyPolygonVector maPolyPolys;
+
+        ::boost::function6< bool,
+                            const CanvasHelper&,
+                            const ::basegfx::B2DHomMatrix&,
+                            GLenum,
+                            GLenum,
+                            const rendering::ARGBColor&,
+                            const ::basegfx::B2DPolyPolygonVector& > maFunction;
+    };
+
+    namespace
+    {
+        /// triangulates polygon before
+        void renderComplexPolyPolygon( const ::basegfx::B2DPolyPolygon& rPolyPoly )
+        {
+            ::basegfx::B2DPolyPolygon aPolyPoly(rPolyPoly);
+            if( aPolyPoly.areControlPointsUsed() )
+                aPolyPoly = rPolyPoly.getDefaultAdaptiveSubdivision();
+            const ::basegfx::B2DRange& rBounds(aPolyPoly.getB2DRange());
+            const double nWidth=rBounds.getWidth();
+            const double nHeight=rBounds.getHeight();
+            const ::basegfx::B2DPolygon& rTriangulatedPolygon(
+                ::basegfx::triangulator::triangulate(aPolyPoly));
+
+            for( sal_uInt32 i=0; i<rTriangulatedPolygon.count(); i++ ) 
+            {
+                const ::basegfx::B2DPoint& rPt( rTriangulatedPolygon.getB2DPoint(i) );
+				const double s(rPt.getX()/nWidth);
+                const double t(rPt.getY()/nHeight);
+                glTexCoord2f(s,t); glVertex2d(rPt.getX(), rPt.getY());
+            }
+        }
+
+        /** only use this for line polygons. 
+
+            better not leave triangulation to OpenGL. also, ignores texturing
+          */
+        void renderPolyPolygon( const ::basegfx::B2DPolyPolygon& rPolyPoly )
+        {
+            ::basegfx::B2DPolyPolygon aPolyPoly(rPolyPoly);
+            if( aPolyPoly.areControlPointsUsed() )
+                aPolyPoly = rPolyPoly.getDefaultAdaptiveSubdivision();
+
+            for( sal_uInt32 i=0; i<aPolyPoly.count(); i++ ) 
+            {
+                const ::basegfx::B2DPolygon& rPolygon( aPolyPoly.getB2DPolygon(i) );
+
+                const sal_uInt32 nPts=rPolygon.count();
+                const sal_uInt32 nExtPts=nPts + rPolygon.isClosed();
+                for( sal_uInt32 j=0; j<nExtPts; j++ ) 
+                {
+                    const ::basegfx::B2DPoint& rPt( rPolygon.getB2DPoint( j % nPts ) );
+                    glVertex2d(rPt.getX(), rPt.getY());
+                }
+            }
+        }
+        
+        void setupState( const ::basegfx::B2DHomMatrix&   rTransform,
+                         GLenum                           eSrcBlend,
+                         GLenum                           eDstBlend,
+                         const rendering::ARGBColor&      rColor )
+        {
+            double aGLTransform[] = 
+                {
+                    rTransform.get(0,0), rTransform.get(1,0), 0, 0,
+                    rTransform.get(0,1), rTransform.get(1,1), 0, 0,
+                    0,                   0,                   1, 0,
+                    rTransform.get(0,2), rTransform.get(1,2), 0, 1
+                };
+            glMultMatrixd(aGLTransform);
+
+            glEnable(GL_BLEND);
+            glBlendFunc(eSrcBlend, eDstBlend);
+
+            glColor4d(rColor.Red,
+                      rColor.Green,
+                      rColor.Blue,
+                      rColor.Alpha);
+
+            // GL 1.2:
+            // glBlendEquation( GLenum mode );
+            // glBlendColor( GLclampf red, GLclampf green,GLclampf blue, GLclampf alpha );
+            // glConvolutionFilter1D
+            // glConvolutionFilter2D
+            // glSeparableFilter2D
+        }
+
+        bool lcl_drawPoint( const CanvasHelper&              /*rHelper*/,
+                            const ::basegfx::B2DHomMatrix&   rTransform,
+                            GLenum                           eSrcBlend,
+                            GLenum                           eDstBlend,
+                            const rendering::ARGBColor&      rColor,
+                            const geometry::RealPoint2D&     rPoint )
+        {
+            TransformationPreserver aPreserver;
+            setupState(rTransform, eSrcBlend, eDstBlend, rColor);
+
+            glBegin(GL_POINTS);
+            glVertex2d(rPoint.X, rPoint.Y);
+            glEnd();
+
+            return true;
+        }
+
+        bool lcl_drawLine( const CanvasHelper&              /*rHelper*/,
+                           const ::basegfx::B2DHomMatrix&   rTransform,
+                           GLenum                           eSrcBlend,
+                           GLenum                           eDstBlend,
+                           const rendering::ARGBColor&      rColor,
+                           const geometry::RealPoint2D&     rStartPoint,
+                           const geometry::RealPoint2D&     rEndPoint )
+        {
+            TransformationPreserver aPreserver;
+            setupState(rTransform, eSrcBlend, eDstBlend, rColor);
+
+            glBegin(GL_LINES);
+            glVertex2d(rStartPoint.X, rStartPoint.Y);
+            glVertex2d(rEndPoint.X, rEndPoint.Y);
+            glEnd();
+
+            return true;
+        }
+
+        bool lcl_drawPolyPolygon( const CanvasHelper&                    /*rHelper*/,
+                                  const ::basegfx::B2DHomMatrix&         rTransform,
+                                  GLenum                                 eSrcBlend,
+                                  GLenum                                 eDstBlend,
+                                  const rendering::ARGBColor&            rColor,
+                                  const ::basegfx::B2DPolyPolygonVector& rPolyPolygons )
+        {
+            TransformationPreserver aPreserver;
+            setupState(rTransform, eSrcBlend, eDstBlend, rColor);
+
+            ::basegfx::B2DPolyPolygonVector::const_iterator aCurr=rPolyPolygons.begin();
+            const ::basegfx::B2DPolyPolygonVector::const_iterator aEnd=rPolyPolygons.end();
+            while( aCurr != aEnd )
+            {
+                glBegin(GL_LINE_STRIP);
+                renderPolyPolygon(*aCurr++);
+                glEnd();
+            }
+
+            return true;
+        }
+
+        bool lcl_fillPolyPolygon( const CanvasHelper&                    rHelper,
+                                  const ::basegfx::B2DHomMatrix&         rTransform,
+                                  GLenum                                 eSrcBlend,
+                                  GLenum                                 eDstBlend,
+                                  const rendering::ARGBColor&            rColor,
+                                  const ::basegfx::B2DPolyPolygonVector& rPolyPolygons )
+        {
+            TransformationPreserver aPreserver;
+            setupState(rTransform, eSrcBlend, eDstBlend, rColor);
+
+            rHelper.getDeviceHelper()->useLinearGradientShader(rColor,
+                                                               rendering::ARGBColor(1.0,0.0,1.0,0.0));
+            
+            ::basegfx::B2DPolyPolygonVector::const_iterator aCurr=rPolyPolygons.begin();
+            const ::basegfx::B2DPolyPolygonVector::const_iterator aEnd=rPolyPolygons.end();
+            while( aCurr != aEnd )
+            {
+                glBegin(GL_TRIANGLES);
+                renderComplexPolyPolygon(*aCurr++);
+                glEnd();
+            }
+
+            return true;
+        }
+
+        bool lcl_drawOwnBitmap( const CanvasHelper&              /*rHelper*/,
+                                const ::basegfx::B2DHomMatrix&   rTransform,
+                                GLenum                           eSrcBlend,
+                                GLenum                           eDstBlend,
+                                const rendering::ARGBColor&      rColor,
+                                const CanvasBitmap&              rBitmap )
+        {
+            TransformationPreserver aPreserver;
+            setupState(rTransform, eSrcBlend, eDstBlend, rColor);
+
+            return rBitmap.renderRecordedActions();
+        }
+
+        bool lcl_drawGenericBitmap( const CanvasHelper&              /*rHelper*/,
+                                    const ::basegfx::B2DHomMatrix&   rTransform,
+                                    GLenum                           eSrcBlend,
+                                    GLenum                           eDstBlend,
+                                    const rendering::ARGBColor&      rColor,
+                                    const geometry::IntegerSize2D&   rPixelSize,
+                                    const uno::Sequence<sal_Int8>&   rPixelData )
+        {
+            TransformationPreserver aPreserver;
+            setupState(rTransform, eSrcBlend, eDstBlend, rColor);
+
+            // TODO(P3): reuse the texture next time
+            unsigned int nTexture;
+            glGenTextures(1, &nTexture);
+            glBindTexture(GL_TEXTURE_2D, nTexture);
+
+            // TODO(E3): handle limited texture sizes -
+            // glGetIntegerv(GL_MAX_TEXTURE_SIZE)
+
+            glTexImage2D(GL_TEXTURE_2D,
+                         0,
+                         4,
+                         rPixelSize.Width, 
+                         rPixelSize.Height, 
+                         0,
+                         GL_RGBA, 
+                         GL_UNSIGNED_INT_8_8_8_8_REV,
+                         &rPixelData[0]);
+            glEnable(GL_TEXTURE_2D);
+            glTexParameteri(GL_TEXTURE_2D,
+                            GL_TEXTURE_MIN_FILTER,
+                            GL_NEAREST);
+            glTexParameteri(GL_TEXTURE_2D,
+                            GL_TEXTURE_MAG_FILTER,
+                            GL_NEAREST);
+            glDisable(GL_BLEND);
+            glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);
+
+            glBegin(GL_TRIANGLE_STRIP);
+            glTexCoord2f(0,0); glVertex2d(0,0);
+            glTexCoord2f(0,1); glVertex2d(0, rPixelSize.Height);
+            glTexCoord2f(1,0); glVertex2d(rPixelSize.Width,0);
+            glTexCoord2f(1,1); glVertex2d(rPixelSize.Width,rPixelSize.Height);
+            glEnd();
+
+            glDeleteTextures(1, &nTexture);
+
+            return true;
+        }
+    }
+
+    CanvasHelper::CanvasHelper() :
+        mpDevice( NULL ),
+        mpRecordedActions()
+    {}
+
+    CanvasHelper::~CanvasHelper()
+    {}
+
+    CanvasHelper& CanvasHelper::operator=( const CanvasHelper& rSrc )
+    {
+        mpDevice = rSrc.mpDevice;
+        mpRecordedActions = rSrc.mpRecordedActions;
+        return *this;
+    }
+
+    void CanvasHelper::disposing()
+    {
+        RecordVectorT aThrowaway;
+        mpRecordedActions.swap( aThrowaway );
+        mpDevice = NULL;
+        mpDeviceHelper = NULL;
+    }
+
+    void CanvasHelper::init( rendering::XGraphicDevice& rDevice,
+                             SpriteDeviceHelper& rDeviceHelper )
+    {
+        mpDevice = &rDevice;
+        mpDeviceHelper = &rDeviceHelper;
+    }
+
+    void CanvasHelper::clear()
+    {        
+        mpRecordedActions->clear();
+    }
+
+    void CanvasHelper::drawPoint( const rendering::XCanvas*     /*pCanvas*/,
+                                  const geometry::RealPoint2D&  aPoint,
+                                  const rendering::ViewState&   viewState,
+                                  const rendering::RenderState& renderState )
+    {
+        if( mpDevice )
+        {
+            mpRecordedActions->push_back( Action() );
+            Action& rAct=mpRecordedActions->back();
+
+            setupGraphicsState( rAct, viewState, renderState );
+            rAct.maFunction = ::boost::bind(&lcl_drawPoint,
+                                            _1,_2,_3,_4,_5,
+                                            aPoint);
+        }
+    }
+
+    void CanvasHelper::drawLine( const rendering::XCanvas*      /*pCanvas*/,
+                                 const geometry::RealPoint2D&   aStartPoint,
+                                 const geometry::RealPoint2D&   aEndPoint,
+                                 const rendering::ViewState&    viewState,
+                                 const rendering::RenderState&  renderState )
+    {
+        if( mpDevice )
+        {
+            mpRecordedActions->push_back( Action() );
+            Action& rAct=mpRecordedActions->back();
+
+            setupGraphicsState( rAct, viewState, renderState );
+            rAct.maFunction = ::boost::bind(&lcl_drawLine,
+                                            _1,_2,_3,_4,_5,
+                                            aStartPoint,aEndPoint);
+        }
+    }
+
+    void CanvasHelper::drawBezier( const rendering::XCanvas*            /*pCanvas*/, 
+                                   const geometry::RealBezierSegment2D& aBezierSegment, 
+                                   const geometry::RealPoint2D&         aEndPoint,
+                                   const rendering::ViewState&          viewState, 
+                                   const rendering::RenderState&        renderState )
+    {
+        if( mpDevice )
+        {
+            mpRecordedActions->push_back( Action() );
+            Action& rAct=mpRecordedActions->back();
+
+            setupGraphicsState( rAct, viewState, renderState );
+
+            // TODO(F2): subdivide&render whole curve
+            rAct.maFunction = ::boost::bind(&lcl_drawLine,
+                                            _1,_2,_3,_4,_5,
+                                            geometry::RealPoint2D(
+                                                aBezierSegment.Px,
+                                                aBezierSegment.Py),
+                                            aEndPoint);
+        }
+    }
+
+    uno::Reference< rendering::XCachedPrimitive > CanvasHelper::drawPolyPolygon( const rendering::XCanvas*                          /*pCanvas*/, 
+                                                                                 const uno::Reference< rendering::XPolyPolygon2D >& xPolyPolygon, 
+                                                                                 const rendering::ViewState&                        viewState, 
+                                                                                 const rendering::RenderState&                      renderState )
+    {
+        ENSURE_OR_THROW( xPolyPolygon.is(), 
+                          "CanvasHelper::drawPolyPolygon: polygon is NULL");
+
+        if( mpDevice )
+        {
+            mpRecordedActions->push_back( Action() );
+            Action& rAct=mpRecordedActions->back();
+
+            setupGraphicsState( rAct, viewState, renderState );
+            rAct.maPolyPolys.push_back(
+                ::basegfx::unotools::b2DPolyPolygonFromXPolyPolygon2D(xPolyPolygon));
+            rAct.maPolyPolys.back().makeUnique(); // own copy, for thread safety
+
+            rAct.maFunction = &lcl_drawPolyPolygon;
+        }
+
+        // TODO(P1): Provide caching here.
+        return uno::Reference< rendering::XCachedPrimitive >(NULL);
+    }
+
+    uno::Reference< rendering::XCachedPrimitive > CanvasHelper::strokePolyPolygon( const rendering::XCanvas*                            /*pCanvas*/, 
+                                                                                   const uno::Reference< rendering::XPolyPolygon2D >&   xPolyPolygon, 
+                                                                                   const rendering::ViewState&                          viewState, 
+                                                                                   const rendering::RenderState&                        renderState, 
+                                                                                   const rendering::StrokeAttributes&                   /*strokeAttributes*/ )
+    {
+        ENSURE_OR_THROW( xPolyPolygon.is(), 
+                          "CanvasHelper::strokePolyPolygon: polygon is NULL");
+
+        if( mpDevice )
+        {
+            mpRecordedActions->push_back( Action() );
+            Action& rAct=mpRecordedActions->back();
+
+            setupGraphicsState( rAct, viewState, renderState );
+            rAct.maPolyPolys.push_back( 
+                ::basegfx::unotools::b2DPolyPolygonFromXPolyPolygon2D(xPolyPolygon));
+            rAct.maPolyPolys.back().makeUnique(); // own copy, for thread safety
+
+            // TODO(F3): fallback to drawPolyPolygon currently
+            rAct.maFunction = &lcl_drawPolyPolygon;
+        }
+
+        // TODO(P1): Provide caching here.
+        return uno::Reference< rendering::XCachedPrimitive >(NULL);
+    }
+
+    uno::Reference< rendering::XCachedPrimitive > CanvasHelper::strokeTexturedPolyPolygon( const rendering::XCanvas*                            /*pCanvas*/, 
+                                                                                           const uno::Reference< rendering::XPolyPolygon2D >&   /*xPolyPolygon*/, 
+                                                                                           const rendering::ViewState&                          /*viewState*/, 
+                                                                                           const rendering::RenderState&                        /*renderState*/, 
+                                                                                           const uno::Sequence< rendering::Texture >&           /*textures*/, 
+                                                                                           const rendering::StrokeAttributes&                   /*strokeAttributes*/ )
+    {
+        // TODO
+        return uno::Reference< rendering::XCachedPrimitive >(NULL);
+    }
+
+    uno::Reference< rendering::XCachedPrimitive > CanvasHelper::strokeTextureMappedPolyPolygon( const rendering::XCanvas*                           /*pCanvas*/, 
+                                                                                                const uno::Reference< rendering::XPolyPolygon2D >&  /*xPolyPolygon*/, 
+                                                                                                const rendering::ViewState&                         /*viewState*/, 
+                                                                                                const rendering::RenderState&                       /*renderState*/, 
+                                                                                                const uno::Sequence< rendering::Texture >&          /*textures*/, 
+                                                                                                const uno::Reference< geometry::XMapping2D >&       /*xMapping*/, 
+                                                                                                const rendering::StrokeAttributes&                  /*strokeAttributes*/ )
+    {
+        // TODO
+        return uno::Reference< rendering::XCachedPrimitive >(NULL);
+    }
+
+    uno::Reference< rendering::XPolyPolygon2D >   CanvasHelper::queryStrokeShapes( const rendering::XCanvas*                            /*pCanvas*/, 
+                                                                                   const uno::Reference< rendering::XPolyPolygon2D >&   /*xPolyPolygon*/, 
+                                                                                   const rendering::ViewState&                          /*viewState*/, 
+                                                                                   const rendering::RenderState&                        /*renderState*/, 
+                                                                                   const rendering::StrokeAttributes&                   /*strokeAttributes*/ )
+    {
+        // TODO
+        return uno::Reference< rendering::XPolyPolygon2D >(NULL);
+    }
+
+    uno::Reference< rendering::XCachedPrimitive > CanvasHelper::fillPolyPolygon( const rendering::XCanvas*                          /*pCanvas*/, 
+                                                                                 const uno::Reference< rendering::XPolyPolygon2D >& xPolyPolygon, 
+                                                                                 const rendering::ViewState&                        viewState, 
+                                                                                 const rendering::RenderState&                      renderState )
+    {
+        ENSURE_OR_THROW( xPolyPolygon.is(), 
+                          "CanvasHelper::fillPolyPolygon: polygon is NULL");
+
+        if( mpDevice )
+        {
+            mpRecordedActions->push_back( Action() );
+            Action& rAct=mpRecordedActions->back();
+
+            setupGraphicsState( rAct, viewState, renderState );
+            rAct.maPolyPolys.push_back(
+                ::basegfx::unotools::b2DPolyPolygonFromXPolyPolygon2D(xPolyPolygon));
+            rAct.maPolyPolys.back().makeUnique(); // own copy, for thread safety
+
+            rAct.maFunction = &lcl_fillPolyPolygon;
+        }
+
+        // TODO(P1): Provide caching here.
+        return uno::Reference< rendering::XCachedPrimitive >(NULL);
+    }
+
+    uno::Reference< rendering::XCachedPrimitive > CanvasHelper::fillTexturedPolyPolygon( const rendering::XCanvas*                          /*pCanvas*/, 
+                                                                                         const uno::Reference< rendering::XPolyPolygon2D >& /*xPolyPolygon*/,
+                                                                                         const rendering::ViewState&                        /*viewState*/,
+                                                                                         const rendering::RenderState&                      /*renderState*/,
+                                                                                         const uno::Sequence< rendering::Texture >&         /*textures*/ )
+    {
+        // TODO(P1): Provide caching here.
+        return uno::Reference< rendering::XCachedPrimitive >(NULL);
+    }
+
+    uno::Reference< rendering::XCachedPrimitive > CanvasHelper::fillTextureMappedPolyPolygon( const rendering::XCanvas*                             /*pCanvas*/, 
+                                                                                              const uno::Reference< rendering::XPolyPolygon2D >&    /*xPolyPolygon*/, 
+                                                                                              const rendering::ViewState&                           /*viewState*/, 
+                                                                                              const rendering::RenderState&                         /*renderState*/, 
+                                                                                              const uno::Sequence< rendering::Texture >&            /*textures*/, 
+                                                                                              const uno::Reference< geometry::XMapping2D >&         /*xMapping*/ )
+    {
+        // TODO
+        return uno::Reference< rendering::XCachedPrimitive >(NULL);
+    }
+
+    uno::Reference< rendering::XCanvasFont > CanvasHelper::createFont( const rendering::XCanvas*                    /*pCanvas*/, 
+                                                                       const rendering::FontRequest&                fontRequest, 
+                                                                       const uno::Sequence< beans::PropertyValue >& extraFontProperties, 
+                                                                       const geometry::Matrix2D&                    fontMatrix )
+    {
+        if( mpDevice )
+            return uno::Reference< rendering::XCanvasFont >( 
+                    new CanvasFont(fontRequest, extraFontProperties, fontMatrix ) );
+
+        return uno::Reference< rendering::XCanvasFont >();
+    }
+
+    uno::Sequence< rendering::FontInfo > CanvasHelper::queryAvailableFonts( const rendering::XCanvas*                       /*pCanvas*/, 
+                                                                            const rendering::FontInfo&                      /*aFilter*/, 
+                                                                            const uno::Sequence< beans::PropertyValue >&    /*aFontProperties*/ )
+    {
+        // TODO
+        return uno::Sequence< rendering::FontInfo >();
+    }
+
+    uno::Reference< rendering::XCachedPrimitive > CanvasHelper::drawText( const rendering::XCanvas*                         /*pCanvas*/, 
+                                                                          const rendering::StringContext&                   /*text*/, 
+                                                                          const uno::Reference< rendering::XCanvasFont >&   /*xFont*/, 
+                                                                          const rendering::ViewState&                       /*viewState*/, 
+                                                                          const rendering::RenderState&                     /*renderState*/, 
+                                                                          sal_Int8                                          /*textDirection*/ )
+    {
+        // TODO - but not used from slideshow
+        return uno::Reference< rendering::XCachedPrimitive >(NULL);
+    }
+
+    uno::Reference< rendering::XCachedPrimitive > CanvasHelper::drawTextLayout( const rendering::XCanvas*                       /*pCanvas*/, 
+                                                                                const uno::Reference< rendering::XTextLayout >& xLayoutetText, 
+                                                                                const rendering::ViewState&                     viewState, 
+                                                                                const rendering::RenderState&                   renderState )
+    {
+        ENSURE_OR_THROW( xLayoutetText.is(), 
+                          "CanvasHelper::drawTextLayout: text is NULL");
+
+        if( mpDevice )
+        {
+            VirtualDevice aVDev;
+            aVDev.EnableOutput(FALSE);
+
+            CanvasFont* pFont=dynamic_cast<CanvasFont*>(xLayoutetText->getFont().get());
+            const rendering::StringContext& rTxt=xLayoutetText->getText();
+            if( pFont && rTxt.Length )
+            {
+                // create the font
+                const rendering::FontRequest& rFontRequest = pFont->getFontRequest();
+                const geometry::Matrix2D&     rFontMatrix = pFont->getFontMatrix();
+                ::Font aFont(
+                    rFontRequest.FontDescription.FamilyName,
+                    rFontRequest.FontDescription.StyleName,
+                    Size( 0, ::basegfx::fround(rFontRequest.CellSize)));
+
+                aFont.SetAlign( ALIGN_BASELINE );
+                aFont.SetCharSet( (rFontRequest.FontDescription.IsSymbolFont==util::TriState_YES) ? RTL_TEXTENCODING_SYMBOL : RTL_TEXTENCODING_UNICODE );
+                aFont.SetVertical( (rFontRequest.FontDescription.IsVertical==util::TriState_YES) ? TRUE : FALSE );
+                aFont.SetWeight( static_cast<FontWeight>(rFontRequest.FontDescription.FontDescription.Weight) );
+                aFont.SetItalic( (rFontRequest.FontDescription.FontDescription.Letterform<=8) ? ITALIC_NONE : ITALIC_NORMAL );
+
+                // adjust to stretched font
+                if(!::rtl::math::approxEqual(rFontMatrix.m00, rFontMatrix.m11))
+                {
+                    const Size aSize = aVDev.GetFontMetric( aFont ).GetSize();
+                    const double fDividend( rFontMatrix.m10 + rFontMatrix.m11 );
+                    double fStretch = (rFontMatrix.m00 + rFontMatrix.m01);
+
+                    if( !::basegfx::fTools::equalZero( fDividend) )
+                        fStretch /= fDividend;
+
+                    const sal_Int32 nNewWidth = ::basegfx::fround( aSize.Width() * fStretch );
+
+                    aFont.SetWidth( nNewWidth );
+                }
+
+                // set font
+                aVDev.SetFont(aFont);
+
+                const Point aEmptyPoint(0, 0);
+                const String aText(rTxt.Text.getStr());
+
+                mpRecordedActions->push_back( Action() );
+                Action& rAct=mpRecordedActions->back();
+                
+                setupGraphicsState( rAct, viewState, renderState );
+                
+                // handle custom spacing, if there
+                uno::Sequence<double> aLogicalAdvancements=xLayoutetText->queryLogicalAdvancements();
+                if( aLogicalAdvancements.getLength() )
+                {
+                    // create the DXArray
+                    const sal_Int32 nLen( aLogicalAdvancements.getLength() );
+                    ::boost::scoped_array<sal_Int32> pDXArray( new sal_Int32[nLen] );
+                    for( sal_Int32 i=0; i<nLen; ++i )
+                        pDXArray[i] = basegfx::fround( aLogicalAdvancements[i] );
+
+                    // get the glyphs
+                    aVDev.GetTextOutlines(rAct.maPolyPolys,
+                                          rTxt.Text,
+                                          0,
+                                          (xub_StrLen)rTxt.StartPosition,
+                                          (xub_StrLen)rTxt.Length,
+                                          TRUE,
+                                          0,
+                                          pDXArray.get() );
+                }
+                else
+                {
+                    // get the glyphs
+                    aVDev.GetTextOutlines(rAct.maPolyPolys,
+                                          rTxt.Text,
+                                          0,
+                                          (xub_StrLen)rTxt.StartPosition,
+                                          (xub_StrLen)rTxt.Length );
+                }
+
+                // own copy, for thread safety 
+                std::for_each(rAct.maPolyPolys.begin(),
+                              rAct.maPolyPolys.end(),
+                              ::boost::mem_fn(&::basegfx::B2DPolyPolygon::makeUnique));
+                
+                rAct.maFunction = &lcl_fillPolyPolygon;
+            }
+        }        
+        
+        // TODO
+        return uno::Reference< rendering::XCachedPrimitive >(NULL);
+    }
+
+    uno::Reference< rendering::XCachedPrimitive > CanvasHelper::drawBitmap( const rendering::XCanvas*                   /*pCanvas*/, 
+                                                                            const uno::Reference< rendering::XBitmap >& xBitmap, 
+                                                                            const rendering::ViewState&                 viewState, 
+                                                                            const rendering::RenderState&               renderState )
+    {
+        ENSURE_OR_THROW( xBitmap.is(), 
+                          "CanvasHelper::drawBitmap: bitmap is NULL");
+
+        if( mpDevice )
+        {
+            // own bitmap?
+            CanvasBitmap* pOwnBitmap=dynamic_cast<CanvasBitmap*>(xBitmap.get());
+            if( pOwnBitmap )
+            {
+                // insert as transformed copy of bitmap action vector -
+                // during rendering, this gets rendered into a temporary
+                // buffer, and then composited to the front
+                mpRecordedActions->push_back( Action() );
+                Action& rAct=mpRecordedActions->back();
+                
+                setupGraphicsState( rAct, viewState, renderState );
+                rAct.maFunction = ::boost::bind(&lcl_drawOwnBitmap,
+                                                _1,_2,_3,_4,_5,
+                                                *pOwnBitmap);
+            }
+            else
+            {
+                // TODO(P3): Highly inefficient - simply copies pixel data
+
+                uno::Reference< rendering::XIntegerReadOnlyBitmap > xIntegerBitmap(
+                    xBitmap, uno::UNO_QUERY);
+                if( xIntegerBitmap.is() )
+                {
+                    const geometry::IntegerSize2D aSize=xBitmap->getSize();
+                    rendering::IntegerBitmapLayout aLayout;
+                    uno::Sequence<sal_Int8> aPixelData=
+                        xIntegerBitmap->getData(
+                            aLayout,
+                            geometry::IntegerRectangle2D(0,0,aSize.Width,aSize.Height));
+
+                    // force-convert color to ARGB8888 int color space  
+                    uno::Sequence<sal_Int8> aARGBBytes(
+                        aLayout.ColorSpace->convertToIntegerColorSpace(
+                            aPixelData,
+                            canvas::tools::getStdColorSpace()));
+
+                    mpRecordedActions->push_back( Action() );
+                    Action& rAct=mpRecordedActions->back();
+                
+                    setupGraphicsState( rAct, viewState, renderState );
+                    rAct.maFunction = ::boost::bind(&lcl_drawGenericBitmap,
+                                                    _1,_2,_3,_4,_5,
+                                                    aSize, aARGBBytes);
+                }
+                // TODO(F1): handle non-integer case
+            }
+        }
+
+        // TODO(P1): Provide caching here.
+        return uno::Reference< rendering::XCachedPrimitive >(NULL);
+    }
+
+    uno::Reference< rendering::XCachedPrimitive > CanvasHelper::drawBitmapModulated( const rendering::XCanvas*                      pCanvas, 
+                                                                                     const uno::Reference< rendering::XBitmap >&    xBitmap, 
+                                                                                     const rendering::ViewState&                    viewState, 
+                                                                                     const rendering::RenderState&                  renderState )
+    {
+        // TODO(F3): remove this wart altogether
+        return drawBitmap(pCanvas, xBitmap, viewState, renderState);
+    }
+
+    uno::Reference< rendering::XGraphicDevice > CanvasHelper::getDevice()
+    {
+        return uno::Reference< rendering::XGraphicDevice >(mpDevice);
+    }
+
+    void CanvasHelper::setupGraphicsState( Action&                       o_action,
+                                           const rendering::ViewState&   viewState, 
+                                           const rendering::RenderState& renderState )
+    {
+        ENSURE_OR_THROW( mpDevice,
+                          "CanvasHelper::setupGraphicsState: reference device invalid" );
+
+        // TODO(F3): clipping
+        // TODO(P2): think about caching transformations between canvas calls
+
+        // setup overall transform only now. View clip above was
+        // relative to view transform
+        ::basegfx::B2DHomMatrix aTransform;
+        ::canvas::tools::mergeViewAndRenderTransform(o_action.maTransform,
+                                                     viewState,
+                                                     renderState);
+        // setup compositing - mapping courtesy David Reveman
+        // (glitz_operator.c)
+        switch( renderState.CompositeOperation )
+        {
+            case rendering::CompositeOperation::OVER:
+                o_action.meSrcBlendMode=GL_ONE; 
+                o_action.meDstBlendMode=GL_ONE_MINUS_SRC_ALPHA; 
+                break;
+            case rendering::CompositeOperation::CLEAR:
+                o_action.meSrcBlendMode=GL_ZERO; 
+                o_action.meDstBlendMode=GL_ZERO; 
+                break;
+            case rendering::CompositeOperation::SOURCE:
+                o_action.meSrcBlendMode=GL_ONE; 
+                o_action.meDstBlendMode=GL_ZERO; 
+                break;
+            case rendering::CompositeOperation::UNDER:
+                // FALLTHROUGH intended - but correct?!
+            case rendering::CompositeOperation::DESTINATION:
+                o_action.meSrcBlendMode=GL_ZERO; 
+                o_action.meDstBlendMode=GL_ONE; 
+                break;
+            case rendering::CompositeOperation::INSIDE:
+                o_action.meSrcBlendMode=GL_DST_ALPHA; 
+                o_action.meDstBlendMode=GL_ZERO; 
+                break;
+            case rendering::CompositeOperation::INSIDE_REVERSE:
+                o_action.meSrcBlendMode=GL_ONE_MINUS_DST_ALPHA; 
+                o_action.meDstBlendMode=GL_ZERO; 
+                break;
+            case rendering::CompositeOperation::OUTSIDE:
+                o_action.meSrcBlendMode=GL_ONE_MINUS_DST_ALPHA; 
+                o_action.meDstBlendMode=GL_ONE; 
+                break;
+            case rendering::CompositeOperation::OUTSIDE_REVERSE:
+                o_action.meSrcBlendMode=GL_ZERO; 
+                o_action.meDstBlendMode=GL_ONE_MINUS_SRC_ALPHA; 
+                break;
+            case rendering::CompositeOperation::ATOP:
+                o_action.meSrcBlendMode=GL_DST_ALPHA; 
+                o_action.meDstBlendMode=GL_ONE_MINUS_SRC_ALPHA; 
+                break;
+            case rendering::CompositeOperation::ATOP_REVERSE:
+                o_action.meSrcBlendMode=GL_ONE_MINUS_DST_ALPHA; 
+                o_action.meDstBlendMode=GL_SRC_ALPHA; 
+                break;
+            case rendering::CompositeOperation::XOR:
+                o_action.meSrcBlendMode=GL_ONE_MINUS_DST_ALPHA; 
+                o_action.meDstBlendMode=GL_ONE_MINUS_SRC_ALPHA; 
+                break;
+            case rendering::CompositeOperation::ADD:
+                o_action.meSrcBlendMode=GL_ONE;
+                o_action.meDstBlendMode=GL_ONE;
+                break;
+            case rendering::CompositeOperation::SATURATE:
+                o_action.meSrcBlendMode=GL_SRC_ALPHA_SATURATE;
+                o_action.meDstBlendMode=GL_SRC_ALPHA_SATURATE;
+                break;
+                
+            default:
+                ENSURE_OR_THROW( false, "CanvasHelper::setupGraphicsState: unexpected mode" );
+                break;
+        }
+
+        o_action.maARGBColor = 
+            mpDevice->getDeviceColorSpace()->convertToARGB(renderState.DeviceColor)[0];
+    }
+
+    void CanvasHelper::flush() const
+    {
+    }
+
+    bool CanvasHelper::renderRecordedActions() const
+    {
+        std::vector<Action>::const_iterator aCurr(mpRecordedActions->begin());
+        const std::vector<Action>::const_iterator aEnd(mpRecordedActions->end());
+        while( aCurr != aEnd )
+        {
+            if( !aCurr->maFunction( *this,
+                                    aCurr->maTransform,
+                                    aCurr->meSrcBlendMode,
+                                    aCurr->meDstBlendMode,
+                                    aCurr->maARGBColor,
+                                    aCurr->maPolyPolys ) )
+                return false;
+
+            ++aCurr;
+        }
+
+        return true;
+    }
+}
diff --git canvas/source/opengl/ogl_canvashelper.hxx canvas/source/opengl/ogl_canvashelper.hxx
new file mode 100644
index 0000000..88ab9d9
--- /dev/null
+++ canvas/source/opengl/ogl_canvashelper.hxx
@@ -0,0 +1,237 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+#ifndef OGL_CANVASHELPER_HXX_
+#define OGL_CANVASHELPER_HXX_
+
+#include <com/sun/star/rendering/XCanvas.hpp>
+
+#include <basegfx/vector/b2isize.hxx>
+#include <basegfx/vector/b2dsize.hxx>
+
+#include <o3tl/cow_wrapper.hxx>
+#include <vector>
+
+namespace oglcanvas
+{
+    class SpriteDeviceHelper;
+
+    /** Helper class for basic canvas functionality. */
+    class CanvasHelper
+    {
+    public:
+        CanvasHelper();
+
+        // outline because of incomplete type Action 
+        ~CanvasHelper();
+        CanvasHelper& operator=( const CanvasHelper& );
+
+        /// Release all references
+        void disposing();
+
+        /** Initialize canvas helper
+
+            This method late-initializes the canvas helper, providing
+            it with the necessary device and output objects. Note that
+            the CanvasHelper does <em>not</em> take ownership of the
+            passed rDevice reference, nor does it perform any
+            reference counting. Thus, to prevent the reference counted
+            SpriteCanvas object from deletion, the user of this class
+            is responsible for holding ref-counted references itself!
+
+            @param rDevice
+            Reference device this canvas is associated with
+
+         */
+        void init( com::sun::star::rendering::XGraphicDevice& rDevice,
+                   SpriteDeviceHelper& rDeviceHelper );
+
+        // CanvasHelper functionality
+        // ==========================
+
+        // XCanvas (only providing, not implementing the
+        // interface. Also note subtle method parameter differences)
+        void clear();
+        void drawPoint( const ::com::sun::star::rendering::XCanvas*     pCanvas, 
+                        const ::com::sun::star::geometry::RealPoint2D&  aPoint, 
+                        const ::com::sun::star::rendering::ViewState&   viewState, 
+                        const ::com::sun::star::rendering::RenderState& renderState );
+        void drawLine( const ::com::sun::star::rendering::XCanvas*      pCanvas,
+                       const ::com::sun::star::geometry::RealPoint2D&   aStartPoint,
+                       const ::com::sun::star::geometry::RealPoint2D&   aEndPoint,
+                       const ::com::sun::star::rendering::ViewState&    viewState,
+                       const ::com::sun::star::rendering::RenderState&  renderState );
+        void drawBezier( const ::com::sun::star::rendering::XCanvas*            pCanvas,
+                         const ::com::sun::star::geometry::RealBezierSegment2D& aBezierSegment,
+                         const ::com::sun::star::geometry::RealPoint2D&         aEndPoint,
+                         const ::com::sun::star::rendering::ViewState&          viewState,
+                         const ::com::sun::star::rendering::RenderState&        renderState );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive >
+            drawPolyPolygon( const ::com::sun::star::rendering::XCanvas*            pCanvas,
+                             const ::com::sun::star::uno::Reference<
+                                    ::com::sun::star::rendering::XPolyPolygon2D >&  xPolyPolygon,
+                             const ::com::sun::star::rendering::ViewState&          viewState,
+                             const ::com::sun::star::rendering::RenderState&        renderState );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive >
+            strokePolyPolygon( const ::com::sun::star::rendering::XCanvas*          pCanvas,
+                               const ::com::sun::star::uno::Reference<
+                                    ::com::sun::star::rendering::XPolyPolygon2D >&  xPolyPolygon,
+                               const ::com::sun::star::rendering::ViewState&        viewState,
+                               const ::com::sun::star::rendering::RenderState&      renderState,
+                               const ::com::sun::star::rendering::StrokeAttributes& strokeAttributes );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive >
+            strokeTexturedPolyPolygon( const ::com::sun::star::rendering::XCanvas*          pCanvas,
+                                       const ::com::sun::star::uno::Reference<
+                                            ::com::sun::star::rendering::XPolyPolygon2D >&  xPolyPolygon,
+                                       const ::com::sun::star::rendering::ViewState&        viewState,
+                                       const ::com::sun::star::rendering::RenderState&      renderState,
+                                       const ::com::sun::star::uno::Sequence<
+                                            ::com::sun::star::rendering::Texture >&         textures,
+                                       const ::com::sun::star::rendering::StrokeAttributes& strokeAttributes );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive >
+            strokeTextureMappedPolyPolygon( const ::com::sun::star::rendering::XCanvas*             pCanvas,
+                                            const ::com::sun::star::uno::Reference<
+                                                    ::com::sun::star::rendering::XPolyPolygon2D >&  xPolyPolygon,
+                                            const ::com::sun::star::rendering::ViewState&           viewState,
+                                            const ::com::sun::star::rendering::RenderState&         renderState,
+                                            const ::com::sun::star::uno::Sequence<
+                                                    ::com::sun::star::rendering::Texture >&         textures,
+                                            const ::com::sun::star::uno::Reference<
+                                                    ::com::sun::star::geometry::XMapping2D >&       xMapping,
+                                            const ::com::sun::star::rendering::StrokeAttributes&    strokeAttributes );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >
+            queryStrokeShapes( const ::com::sun::star::rendering::XCanvas*          pCanvas,
+                               const ::com::sun::star::uno::Reference<
+                                    ::com::sun::star::rendering::XPolyPolygon2D >&  xPolyPolygon,
+                               const ::com::sun::star::rendering::ViewState&        viewState,
+                               const ::com::sun::star::rendering::RenderState&      renderState,
+                               const ::com::sun::star::rendering::StrokeAttributes& strokeAttributes );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive >
+            fillPolyPolygon( const ::com::sun::star::rendering::XCanvas*            pCanvas,
+                             const ::com::sun::star::uno::Reference<
+                                    ::com::sun::star::rendering::XPolyPolygon2D >&  xPolyPolygon,
+                             const ::com::sun::star::rendering::ViewState&          viewState,
+                             const ::com::sun::star::rendering::RenderState&        renderState );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive >
+            fillTexturedPolyPolygon( const ::com::sun::star::rendering::XCanvas*            pCanvas,
+                                     const ::com::sun::star::uno::Reference<
+                                            ::com::sun::star::rendering::XPolyPolygon2D >&  xPolyPolygon,
+                                     const ::com::sun::star::rendering::ViewState&          viewState,
+                                     const ::com::sun::star::rendering::RenderState&        renderState,
+                                     const ::com::sun::star::uno::Sequence<
+                                            ::com::sun::star::rendering::Texture >&         textures );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive >
+            fillTextureMappedPolyPolygon( const ::com::sun::star::rendering::XCanvas*           pCanvas,
+                                          const ::com::sun::star::uno::Reference<
+                                                ::com::sun::star::rendering::XPolyPolygon2D >&  xPolyPolygon,
+                                          const ::com::sun::star::rendering::ViewState&         viewState,
+                                          const ::com::sun::star::rendering::RenderState&       renderState,
+                                          const ::com::sun::star::uno::Sequence<
+                                                ::com::sun::star::rendering::Texture >&         textures,
+                                          const ::com::sun::star::uno::Reference<
+                                                ::com::sun::star::geometry::XMapping2D >&       xMapping );
+
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCanvasFont > SAL_CALL
+            createFont( const ::com::sun::star::rendering::XCanvas*             pCanvas,
+                        const ::com::sun::star::rendering::FontRequest&         fontRequest,
+                        const ::com::sun::star::uno::Sequence<
+                                ::com::sun::star::beans::PropertyValue >&       extraFontProperties,
+                        const ::com::sun::star::geometry::Matrix2D&             fontMatrix );
+
+        ::com::sun::star::uno::Sequence< ::com::sun::star::rendering::FontInfo >
+            queryAvailableFonts( const ::com::sun::star::rendering::XCanvas*        pCanvas,
+                                 const ::com::sun::star::rendering::FontInfo&       aFilter,
+                                 const ::com::sun::star::uno::Sequence<
+                                        ::com::sun::star::beans::PropertyValue >&   aFontProperties );
+
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive >
+            drawText( const ::com::sun::star::rendering::XCanvas*           pCanvas,
+                      const ::com::sun::star::rendering::StringContext&     text,
+                      const ::com::sun::star::uno::Reference<
+                            ::com::sun::star::rendering::XCanvasFont >&     xFont,
+                      const ::com::sun::star::rendering::ViewState&         viewState,
+                      const ::com::sun::star::rendering::RenderState&       renderState,
+                      sal_Int8                                              textDirection );
+
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive >
+            drawTextLayout( const ::com::sun::star::rendering::XCanvas*     pCanvas,
+                            const ::com::sun::star::uno::Reference<
+                                ::com::sun::star::rendering::XTextLayout >& layoutetText,
+                            const ::com::sun::star::rendering::ViewState&   viewState,
+                            const ::com::sun::star::rendering::RenderState& renderState );
+
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive >
+            drawBitmap( const ::com::sun::star::rendering::XCanvas*     pCanvas,
+                        const ::com::sun::star::uno::Reference<
+                                ::com::sun::star::rendering::XBitmap >& xBitmap,
+                        const ::com::sun::star::rendering::ViewState&   viewState,
+                        const ::com::sun::star::rendering::RenderState& renderState );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive >
+            drawBitmapModulated( const ::com::sun::star::rendering::XCanvas*        pCanvas,
+                                 const ::com::sun::star::uno::Reference<
+                                        ::com::sun::star::rendering::XBitmap >&     xBitmap,
+                                 const ::com::sun::star::rendering::ViewState&      viewState,
+                                 const ::com::sun::star::rendering::RenderState&    renderState );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XGraphicDevice >
+            getDevice();
+
+        // Flush drawing queue to screen
+        void                    flush() const;
+
+        /** Called from XCanvas base classes, to notify that content
+            is _about_ to change
+        */
+        void modifying() {}
+
+        /** Write out recorded actions
+         */
+        bool renderRecordedActions() const;
+
+        SpriteDeviceHelper* getDeviceHelper() const { return mpDeviceHelper; }
+
+    private:
+        // declared, but not defined
+        CanvasHelper( const CanvasHelper& );
+
+        struct Action;
+        typedef o3tl::cow_wrapper< std::vector<Action>,
+                                   o3tl::ThreadSafeRefCountingPolicy > RecordVectorT;
+
+        void setupGraphicsState( Action&                                         o_action,
+                                 const ::com::sun::star::rendering::ViewState&   viewState, 
+                                 const ::com::sun::star::rendering::RenderState& renderState );
+
+        /** Phyical output device
+
+            Deliberately not a refcounted reference, because of
+            potential circular references for spritecanvas.
+         */
+        ::com::sun::star::rendering::XGraphicDevice* mpDevice;
+
+        /** Internal helper - used for a few global GL objects,
+            e.g. shader programs
+         */
+        SpriteDeviceHelper*                          mpDeviceHelper;
+
+        /** Ptr to array of recorded render calls
+
+            Gets shared copy-on-write, when this CanvasHelper is
+            copied (used e.g. for CanvasBitmap)
+         */
+        RecordVectorT                                mpRecordedActions;
+    };
+}
+
+#endif
diff --git canvas/source/opengl/ogl_spritecanvas.cxx canvas/source/opengl/ogl_spritecanvas.cxx
new file mode 100644
index 0000000..275adbc
--- /dev/null
+++ canvas/source/opengl/ogl_spritecanvas.cxx
@@ -0,0 +1,202 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_canvas.hxx"
+
+#include "ogl_spritecanvas.hxx"
+
+#include <canvas/debug.hxx>
+#include <canvas/verbosetrace.hxx>
+#include <tools/diagnose_ex.h>
+
+#include <osl/mutex.hxx>
+
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/registry/XRegistryKey.hpp>
+#include <com/sun/star/lang/XSingleServiceFactory.hpp>
+#include <com/sun/star/lang/NoSupportException.hpp>
+
+#include <toolkit/helper/vclunohelper.hxx>
+#include <cppuhelper/factory.hxx>
+#include <cppuhelper/implementationentry.hxx>
+#include <comphelper/servicedecl.hxx>
+
+#include "ogl_canvascustomsprite.hxx"
+
+#include <GL/gl.h>
+#include <GL/glext.h>
+
+#define SPRITECANVAS_SERVICE_NAME        "com.sun.star.rendering.SpriteCanvas.OGL"
+#define SPRITECANVAS_IMPLEMENTATION_NAME "com.sun.star.comp.rendering.SpriteCanvas.OGL"
+
+
+using namespace ::com::sun::star;
+
+namespace oglcanvas
+{
+    SpriteCanvas::SpriteCanvas( const uno::Sequence< uno::Any >&                aArguments,
+                                const uno::Reference< uno::XComponentContext >& rxContext ) :
+        maArguments(aArguments),
+        mxComponentContext( rxContext )
+    {
+    }
+
+    void SpriteCanvas::initialize()
+    {
+        // Only call initialize when not in probe mode
+        if( maArguments.getLength() == 0 )
+            return;
+
+        VERBOSE_TRACE( "SpriteCanvas::initialize called" );
+
+        /* aArguments:
+           0: ptr to creating instance (Window or VirtualDevice)
+           1: SystemEnvData as a streamed Any (or empty for VirtualDevice)
+           2: current bounds of creating instance
+           3: bool, denoting always on top state for Window (always false for VirtualDevice)
+           4: XWindow for creating Window (or empty for VirtualDevice)
+           5: SystemGraphicsData as a streamed Any
+         */
+        ENSURE_ARG_OR_THROW( maArguments.getLength() >= 5 &&
+                             maArguments[4].getValueTypeClass() == uno::TypeClass_INTERFACE, 
+                             "OpenGL SpriteCanvas::initialize: wrong number of arguments, or wrong types" );
+
+        uno::Reference< awt::XWindow > xParentWindow;
+        maArguments[4] >>= xParentWindow;
+        Window* pParentWindow = VCLUnoHelper::GetWindow(xParentWindow);
+        if( !pParentWindow )
+            throw lang::NoSupportException(
+                ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(
+                                     "Parent window not VCL window, or canvas out-of-process!")),
+                NULL);            
+
+        awt::Rectangle aRect;
+        maArguments[2] >>= aRect;
+
+        // setup helper
+        maDeviceHelper.init( *pParentWindow,
+                             *this,
+                             aRect );
+        maCanvasHelper.init( *this, maDeviceHelper );
+        maArguments.realloc(0);
+    }
+
+    void SAL_CALL SpriteCanvas::disposing()
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        mxComponentContext.clear();
+
+        // forward to parent
+        SpriteCanvasBaseT::disposing();
+    }
+
+    ::sal_Bool SAL_CALL SpriteCanvas::showBuffer( ::sal_Bool bUpdateAll ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // avoid repaints on hidden window (hidden: not mapped to
+        // screen). Return failure, since the screen really has _not_
+        // been updated (caller should try again later)
+        return !mbIsVisible ? false : SpriteCanvasBaseT::showBuffer( bUpdateAll );
+    }
+
+    ::sal_Bool SAL_CALL SpriteCanvas::switchBuffer( ::sal_Bool bUpdateAll ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // avoid repaints on hidden window (hidden: not mapped to
+        // screen). Return failure, since the screen really has _not_
+        // been updated (caller should try again later)
+        return !mbIsVisible ? false : SpriteCanvasBaseT::switchBuffer( bUpdateAll );
+    }
+
+    uno::Reference< rendering::XAnimatedSprite > SAL_CALL SpriteCanvas::createSpriteFromAnimation( 
+        const uno::Reference< rendering::XAnimation >& /*animation*/ ) throw (lang::IllegalArgumentException, 
+                                                                              uno::RuntimeException)
+    {
+        return uno::Reference< rendering::XAnimatedSprite >();
+    }
+
+    uno::Reference< rendering::XAnimatedSprite > SAL_CALL SpriteCanvas::createSpriteFromBitmaps( 
+        const uno::Sequence< uno::Reference< rendering::XBitmap > >& /*animationBitmaps*/, 
+        ::sal_Int8 /*interpolationMode*/ ) throw (lang::IllegalArgumentException, 
+                                                  rendering::VolatileContentDestroyedException, 
+                                                  uno::RuntimeException)
+    {
+        return uno::Reference< rendering::XAnimatedSprite >();
+    }
+
+    uno::Reference< rendering::XCustomSprite > SAL_CALL SpriteCanvas::createCustomSprite( 
+        const geometry::RealSize2D& spriteSize ) throw (lang::IllegalArgumentException, 
+                                                        uno::RuntimeException)
+    {
+        return uno::Reference< rendering::XCustomSprite >( 
+            new CanvasCustomSprite(spriteSize, this, maDeviceHelper) );
+    }
+
+    uno::Reference< rendering::XSprite > SAL_CALL SpriteCanvas::createClonedSprite( 
+        const uno::Reference< rendering::XSprite >& /*original*/ ) throw (lang::IllegalArgumentException, 
+                                                                          uno::RuntimeException)
+    {
+        return uno::Reference< rendering::XSprite >();
+    }
+
+    sal_Bool SAL_CALL SpriteCanvas::updateScreen( sal_Bool bUpdateAll ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+        return maDeviceHelper.showBuffer(mbIsVisible, bUpdateAll);
+    }
+
+    ::rtl::OUString SAL_CALL SpriteCanvas::getServiceName(  ) throw (uno::RuntimeException)
+    {
+        return ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( SPRITECANVAS_SERVICE_NAME ) );
+    }
+
+    void SpriteCanvas::show( const ::rtl::Reference< CanvasCustomSprite >& xSprite )
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+        maDeviceHelper.show(xSprite);
+    }
+
+    void SpriteCanvas::hide( const ::rtl::Reference< CanvasCustomSprite >& xSprite )
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+        maDeviceHelper.hide(xSprite);
+    }
+
+    bool SpriteCanvas::renderRecordedActions() const
+    {
+        return maCanvasHelper.renderRecordedActions();
+    }
+
+    static uno::Reference<uno::XInterface> initCanvas( SpriteCanvas* pCanvas )
+    {
+        uno::Reference<uno::XInterface> xRet(static_cast<cppu::OWeakObject*>(pCanvas));
+        pCanvas->initialize();
+        return xRet;
+    }
+
+    namespace sdecl = comphelper::service_decl;
+    sdecl::class_<SpriteCanvas, sdecl::with_args<true> > serviceImpl(&initCanvas);
+    const sdecl::ServiceDecl oglSpriteCanvasDecl(
+        serviceImpl,
+        SPRITECANVAS_IMPLEMENTATION_NAME,
+        SPRITECANVAS_SERVICE_NAME );
+}
+
+// The C shared lib entry points
+COMPHELPER_SERVICEDECL_EXPORTS1(oglcanvas::oglSpriteCanvasDecl);
diff --git canvas/source/opengl/ogl_spritecanvas.hxx canvas/source/opengl/ogl_spritecanvas.hxx
new file mode 100644
index 0000000..ea14bc7
--- /dev/null
+++ canvas/source/opengl/ogl_spritecanvas.hxx
@@ -0,0 +1,126 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+#ifndef OGL_SPRITECANVAS_HXX_
+#define OGL_SPRITECANVAS_HXX_
+
+#include <rtl/ref.hxx>
+
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/lang/XServiceName.hpp>
+#include <com/sun/star/awt/XWindowListener.hpp>
+#include <com/sun/star/util/XUpdatable.hpp>
+#include <com/sun/star/rendering/XSpriteCanvas.hpp>
+#include <com/sun/star/rendering/XGraphicDevice.hpp>
+#include <com/sun/star/rendering/XBufferController.hpp>
+#include <com/sun/star/rendering/XParametricPolyPolygon2DFactory.hpp>
+
+#include <cppuhelper/compbase8.hxx>
+#include <comphelper/uno3.hxx>
+
+#include <canvas/base/spritecanvasbase.hxx>
+#include <canvas/base/basemutexhelper.hxx>
+#include <canvas/base/bufferedgraphicdevicebase.hxx>
+
+#include "ogl_spritedevicehelper.hxx"
+#include "ogl_canvashelper.hxx"
+
+
+namespace oglcanvas
+{
+    class CanvasCustomSprite;
+
+    typedef ::cppu::WeakComponentImplHelper8< ::com::sun::star::rendering::XSpriteCanvas,
+                                              ::com::sun::star::rendering::XGraphicDevice,
+                                              ::com::sun::star::rendering::XParametricPolyPolygon2DFactory,
+                                              ::com::sun::star::rendering::XBufferController,
+                                              ::com::sun::star::awt::XWindowListener,
+                                              ::com::sun::star::util::XUpdatable,
+                                              ::com::sun::star::beans::XPropertySet,
+                                              ::com::sun::star::lang::XServiceName >    WindowGraphicDeviceBase_Base;
+    typedef ::canvas::BufferedGraphicDeviceBase< ::canvas::BaseMutexHelper< WindowGraphicDeviceBase_Base >,
+                                                 SpriteDeviceHelper, 
+                                                 ::osl::MutexGuard,
+                                                 ::cppu::OWeakObject >  SpriteCanvasDeviceBaseT;
+
+	typedef ::canvas::CanvasBase< SpriteCanvasDeviceBaseT,
+                                  CanvasHelper,
+                                  ::osl::MutexGuard,
+                                  ::cppu::OWeakObject >			SpriteCanvasBaseT;
+
+    /** Product of this component's factory.
+
+        The SpriteCanvas object combines the actual Window canvas with
+        the XGraphicDevice interface. This is because there's a
+        one-to-one relation between them, anyway, since each window
+        can have exactly one canvas and one associated
+        XGraphicDevice. And to avoid messing around with circular
+        references, this is implemented as one single object.
+     */
+    class SpriteCanvas : public SpriteCanvasBaseT
+    {
+    public:
+        SpriteCanvas( const ::com::sun::star::uno::Sequence< 
+                            ::com::sun::star::uno::Any >&               aArguments,
+                      const ::com::sun::star::uno::Reference< 
+                            ::com::sun::star::uno::XComponentContext >& rxContext );
+
+        void initialize();
+
+#if defined __SUNPRO_CC
+        using SpriteCanvasBaseT::disposing;
+#endif
+
+        /// Dispose all internal references
+        virtual void SAL_CALL disposing();
+
+        // Forwarding the XComponent implementation to the
+        // cppu::ImplHelper templated base
+        //                                    Classname     Base doing refcounting        Base implementing the XComponent interface
+        //                                       |                 |                            |
+        //                                       V                 V                            V
+        DECLARE_UNO3_XCOMPONENT_AGG_DEFAULTS( SpriteCanvas, WindowGraphicDeviceBase_Base, ::cppu::WeakComponentImplHelperBase );
+
+        // XBufferController (partial)
+        virtual ::sal_Bool SAL_CALL showBuffer( ::sal_Bool bUpdateAll ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::sal_Bool SAL_CALL switchBuffer( ::sal_Bool bUpdateAll ) throw (::com::sun::star::uno::RuntimeException);
+
+        // XSpriteCanvas
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XAnimatedSprite > SAL_CALL createSpriteFromAnimation( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XAnimation >& animation ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XAnimatedSprite > SAL_CALL createSpriteFromBitmaps( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmap > >& animationBitmaps, ::sal_Int8 interpolationMode ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::rendering::VolatileContentDestroyedException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCustomSprite > SAL_CALL createCustomSprite( const ::com::sun::star::geometry::RealSize2D& spriteSize ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XSprite > SAL_CALL createClonedSprite( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XSprite >& original ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::sal_Bool SAL_CALL updateScreen( ::sal_Bool bUpdateAll ) throw (::com::sun::star::uno::RuntimeException);
+
+        // XServiceName
+        virtual ::rtl::OUString SAL_CALL getServiceName(  ) throw (::com::sun::star::uno::RuntimeException);
+
+        void show( const ::rtl::Reference< CanvasCustomSprite >& );
+        void hide( const ::rtl::Reference< CanvasCustomSprite >& );
+
+        /** Write out recorded actions
+         */
+        bool renderRecordedActions() const;        
+
+    private:
+        ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >                maArguments;
+        ::com::sun::star::uno::Reference< ::com::sun::star::uno::XComponentContext > mxComponentContext;
+    };
+
+    typedef ::rtl::Reference< SpriteCanvas > SpriteCanvasRef;
+}
+
+#endif
diff --git canvas/source/opengl/ogl_spritedevicehelper.cxx canvas/source/opengl/ogl_spritedevicehelper.cxx
new file mode 100644
index 0000000..8e8fb5d
--- /dev/null
+++ canvas/source/opengl/ogl_spritedevicehelper.cxx
@@ -0,0 +1,658 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *      Radek Doulik <rodo@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_canvas.hxx"
+
+#include "ogl_spritedevicehelper.hxx"
+#include "ogl_spritecanvas.hxx"
+#include "ogl_canvasbitmap.hxx"
+#include "ogl_canvascustomsprite.hxx"
+
+#include <canvas/verbosetrace.hxx>
+#include <basegfx/tools/canvastools.hxx>
+#include <basegfx/tools/unopolypolygon.hxx>
+
+#include <osl/mutex.hxx>
+#include <rtl/instance.hxx>
+#include <com/sun/star/uno/Reference.hxx>
+#include <com/sun/star/lang/NoSupportException.hpp>
+#include <com/sun/star/rendering/XColorSpace.hpp>
+#include <com/sun/star/rendering/XIntegerBitmapColorSpace.hpp>
+
+#include <vcl/sysdata.hxx>
+#include <vcl/syschild.hxx>
+#include <vcl/canvastools.hxx>
+#include <toolkit/helper/vclunohelper.hxx>
+
+#define GL_GLEXT_PROTOTYPES
+#include <GL/gl.h>
+#include <GL/glu.h>
+#include <GL/glext.h>
+
+namespace unx
+{
+ #include <X11/keysym.h>
+ #include <X11/X.h>
+ #include <GL/glx.h>
+ #include <GL/glxext.h>
+}
+
+
+using namespace ::com::sun::star;
+
+static bool lcl_bErrorTriggered=false;
+static int lcl_XErrorHandler( unx::Display*, unx::XErrorEvent* )
+{
+    lcl_bErrorTriggered = true;
+    return 0;
+}
+
+/** Dummy vertex processing. Simply uses default pipeline for vertex
+   transformation, and forwards texture coodinates to fragment shader
+ */
+static const char dummyVertexShader[] = 
+{
+    "varying vec2 v_textureCoords2d;                                            "
+    "void main(void)                                                            "
+    "{                                                                          "
+	"    gl_Position = ftransform();                                            "
+	"    v_textureCoords2d = gl_MultiTexCoord0.st;                              "
+    "}                                                                          "
+};
+
+/** Two-color linear gradient
+ */
+static const char linearGradientFragmentShader[] = 
+{
+    "uniform vec4 v_startColor4d;                                               "
+    "uniform vec4 v_endColor4d;                                                 "
+    "varying vec2 v_textureCoords2d;                                            "
+    "void main(void)                                                            "
+    "{                                                                          "
+	"    gl_FragColor = mix(v_startColor4d,                                     "
+    "                       v_endColor4d,                                       "
+    "                       v_textureCoords2d.s);                               "
+    "}                                                                          "
+};
+
+namespace oglcanvas
+{
+    /** Compile shader program
+
+        Code courtesy rodo
+     */
+    void SpriteDeviceHelper::compileShader(unsigned int& o_rShaderHandle,
+                                           unsigned int  eShaderType, 
+                                           const char*   pShaderSourceCode)
+    {
+        GLint nCompileStatus;
+        char log[1024];
+
+        o_rShaderHandle = glCreateShader( eShaderType );
+        glShaderSource( o_rShaderHandle, 1, &pShaderSourceCode, NULL );
+        glCompileShader( o_rShaderHandle );
+        glGetShaderInfoLog( o_rShaderHandle, sizeof(log), NULL, log );
+        OSL_TRACE("shader compile log: %s", log);
+
+        glGetShaderiv( o_rShaderHandle, GL_COMPILE_STATUS, &nCompileStatus );
+        if( !nCompileStatus )
+        {
+            glDeleteShader(o_rShaderHandle);
+            o_rShaderHandle=0;
+        }
+    }
+
+    /** Link vertex & fragment shaders
+
+        Code courtesy rodo
+     */
+    void SpriteDeviceHelper::linkShaders(unsigned int& o_rProgramHandle,
+                                         unsigned int  nVertexProgramId, 
+                                         unsigned int  nFragmentProgramId)
+    {
+        if( !nVertexProgramId || !nFragmentProgramId )
+            return;
+
+        o_rProgramHandle = glCreateProgram();
+        glAttachShader( o_rProgramHandle, nVertexProgramId );
+        glAttachShader( o_rProgramHandle, nFragmentProgramId );
+
+        char log[1024];
+        GLint nProgramLinked;
+
+        glLinkProgram( o_rProgramHandle );
+        glGetProgramInfoLog( o_rProgramHandle, sizeof(log), NULL, log );
+        OSL_TRACE("shader program link log: %s", log);
+        glGetProgramiv( o_rProgramHandle, GL_LINK_STATUS, &nProgramLinked );
+
+        if( !nProgramLinked )
+        {
+            glDeleteProgram(o_rProgramHandle);
+            o_rProgramHandle=0;
+        }
+    }
+
+    SpriteDeviceHelper::SpriteDeviceHelper() :
+        mpDevice(NULL),
+        mpSpriteCanvas(NULL),
+        maActiveSprites(),
+        mpChildWindow(),
+        mpDisplay(NULL),
+        mpGLContext(NULL),
+        mnDummyVertexProgram(0),
+        mnLinearGradientFragmentProgram(0),
+        mnLinearGradientProgram(0)
+    {}
+
+    void SpriteDeviceHelper::init( Window&               rWindow,
+                                   SpriteCanvas&         rSpriteCanvas,
+                                   const awt::Rectangle& rViewArea )
+    {
+        mpSpriteCanvas = &rSpriteCanvas;
+
+        rSpriteCanvas.setWindow(
+            uno::Reference<awt::XWindow2>(
+                VCLUnoHelper::GetInterface(&rWindow),
+                uno::UNO_QUERY_THROW) );
+
+        // init OpenGL
+        const SystemEnvData* sysData(rWindow.GetSystemData());
+        unx::Display* pDisplay=reinterpret_cast<unx::Display*>(sysData->pDisplay);
+        mpDisplay=pDisplay;
+        if( !unx::glXQueryExtension(pDisplay, NULL, NULL) )
+            return;
+
+        unx::Window xWindow = sysData->aWindow;
+        unx::XWindowAttributes xAttr;
+        unx::XGetWindowAttributes( pDisplay, xWindow, &xAttr );
+        int nScreen = XScreenNumberOfScreen( xAttr.screen );
+
+        // select appropriate visual
+        static int attrList3[] =
+            {
+                GLX_RGBA,//only TrueColor or DirectColor
+                //single buffered
+                GLX_RED_SIZE,4,//use the maximum red bits, with a minimum of 4 bits
+                GLX_GREEN_SIZE,4,//use the maximum green bits, with a minimum of 4 bits
+                GLX_BLUE_SIZE,4,//use the maximum blue bits, with a minimum of 4 bits
+                GLX_DEPTH_SIZE,0,//no depth buffer
+                None
+            };
+        static int attrList2[] = 
+            {
+                GLX_RGBA,//only TrueColor or DirectColor
+                /// single buffered
+                GLX_RED_SIZE,4,/// use the maximum red bits, with a minimum of 4 bits
+                GLX_GREEN_SIZE,4,/// use the maximum green bits, with a minimum of 4 bits
+                GLX_BLUE_SIZE,4,/// use the maximum blue bits, with a minimum of 4 bits
+                GLX_DEPTH_SIZE,1,/// use the maximum depth bits, making sure there is a depth buffer
+                None
+            };
+        static int attrList1[] =
+            {
+                GLX_RGBA,//only TrueColor or DirectColor
+                GLX_DOUBLEBUFFER,/// only double buffer
+                GLX_RED_SIZE,4,/// use the maximum red bits, with a minimum of 4 bits
+                GLX_GREEN_SIZE,4,/// use the maximum green bits, with a minimum of 4 bits
+                GLX_BLUE_SIZE,4,/// use the maximum blue bits, with a minimum of 4 bits
+                GLX_DEPTH_SIZE,0,/// no depth buffer
+                None
+            };
+        static int attrList0[] =
+            {
+                GLX_RGBA,//only TrueColor or DirectColor
+                GLX_DOUBLEBUFFER,/// only double buffer
+                GLX_RED_SIZE,4,/// use the maximum red bits, with a minimum of 4 bits
+                GLX_GREEN_SIZE,4,/// use the maximum green bits, with a minimum of 4 bits
+                GLX_BLUE_SIZE,4,/// use the maximum blue bits, with a minimum of 4 bits
+                GLX_DEPTH_SIZE,1,/// use the maximum depth bits, making sure there is a depth buffer
+                None
+            }; 
+        static int* attrTable[] = 
+            {
+                attrList0,
+                attrList1,
+                attrList2,
+                attrList3,
+                NULL
+            };
+        int** pAttributeTable = attrTable;
+        
+        unx::Window childXWindow=0;
+        unx::XVisualInfo* vi=NULL;
+        while( *pAttributeTable )
+        {
+            // try to find a visual for the current set of attributes
+            vi = unx::glXChooseVisual( pDisplay,
+                                       nScreen,
+                                       *pAttributeTable );
+            if( vi ) 
+            {
+                SystemWindowData winData;
+                winData.nSize = sizeof(winData);
+                OSL_TRACE("using VisualID %08X for OpenGL canvas", vi->visualid);
+                winData.pVisual = (void*)(vi->visual);
+                mpChildWindow.reset( new SystemChildWindow(&rWindow, 0, &winData, FALSE) );
+                if( mpChildWindow->GetSystemData() )
+                    break;
+                else
+                    mpChildWindow.reset();
+            }
+
+            ++pAttributeTable;
+        }
+
+        // tweak SysChild window to act as an input-transparent
+        // overlay
+        if( mpChildWindow )
+        {
+            childXWindow=mpChildWindow->GetSystemData()->aWindow;
+            mpChildWindow->SetMouseTransparent( TRUE );
+            mpChildWindow->SetParentClipMode( PARENTCLIPMODE_NOCLIP );
+            mpChildWindow->EnableEraseBackground( FALSE );
+            mpChildWindow->SetControlForeground();
+            mpChildWindow->SetControlBackground();
+            mpChildWindow->EnablePaint(FALSE);
+
+            unx::GLXContext pContext = 
+                glXCreateContext(pDisplay,
+                                 vi,
+                                 0,
+                                 GL_TRUE);
+            mpGLContext = pContext;
+
+            if( !glXMakeCurrent( pDisplay,
+                                 childXWindow,
+                                 pContext) )
+            {
+                glXDestroyContext(pDisplay,
+                                  pContext);
+                throw lang::NoSupportException(
+                    ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(
+                                         "Could not select OpenGL context!") ),NULL);
+            }
+
+            const GLubyte* extensions=glGetString( GL_EXTENSIONS );
+            if( gluCheckExtension((const GLubyte*)"GLX_SGI_swap_control", extensions) )
+            {
+                // try to enable vsync
+                typedef GLint (*glXSwapIntervalProc)(GLint);
+                glXSwapIntervalProc glXSwapInterval = 
+                    (glXSwapIntervalProc) unx::glXGetProcAddress((const GLubyte*)"glXSwapIntervalSGI");
+                if( glXSwapInterval ) 
+                {
+                    int (*oldHandler)(unx::Display*, unx::XErrorEvent*);
+
+                    // synchronize on global mutex - no other ogl
+                    // canvas instance permitted to enter here
+                    {
+                        ::osl::MutexGuard aGuard( *::osl::Mutex::getGlobalMutex() );
+                    
+                        // replace error handler temporarily
+                        oldHandler = unx::XSetErrorHandler( lcl_XErrorHandler );
+
+                        lcl_bErrorTriggered = false;
+
+                        // Note: if this fails, so be it. Buggy
+                        // drivers will then not have vsync.
+                        glXSwapInterval(1);
+
+                        // sync so that we possibly get an XError
+                        unx::glXWaitGL();
+                        XSync(pDisplay, false);
+
+                        unx::XSetErrorHandler( oldHandler );
+                    }
+                }
+            }
+
+            // need the backside for mirror effects
+            glDisable(GL_CULL_FACE);
+
+            // no perspective, we're 2D 
+            glMatrixMode(GL_PROJECTION);
+            glLoadIdentity();
+
+            // misc preferences
+            glEnable(GL_POINT_SMOOTH);
+            glEnable(GL_LINE_SMOOTH);
+            glEnable(GL_POLYGON_SMOOTH);
+            glHint(GL_POINT_SMOOTH_HINT,GL_NICEST);
+            glHint(GL_LINE_SMOOTH_HINT,GL_NICEST);
+            glHint(GL_POLYGON_SMOOTH_HINT,GL_NICEST);
+            glShadeModel(GL_FLAT);
+
+            // compile & link shaders - code courtesy rodo
+            compileShader(mnDummyVertexProgram, 
+                          GL_VERTEX_SHADER, 
+                          dummyVertexShader);
+            compileShader(mnLinearGradientFragmentProgram, 
+                          GL_FRAGMENT_SHADER, 
+                          linearGradientFragmentShader);
+            linkShaders(mnLinearGradientProgram,
+                        mnDummyVertexProgram,
+                        mnLinearGradientFragmentProgram);
+
+            glXMakeCurrent(pDisplay, None, NULL);
+        }
+
+        if( !mpGLContext )
+            throw lang::NoSupportException(
+                ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(
+                                     "Could not create OpenGL context!") ),NULL);
+
+        notifySizeUpdate(rViewArea);
+        mpChildWindow->Show();
+        // TODO(E3): check for GL_ARB_imaging extension
+    }
+
+    void SpriteDeviceHelper::disposing()
+    {
+        // release all references
+        mpSpriteCanvas = NULL;
+        mpDevice = NULL;
+
+        if( mpGLContext )
+        {
+            glDeleteProgram( mnLinearGradientProgram );
+            glDeleteShader( mnLinearGradientFragmentProgram );
+            glDeleteShader( mnDummyVertexProgram );
+
+            glXDestroyContext(reinterpret_cast<unx::Display*>(mpDisplay), 
+                              reinterpret_cast<unx::GLXContext>(mpGLContext));
+        }
+
+        mpDisplay = NULL;
+        mpGLContext = NULL;
+        mpChildWindow.reset();
+    }
+
+    geometry::RealSize2D SpriteDeviceHelper::getPhysicalResolution()
+    {
+        if( !mpChildWindow )
+            return ::canvas::tools::createInfiniteSize2D(); // we're disposed
+
+        // Map a one-by-one millimeter box to pixel
+        const MapMode aOldMapMode( mpChildWindow->GetMapMode() );
+        mpChildWindow->SetMapMode( MapMode(MAP_MM) );
+        const Size aPixelSize( mpChildWindow->LogicToPixel(Size(1,1)) );
+        mpChildWindow->SetMapMode( aOldMapMode );
+
+        return ::vcl::unotools::size2DFromSize( aPixelSize );
+    }
+
+    geometry::RealSize2D SpriteDeviceHelper::getPhysicalSize()
+    {
+        if( !mpChildWindow )
+            return ::canvas::tools::createInfiniteSize2D(); // we're disposed
+
+        // Map the pixel dimensions of the output window to millimeter
+        const MapMode aOldMapMode( mpChildWindow->GetMapMode() );
+        mpChildWindow->SetMapMode( MapMode(MAP_MM) );
+        const Size aLogSize( mpChildWindow->PixelToLogic(mpChildWindow->GetOutputSizePixel()) );
+        mpChildWindow->SetMapMode( aOldMapMode );
+
+        return ::vcl::unotools::size2DFromSize( aLogSize );
+    }
+
+    uno::Reference< rendering::XLinePolyPolygon2D > SpriteDeviceHelper::createCompatibleLinePolyPolygon( 
+        const uno::Reference< rendering::XGraphicDevice >& 				/*rDevice*/,
+        const uno::Sequence< uno::Sequence< geometry::RealPoint2D > >&	points )
+    {
+        // disposed?
+        if( !mpSpriteCanvas )
+            return uno::Reference< rendering::XLinePolyPolygon2D >(); // we're disposed
+
+        return uno::Reference< rendering::XLinePolyPolygon2D >( 
+            new ::basegfx::unotools::UnoPolyPolygon( 
+                ::basegfx::unotools::polyPolygonFromPoint2DSequenceSequence( points )));
+    }
+
+    uno::Reference< rendering::XBezierPolyPolygon2D > SpriteDeviceHelper::createCompatibleBezierPolyPolygon( 
+        const uno::Reference< rendering::XGraphicDevice >& 						/*rDevice*/,
+        const uno::Sequence< uno::Sequence< geometry::RealBezierSegment2D > >&	points )
+    {
+        // disposed?
+        if( !mpSpriteCanvas )
+            return uno::Reference< rendering::XBezierPolyPolygon2D >(); // we're disposed
+
+        return uno::Reference< rendering::XBezierPolyPolygon2D >( 
+            new ::basegfx::unotools::UnoPolyPolygon( 
+                ::basegfx::unotools::polyPolygonFromBezier2DSequenceSequence( points ) ) );
+    }
+
+    uno::Reference< rendering::XBitmap > SpriteDeviceHelper::createCompatibleBitmap( 
+        const uno::Reference< rendering::XGraphicDevice >& 	/*rDevice*/,
+        const geometry::IntegerSize2D& 						size )
+    {
+        // disposed?
+        if( !mpSpriteCanvas )
+            return uno::Reference< rendering::XBitmap >(); // we're disposed
+
+        return uno::Reference< rendering::XBitmap >(
+            new CanvasBitmap( size,
+                              mpSpriteCanvas,
+                              *this,
+                              false ) );
+    }
+
+    uno::Reference< rendering::XVolatileBitmap > SpriteDeviceHelper::createVolatileBitmap( 
+        const uno::Reference< rendering::XGraphicDevice >& 	/*rDevice*/,
+        const geometry::IntegerSize2D& 						/*size*/ )
+    {
+        return uno::Reference< rendering::XVolatileBitmap >();
+    }
+
+    uno::Reference< rendering::XBitmap > SpriteDeviceHelper::createCompatibleAlphaBitmap( 
+        const uno::Reference< rendering::XGraphicDevice >& 	/*rDevice*/,
+        const geometry::IntegerSize2D& 						size )
+    {
+        // disposed?
+        if( !mpSpriteCanvas )
+            return uno::Reference< rendering::XBitmap >(); // we're disposed
+
+        return uno::Reference< rendering::XBitmap >(
+            new CanvasBitmap( size,
+                              mpSpriteCanvas,
+                              *this,
+                              true ) );
+    }
+
+    uno::Reference< rendering::XVolatileBitmap > SpriteDeviceHelper::createVolatileAlphaBitmap( 
+        const uno::Reference< rendering::XGraphicDevice >& 	/*rDevice*/,
+        const geometry::IntegerSize2D& 						/*size*/ )
+    {
+        return uno::Reference< rendering::XVolatileBitmap >();
+    }
+
+    sal_Bool SpriteDeviceHelper::hasFullScreenMode()
+    {
+        // TODO(F3): offer fullscreen mode the XCanvas way
+        return false;
+    }
+
+    sal_Bool SpriteDeviceHelper::enterFullScreenMode( sal_Bool /*bEnter*/ )
+    {
+        // TODO(F3): offer fullscreen mode the XCanvas way
+        return false;
+    }
+    
+    ::sal_Int32 SpriteDeviceHelper::createBuffers( ::sal_Int32 /*nBuffers*/ )
+    {
+        // TODO(F3): implement XBufferStrategy interface. For now, we
+        // _always_ will have exactly one backbuffer
+        return 1;
+    }
+
+    void SpriteDeviceHelper::destroyBuffers()
+    {
+        // TODO(F3): implement XBufferStrategy interface. For now, we
+        // _always_ will have exactly one backbuffer
+    }
+
+    namespace
+    {
+        /** Functor providing a StrictWeakOrdering for XSprites (over
+            priority)
+         */
+        struct SpriteComparator
+        {
+            bool operator()( const ::rtl::Reference<CanvasCustomSprite>& rLHS,
+                             const ::rtl::Reference<CanvasCustomSprite>& rRHS ) const
+            {
+                const double nPrioL( rLHS->getPriority() );
+                const double nPrioR( rRHS->getPriority() );
+            
+                // if prios are equal, tie-break on ptr value   
+                return nPrioL == nPrioR ? rLHS.get() < rRHS.get() : nPrioL < nPrioR;
+            }
+        };
+    }
+
+    ::sal_Bool SpriteDeviceHelper::showBuffer( bool bIsVisible, ::sal_Bool /*bUpdateAll*/ )
+    {
+        // hidden or disposed?
+        if( !bIsVisible || !mpChildWindow || !mpSpriteCanvas )
+            return false;
+
+        const unx::Window aXWindow=mpChildWindow->GetSystemData()->aWindow;
+        if( !glXMakeCurrent( reinterpret_cast<unx::Display*>(mpDisplay), 
+                             aXWindow,
+                             reinterpret_cast<unx::GLXContext>(mpGLContext)) )
+        {
+            OSL_TRACE("SpriteDeviceHelper::showBuffer(): cannot activate GL context");
+            return false;
+        }
+
+        const Size& rOutputSize=mpChildWindow->GetSizePixel();
+
+        // use whole window
+        glViewport( 0,0,
+                    (GLsizei)rOutputSize.Width(),
+                    (GLsizei)rOutputSize.Height() );
+
+        // model coordinate system is already in device pixel
+        glMatrixMode(GL_MODELVIEW);
+        glLoadIdentity();
+        glTranslated(-1.0, 1.0, 0.0);
+        glScaled( 2.0  / rOutputSize.Width(), 
+                  -2.0 / rOutputSize.Height(), 
+                  1.0 );
+
+        // clear to black
+        glClearColor(0,0,0,0);
+        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+        // render the actual spritecanvas content
+        mpSpriteCanvas->renderRecordedActions();
+
+        // render all sprites (in order of priority) on top of that
+        std::vector< ::rtl::Reference<CanvasCustomSprite> > aSprites;
+        std::copy(maActiveSprites.begin(), 
+                  maActiveSprites.end(), 
+                  std::back_insert_iterator< 
+                       std::vector< ::rtl::Reference< CanvasCustomSprite > > >(aSprites));
+        std::sort(aSprites.begin(),
+                  aSprites.end(),
+                  SpriteComparator());
+        std::for_each(aSprites.begin(),
+                      aSprites.end(),
+                      boost::mem_fn(&CanvasCustomSprite::renderSprite));
+        // switch buffer, sync etc.
+        unx::glXSwapBuffers(reinterpret_cast<unx::Display*>(mpDisplay), 
+                            aXWindow);
+        mpChildWindow->Show();        
+        unx::glXWaitGL();
+        XSync( reinterpret_cast<unx::Display*>(mpDisplay), false );
+
+        return true;
+    }
+
+    ::sal_Bool SpriteDeviceHelper::switchBuffer( bool bIsVisible, ::sal_Bool bUpdateAll )
+    {
+        // no difference for VCL canvas
+        return showBuffer( bIsVisible, bUpdateAll );
+    }
+
+    uno::Any SpriteDeviceHelper::isAccelerated() const
+    {
+        return ::com::sun::star::uno::makeAny(false);
+    }
+
+    uno::Any SpriteDeviceHelper::getDeviceHandle() const
+    {
+        return uno::Any();
+    }
+
+    uno::Any SpriteDeviceHelper::getSurfaceHandle() const
+    {
+        return uno::Any();
+    }
+
+    uno::Reference<rendering::XColorSpace> SpriteDeviceHelper::getColorSpace() const
+    {
+        // always the same
+        return uno::Reference<rendering::XColorSpace>(
+            ::canvas::tools::getStdColorSpace(),
+            uno::UNO_QUERY);
+    }
+
+    void SpriteDeviceHelper::notifySizeUpdate( const awt::Rectangle& rBounds )
+    {
+        if( mpChildWindow )
+            mpChildWindow->SetPosSizePixel(
+                0,0,rBounds.Width,rBounds.Height);
+    }
+
+    void SpriteDeviceHelper::dumpScreenContent() const
+    {
+        OSL_TRACE( "%s\n",
+                   BOOST_CURRENT_FUNCTION );
+    }
+
+    void SpriteDeviceHelper::show( const ::rtl::Reference< CanvasCustomSprite >& xSprite )
+    {
+        maActiveSprites.insert(xSprite);
+    }
+
+    void SpriteDeviceHelper::hide( const ::rtl::Reference< CanvasCustomSprite >& xSprite )
+    {
+        maActiveSprites.erase(xSprite);
+    }
+
+    void SpriteDeviceHelper::useLinearGradientShader( const rendering::ARGBColor& rStartColor,
+                                                      const rendering::ARGBColor& rEndColor )
+    {
+        glUseProgram(mnLinearGradientProgram);
+
+        const GLint nStartColorLocation = glGetUniformLocation(mnLinearGradientProgram,
+                                                               "v_startColor4d" );
+        glUniform4f(nStartColorLocation, 
+                    rStartColor.Alpha,
+                    rStartColor.Red,
+                    rStartColor.Green,
+                    rStartColor.Blue);
+
+        const GLint nEndColorLocation = glGetUniformLocation(mnLinearGradientProgram,
+                                                             "v_endColor4d" );
+        glUniform4f(nEndColorLocation, 
+                    rEndColor.Alpha,
+                    rEndColor.Red,
+                    rEndColor.Green,
+                    rEndColor.Blue);
+    }
+}
diff --git canvas/source/opengl/ogl_spritedevicehelper.hxx canvas/source/opengl/ogl_spritedevicehelper.hxx
new file mode 100644
index 0000000..0318c6d
--- /dev/null
+++ canvas/source/opengl/ogl_spritedevicehelper.hxx
@@ -0,0 +1,134 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+#ifndef OGL_SPRITEDEVICEHELPER_HXX
+#define OGL_SPRITEDEVICEHELPER_HXX
+
+#include <rtl/ref.hxx>
+#include <com/sun/star/rendering/XGraphicDevice.hpp>
+#include <boost/utility.hpp>
+#include <boost/shared_ptr.hpp>
+
+#include <set>
+
+
+class Window;
+class SystemChildWindow;
+namespace basegfx{ class B2IVector; }
+namespace com { namespace sun { namespace star { namespace awt {
+    struct Rectangle;
+}}}}
+
+namespace oglcanvas
+{
+    class SpriteCanvas;
+    class CanvasCustomSprite;
+
+    class SpriteDeviceHelper : private ::boost::noncopyable
+    {
+    public:
+        SpriteDeviceHelper();
+
+        void init( Window&                                 rWindow,
+                   SpriteCanvas&                           rSpriteCanvas,
+                   const ::com::sun::star::awt::Rectangle& rViewArea );
+
+        /// Dispose all internal references
+        void disposing();
+
+        // XWindowGraphicDevice
+        ::com::sun::star::geometry::RealSize2D getPhysicalResolution();
+        ::com::sun::star::geometry::RealSize2D getPhysicalSize();
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XLinePolyPolygon2D > createCompatibleLinePolyPolygon(
+            const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XGraphicDevice >&                               rDevice,
+            const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::geometry::RealPoint2D > >& points );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBezierPolyPolygon2D > createCompatibleBezierPolyPolygon(
+            const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XGraphicDevice >&                                       rDevice,
+            const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::geometry::RealBezierSegment2D > >& points );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmap > createCompatibleBitmap(
+            const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XGraphicDevice >&  rDevice,
+            const ::com::sun::star::geometry::IntegerSize2D&                                        size );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XVolatileBitmap > createVolatileBitmap(
+            const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XGraphicDevice >&  rDevice,
+            const ::com::sun::star::geometry::IntegerSize2D&                                        size );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmap > createCompatibleAlphaBitmap(
+            const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XGraphicDevice >&  rDevice,
+            const ::com::sun::star::geometry::IntegerSize2D&                                        size );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XVolatileBitmap > createVolatileAlphaBitmap(
+            const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XGraphicDevice >&  rDevice,
+            const ::com::sun::star::geometry::IntegerSize2D&                                        size );
+
+        sal_Bool hasFullScreenMode(  );
+        sal_Bool enterFullScreenMode( sal_Bool bEnter );
+
+        ::sal_Int32 createBuffers( ::sal_Int32 nBuffers );
+        void        destroyBuffers(  );
+        ::sal_Bool  showBuffer( bool bIsVisible, ::sal_Bool bUpdateAll );
+        ::sal_Bool  switchBuffer( bool bIsVisible, ::sal_Bool bUpdateAll );
+
+        ::com::sun::star::uno::Any isAccelerated() const;
+        ::com::sun::star::uno::Any getDeviceHandle() const;
+        ::com::sun::star::uno::Any getSurfaceHandle() const;
+        ::com::sun::star::uno::Reference< 
+            ::com::sun::star::rendering::XColorSpace > getColorSpace() const;
+
+        void notifySizeUpdate( const ::com::sun::star::awt::Rectangle& rBounds );
+
+        /** called when DumpScreenContent property is enabled on
+            XGraphicDevice, and writes out bitmaps of current screen.
+         */
+        void dumpScreenContent() const;
+
+        void show( const ::rtl::Reference< CanvasCustomSprite >& );
+        void hide( const ::rtl::Reference< CanvasCustomSprite >& );
+
+        void useLinearGradientShader( const ::com::sun::star::rendering::ARGBColor& rStartColor,
+                                      const ::com::sun::star::rendering::ARGBColor& rEndColor );
+
+    private:
+        void resize( const ::basegfx::B2IVector& rNewSize );
+
+        void compileShader(unsigned int& o_rShaderHandle,
+                           unsigned int  eShaderType, 
+                           const char*   pShaderSourceCode);
+        void linkShaders(unsigned int& o_rProgramHandle,
+                         unsigned int  nVertexProgramId, 
+                         unsigned int  nFragmentProgramId);
+
+        /** Phyical output device
+
+            Deliberately not a refcounted reference, because of
+            potential circular references for canvas. Needed to
+            create bitmaps
+         */
+        com::sun::star::rendering::XGraphicDevice*         mpDevice;
+
+        /// Pointer to sprite canvas (owner of this helper), needed to create bitmaps
+        SpriteCanvas*                                      mpSpriteCanvas;
+
+        std::set< ::rtl::Reference< CanvasCustomSprite > > maActiveSprites;
+
+        boost::shared_ptr<SystemChildWindow>               mpChildWindow;
+        void*                                              mpDisplay;
+        void*                                              mpGLContext;
+
+        unsigned int                                       mnDummyVertexProgram;
+
+        unsigned int                                       mnLinearGradientFragmentProgram;
+        unsigned int                                       mnLinearGradientProgram;
+    };
+}
+
+#endif
diff --git canvas/source/opengl/ogl_textlayout.cxx canvas/source/opengl/ogl_textlayout.cxx
new file mode 100644
index 0000000..87d1a02
--- /dev/null
+++ canvas/source/opengl/ogl_textlayout.cxx
@@ -0,0 +1,222 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_canvas.hxx"
+
+#include "ogl_textlayout.hxx"
+
+#include <canvas/debug.hxx>
+#include <canvas/verbosetrace.hxx>
+#include <tools/diagnose_ex.h>
+
+#include <basegfx/matrix/b2dhommatrix.hxx>
+#include <basegfx/numeric/ftools.hxx>
+
+
+using namespace ::com::sun::star;
+
+namespace oglcanvas
+{
+    TextLayout::TextLayout( const rendering::StringContext&     aText, 
+                            sal_Int8                            nDirection, 
+                            sal_Int64                           /*nRandomSeed*/,
+                            const CanvasFont::ImplRef&          rFont ) :
+        TextLayoutBaseT( m_aMutex ),
+        maText( aText ),
+        maLogicalAdvancements(),
+        mpFont( rFont ),
+        mnTextDirection( nDirection )
+    {
+    }
+    
+    void SAL_CALL TextLayout::disposing()
+    {
+        mpFont.reset();
+    }
+
+    // XTextLayout
+    uno::Sequence< uno::Reference< rendering::XPolyPolygon2D > > SAL_CALL TextLayout::queryTextShapes(  ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // TODO
+        return uno::Sequence< uno::Reference< rendering::XPolyPolygon2D > >();
+    }
+
+    uno::Sequence< geometry::RealRectangle2D > SAL_CALL TextLayout::queryInkMeasures(  ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // TODO
+        return uno::Sequence< geometry::RealRectangle2D >();
+    }
+
+    uno::Sequence< geometry::RealRectangle2D > SAL_CALL TextLayout::queryMeasures(  ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // TODO
+        return uno::Sequence< geometry::RealRectangle2D >();
+    }
+
+    uno::Sequence< double > SAL_CALL TextLayout::queryLogicalAdvancements(  ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        return maLogicalAdvancements;
+    }
+
+    void SAL_CALL TextLayout::applyLogicalAdvancements( const uno::Sequence< double >& aAdvancements ) throw (lang::IllegalArgumentException, uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        if( aAdvancements.getLength() != maText.Length )
+        {
+            OSL_TRACE( "TextLayout::applyLogicalAdvancements(): mismatching number of advancements" );
+            throw lang::IllegalArgumentException();
+        }
+
+        maLogicalAdvancements = aAdvancements;
+    }
+
+    geometry::RealRectangle2D SAL_CALL TextLayout::queryTextBounds(  ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        ENSURE_OR_THROW( mpFont.get(),
+                         "TextLayout::queryTextBounds(): invalid font" );
+
+        // fake text bounds by either taking the advancement values,
+        // or assuming square glyph boxes (width similar to height)
+        const rendering::FontRequest& rFontRequest( mpFont->getFontRequest() );
+        const double nFontSize( ::std::max( rFontRequest.CellSize,
+                                            rFontRequest.ReferenceAdvancement ) );
+        if( maLogicalAdvancements.getLength() )
+        {
+            return geometry::RealRectangle2D( 0, -nFontSize/2,
+                                              maLogicalAdvancements[ maLogicalAdvancements.getLength()-1 ],
+                                              nFontSize/2 );
+        }
+        else
+        {
+            return geometry::RealRectangle2D( 0, -nFontSize/2,
+                                              nFontSize * maText.Length,
+                                              nFontSize/2 );
+        }
+    }
+
+    double SAL_CALL TextLayout::justify( double /*nSize*/ ) throw (lang::IllegalArgumentException, uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // TODO
+        return 0.0;
+    }
+
+    double SAL_CALL TextLayout::combinedJustify( const uno::Sequence< uno::Reference< rendering::XTextLayout > >& /*aNextLayouts*/, 
+                                                 double /*nSize*/ ) throw (lang::IllegalArgumentException, uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // TODO
+        return 0.0;
+    }
+
+    rendering::TextHit SAL_CALL TextLayout::getTextHit( const geometry::RealPoint2D& /*aHitPoint*/ ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // TODO
+        return rendering::TextHit();
+    }
+
+    rendering::Caret SAL_CALL TextLayout::getCaret( sal_Int32 /*nInsertionIndex*/, 
+                                                    sal_Bool  /*bExcludeLigatures*/ ) throw (lang::IndexOutOfBoundsException, uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // TODO
+        return rendering::Caret();
+    }
+
+    sal_Int32 SAL_CALL TextLayout::getNextInsertionIndex( sal_Int32 /*nStartIndex*/, 
+                                                          sal_Int32 /*nCaretAdvancement*/, 
+                                                          sal_Bool  /*bExcludeLigatures*/ ) throw (lang::IndexOutOfBoundsException, uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // TODO
+        return 0;
+    }
+
+    uno::Reference< rendering::XPolyPolygon2D > SAL_CALL TextLayout::queryVisualHighlighting( sal_Int32 /*nStartIndex*/, 
+                                                                                              sal_Int32 /*nEndIndex*/ ) throw (lang::IndexOutOfBoundsException, uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // TODO
+        return uno::Reference< rendering::XPolyPolygon2D >();
+    }
+
+    uno::Reference< rendering::XPolyPolygon2D > SAL_CALL TextLayout::queryLogicalHighlighting( sal_Int32 /*nStartIndex*/, 
+                                                                                               sal_Int32 /*nEndIndex*/ ) throw (lang::IndexOutOfBoundsException, uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // TODO
+        return uno::Reference< rendering::XPolyPolygon2D >();
+    }
+
+    double SAL_CALL TextLayout::getBaselineOffset(  ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // TODO
+        return 0.0;
+    }
+
+    sal_Int8 SAL_CALL TextLayout::getMainTextDirection(  ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        return mnTextDirection;
+    }
+
+    uno::Reference< rendering::XCanvasFont > SAL_CALL TextLayout::getFont(  ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        return mpFont.getRef();
+    }
+
+    rendering::StringContext SAL_CALL TextLayout::getText(  ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        return maText;
+    }
+  
+    bool TextLayout::draw( const rendering::ViewState&                          /*rViewState*/, 
+                           const rendering::RenderState&                        /*rRenderState*/,
+                           const uno::Reference< rendering::XGraphicDevice >&   /*xGraphicDevice*/ ) const
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // TODO
+
+        return true;
+    }
+}
diff --git canvas/source/opengl/ogl_textlayout.hxx canvas/source/opengl/ogl_textlayout.hxx
new file mode 100644
index 0000000..f822a19
--- /dev/null
+++ canvas/source/opengl/ogl_textlayout.hxx
@@ -0,0 +1,83 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+#ifndef OGL_TEXTLAYOUT_HXX
+#define OGL_TEXTLAYOUT_HXX
+
+#include <cppuhelper/compbase1.hxx>
+#include <comphelper/broadcasthelper.hxx>
+
+#include <com/sun/star/rendering/XTextLayout.hpp>
+
+#include <basegfx/vector/b2isize.hxx>
+
+#include <boost/utility.hpp>
+
+#include "ogl_canvasfont.hxx"
+
+
+/* Definition of TextLayout class */
+
+namespace oglcanvas
+{
+    typedef ::cppu::WeakComponentImplHelper1< ::com::sun::star::rendering::XTextLayout > TextLayoutBaseT;
+
+    class TextLayout : public ::comphelper::OBaseMutex, 
+                       public TextLayoutBaseT,
+                       private ::boost::noncopyable
+    {
+    public:
+        TextLayout( const ::com::sun::star::rendering::StringContext& aText, 
+                    sal_Int8                                          nDirection, 
+                    sal_Int64                                         nRandomSeed,
+                    const CanvasFont::ImplRef&                        rFont );
+
+        /// Dispose all internal references
+        virtual void SAL_CALL disposing();
+
+        // XTextLayout
+        virtual ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D > > SAL_CALL queryTextShapes(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Sequence< ::com::sun::star::geometry::RealRectangle2D > SAL_CALL queryInkMeasures(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Sequence< ::com::sun::star::geometry::RealRectangle2D > SAL_CALL queryMeasures(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Sequence< double > SAL_CALL queryLogicalAdvancements(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual void SAL_CALL applyLogicalAdvancements( const ::com::sun::star::uno::Sequence< double >& aAdvancements ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::geometry::RealRectangle2D SAL_CALL queryTextBounds(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual double SAL_CALL justify( double nSize ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual double SAL_CALL combinedJustify( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XTextLayout > >& aNextLayouts, double nSize ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::rendering::TextHit SAL_CALL getTextHit( const ::com::sun::star::geometry::RealPoint2D& aHitPoint ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::rendering::Caret SAL_CALL getCaret( sal_Int32 nInsertionIndex, sal_Bool bExcludeLigatures ) throw (::com::sun::star::lang::IndexOutOfBoundsException, ::com::sun::star::uno::RuntimeException);
+        virtual sal_Int32 SAL_CALL getNextInsertionIndex( sal_Int32 nStartIndex, sal_Int32 nCaretAdvancement, sal_Bool bExcludeLigatures ) throw (::com::sun::star::lang::IndexOutOfBoundsException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D > SAL_CALL queryVisualHighlighting( sal_Int32 nStartIndex, sal_Int32 nEndIndex ) throw (::com::sun::star::lang::IndexOutOfBoundsException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D > SAL_CALL queryLogicalHighlighting( sal_Int32 nStartIndex, sal_Int32 nEndIndex ) throw (::com::sun::star::lang::IndexOutOfBoundsException, ::com::sun::star::uno::RuntimeException);
+        virtual double SAL_CALL getBaselineOffset(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual sal_Int8 SAL_CALL getMainTextDirection(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCanvasFont > SAL_CALL getFont(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::rendering::StringContext SAL_CALL getText(  ) throw (::com::sun::star::uno::RuntimeException);
+        
+        bool draw( const ::com::sun::star::rendering::ViewState&         rViewState, 
+				   const ::com::sun::star::rendering::RenderState&       rRenderState,
+				   const ::com::sun::star::uno::Reference< 
+                         ::com::sun::star::rendering::XGraphicDevice >&  xGraphicDevice ) const;
+
+    private:
+        ::com::sun::star::rendering::StringContext maText;
+        ::com::sun::star::uno::Sequence< double >  maLogicalAdvancements;
+        CanvasFont::ImplRef                        mpFont;
+        sal_Int8                                   mnTextDirection;
+    };
+
+}
+
+#endif
diff --git canvas/source/opengl/ogl_tools.hxx canvas/source/opengl/ogl_tools.hxx
new file mode 100644
index 0000000..e7575d4
--- /dev/null
+++ canvas/source/opengl/ogl_tools.hxx
@@ -0,0 +1,35 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+#ifndef OGL_CANVAS_TOOLS_HXX
+#define OGL_CANVAS_TOOLS_HXX
+
+#include <sal/config.h>
+#include <GL/gl.h>
+
+
+namespace oglcanvas
+{
+    struct TransformationPreserver
+    {
+        TransformationPreserver()
+        { glPushMatrix(); }
+
+        ~TransformationPreserver()
+        { glPopMatrix(); }
+    };
+}
+
+#endif
diff --git canvas/source/tools/canvastools.cxx canvas/source/tools/canvastools.cxx
index f0fc3e3..7b4b04e 100644
--- canvas/source/tools/canvastools.cxx
+++ canvas/source/tools/canvastools.cxx
@@ -434,7 +434,7 @@ namespace canvas
                             *pOut++ = vcl::unotools::toDoubleColor(*pIn++);
                             *pOut++ = vcl::unotools::toDoubleColor(*pIn++);
                             *pOut++ = vcl::unotools::toDoubleColor(*pIn++);
-                            *pOut++ = vcl::unotools::toDoubleColor(255-*pIn++);
+                            *pOut++ = vcl::unotools::toDoubleColor(*pIn++);
                         }
                         return aRes;
                     }
@@ -499,7 +499,7 @@ namespace canvas
                     for( sal_Size i=0; i<nLen; i+=4 )
                     {
                         *pOut++ = rendering::ARGBColor(
-                            vcl::unotools::toDoubleColor(255-pIn[3]),
+                            vcl::unotools::toDoubleColor(pIn[3]),
                             vcl::unotools::toDoubleColor(pIn[0]),
                             vcl::unotools::toDoubleColor(pIn[1]),
                             vcl::unotools::toDoubleColor(pIn[2]));
@@ -520,7 +520,7 @@ namespace canvas
                     rendering::ARGBColor* pOut( aRes.getArray() );
                     for( sal_Size i=0; i<nLen; i+=4 )
                     {
-                        const sal_Int8 nAlpha( 255-pIn[3] );
+                        const sal_Int8 nAlpha( pIn[3] );
                         *pOut++ = rendering::ARGBColor(
                             vcl::unotools::toDoubleColor(nAlpha),
                             vcl::unotools::toDoubleColor(nAlpha*pIn[0]),
@@ -561,7 +561,7 @@ namespace canvas
                         *pColors++ = vcl::unotools::toByteColor(pIn->Red);
                         *pColors++ = vcl::unotools::toByteColor(pIn->Green);
                         *pColors++ = vcl::unotools::toByteColor(pIn->Blue);
-                        *pColors++ = 255-vcl::unotools::toByteColor(pIn->Alpha);
+                        *pColors++ = vcl::unotools::toByteColor(pIn->Alpha);
                         ++pIn;
                     }
                     return aRes;
@@ -579,7 +579,7 @@ namespace canvas
                         *pColors++ = vcl::unotools::toByteColor(pIn->Red/pIn->Alpha);
                         *pColors++ = vcl::unotools::toByteColor(pIn->Green/pIn->Alpha);
                         *pColors++ = vcl::unotools::toByteColor(pIn->Blue/pIn->Alpha);
-                        *pColors++ = 255-vcl::unotools::toByteColor(pIn->Alpha);
+                        *pColors++ = vcl::unotools::toByteColor(pIn->Alpha);
                         ++pIn;
                     }
                     return aRes;
diff --git canvas/source/vcl/canvashelper.hxx canvas/source/vcl/canvashelper.hxx
index 30d9677..923d02d 100644
--- canvas/source/vcl/canvashelper.hxx
+++ canvas/source/vcl/canvashelper.hxx
@@ -32,6 +32,7 @@
 #define _VCLCANVAS_CANVASHELPER_HXX_
 
 #include <com/sun/star/rendering/XCanvas.hpp>
+#include <com/sun/star/rendering/XBitmapCanvas.hpp>
 #include <com/sun/star/rendering/XIntegerBitmap.hpp>
 
 #include <vcl/outdev.hxx>
diff --git cppcanvas/inc/cppcanvas/spritecanvas.hxx cppcanvas/inc/cppcanvas/spritecanvas.hxx
index 287b1a4..9263b54 100644
--- cppcanvas/inc/cppcanvas/spritecanvas.hxx
+++ cppcanvas/inc/cppcanvas/spritecanvas.hxx
@@ -38,7 +38,7 @@
 #include <boost/shared_ptr.hpp>
 
 
-#include <cppcanvas/bitmapcanvas.hxx>
+#include <cppcanvas/canvas.hxx>
 #include <cppcanvas/sprite.hxx>
 #include <cppcanvas/customsprite.hxx>
 
@@ -59,7 +59,7 @@ namespace cppcanvas
 
     /** SpriteCanvas interface
      */
-    class SpriteCanvas : public virtual BitmapCanvas
+    class SpriteCanvas : public virtual Canvas
     {
     public:
         virtual bool					updateScreen( bool bUpdateAll ) const = 0;
diff --git cppcanvas/source/wrapper/implspritecanvas.cxx cppcanvas/source/wrapper/implspritecanvas.cxx
index 1f66544..3402665 100644
--- cppcanvas/source/wrapper/implspritecanvas.cxx
+++ cppcanvas/source/wrapper/implspritecanvas.cxx
@@ -64,8 +64,6 @@ namespace cppcanvas
         ImplSpriteCanvas::ImplSpriteCanvas( const uno::Reference< rendering::XSpriteCanvas >& rCanvas ) :
             ImplCanvas( uno::Reference< rendering::XCanvas >(rCanvas,
                                                              uno::UNO_QUERY) ),
-            ImplBitmapCanvas( uno::Reference< rendering::XBitmapCanvas >(rCanvas,
-                                                                         uno::UNO_QUERY) ),
             mxSpriteCanvas( rCanvas ),
             mpTransformArbiter( new TransformationArbiter() )
         {
@@ -74,10 +72,8 @@ namespace cppcanvas
         
         ImplSpriteCanvas::ImplSpriteCanvas(const ImplSpriteCanvas& rOrig) :
             Canvas(),
-            BitmapCanvas(),
             SpriteCanvas(),
             ImplCanvas( rOrig ),
-            ImplBitmapCanvas( rOrig ),
             mxSpriteCanvas( rOrig.getUNOSpriteCanvas() ),
             mpTransformArbiter( new TransformationArbiter() )
         {
diff --git cppcanvas/source/wrapper/implspritecanvas.hxx cppcanvas/source/wrapper/implspritecanvas.hxx
index b43e2a9..3909c10 100644
--- cppcanvas/source/wrapper/implspritecanvas.hxx
+++ cppcanvas/source/wrapper/implspritecanvas.hxx
@@ -44,14 +44,14 @@
 
 #include <cppcanvas/spritecanvas.hxx>
 
-#include <implbitmapcanvas.hxx>
+#include <implcanvas.hxx>
 
 
 namespace cppcanvas
 {
     namespace internal
     {
-        class ImplSpriteCanvas : public virtual SpriteCanvas, protected virtual ImplBitmapCanvas
+        class ImplSpriteCanvas : public virtual SpriteCanvas, protected virtual ImplCanvas
         {
         public:
             ImplSpriteCanvas( const ::com::sun::star::uno::Reference< 
diff --git offapi/com/sun/star/presentation/XSlideShowView.idl offapi/com/sun/star/presentation/XSlideShowView.idl
index a9a3723..935a013 100644
--- offapi/com/sun/star/presentation/XSlideShowView.idl
+++ offapi/com/sun/star/presentation/XSlideShowView.idl
@@ -37,9 +37,6 @@
 #ifndef __com_sun_star_rendering_XSpriteCanvas_idl__ 
 #include <com/sun/star/rendering/XSpriteCanvas.idl> 
 #endif 
-#ifndef __com_sun_star_geometry_RealRectangle2D_idl__ 
-#include <com/sun/star/geometry/RealRectangle2D.idl> 
-#endif 
 #ifndef __com_sun_star_util_XModifyListener_idl__ 
 #include <com/sun/star/util/XModifyListener.idl> 
 #endif 
@@ -52,6 +49,9 @@
 #ifndef __com_sun_star_awt_XMouseMotionListener_idl__ 
 #include <com/sun/star/awt/XMouseMotionListener.idl> 
 #endif 
+#ifndef __com_sun_star_awt_Rectangle_idl__ 
+#include <com/sun/star/awt/Rectangle.idl> 
+#endif 
 
 module com {  module sun {  module star {  module presentation {
 
@@ -179,6 +179,10 @@ interface XSlideShowView : ::com::sun::star::uno::XInterface
      */
     void setMouseCursor( [in] short nPointerShape );
 
+    /** Get rectangle defining area inside of canvas device which
+	this slideshow view uses.
+    */
+    ::com::sun::star::awt::Rectangle getCanvasArea();
 };
 
 }; }; }; };
diff --git offapi/com/sun/star/rendering/XSpriteCanvas.idl offapi/com/sun/star/rendering/XSpriteCanvas.idl
index b3717b2..85a3ca8 100644
--- offapi/com/sun/star/rendering/XSpriteCanvas.idl
+++ offapi/com/sun/star/rendering/XSpriteCanvas.idl
@@ -33,7 +33,7 @@
 #ifndef __com_sun_star_lang_IllegalArgumentException_idl__
 #include <com/sun/star/lang/IllegalArgumentException.idl>
 #endif 
-#ifndef __com_sun_star_rendering_XBitmapCanvas_idl__
+#ifndef __com_sun_star_rendering_XCanvas_idl__
 #include <com/sun/star/rendering/XBitmapCanvas.idl>
 #endif
 #ifndef __com_sun_star_rendering_XAnimation_idl__
@@ -49,7 +49,7 @@ interface XSprite;
 interface XAnimatedSprite;
 interface XCustomSprite;
 
-/** Specialization of a XBitmapCanvas, where moving, animated objects
+/** Specialization of a XCanvas, where moving, animated objects
     (called sprites) are supported.<p>
 
     @attention The screen output of canvas drawing operations is
@@ -63,9 +63,9 @@ interface XCustomSprite;
     (because there's a defined moment in time where content display
     can happen, namely the XBufferController::showBuffer()) call. If
     you don't need sprite functionality, and don't want the
-    updateScreen hassle, simply use the XBitmapCanvas.
+    updateScreen hassle, simply use the XCanvas.
  */
-interface XSpriteCanvas : XBitmapCanvas
+interface XSpriteCanvas : XCanvas
 {
 	/** Create a sprite object from the specified animation
 		sequence. A sprite is a back-buffered object with its own,
@@ -117,9 +117,8 @@ interface XSpriteCanvas : XBitmapCanvas
         object.
 
         The cloned sprite always shows the same content as its
-        original. Furthermore, cloned copies of a hidden original are
-        never visible, although cloned copies of a visible original
-        can of course be invisible.
+        original, but of course the sprite position, visibility, alpha
+        etc. can be modified independently.
 
         @param original
         The original sprite to copy the content from. This sprite must
diff --git officecfg/registry/data/org/openoffice/Office/Canvas.xcu officecfg/registry/data/org/openoffice/Office/Canvas.xcu
index 40a757d..4bafc24 100755
--- officecfg/registry/data/org/openoffice/Office/Canvas.xcu
+++ officecfg/registry/data/org/openoffice/Office/Canvas.xcu
@@ -37,6 +37,7 @@
    <prop oor:name="PreferredImplementations" oor:type="oor:string-list">
     <value oor:separator=",">com.sun.star.comp.rendering.SpriteCanvas.DX9,
 							 com.sun.star.comp.rendering.SpriteCanvas.DX5,
+							 com.sun.star.comp.rendering.SpriteCanvas.OGL,
 							 com.sun.star.comp.rendering.SpriteCanvas.Cairo,
 							 com.sun.star.comp.rendering.SpriteCanvas.GL,
 							 com.sun.star.comp.rendering.SpriteCanvas.Java,
diff --git scp2/source/canvas/makefile.mk scp2/source/canvas/makefile.mk
index 9bfc24d..6cc5c6e 100644
--- scp2/source/canvas/makefile.mk
+++ scp2/source/canvas/makefile.mk
@@ -51,6 +51,7 @@ SCPDEFS+=-DSYSTEM_AGG
 .ENDIF
 
 PARFILES= canvascommons.par		\
+          openglcanvas.par		\
           vclcanvas.par
 
 .IF "$(ENABLE_CAIRO)" == "TRUE"
diff --git scp2/source/canvas/openglcanvas.scp scp2/source/canvas/openglcanvas.scp
new file mode 100644
index 0000000..4ea2d47
--- /dev/null
+++ scp2/source/canvas/openglcanvas.scp
@@ -0,0 +1,28 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+#include "macros.inc"
+
+File gid_File_Lib_OpenGLCanvas
+    TXT_FILE_BODY;
+    Styles = (PACKED,UNO_COMPONENT);
+    RegistryID = gid_Starregistry_Services_Rdb;
+    Dir = gid_Dir_Program;
+  #ifdef UNX
+    Name = STRING(CONCAT2(oglcanvas.uno,UNXSUFFIX));
+  #else
+    Name = "oglcanvas.uno.dll";
+  #endif
+End
diff --git scp2/util/makefile.mk scp2/util/makefile.mk
index 57652db..9dec807 100644
--- scp2/util/makefile.mk
+++ scp2/util/makefile.mk
@@ -167,8 +167,8 @@ SCP1FILES += \
              file_crashrep_dynamic.par
 .ENDIF
 
-SCP1FILES += \
-             vclcanvas.par
+SCP1FILES += vclcanvas.par \
+             openglcanvas.par
 
 .IF "$(ENABLE_CAIRO)" == "TRUE"
 SCP1FILES += cairocanvas.par
diff --git sd/source/ui/slideshow/slideshowviewimpl.cxx sd/source/ui/slideshow/slideshowviewimpl.cxx
index e20921c..f3532bb 100644
--- sd/source/ui/slideshow/slideshowviewimpl.cxx
+++ sd/source/ui/slideshow/slideshowviewimpl.cxx
@@ -57,7 +57,6 @@ using ::comphelper::ImplementationReference;
 
 using ::rtl::OUString;
 using namespace ::com::sun::star;
-using namespace ::com::sun::star;
 
 namespace sd
 {
@@ -487,6 +486,18 @@ void SAL_CALL SlideShowView::setMouseCursor( sal_Int16 nPointerShape ) throw (Ru
 		mxWindowPeer->setPointer( mxPointer );
 }
 
+awt::Rectangle SAL_CALL SlideShowView::getCanvasArea(  ) throw (RuntimeException)
+{
+    awt::Rectangle aRectangle;
+
+    if( mxWindow.is() )
+	return mxWindow->getPosSize();
+
+    aRectangle.X = aRectangle.Y = aRectangle.Width = aRectangle.Height = 0;
+
+    return aRectangle;
+}
+
 void SlideShowView::updateimpl( ::osl::ClearableMutexGuard& rGuard, SlideshowImpl* pSlideShow )
 {
 	if( pSlideShow )
diff --git sd/source/ui/slideshow/slideshowviewimpl.hxx sd/source/ui/slideshow/slideshowviewimpl.hxx
index 4e8f3cc..b68d4e0 100644
--- sd/source/ui/slideshow/slideshowviewimpl.hxx
+++ sd/source/ui/slideshow/slideshowviewimpl.hxx
@@ -236,6 +236,7 @@ public:
     virtual void SAL_CALL addMouseMotionListener( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XMouseMotionListener >& xListener ) throw (::com::sun::star::uno::RuntimeException);
 	virtual void SAL_CALL removeMouseMotionListener( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XMouseMotionListener >& xListener ) throw (::com::sun::star::uno::RuntimeException);
     virtual void SAL_CALL setMouseCursor( sal_Int16 nPointerShape ) throw (::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::awt::Rectangle SAL_CALL getCanvasArea(  ) throw (::com::sun::star::uno::RuntimeException);
 
     // XWindowListener methods
     virtual void SAL_CALL windowResized( const ::com::sun::star::awt::WindowEvent& e ) throw (::com::sun::star::uno::RuntimeException);
diff --git sdext/source/presenter/PresenterSlideShowView.cxx sdext/source/presenter/PresenterSlideShowView.cxx
index 1da7db7..68417a8 100644
--- sdext/source/presenter/PresenterSlideShowView.cxx
+++ sdext/source/presenter/PresenterSlideShowView.cxx
@@ -79,6 +79,8 @@ PresenterSlideShowView::PresenterSlideShowView (
       mxPointer(),
       mxWindow(),
       mxViewWindow(),
+      mxTopPane(),
+      mxPresenterHelper(),
       mxBackgroundPolygon1(),
       mxBackgroundPolygon2(),
       mbIsViewAdded(false),
@@ -111,6 +113,13 @@ void PresenterSlideShowView::LateInit (void)
     if (xSlideShowComponent.is())
         xSlideShowComponent->addEventListener(static_cast<awt::XWindowListener*>(this));
 
+    Reference<lang::XMultiComponentFactory> xFactory (
+        mxComponentContext->getServiceManager(), UNO_QUERY_THROW);
+    mxPresenterHelper.set (xFactory->createInstanceWithContext(
+			       OUString::createFromAscii("com.sun.star.comp.Draw.PresenterHelper"),
+			       mxComponentContext),
+			   UNO_QUERY_THROW);
+
     // Use view id and controller to retrieve window and canvas from
     // configuration controller.
     Reference<XControllerManager> xCM (mxController, UNO_QUERY_THROW);
@@ -118,6 +127,8 @@ void PresenterSlideShowView::LateInit (void)
 
     if (xCC.is())
     {
+	mxTopPane.set(xCC->getResource(mxViewId->getAnchor()->getAnchor()), UNO_QUERY);
+
         Reference<XPane> xPane (xCC->getResource(mxViewId->getAnchor()), UNO_QUERY_THROW);
 
         mxWindow = xPane->getWindow();
@@ -139,8 +150,8 @@ void PresenterSlideShowView::LateInit (void)
     // Create a window for the actual slide show view.  It is places
     // centered and with maximal size inside the pane.
     mxViewWindow = CreateViewWindow(mxWindow);
-    mxViewCanvas = CreateViewCanvas(mxViewWindow,
-        Reference<XPane>(xCC->getResource(mxViewId->getAnchor()->getAnchor()), UNO_QUERY));
+
+    mxViewCanvas = CreateViewCanvas(mxViewWindow);
             
     if (mxViewWindow.is())
     {
@@ -540,6 +551,19 @@ void SAL_CALL PresenterSlideShowView::setMouseCursor(::sal_Int16 nPointerShape)
 
 
 
+awt::Rectangle SAL_CALL PresenterSlideShowView::getCanvasArea(  ) throw (RuntimeException)
+{
+    if( mxViewWindow.is() && mxTopPane.is() )
+	return mxPresenterHelper->getWindowExtentsRelative( mxViewWindow, mxTopPane->getWindow() );
+
+    awt::Rectangle aRectangle;
+
+    aRectangle.X = aRectangle.Y = aRectangle.Width = aRectangle.Height = 0;
+
+    return aRectangle;
+}
+
+
 
 //----- lang::XEventListener --------------------------------------------------
 
@@ -973,22 +997,14 @@ Reference<awt::XWindow> PresenterSlideShowView::CreateViewWindow (
 
 
 Reference<rendering::XCanvas> PresenterSlideShowView::CreateViewCanvas (
-    const Reference<awt::XWindow>& rxViewWindow,
-    const Reference<XPane>& rxParentPane) const
+    const Reference<awt::XWindow>& rxViewWindow) const
 {
     // Create a canvas for the view window.
-    Reference<lang::XMultiComponentFactory> xFactory (
-        mxComponentContext->getServiceManager(), UNO_QUERY_THROW);
-    Reference<drawing::XPresenterHelper> xPresenterHelper(
-        xFactory->createInstanceWithContext(
-            OUString::createFromAscii("com.sun.star.comp.Draw.PresenterHelper"),
-            mxComponentContext),
-        UNO_QUERY_THROW);
-    return xPresenterHelper->createSharedCanvas(
-        Reference<rendering::XSpriteCanvas>(rxParentPane->getCanvas(), UNO_QUERY),
-        rxParentPane->getWindow(),
-        rxParentPane->getCanvas(),
-        rxParentPane->getWindow(),
+    return mxPresenterHelper->createSharedCanvas(
+        Reference<rendering::XSpriteCanvas>(mxTopPane->getCanvas(), UNO_QUERY),
+        mxTopPane->getWindow(),
+        mxTopPane->getCanvas(),
+        mxTopPane->getWindow(),
         rxViewWindow);
 }
 
diff --git sdext/source/presenter/PresenterSlideShowView.hxx sdext/source/presenter/PresenterSlideShowView.hxx
index 0270752..145a6d3 100644
--- sdext/source/presenter/PresenterSlideShowView.hxx
+++ sdext/source/presenter/PresenterSlideShowView.hxx
@@ -149,6 +149,8 @@ public:
     virtual void SAL_CALL setMouseCursor(::sal_Int16 nPointerShape)
         throw (css::uno::RuntimeException);
 
+    virtual ::com::sun::star::awt::Rectangle SAL_CALL getCanvasArea(  )
+	throw (::com::sun::star::uno::RuntimeException);
     
     // lang::XEventListener
     virtual void SAL_CALL disposing (const css::lang::EventObject& rEvent)
@@ -236,6 +238,8 @@ private:
     css::uno::Reference<css::awt::XPointer> mxPointer;
     css::uno::Reference<css::awt::XWindow> mxWindow;
     css::uno::Reference<css::awt::XWindow> mxViewWindow;
+    css::uno::Reference<css::drawing::framework::XPane> mxTopPane;
+    css::uno::Reference<css::drawing::XPresenterHelper> mxPresenterHelper;
     css::uno::Reference<css::rendering::XPolyPolygon2D> mxBackgroundPolygon1;
     css::uno::Reference<css::rendering::XPolyPolygon2D> mxBackgroundPolygon2;
     bool mbIsViewAdded;
@@ -267,8 +271,7 @@ private:
     css::uno::Reference<css::awt::XWindow> CreateViewWindow (
         const css::uno::Reference<css::awt::XWindow>& rxParentWindow) const;
     css::uno::Reference<css::rendering::XCanvas> CreateViewCanvas (
-        const css::uno::Reference<css::awt::XWindow>& rxWindow,
-        const css::uno::Reference<css::drawing::framework::XPane>& rxParentPane) const;
+        const css::uno::Reference<css::awt::XWindow>& rxWindow) const;
 
     void Resize (void);
 
diff --git slideshow/source/engine/waitsymbol.cxx slideshow/source/engine/waitsymbol.cxx
index 4dafb23..ecd8442 100644
--- slideshow/source/engine/waitsymbol.cxx
+++ slideshow/source/engine/waitsymbol.cxx
@@ -41,6 +41,7 @@
 #include <basegfx/vector/b2dvector.hxx>
 
 #include <com/sun/star/rendering/XCanvas.hpp>
+#include <com/sun/star/presentation/XSlideShowView.hpp>
 
 #include "waitsymbol.hxx"
 #include "eventmultiplexer.hxx"
@@ -115,13 +116,13 @@ void WaitSymbol::setVisible( const bool bVisible )
 basegfx::B2DPoint WaitSymbol::calcSpritePos(
     UnoViewSharedPtr const & rView ) const
 {
-    const uno::Reference<rendering::XBitmap> xBitmap( rView->getCanvas()->getUNOCanvas(), 
-                                                      uno::UNO_QUERY_THROW );
-    const geometry::IntegerSize2D realSize( xBitmap->getSize() );
+    const awt::Rectangle aViewArea( rView->getUnoView()->getCanvasArea() );
     return basegfx::B2DPoint(
-        std::min<sal_Int32>( realSize.Width, LEFT_BORDER_SPACE ),
-        std::max<sal_Int32>( 0, realSize.Height - mxBitmap->getSize().Height
-                                                - LOWER_BORDER_SPACE ) );
+        aViewArea.X + std::min<sal_Int32>( aViewArea.Width, LEFT_BORDER_SPACE ),
+        aViewArea.X + std::max<sal_Int32>( 0, 
+                                           aViewArea.Height 
+                                            - mxBitmap->getSize().Height
+                                            - LOWER_BORDER_SPACE ) );
 }
 
 void WaitSymbol::viewAdded( const UnoViewSharedPtr& rView )
