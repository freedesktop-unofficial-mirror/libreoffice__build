A hackweek project - doing XCanvas API natively in OpenGL

From: Thorsten Behrens <thb@openoffice.org>


---

 canvas/prj/build.lst                            |    1 
 canvas/source/opengl/exports.dxp                |    3 
 canvas/source/opengl/exports.map                |    8 
 canvas/source/opengl/makefile.mk                |   65 ++
 canvas/source/opengl/ogl_bitmapcanvashelper.cxx |  107 +++
 canvas/source/opengl/ogl_bitmapcanvashelper.hxx |  106 +++
 canvas/source/opengl/ogl_canvasbitmap.cxx       |   62 ++
 canvas/source/opengl/ogl_canvasbitmap.hxx       |   81 +++
 canvas/source/opengl/ogl_canvascustomsprite.cxx |  123 ++++
 canvas/source/opengl/ogl_canvascustomsprite.hxx |   97 +++
 canvas/source/opengl/ogl_canvasfont.cxx         |   88 +++
 canvas/source/opengl/ogl_canvasfont.hxx         |   72 ++
 canvas/source/opengl/ogl_canvashelper.cxx       |  705 +++++++++++++++++++++++
 canvas/source/opengl/ogl_canvashelper.hxx       |  227 +++++++
 canvas/source/opengl/ogl_spritecanvas.cxx       |  204 +++++++
 canvas/source/opengl/ogl_spritecanvas.hxx       |  125 ++++
 canvas/source/opengl/ogl_spritedevicehelper.cxx |  220 +++++++
 canvas/source/opengl/ogl_spritedevicehelper.hxx |  102 +++
 canvas/source/opengl/ogl_textlayout.cxx         |  222 +++++++
 canvas/source/opengl/ogl_textlayout.hxx         |   83 +++
 offapi/com/sun/star/rendering/XSpriteCanvas.idl |   13 
 21 files changed, 2707 insertions(+), 7 deletions(-)
 create mode 100644 canvas/source/opengl/exports.dxp
 create mode 100644 canvas/source/opengl/exports.map
 create mode 100644 canvas/source/opengl/makefile.mk
 create mode 100644 canvas/source/opengl/ogl_bitmapcanvashelper.cxx
 create mode 100644 canvas/source/opengl/ogl_bitmapcanvashelper.hxx
 create mode 100644 canvas/source/opengl/ogl_canvasbitmap.cxx
 create mode 100644 canvas/source/opengl/ogl_canvasbitmap.hxx
 create mode 100644 canvas/source/opengl/ogl_canvascustomsprite.cxx
 create mode 100644 canvas/source/opengl/ogl_canvascustomsprite.hxx
 create mode 100644 canvas/source/opengl/ogl_canvasfont.cxx
 create mode 100644 canvas/source/opengl/ogl_canvasfont.hxx
 create mode 100644 canvas/source/opengl/ogl_canvashelper.cxx
 create mode 100644 canvas/source/opengl/ogl_canvashelper.hxx
 create mode 100644 canvas/source/opengl/ogl_spritecanvas.cxx
 create mode 100644 canvas/source/opengl/ogl_spritecanvas.hxx
 create mode 100644 canvas/source/opengl/ogl_spritedevicehelper.cxx
 create mode 100644 canvas/source/opengl/ogl_spritedevicehelper.hxx
 create mode 100644 canvas/source/opengl/ogl_textlayout.cxx
 create mode 100644 canvas/source/opengl/ogl_textlayout.hxx


diff --git canvas/prj/build.lst canvas/prj/build.lst
index df1f8e9..3f94041 100644
--- canvas/prj/build.lst
+++ canvas/prj/build.lst
@@ -6,6 +6,7 @@ cv	canvas\source\vcl								 nmake	-	all	cv_vcl cv_tools cv_inc NULL
 cv	canvas\source\simplecanvas						 nmake	-	all	cv_simplecanvas cv_tools cv_inc NULL
 cv	canvas\source\cairo								 nmake	-	all	cv_cairo cv_tools cv_inc NULL
 cv	canvas\source\directx							 nmake	-	w	cv_directx cv_tools cv_inc NULL
+cv	canvas\source\opengl							 nmake	-	all	cv_opengl cv_tools cv_inc NULL
 cv	canvas\source\null								 nmake	-	all	cv_null cv_tools cv_inc NULL
 cv	canvas\source\java								 nmake	-	all cv_java cv_inc NULL
 cv	canvas\source\factory							 nmake	-	all cv_factory cv_inc NULL
diff --git canvas/source/opengl/exports.dxp canvas/source/opengl/exports.dxp
new file mode 100644
index 0000000..9630d7e
--- /dev/null
+++ canvas/source/opengl/exports.dxp
@@ -0,0 +1,3 @@
+component_getImplementationEnvironment
+component_writeInfo
+component_getFactory
diff --git canvas/source/opengl/exports.map canvas/source/opengl/exports.map
new file mode 100644
index 0000000..ff8f9ed
--- /dev/null
+++ canvas/source/opengl/exports.map
@@ -0,0 +1,8 @@
+CAN_1_0 {
+	global:
+		component_getImplementationEnvironment;
+		component_writeInfo;
+		component_getFactory;
+	local:
+		*;
+};
diff --git canvas/source/opengl/makefile.mk canvas/source/opengl/makefile.mk
new file mode 100644
index 0000000..fe31daf
--- /dev/null
+++ canvas/source/opengl/makefile.mk
@@ -0,0 +1,65 @@
+#*************************************************************************
+#
+#    OpenOffice.org - a multi-platform office productivity suite
+#
+#    Author:
+#      Thorsten Behrens <tbehrens@novell.com>	   	
+#
+#      Copyright (C) 2008, Novell Inc.
+#      Parts copyright 2005 by Sun Microsystems, Inc.
+#
+#   The Contents of this file are made available subject to
+#   the terms of GNU Lesser General Public License Version 2.1.
+#
+#*************************************************************************
+
+PRJ=..$/..
+
+PRJNAME=canvas
+TARGET=oglcanvas
+ENABLE_EXCEPTIONS=TRUE
+
+# --- Settings -----------------------------------------------------------
+
+.INCLUDE :	settings.mk
+DLLPRE =
+
+# --- Common ----------------------------------------------------------
+
+.IF "$(verbose)"!="" || "$(VERBOSE)"!=""
+CDEFS+= -DVERBOSE
+.ENDIF
+
+SLOFILES =	$(SLO)$/ogl_spritecanvas.obj \
+			$(SLO)$/ogl_spritedevicehelper.obj \
+			$(SLO)$/ogl_canvashelper.obj \
+			$(SLO)$/ogl_canvasfont.obj \
+			$(SLO)$/ogl_canvasbitmap.obj \
+			$(SLO)$/ogl_bitmapcanvashelper.obj \
+			$(SLO)$/ogl_canvascustomsprite.obj \
+			$(SLO)$/ogl_textlayout.obj
+
+
+SHL1TARGET=$(TARGET).uno
+SHL1STDLIBS= $(TKLIB) $(CPPULIB) $(SALLIB) $(COMPHELPERLIB) $(CPPUHELPERLIB) $(BASEGFXLIB) $(CANVASTOOLSLIB)
+
+.IF "$(GUI)"=="UNX"
+	SHL1STDLIBS += -lGL -lGLU -lX11
+.ELIF "$(GUI)"=="WNT"
+	SHL1STDLIBS += opengl32.lib glu32.lib gdi32.lib
+.ELSE
+	.ERROR "Add your system OpenGL libs here"
+.ENDIF
+
+SHL1IMPLIB=i$(TARGET)
+SHL1LIBS=$(SLB)$/$(TARGET).lib
+SHL1DEF=$(MISC)$/$(SHL1TARGET).def
+
+SHL1VERSIONMAP=exports.map
+
+DEF1NAME=$(SHL1TARGET)
+DEF1EXPORTFILE=exports.dxp
+
+# ==========================================================================
+
+.INCLUDE :	target.mk
diff --git canvas/source/opengl/ogl_bitmapcanvashelper.cxx canvas/source/opengl/ogl_bitmapcanvashelper.cxx
new file mode 100644
index 0000000..3033de3
--- /dev/null
+++ canvas/source/opengl/ogl_bitmapcanvashelper.cxx
@@ -0,0 +1,107 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_canvas.hxx"
+
+#include "ogl_bitmapcanvashelper.hxx"
+
+#include <canvas/debug.hxx>
+#include <canvas/canvastools.hxx>
+#include <tools/diagnose_ex.h>
+
+
+using namespace ::com::sun::star;
+
+namespace oglcanvas
+{
+    BitmapCanvasHelper::BitmapCanvasHelper()
+    {}
+
+    void BitmapCanvasHelper::disposing()
+    {
+        CanvasHelper::disposing();
+    }
+
+    void BitmapCanvasHelper::init( rendering::XGraphicDevice&     rDevice,
+                                   const geometry::IntegerSize2D& rSize )
+    {
+        maSize = rSize;
+        CanvasHelper::init(rDevice);
+    }
+
+    void BitmapCanvasHelper::copyRect( const rendering::XCanvas*                            /*pCanvas*/, 
+                                       const uno::Reference< rendering::XBitmapCanvas >&    /*sourceCanvas*/, 
+                                       const geometry::RealRectangle2D&                     /*sourceRect*/, 
+                                       const rendering::ViewState&                          /*sourceViewState*/, 
+                                       const rendering::RenderState&                        /*sourceRenderState*/, 
+                                       const geometry::RealRectangle2D&                     /*destRect*/, 
+                                       const rendering::ViewState&                          /*destViewState*/, 
+                                       const rendering::RenderState&                        /*destRenderState*/ )
+    {
+        // TODO(F2): copyRect NYI
+    }
+
+    geometry::IntegerSize2D BitmapCanvasHelper::getSize()
+    {
+        return maSize;
+    }
+
+    uno::Reference< rendering::XBitmap > BitmapCanvasHelper::getScaledBitmap( const geometry::RealSize2D& /*newSize*/, 
+                                                                              sal_Bool                    /*beFast*/ )
+    {
+        // TODO(F1):
+        return uno::Reference< rendering::XBitmap >();
+    }
+
+    uno::Sequence< sal_Int8 > BitmapCanvasHelper::getData( rendering::IntegerBitmapLayout&     /*bitmapLayout*/, 
+                                                           const geometry::IntegerRectangle2D& /*rect*/ )
+    {
+        // TODO(F2): NYI - and improbable to ever be
+        return uno::Sequence< sal_Int8 >();
+    }
+
+    void BitmapCanvasHelper::setData( const uno::Sequence< sal_Int8 >&      /*data*/, 
+                                      const rendering::IntegerBitmapLayout& /*bitmapLayout*/, 
+                                      const geometry::IntegerRectangle2D&   /*rect*/ )
+    {
+        // TODO(F2): NYI - and improbable to ever be
+    }
+
+    void BitmapCanvasHelper::setPixel( const uno::Sequence< sal_Int8 >&       /*color*/, 
+                                       const rendering::IntegerBitmapLayout&  /*bitmapLayout*/, 
+                                       const geometry::IntegerPoint2D&        /*pos*/ )
+    {
+        // TODO(F2): NYI - and improbable to ever be
+    }
+
+    uno::Sequence< sal_Int8 > BitmapCanvasHelper::getPixel( rendering::IntegerBitmapLayout&   /*bitmapLayout*/, 
+                                                            const geometry::IntegerPoint2D&   /*pos*/ )
+    {
+        // TODO(F2): NYI - and improbable to ever be
+        return uno::Sequence< sal_Int8 >();
+    }
+
+    rendering::IntegerBitmapLayout BitmapCanvasHelper::getMemoryLayout()
+    {
+        return ::canvas::tools::getStdMemoryLayout(getSize());
+    }
+
+    bool BitmapCanvasHelper::hasAlpha() const
+    {
+        return true;
+    }
+
+}
diff --git canvas/source/opengl/ogl_bitmapcanvashelper.hxx canvas/source/opengl/ogl_bitmapcanvashelper.hxx
new file mode 100644
index 0000000..35c1f94
--- /dev/null
+++ canvas/source/opengl/ogl_bitmapcanvashelper.hxx
@@ -0,0 +1,106 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+#ifndef OGL_BITMAPCANVASHELPER_HXX_
+#define OGL_BITMAPCANVASHELPER_HXX_
+
+#include <com/sun/star/rendering/XBitmapCanvas.hpp>
+#include <com/sun/star/rendering/XIntegerBitmap.hpp>
+
+#include <basegfx/vector/b2isize.hxx>
+#include <basegfx/vector/b2dsize.hxx>
+
+#include <boost/utility.hpp>
+#include <boost/shared_ptr.hpp>
+#include <vector>
+
+#include "ogl_canvashelper.hxx"
+
+
+namespace oglcanvas
+{
+    /** Helper class for basic canvas functionality. */
+    class BitmapCanvasHelper : public CanvasHelper
+    {
+    public:
+        BitmapCanvasHelper();
+
+        /// Release all references
+        void disposing();
+
+        /** Initialize canvas helper
+
+            This method late-initializes the canvas helper, providing
+            it with the necessary device and output objects. Note that
+            the CanvasHelper does <em>not</em> take ownership of the
+            passed rDevice reference, nor does it perform any
+            reference counting. Thus, to prevent the reference counted
+            SpriteCanvas object from deletion, the user of this class
+            is responsible for holding ref-counted references itself!
+
+            @param rDevice
+            Reference device this canvas is associated with
+
+         */
+        void init( ::com::sun::star::rendering::XGraphicDevice&     rDevice,
+                   const ::com::sun::star::geometry::IntegerSize2D& rSize );
+
+        // BitmapCanvasHelper functionality
+        // ================================
+
+        void copyRect( const ::com::sun::star::rendering::XCanvas*          rCanvas,
+                       const ::com::sun::star::uno::Reference< 
+                            ::com::sun::star::rendering::XBitmapCanvas >&   sourceCanvas, 
+                       const ::com::sun::star::geometry::RealRectangle2D&   sourceRect, 
+                       const ::com::sun::star::rendering::ViewState&        sourceViewState, 
+                       const ::com::sun::star::rendering::RenderState&      sourceRenderState, 
+                       const ::com::sun::star::geometry::RealRectangle2D&   destRect, 
+                       const ::com::sun::star::rendering::ViewState&        destViewState, 
+                       const ::com::sun::star::rendering::RenderState&      destRenderState );
+            
+        ::com::sun::star::geometry::IntegerSize2D getSize();
+
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmapCanvas > queryBitmapCanvas();
+
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmap > 
+            getScaledBitmap( const ::com::sun::star::geometry::RealSize2D&  newSize, 
+                             sal_Bool                                               beFast );
+
+        ::com::sun::star::uno::Sequence< sal_Int8 > 
+            getData( ::com::sun::star::rendering::IntegerBitmapLayout&      bitmapLayout,
+                     const ::com::sun::star::geometry::IntegerRectangle2D&  rect );
+
+        void setData( const ::com::sun::star::uno::Sequence< sal_Int8 >&        data, 
+                      const ::com::sun::star::rendering::IntegerBitmapLayout&   bitmapLayout, 
+                      const ::com::sun::star::geometry::IntegerRectangle2D&     rect );
+
+        void setPixel( const ::com::sun::star::uno::Sequence< sal_Int8 >&       color, 
+                       const ::com::sun::star::rendering::IntegerBitmapLayout&  bitmapLayout, 
+                       const ::com::sun::star::geometry::IntegerPoint2D&        pos );
+
+        ::com::sun::star::uno::Sequence< sal_Int8 > 
+            getPixel( ::com::sun::star::rendering::IntegerBitmapLayout& bitmapLayout, 
+                      const ::com::sun::star::geometry::IntegerPoint2D& pos );
+
+        ::com::sun::star::rendering::IntegerBitmapLayout getMemoryLayout();
+
+        bool hasAlpha() const;
+
+    private:
+        ::com::sun::star::geometry::IntegerSize2D maSize;
+    };
+}
+
+#endif
diff --git canvas/source/opengl/ogl_canvasbitmap.cxx canvas/source/opengl/ogl_canvasbitmap.cxx
new file mode 100644
index 0000000..51b58e5
--- /dev/null
+++ canvas/source/opengl/ogl_canvasbitmap.cxx
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *      Parts copyright 2004 David Reveman, Peter Nilsson
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_canvas.hxx"
+
+#include "ogl_canvasbitmap.hxx"
+
+#include <canvas/debug.hxx>
+#include <canvas/canvastools.hxx>
+#include <tools/diagnose_ex.h>
+
+
+using namespace ::com::sun::star;
+
+namespace oglcanvas
+{
+    CanvasBitmap::CanvasBitmap( const geometry::IntegerSize2D& rSize,
+                                const SpriteCanvasRef&         rDevice,
+                                bool                           bHasAlpha ) :
+        mpDevice( rDevice ),
+        mbHasAlpha( bHasAlpha )
+    {
+        ENSURE_OR_THROW( mpDevice.is(),
+                         "CanvasBitmap::CanvasBitmap(): Invalid surface or device" );
+
+        maCanvasHelper.init( *mpDevice.get(), rSize );
+    }
+
+    CanvasBitmap::CanvasBitmap( const CanvasBitmap& rSrc ) :
+        mpDevice( rSrc.mpDevice ),
+        mbHasAlpha( rSrc.mbHasAlpha )
+    {
+        maCanvasHelper = rSrc.maCanvasHelper;
+    }
+
+    void SAL_CALL CanvasBitmap::disposing()
+    {
+        mpDevice.clear();
+
+        // forward to parent
+        CanvasBitmapBaseT::disposing();
+    }
+
+    bool CanvasBitmap::renderRecordedActions() const
+    {
+        return maCanvasHelper.renderRecordedActions();
+    }
+}
diff --git canvas/source/opengl/ogl_canvasbitmap.hxx canvas/source/opengl/ogl_canvasbitmap.hxx
new file mode 100644
index 0000000..efb92bb
--- /dev/null
+++ canvas/source/opengl/ogl_canvasbitmap.hxx
@@ -0,0 +1,81 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *      Parts copyright 2004 David Reveman, Peter Nilsson
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+#ifndef OGL_CANVASBITMAP_HXX
+#define OGL_CANVASBITMAP_HXX
+
+#include <cppuhelper/compbase2.hxx>
+
+#include <com/sun/star/rendering/XBitmapCanvas.hpp>
+#include <com/sun/star/rendering/XIntegerBitmap.hpp>
+
+#include <canvas/base/integerbitmapbase.hxx>
+#include <canvas/base/basemutexhelper.hxx>
+#include <basegfx/vector/b2isize.hxx>
+
+#include <boost/shared_ptr.hpp>
+
+#include "ogl_bitmapcanvashelper.hxx"
+#include "ogl_spritecanvas.hxx"
+
+
+/* Definition of CanvasBitmap class */
+
+namespace oglcanvas
+{
+    typedef ::cppu::WeakComponentImplHelper2< ::com::sun::star::rendering::XBitmapCanvas,
+                                              ::com::sun::star::rendering::XIntegerBitmap > CanvasBitmapBase_Base;
+    typedef ::canvas::IntegerBitmapBase< ::canvas::BaseMutexHelper< CanvasBitmapBase_Base >, 
+                                         BitmapCanvasHelper, 
+                                         ::osl::MutexGuard,
+                                         ::cppu::OWeakObject >                          CanvasBitmapBaseT;
+
+    class CanvasBitmap : public CanvasBitmapBaseT
+    {
+    public:
+        /** Create a canvas bitmap for the given surface
+
+            @param rSize
+            Size of the bitmap
+        
+            @param rDevice
+            Reference device, with which bitmap should be compatible
+         */
+        CanvasBitmap( const ::com::sun::star::geometry::IntegerSize2D& rSize,
+                      const SpriteCanvasRef&                           rDevice,
+                      bool                                             bHasAlpha );
+
+        /** Create verbatim copy (including all recorded actions)
+         */
+        CanvasBitmap( const CanvasBitmap& rSrc );
+
+        /// Dispose all internal references
+        virtual void SAL_CALL disposing();
+
+        /** Write out recorded actions
+         */
+        bool renderRecordedActions() const;
+
+    private:
+        /** MUST hold here, too, since CanvasHelper only contains a
+            raw pointer (without refcounting) 
+        */
+        SpriteCanvasRef mpDevice;
+        bool            mbHasAlpha;
+    };
+}
+
+#endif
diff --git canvas/source/opengl/ogl_canvascustomsprite.cxx canvas/source/opengl/ogl_canvascustomsprite.cxx
new file mode 100644
index 0000000..4d722df
--- /dev/null
+++ canvas/source/opengl/ogl_canvascustomsprite.cxx
@@ -0,0 +1,123 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_canvas.hxx"
+
+#include "ogl_canvascustomsprite.hxx"
+
+#include <canvas/debug.hxx>
+#include <canvas/verbosetrace.hxx>
+#include <canvas/verifyinput.hxx>
+#include <tools/diagnose_ex.h>
+
+#include <canvas/canvastools.hxx>
+
+#include <basegfx/matrix/b2dhommatrix.hxx>
+#include <basegfx/point/b2dpoint.hxx>
+#include <basegfx/tools/canvastools.hxx>
+
+
+using namespace ::com::sun::star;
+
+namespace oglcanvas
+{
+    CanvasCustomSprite::CanvasCustomSprite( const ::com::sun::star::geometry::RealSize2D& rSpriteSize,
+                                            const SpriteCanvasRef&                        rRefDevice ) :
+        mpSpriteCanvas( rRefDevice ),
+        maSize(rSpriteSize),
+        maTransformation(),
+        maPosition(),
+        mfAlpha(0.0),
+        mfPriority(0.0)
+    {
+        ENSURE_OR_THROW( rRefDevice.get(),
+                         "CanvasCustomSprite::CanvasCustomSprite(): Invalid sprite canvas" );
+
+    }
+    
+    void SAL_CALL CanvasCustomSprite::disposing()
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        mpSpriteCanvas.clear();
+    }
+
+    void SAL_CALL CanvasCustomSprite::setAlpha( double alpha ) throw (lang::IllegalArgumentException, 
+                                                                      uno::RuntimeException)
+    {
+        canvas::tools::verifyRange( alpha, 0.0, 1.0 );
+
+        ::osl::MutexGuard aGuard( m_aMutex );
+        mfAlpha = alpha;
+    }
+
+    void SAL_CALL CanvasCustomSprite::move( const geometry::RealPoint2D&  aNewPos, 
+                                            const rendering::ViewState&   viewState, 
+                                            const rendering::RenderState& renderState ) throw (lang::IllegalArgumentException, 
+                                                                                               uno::RuntimeException)
+    {
+        canvas::tools::verifyArgs(aNewPos, viewState, renderState, 
+                                  BOOST_CURRENT_FUNCTION,
+                                  static_cast< ::cppu::OWeakObject* >(this));
+        
+        ::osl::MutexGuard aGuard( m_aMutex );
+        ::basegfx::B2DHomMatrix aTransform;
+        ::canvas::tools::mergeViewAndRenderTransform(aTransform,
+                                                     viewState, 
+                                                     renderState);
+
+        // convert position to device pixel
+        maPosition = ::basegfx::unotools::b2DPointFromRealPoint2D(aNewPos);
+        maPosition *= aTransform;
+    }
+
+    void SAL_CALL CanvasCustomSprite::transform( const geometry::AffineMatrix2D& aTransformation ) throw (lang::IllegalArgumentException, 
+                                                                                                          uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+        maTransformation = aTransformation;
+    }
+
+    void SAL_CALL CanvasCustomSprite::clip( const uno::Reference< rendering::XPolyPolygon2D >& /*aClip*/ ) throw (uno::RuntimeException)
+    {
+        // TODO(F3)
+    }
+
+    void SAL_CALL CanvasCustomSprite::setPriority( double nPriority ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+        mfPriority = nPriority;
+    }
+
+    void SAL_CALL CanvasCustomSprite::show() throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+        if( mpSpriteCanvas.is() )
+            mpSpriteCanvas->show(this);
+    }
+
+    void SAL_CALL CanvasCustomSprite::hide() throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+        if( mpSpriteCanvas.is() )
+            mpSpriteCanvas->hide(this);
+    }
+
+    uno::Reference< rendering::XCanvas > SAL_CALL CanvasCustomSprite::getContentCanvas() throw (uno::RuntimeException)
+    {
+        return this;
+    }
+}
diff --git canvas/source/opengl/ogl_canvascustomsprite.hxx canvas/source/opengl/ogl_canvascustomsprite.hxx
new file mode 100644
index 0000000..87e14af
--- /dev/null
+++ canvas/source/opengl/ogl_canvascustomsprite.hxx
@@ -0,0 +1,97 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+#ifndef OGL_CANVASCUSTOMSPRITE_HXX
+#define OGL_CANVASCUSTOMSPRITE_HXX
+
+#include <cppuhelper/compbase2.hxx>
+#include <comphelper/uno3.hxx>
+
+#include <com/sun/star/lang/XComponent.hpp>
+#include <com/sun/star/rendering/XCustomSprite.hpp>
+#include <com/sun/star/rendering/XPolyPolygon2D.hpp>
+
+#include <basegfx/point/b2dpoint.hxx>
+#include <basegfx/vector/b2isize.hxx>
+#include <basegfx/matrix/b2dhommatrix.hxx>
+
+#include <canvas/base/basemutexhelper.hxx>
+
+#include "ogl_spritecanvas.hxx"
+#include "ogl_canvashelper.hxx"
+
+
+namespace oglcanvas
+{
+    typedef ::cppu::WeakComponentImplHelper2< ::com::sun::star::rendering::XCustomSprite,
+                                              ::com::sun::star::rendering::XCanvas > CanvasCustomSpriteBase_Base;
+    typedef ::canvas::CanvasBase< ::canvas::BaseMutexHelper< CanvasCustomSpriteBase_Base >, 
+                                    CanvasHelper, 
+                                    ::osl::MutexGuard,
+                                    ::cppu::OWeakObject >                          CanvasCustomSpriteBaseT;
+
+    /* Definition of CanvasCustomSprite class */
+
+    class CanvasCustomSprite : public CanvasCustomSpriteBaseT
+    {
+    public:
+        /** Create a custom sprite
+
+            @param rSpriteSize
+            Size of the sprite in pixel
+
+            @param rRefDevice
+            Associated output device
+
+            @param rSpriteCanvas
+            Target canvas
+
+            @param rDevice
+            Target DX device
+         */
+        CanvasCustomSprite( const ::com::sun::star::geometry::RealSize2D&   rSpriteSize,
+                            const SpriteCanvasRef&                          rRefDevice );
+
+        virtual void SAL_CALL disposing();
+
+        // XSprite
+        virtual void SAL_CALL setAlpha( double alpha ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual void SAL_CALL move( const ::com::sun::star::geometry::RealPoint2D&  aNewPos, const ::com::sun::star::rendering::ViewState&  viewState, const ::com::sun::star::rendering::RenderState& renderState ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual void SAL_CALL transform( const ::com::sun::star::geometry::AffineMatrix2D& aTransformation ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual void SAL_CALL clip( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >& aClip ) throw (::com::sun::star::uno::RuntimeException);
+        virtual void SAL_CALL setPriority( double nPriority ) throw (::com::sun::star::uno::RuntimeException);
+        virtual void SAL_CALL show() throw (::com::sun::star::uno::RuntimeException);
+        virtual void SAL_CALL hide() throw (::com::sun::star::uno::RuntimeException);
+
+        // XCustomSprite
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCanvas > SAL_CALL getContentCanvas() throw (::com::sun::star::uno::RuntimeException);
+
+        double getPriority() const;
+
+    private:
+        /** MUST hold here, too, since CanvasHelper only contains a
+            raw pointer (without refcounting) 
+        */
+        SpriteCanvasRef                              mpSpriteCanvas;
+        const ::com::sun::star::geometry::RealSize2D maSize;
+
+        ::com::sun::star::geometry::AffineMatrix2D   maTransformation;
+        ::basegfx::B2DPoint                          maPosition;
+        double                                       mfAlpha;
+        double                                       mfPriority;
+    };
+}
+
+#endif
diff --git canvas/source/opengl/ogl_canvasfont.cxx canvas/source/opengl/ogl_canvasfont.cxx
new file mode 100644
index 0000000..9473fb3
--- /dev/null
+++ canvas/source/opengl/ogl_canvasfont.cxx
@@ -0,0 +1,88 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_canvas.hxx"
+
+#include "ogl_canvasfont.hxx"
+#include "ogl_textlayout.hxx"
+
+#include <com/sun/star/rendering/XSpriteCanvas.hpp>
+#include <com/sun/star/rendering/PanoseWeight.hpp>
+
+
+using namespace ::com::sun::star;
+
+namespace oglcanvas
+{
+    CanvasFont::CanvasFont( const rendering::FontRequest&                   rFontRequest,
+                            const uno::Sequence< beans::PropertyValue >&    /*extraFontProperties*/, 
+                            const geometry::Matrix2D&                       fontMatrix ) :
+        CanvasFontBaseT( m_aMutex ),
+        maFontRequest( rFontRequest ),
+        maFontMatrix( fontMatrix )
+    {
+    }
+
+    void SAL_CALL CanvasFont::disposing()
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+    }
+
+    uno::Reference< rendering::XTextLayout > SAL_CALL CanvasFont::createTextLayout( const rendering::StringContext& aText, 
+                                                                                    sal_Int8                        nDirection, 
+                                                                                    sal_Int64                       nRandomSeed ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        return new TextLayout( aText, nDirection, nRandomSeed, ImplRef( this ) );
+    }
+
+    uno::Sequence< double > SAL_CALL CanvasFont::getAvailableSizes(  ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // TODO
+        return uno::Sequence< double >();
+    }
+
+    uno::Sequence< beans::PropertyValue > SAL_CALL CanvasFont::getExtraFontProperties(  ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // TODO
+        return uno::Sequence< beans::PropertyValue >();
+    }
+
+    rendering::FontRequest SAL_CALL CanvasFont::getFontRequest(  ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        return maFontRequest;
+    }
+
+    rendering::FontMetrics SAL_CALL CanvasFont::getFontMetrics(  ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // TODO
+        return rendering::FontMetrics();
+    }
+
+    const ::com::sun::star::geometry::Matrix2D& CanvasFont::getFontMatrix() const
+    {
+        return maFontMatrix;
+    }
+}
diff --git canvas/source/opengl/ogl_canvasfont.hxx canvas/source/opengl/ogl_canvasfont.hxx
new file mode 100644
index 0000000..3c84f11
--- /dev/null
+++ canvas/source/opengl/ogl_canvasfont.hxx
@@ -0,0 +1,72 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+#ifndef OGL_CANVASFONT_HXX
+#define OGL_CANVASFONT_HXX
+
+#include <comphelper/implementationreference.hxx>
+
+#include <cppuhelper/compbase1.hxx>
+#include <comphelper/broadcasthelper.hxx>
+
+#include <com/sun/star/rendering/XCanvas.hpp>
+#include <com/sun/star/rendering/XCanvasFont.hpp>
+
+#include <rtl/ref.hxx>
+
+#include <boost/shared_ptr.hpp>
+#include <boost/utility.hpp>
+
+
+/* Definition of CanvasFont class */
+
+namespace oglcanvas
+{
+    class SpriteCanvas;
+
+    typedef ::cppu::WeakComponentImplHelper1< ::com::sun::star::rendering::XCanvasFont > CanvasFontBaseT;
+
+    class CanvasFont : public ::comphelper::OBaseMutex, 
+                       public CanvasFontBaseT,
+                       private ::boost::noncopyable
+    {
+    public:
+        typedef ::comphelper::ImplementationReference< 
+            CanvasFont, 
+            ::com::sun::star::rendering::XCanvasFont > ImplRef;
+
+        CanvasFont( const ::com::sun::star::rendering::FontRequest&                                     fontRequest,
+                    const ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue >& 	extraFontProperties, 
+                    const ::com::sun::star::geometry::Matrix2D&                                         fontMatrix );
+
+        /// Dispose all internal references
+        virtual void SAL_CALL disposing();
+
+        // XCanvasFont
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XTextLayout > SAL_CALL createTextLayout( const ::com::sun::star::rendering::StringContext& aText, sal_Int8 nDirection, sal_Int64 nRandomSeed ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::rendering::FontRequest SAL_CALL getFontRequest(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::rendering::FontMetrics SAL_CALL getFontMetrics(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Sequence< double > SAL_CALL getAvailableSizes(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue > SAL_CALL getExtraFontProperties(  ) throw (::com::sun::star::uno::RuntimeException);
+
+		const ::com::sun::star::geometry::Matrix2D& getFontMatrix() const;
+
+    private:
+        ::com::sun::star::rendering::FontRequest	maFontRequest;
+		::com::sun::star::geometry::Matrix2D		maFontMatrix;
+    };
+}
+
+#endif
diff --git canvas/source/opengl/ogl_canvashelper.cxx canvas/source/opengl/ogl_canvashelper.cxx
new file mode 100644
index 0000000..168ae2d
--- /dev/null
+++ canvas/source/opengl/ogl_canvashelper.cxx
@@ -0,0 +1,705 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *      Parts copyright 2004 David Reveman, Peter Nilsson
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_canvas.hxx"
+
+#include "ogl_canvashelper.hxx"
+
+#include <canvas/debug.hxx>
+#include <tools/diagnose_ex.h>
+#include <basegfx/tools/canvastools.hxx>
+#include <basegfx/polygon/b2dpolypolygon.hxx>
+
+#include <com/sun/star/rendering/TexturingMode.hpp>
+#include <com/sun/star/rendering/CompositeOperation.hpp>
+#include <com/sun/star/rendering/RepaintResult.hpp>
+#include <com/sun/star/rendering/PathCapType.hpp>
+#include <com/sun/star/rendering/PathJoinType.hpp>
+
+#include "ogl_canvasfont.hxx"
+#include "ogl_canvasbitmap.hxx"
+#include "ogl_spritecanvas.hxx"
+
+#include <GL/gl.h>
+#include <GL/glu.h>
+#include <GL/glext.h>
+
+
+using namespace ::com::sun::star;
+
+namespace oglcanvas
+{
+    /* Concepts:
+       =========
+
+       This OpenGL canvas implementation tries to keep all render
+       output as high-level as possible, i.e. geometry data and
+       externally-provided bitmaps. Therefore, calls at the
+       XCanvas-interfaces are not immediately transformed into colored
+       pixel inside some GL buffer, but are retained simply with their
+       call parameters. Only after XSpriteCanvas::updateScreen() has
+       been called, this all gets transferred to the OpenGL subsystem
+       and converted to a visible scene. The big advantage is, this
+       makes sprite modifications practically zero-overhead, and saves
+       a lot on texture memory (compared to the directx canvas, which
+       immediately dumps every render call into a texture).
+
+       The drawback, of course, is that complex images churn a lot of
+       GPU cycles on every re-rendering.
+
+       For the while, I'll be using immediate mode, i.e. transfer data
+       over and over again to the OpenGL subsystem. Alternatively,
+       there are display lists, which at least keep the data on the
+       server, or even better, vertex buffers, which copy geometry
+       data over en bloc.
+
+       Text: http://www.opengl.org/resources/features/fontsurvey/
+     */
+
+    struct CanvasHelper::Action
+    {
+        ::basegfx::B2DHomMatrix   maTransform;
+        GLenum                    meSrcBlendMode;
+        GLenum                    meDstBlendMode;
+        rendering::ARGBColor      maARGBColor;
+        ::basegfx::B2DPolyPolygon maPolyPoly;
+
+        ::boost::function6< bool,
+                            const CanvasHelper&,
+                            const ::basegfx::B2DHomMatrix&,
+                            GLenum,
+                            GLenum,
+                            const rendering::ARGBColor&,
+                            const ::basegfx::B2DPolyPolygon& > maFunction;
+    };
+
+    namespace
+    {
+        struct TransformationPreserver
+        {
+            TransformationPreserver()
+            { glPushAttrib(GL_TRANSFORM_BIT); }
+
+            ~TransformationPreserver()
+            { glPopAttrib(); }
+        };
+
+        void renderPolyPolygon( const ::basegfx::B2DPolyPolygon& rPolyPoly )
+        {
+            for( sal_uInt32 i=0; i<rPolyPoly.count(); i++ ) 
+            {
+                const ::basegfx::B2DPolygon& rPolygon( rPolyPoly.getB2DPolygon(i) );
+
+                const sal_uInt32 nPts=rPolygon.count();
+                const sal_uInt32 nExtPts=nPts + rPolygon.isClosed();
+                for( sal_uInt32 j=0; j<nExtPts; j++ ) 
+                {
+                    const ::basegfx::B2DPoint& rPt( rPolygon.getB2DPoint( j % nPts ) );
+                    glVertex2d(rPt.getX(), rPt.getY());
+                }
+            }
+        }
+
+        
+        void setupState( const ::basegfx::B2DHomMatrix&   rTransform,
+                         GLenum                           eSrcBlend,
+                         GLenum                           eDstBlend,
+                         const rendering::ARGBColor&      rColor )
+        {
+            double aGLTransform[] = 
+                {
+                    rTransform.get(0,0), rTransform.get(1,0), 0, 0,
+                    rTransform.get(0,1), rTransform.get(1,1), 0, 0,
+                    rTransform.get(0,2), rTransform.get(1,2), 0, 0,
+                    0,                   0,                   0, 1
+                };
+            glMultMatrixd(aGLTransform);
+
+            glEnable(GL_BLEND);
+            glBlendFunc(eSrcBlend, eDstBlend);
+
+            glColor4d(rColor.Red,
+                      rColor.Green,
+                      rColor.Blue,
+                      rColor.Alpha);
+
+            // GL 1.2:
+            // glBlendEquation( GLenum mode );
+            // glBlendColor( GLclampf red, GLclampf green,GLclampf blue, GLclampf alpha );
+            // glConvolutionFilter1D
+            // glConvolutionFilter2D
+            // glSeparableFilter2D
+        }
+
+        bool lcl_drawPoint( const CanvasHelper&              /*rHelper*/,
+                            const ::basegfx::B2DHomMatrix&   rTransform,
+                            GLenum                           eSrcBlend,
+                            GLenum                           eDstBlend,
+                            const rendering::ARGBColor&      rColor,
+                            const geometry::RealPoint2D&     rPoint )
+        {
+            TransformationPreserver aPreserver;
+            setupState(rTransform, eSrcBlend, eDstBlend, rColor);
+
+            glBegin(GL_POINTS);
+            glVertex2d(rPoint.X, rPoint.Y);
+            glEnd();
+
+            return true;
+        }
+
+        bool lcl_drawLine( const CanvasHelper&              /*rHelper*/,
+                           const ::basegfx::B2DHomMatrix&   rTransform,
+                           GLenum                           eSrcBlend,
+                           GLenum                           eDstBlend,
+                           const rendering::ARGBColor&      rColor,
+                           const geometry::RealPoint2D&     rStartPoint,
+                           const geometry::RealPoint2D&     rEndPoint )
+        {
+            TransformationPreserver aPreserver;
+            setupState(rTransform, eSrcBlend, eDstBlend, rColor);
+
+            glBegin(GL_LINES);
+            glVertex2d(rStartPoint.X, rStartPoint.Y);
+            glVertex2d(rEndPoint.X, rEndPoint.Y);
+            glEnd();
+
+            return true;
+        }
+
+        bool lcl_drawPolyPolygon( const CanvasHelper&              /*rHelper*/,
+                                  const ::basegfx::B2DHomMatrix&   rTransform,
+                                  GLenum                           eSrcBlend,
+                                  GLenum                           eDstBlend,
+                                  const rendering::ARGBColor&      rColor,
+                                  const ::basegfx::B2DPolyPolygon& rPolyPolygon )
+        {
+            TransformationPreserver aPreserver;
+            setupState(rTransform, eSrcBlend, eDstBlend, rColor);
+
+            glBegin(GL_LINES);
+            renderPolyPolygon(rPolyPolygon);
+            glEnd();
+
+            return true;
+        }
+
+        bool lcl_fillPolyPolygon( const CanvasHelper&              /*rHelper*/,
+                                  const ::basegfx::B2DHomMatrix&   rTransform,
+                                  GLenum                           eSrcBlend,
+                                  GLenum                           eDstBlend,
+                                  const rendering::ARGBColor&      rColor,
+                                  const ::basegfx::B2DPolyPolygon& rPolyPolygon )
+        {
+            TransformationPreserver aPreserver;
+            setupState(rTransform, eSrcBlend, eDstBlend, rColor);
+
+            glBegin(GL_POLYGON);
+            renderPolyPolygon(rPolyPolygon);
+            glEnd();
+
+            return true;
+        }
+
+        bool lcl_drawOwnBitmap( const CanvasHelper&              /*rHelper*/,
+                                const ::basegfx::B2DHomMatrix&   rTransform,
+                                GLenum                           eSrcBlend,
+                                GLenum                           eDstBlend,
+                                const rendering::ARGBColor&      rColor,
+                                const CanvasBitmap&              rBitmap )
+        {
+            TransformationPreserver aPreserver;
+            setupState(rTransform, eSrcBlend, eDstBlend, rColor);
+
+            return rBitmap.renderRecordedActions();
+        }
+
+        bool lcl_drawGenericBitmap( const CanvasHelper&              /*rHelper*/,
+                                    const ::basegfx::B2DHomMatrix&   rTransform,
+                                    GLenum                           eSrcBlend,
+                                    GLenum                           eDstBlend,
+                                    const rendering::ARGBColor&      rColor,
+                                    const geometry::IntegerSize2D&   rPixelSize,
+                                    const uno::Sequence<sal_Int8>&   rPixelData )
+        {
+            TransformationPreserver aPreserver;
+            setupState(rTransform, eSrcBlend, eDstBlend, rColor);
+
+            // TODO(P3): reuse the texture next time
+            unsigned int nTexture;
+            glGenTextures(1, &nTexture);
+            glBindTexture(GL_TEXTURE_2D, nTexture);
+
+            gluBuild2DMipmaps(GL_TEXTURE_2D, 
+                              4, 
+                              rPixelSize.Width, 
+                              rPixelSize.Height, 
+                              GL_RGBA, 
+                              GL_UNSIGNED_BYTE,
+                              &rPixelData[0]);
+            glEnable(GL_TEXTURE_2D);
+            glBegin(GL_TRIANGLE_STRIP);
+            glTexCoord2f(0,0); glVertex2d(0,0);
+            glTexCoord2f(1,0); glVertex2d(rPixelSize.Width, 0);
+            glTexCoord2f(1,1); glVertex2d(rPixelSize.Width, rPixelSize.Height);
+            glTexCoord2f(0,1); glVertex2d(0, rPixelSize.Height);
+            glEnd();
+
+            glDeleteTextures(1, &nTexture);
+
+            return true;
+        }
+    }
+
+    CanvasHelper::CanvasHelper() :
+        mpDevice( NULL ),
+        mpRecordedActions()
+    {}
+
+    CanvasHelper::~CanvasHelper()
+    {}
+
+    CanvasHelper& CanvasHelper::operator=( const CanvasHelper& rSrc )
+    {
+        mpDevice = rSrc.mpDevice;
+        mpRecordedActions = rSrc.mpRecordedActions;
+    }
+
+    void CanvasHelper::disposing()
+    {
+        RecordVectorT aThrowaway;
+        mpRecordedActions.swap( aThrowaway );
+        mpDevice = NULL;
+    }
+
+    void CanvasHelper::init( rendering::XGraphicDevice& rDevice )
+    {
+        mpDevice = &rDevice;
+    }
+
+    void CanvasHelper::clear()
+    {        
+        mpRecordedActions->clear();
+    }
+
+    void CanvasHelper::drawPoint( const rendering::XCanvas*     /*pCanvas*/,
+                                  const geometry::RealPoint2D&  aPoint,
+                                  const rendering::ViewState&   viewState,
+                                  const rendering::RenderState& renderState )
+    {
+        if( mpDevice )
+        {
+            mpRecordedActions->push_back( Action() );
+            Action& rAct=mpRecordedActions->back();
+
+            setupGraphicsState( rAct, viewState, renderState );
+            rAct.maFunction = ::boost::bind(&lcl_drawPoint,
+                                            _1,_2,_3,_4,_5,
+                                            aPoint);
+        }
+    }
+
+    void CanvasHelper::drawLine( const rendering::XCanvas*      /*pCanvas*/,
+                                 const geometry::RealPoint2D&   aStartPoint,
+                                 const geometry::RealPoint2D&   aEndPoint,
+                                 const rendering::ViewState&    viewState,
+                                 const rendering::RenderState&  renderState )
+    {
+        if( mpDevice )
+        {
+            mpRecordedActions->push_back( Action() );
+            Action& rAct=mpRecordedActions->back();
+
+            setupGraphicsState( rAct, viewState, renderState );
+            rAct.maFunction = ::boost::bind(&lcl_drawLine,
+                                            _1,_2,_3,_4,_5,
+                                            aStartPoint,aEndPoint);
+        }
+    }
+
+    void CanvasHelper::drawBezier( const rendering::XCanvas*            /*pCanvas*/, 
+                                   const geometry::RealBezierSegment2D& aBezierSegment, 
+                                   const geometry::RealPoint2D&         aEndPoint,
+                                   const rendering::ViewState&          viewState, 
+                                   const rendering::RenderState&        renderState )
+    {
+        if( mpDevice )
+        {
+            mpRecordedActions->push_back( Action() );
+            Action& rAct=mpRecordedActions->back();
+
+            setupGraphicsState( rAct, viewState, renderState );
+
+            // TODO(F2): subdivide&render whole curve
+            rAct.maFunction = ::boost::bind(&lcl_drawLine,
+                                            _1,_2,_3,_4,_5,
+                                            geometry::RealPoint2D(
+                                                aBezierSegment.Px,
+                                                aBezierSegment.Py),
+                                            aEndPoint);
+        }
+    }
+
+    uno::Reference< rendering::XCachedPrimitive > CanvasHelper::drawPolyPolygon( const rendering::XCanvas*                          /*pCanvas*/, 
+                                                                                 const uno::Reference< rendering::XPolyPolygon2D >& xPolyPolygon, 
+                                                                                 const rendering::ViewState&                        viewState, 
+                                                                                 const rendering::RenderState&                      renderState )
+    {
+        ENSURE_OR_THROW( xPolyPolygon.is(), 
+                          "CanvasHelper::drawPolyPolygon: polygon is NULL");
+
+        if( mpDevice )
+        {
+            mpRecordedActions->push_back( Action() );
+            Action& rAct=mpRecordedActions->back();
+
+            setupGraphicsState( rAct, viewState, renderState );
+            rAct.maPolyPoly = 
+                ::basegfx::unotools::b2DPolyPolygonFromXPolyPolygon2D(xPolyPolygon);
+            rAct.maPolyPoly.makeUnique(); // own copy, for thread safety
+
+            rAct.maFunction = &lcl_drawPolyPolygon;
+        }
+
+        // TODO(P1): Provide caching here.
+        return uno::Reference< rendering::XCachedPrimitive >(NULL);
+    }
+
+    uno::Reference< rendering::XCachedPrimitive > CanvasHelper::strokePolyPolygon( const rendering::XCanvas*                            /*pCanvas*/, 
+                                                                                   const uno::Reference< rendering::XPolyPolygon2D >&   xPolyPolygon, 
+                                                                                   const rendering::ViewState&                          viewState, 
+                                                                                   const rendering::RenderState&                        renderState, 
+                                                                                   const rendering::StrokeAttributes&                   /*strokeAttributes*/ )
+    {
+        ENSURE_OR_THROW( xPolyPolygon.is(), 
+                          "CanvasHelper::strokePolyPolygon: polygon is NULL");
+
+        if( mpDevice )
+        {
+            mpRecordedActions->push_back( Action() );
+            Action& rAct=mpRecordedActions->back();
+
+            setupGraphicsState( rAct, viewState, renderState );
+            rAct.maPolyPoly = 
+                ::basegfx::unotools::b2DPolyPolygonFromXPolyPolygon2D(xPolyPolygon);
+            rAct.maPolyPoly.makeUnique(); // own copy, for thread safety
+
+            // TODO(F3): fallback to drawPolyPolygon currently
+            rAct.maFunction = &lcl_drawPolyPolygon;
+        }
+
+        // TODO(P1): Provide caching here.
+        return uno::Reference< rendering::XCachedPrimitive >(NULL);
+    }
+
+    uno::Reference< rendering::XCachedPrimitive > CanvasHelper::strokeTexturedPolyPolygon( const rendering::XCanvas*                            /*pCanvas*/, 
+                                                                                           const uno::Reference< rendering::XPolyPolygon2D >&   /*xPolyPolygon*/, 
+                                                                                           const rendering::ViewState&                          /*viewState*/, 
+                                                                                           const rendering::RenderState&                        /*renderState*/, 
+                                                                                           const uno::Sequence< rendering::Texture >&           /*textures*/, 
+                                                                                           const rendering::StrokeAttributes&                   /*strokeAttributes*/ )
+    {
+        // TODO
+        return uno::Reference< rendering::XCachedPrimitive >(NULL);
+    }
+
+    uno::Reference< rendering::XCachedPrimitive > CanvasHelper::strokeTextureMappedPolyPolygon( const rendering::XCanvas*                           /*pCanvas*/, 
+                                                                                                const uno::Reference< rendering::XPolyPolygon2D >&  /*xPolyPolygon*/, 
+                                                                                                const rendering::ViewState&                         /*viewState*/, 
+                                                                                                const rendering::RenderState&                       /*renderState*/, 
+                                                                                                const uno::Sequence< rendering::Texture >&          /*textures*/, 
+                                                                                                const uno::Reference< geometry::XMapping2D >&       /*xMapping*/, 
+                                                                                                const rendering::StrokeAttributes&                  /*strokeAttributes*/ )
+    {
+        // TODO
+        return uno::Reference< rendering::XCachedPrimitive >(NULL);
+    }
+
+    uno::Reference< rendering::XPolyPolygon2D >   CanvasHelper::queryStrokeShapes( const rendering::XCanvas*                            /*pCanvas*/, 
+                                                                                   const uno::Reference< rendering::XPolyPolygon2D >&   /*xPolyPolygon*/, 
+                                                                                   const rendering::ViewState&                          /*viewState*/, 
+                                                                                   const rendering::RenderState&                        /*renderState*/, 
+                                                                                   const rendering::StrokeAttributes&                   /*strokeAttributes*/ )
+    {
+        // TODO
+        return uno::Reference< rendering::XPolyPolygon2D >(NULL);
+    }
+
+    uno::Reference< rendering::XCachedPrimitive > CanvasHelper::fillPolyPolygon( const rendering::XCanvas*                          /*pCanvas*/, 
+                                                                                 const uno::Reference< rendering::XPolyPolygon2D >& xPolyPolygon, 
+                                                                                 const rendering::ViewState&                        viewState, 
+                                                                                 const rendering::RenderState&                      renderState )
+    {
+        ENSURE_OR_THROW( xPolyPolygon.is(), 
+                          "CanvasHelper::fillPolyPolygon: polygon is NULL");
+
+        if( mpDevice )
+        {
+            mpRecordedActions->push_back( Action() );
+            Action& rAct=mpRecordedActions->back();
+
+            setupGraphicsState( rAct, viewState, renderState );
+            rAct.maPolyPoly = 
+                ::basegfx::unotools::b2DPolyPolygonFromXPolyPolygon2D(xPolyPolygon);
+            rAct.maPolyPoly.makeUnique(); // own copy, for thread safety
+
+            rAct.maFunction = &lcl_fillPolyPolygon;
+        }
+
+        // TODO(P1): Provide caching here.
+        return uno::Reference< rendering::XCachedPrimitive >(NULL);
+    }
+
+    uno::Reference< rendering::XCachedPrimitive > CanvasHelper::fillTexturedPolyPolygon( const rendering::XCanvas* 							/*pCanvas*/, 
+                                                                                         const uno::Reference< rendering::XPolyPolygon2D >& /*xPolyPolygon*/,
+                                                                                         const rendering::ViewState& 						/*viewState*/,
+                                                                                         const rendering::RenderState& 						/*renderState*/,
+                                                                                         const uno::Sequence< rendering::Texture >& 		/*textures*/ )
+    {
+        // TODO(P1): Provide caching here.
+        return uno::Reference< rendering::XCachedPrimitive >(NULL);
+    }
+
+    uno::Reference< rendering::XCachedPrimitive > CanvasHelper::fillTextureMappedPolyPolygon( const rendering::XCanvas*                             /*pCanvas*/, 
+                                                                                              const uno::Reference< rendering::XPolyPolygon2D >&    /*xPolyPolygon*/, 
+                                                                                              const rendering::ViewState&                           /*viewState*/, 
+                                                                                              const rendering::RenderState&                         /*renderState*/, 
+                                                                                              const uno::Sequence< rendering::Texture >&            /*textures*/, 
+                                                                                              const uno::Reference< geometry::XMapping2D >&         /*xMapping*/ )
+    {
+        // TODO
+        return uno::Reference< rendering::XCachedPrimitive >(NULL);
+    }
+
+    uno::Reference< rendering::XCanvasFont > CanvasHelper::createFont( const rendering::XCanvas*                    /*pCanvas*/, 
+                                                                       const rendering::FontRequest&                fontRequest, 
+                                                                       const uno::Sequence< beans::PropertyValue >& extraFontProperties, 
+                                                                       const geometry::Matrix2D&                    fontMatrix )
+    {
+        if( mpDevice )
+            return uno::Reference< rendering::XCanvasFont >( 
+                    new CanvasFont(fontRequest, extraFontProperties, fontMatrix ) );
+
+        return uno::Reference< rendering::XCanvasFont >();
+    }
+
+    uno::Sequence< rendering::FontInfo > CanvasHelper::queryAvailableFonts( const rendering::XCanvas*                       /*pCanvas*/, 
+                                                                            const rendering::FontInfo&                      /*aFilter*/, 
+                                                                            const uno::Sequence< beans::PropertyValue >&    /*aFontProperties*/ )
+    {
+        // TODO
+        return uno::Sequence< rendering::FontInfo >();
+    }
+
+    uno::Reference< rendering::XCachedPrimitive > CanvasHelper::drawText( const rendering::XCanvas*                         /*pCanvas*/, 
+                                                                          const rendering::StringContext&                   /*text*/, 
+                                                                          const uno::Reference< rendering::XCanvasFont >&   /*xFont*/, 
+                                                                          const rendering::ViewState&                       /*viewState*/, 
+                                                                          const rendering::RenderState&                     /*renderState*/, 
+                                                                          sal_Int8                                          /*textDirection*/ )
+    {
+        // TODO - but not used from slideshow
+        return uno::Reference< rendering::XCachedPrimitive >(NULL);
+    }
+
+    uno::Reference< rendering::XCachedPrimitive > CanvasHelper::drawTextLayout( const rendering::XCanvas*                       /*pCanvas*/, 
+                                                                                const uno::Reference< rendering::XTextLayout >& /*xLayoutetText*/, 
+                                                                                const rendering::ViewState&                     /*viewState*/, 
+                                                                                const rendering::RenderState&                   /*renderState*/ )
+    {
+        // TODO
+        return uno::Reference< rendering::XCachedPrimitive >(NULL);
+    }
+
+    uno::Reference< rendering::XCachedPrimitive > CanvasHelper::drawBitmap( const rendering::XCanvas*                   /*pCanvas*/, 
+                                                                            const uno::Reference< rendering::XBitmap >& xBitmap, 
+                                                                            const rendering::ViewState&                 viewState, 
+                                                                            const rendering::RenderState&               renderState )
+    {
+        ENSURE_OR_THROW( xBitmap.is(), 
+                          "CanvasHelper::drawBitmap: bitmap is NULL");
+
+        if( mpDevice )
+        {
+            // own bitmap?
+            CanvasBitmap* pOwnBitmap=dynamic_cast<CanvasBitmap*>(xBitmap.get());
+            if( pOwnBitmap )
+            {
+                // insert as transformed copy of bitmap action vector -
+                // during rendering, this gets rendered into a temporary
+                // buffer, and then composited to the front
+                mpRecordedActions->push_back( Action() );
+                Action& rAct=mpRecordedActions->back();
+                
+                setupGraphicsState( rAct, viewState, renderState );
+                rAct.maFunction = ::boost::bind(&lcl_drawOwnBitmap,
+                                                _1,_2,_3,_4,_5,
+                                                *pOwnBitmap);
+            }
+            else
+            {
+                // TODO(P3): Highly inefficient - simply copies pixel data
+
+                uno::Reference< rendering::XIntegerReadOnlyBitmap > xIntegerBitmap(
+                    xBitmap, uno::UNO_QUERY);
+                if( xIntegerBitmap.is() )
+                {
+                    const geometry::IntegerSize2D aSize=xBitmap->getSize();
+                    rendering::IntegerBitmapLayout aLayout;
+                    uno::Sequence<sal_Int8> aPixelData=
+                        xIntegerBitmap->getData(
+                            aLayout,
+                            geometry::IntegerRectangle2D(0,0,aSize.Width,aSize.Height));
+
+                    // force-convert color to ARGB8888 int color space  
+                    uno::Sequence<sal_Int8> aARGBBytes(
+                        aLayout.ColorSpace->convertToIntegerColorSpace(
+                            aPixelData,
+                            canvas::tools::getStdColorSpace()));
+
+                    mpRecordedActions->push_back( Action() );
+                    Action& rAct=mpRecordedActions->back();
+                
+                    setupGraphicsState( rAct, viewState, renderState );
+                    rAct.maFunction = ::boost::bind(&lcl_drawGenericBitmap,
+                                                    _1,_2,_3,_4,_5,
+                                                    aSize, aARGBBytes);
+                }
+                // TODO(F1): handle non-integer case
+            }
+        }
+
+        // TODO(P1): Provide caching here.
+        return uno::Reference< rendering::XCachedPrimitive >(NULL);
+    }
+
+    uno::Reference< rendering::XCachedPrimitive > CanvasHelper::drawBitmapModulated( const rendering::XCanvas*                      pCanvas, 
+                                                                                     const uno::Reference< rendering::XBitmap >&    xBitmap, 
+                                                                                     const rendering::ViewState&                    viewState, 
+                                                                                     const rendering::RenderState&                  renderState )
+    {
+        // TODO(F3): remove this wart altogether
+        return drawBitmap(pCanvas, xBitmap, viewState, renderState);
+    }
+
+    uno::Reference< rendering::XGraphicDevice > CanvasHelper::getDevice()
+    {
+        return uno::Reference< rendering::XGraphicDevice >(mpDevice);
+    }
+
+    void CanvasHelper::setupGraphicsState( Action&                       o_action,
+                                           const rendering::ViewState&   viewState, 
+                                           const rendering::RenderState& renderState )
+    {
+        ENSURE_OR_THROW( mpDevice,
+                          "CanvasHelper::setupGraphicsState: reference device invalid" );
+
+        // TODO(F3): clipping
+        // TODO(P2): think about caching transformations between canvas calls
+
+        // setup overall transform only now. View clip above was
+        // relative to view transform
+        ::basegfx::B2DHomMatrix aTransform;
+        ::canvas::tools::mergeViewAndRenderTransform(o_action.maTransform,
+                                                     viewState,
+                                                     renderState);
+        // setup compositing - mapping courtesy David Reveman
+        // (glitz_operator.c)
+        switch( renderState.CompositeOperation )
+        {
+            case rendering::CompositeOperation::OVER:
+                o_action.meSrcBlendMode=GL_ONE; 
+                o_action.meDstBlendMode=GL_ONE_MINUS_SRC_ALPHA; 
+                break;
+            case rendering::CompositeOperation::CLEAR:
+                o_action.meSrcBlendMode=GL_ZERO; 
+                o_action.meDstBlendMode=GL_ZERO; 
+                break;
+            case rendering::CompositeOperation::SOURCE:
+                o_action.meSrcBlendMode=GL_ONE; 
+                o_action.meDstBlendMode=GL_ZERO; 
+                break;
+            case rendering::CompositeOperation::UNDER:
+                // FALLTHROUGH intended - but correct?!
+            case rendering::CompositeOperation::DESTINATION:
+                o_action.meSrcBlendMode=GL_ZERO; 
+                o_action.meDstBlendMode=GL_ONE; 
+                break;
+            case rendering::CompositeOperation::INSIDE:
+                o_action.meSrcBlendMode=GL_DST_ALPHA; 
+                o_action.meDstBlendMode=GL_ZERO; 
+                break;
+            case rendering::CompositeOperation::INSIDE_REVERSE:
+                o_action.meSrcBlendMode=GL_ONE_MINUS_DST_ALPHA; 
+                o_action.meDstBlendMode=GL_ZERO; 
+                break;
+            case rendering::CompositeOperation::OUTSIDE:
+                o_action.meSrcBlendMode=GL_ONE_MINUS_DST_ALPHA; 
+                o_action.meDstBlendMode=GL_ONE; 
+                break;
+            case rendering::CompositeOperation::OUTSIDE_REVERSE:
+                o_action.meSrcBlendMode=GL_ZERO; 
+                o_action.meDstBlendMode=GL_ONE_MINUS_SRC_ALPHA; 
+                break;
+            case rendering::CompositeOperation::ATOP:
+                o_action.meSrcBlendMode=GL_DST_ALPHA; 
+                o_action.meDstBlendMode=GL_ONE_MINUS_SRC_ALPHA; 
+                break;
+            case rendering::CompositeOperation::ATOP_REVERSE:
+                o_action.meSrcBlendMode=GL_ONE_MINUS_DST_ALPHA; 
+                o_action.meDstBlendMode=GL_SRC_ALPHA; 
+                break;
+            case rendering::CompositeOperation::XOR:
+                o_action.meSrcBlendMode=GL_ONE_MINUS_DST_ALPHA; 
+                o_action.meDstBlendMode=GL_ONE_MINUS_SRC_ALPHA; 
+                break;
+            case rendering::CompositeOperation::ADD:
+                o_action.meSrcBlendMode=GL_ONE;
+                o_action.meDstBlendMode=GL_ONE;
+                break;
+            case rendering::CompositeOperation::SATURATE:
+                o_action.meSrcBlendMode=GL_SRC_ALPHA_SATURATE;
+                o_action.meDstBlendMode=GL_SRC_ALPHA_SATURATE;
+                break;
+                
+            default:
+                ENSURE_OR_THROW( false, "CanvasHelper::setupGraphicsState: unexpected mode" );
+                break;
+        }
+
+        o_action.maARGBColor = 
+            mpDevice->getDeviceColorSpace()->convertToARGB(renderState.DeviceColor)[0];
+    }
+
+    void CanvasHelper::flush() const
+    {
+    }
+
+    bool CanvasHelper::renderRecordedActions() const
+    {
+        std::vector<Action>::const_iterator aCurr(mpRecordedActions->begin());
+        const std::vector<Action>::const_iterator aEnd(mpRecordedActions->end());
+        while( aCurr != aEnd )
+            if( !aCurr->maFunction( *this,
+                                    aCurr->maTransform,
+                                    aCurr->meSrcBlendMode,
+                                    aCurr->meDstBlendMode,
+                                    aCurr->maARGBColor,
+                                    aCurr->maPolyPoly ) )
+                return false;
+    }
+}
diff --git canvas/source/opengl/ogl_canvashelper.hxx canvas/source/opengl/ogl_canvashelper.hxx
new file mode 100644
index 0000000..74efbc5
--- /dev/null
+++ canvas/source/opengl/ogl_canvashelper.hxx
@@ -0,0 +1,227 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+#ifndef OGL_CANVASHELPER_HXX_
+#define OGL_CANVASHELPER_HXX_
+
+#include <com/sun/star/rendering/XCanvas.hpp>
+
+#include <basegfx/vector/b2isize.hxx>
+#include <basegfx/vector/b2dsize.hxx>
+
+#include <o3tl/cow_wrapper.hxx>
+#include <vector>
+
+namespace oglcanvas
+{
+    /** Helper class for basic canvas functionality. */
+    class CanvasHelper
+    {
+    public:
+        CanvasHelper();
+
+        // outline because of incomplete type Action 
+        ~CanvasHelper();
+        CanvasHelper& operator=( const CanvasHelper& );
+
+        /// Release all references
+        void disposing();
+
+        /** Initialize canvas helper
+
+            This method late-initializes the canvas helper, providing
+            it with the necessary device and output objects. Note that
+            the CanvasHelper does <em>not</em> take ownership of the
+            passed rDevice reference, nor does it perform any
+            reference counting. Thus, to prevent the reference counted
+            SpriteCanvas object from deletion, the user of this class
+            is responsible for holding ref-counted references itself!
+
+            @param rDevice
+            Reference device this canvas is associated with
+
+         */
+        void init( com::sun::star::rendering::XGraphicDevice& rDevice );
+
+        // CanvasHelper functionality
+        // ==========================
+
+        // XCanvas (only providing, not implementing the
+        // interface. Also note subtle method parameter differences)
+        void clear();
+        void drawPoint( const ::com::sun::star::rendering::XCanvas*     pCanvas, 
+                        const ::com::sun::star::geometry::RealPoint2D&  aPoint, 
+                        const ::com::sun::star::rendering::ViewState&   viewState, 
+                        const ::com::sun::star::rendering::RenderState& renderState );
+        void drawLine( const ::com::sun::star::rendering::XCanvas*      pCanvas,
+                       const ::com::sun::star::geometry::RealPoint2D&   aStartPoint,
+                       const ::com::sun::star::geometry::RealPoint2D&   aEndPoint,
+                       const ::com::sun::star::rendering::ViewState&    viewState,
+                       const ::com::sun::star::rendering::RenderState&  renderState );
+        void drawBezier( const ::com::sun::star::rendering::XCanvas*            pCanvas,
+                         const ::com::sun::star::geometry::RealBezierSegment2D& aBezierSegment,
+                         const ::com::sun::star::geometry::RealPoint2D&         aEndPoint,
+                         const ::com::sun::star::rendering::ViewState&          viewState,
+                         const ::com::sun::star::rendering::RenderState&        renderState );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive >
+            drawPolyPolygon( const ::com::sun::star::rendering::XCanvas*            pCanvas,
+                             const ::com::sun::star::uno::Reference<
+                                    ::com::sun::star::rendering::XPolyPolygon2D >&  xPolyPolygon,
+                             const ::com::sun::star::rendering::ViewState&          viewState,
+                             const ::com::sun::star::rendering::RenderState&        renderState );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive >
+            strokePolyPolygon( const ::com::sun::star::rendering::XCanvas*          pCanvas,
+                               const ::com::sun::star::uno::Reference<
+                                    ::com::sun::star::rendering::XPolyPolygon2D >&  xPolyPolygon,
+                               const ::com::sun::star::rendering::ViewState&        viewState,
+                               const ::com::sun::star::rendering::RenderState&      renderState,
+                               const ::com::sun::star::rendering::StrokeAttributes& strokeAttributes );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive >
+            strokeTexturedPolyPolygon( const ::com::sun::star::rendering::XCanvas*          pCanvas,
+                                       const ::com::sun::star::uno::Reference<
+                                            ::com::sun::star::rendering::XPolyPolygon2D >&  xPolyPolygon,
+                                       const ::com::sun::star::rendering::ViewState&        viewState,
+                                       const ::com::sun::star::rendering::RenderState&      renderState,
+                                       const ::com::sun::star::uno::Sequence<
+                                            ::com::sun::star::rendering::Texture >&         textures,
+                                       const ::com::sun::star::rendering::StrokeAttributes& strokeAttributes );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive >
+            strokeTextureMappedPolyPolygon( const ::com::sun::star::rendering::XCanvas*             pCanvas,
+                                            const ::com::sun::star::uno::Reference<
+                                                    ::com::sun::star::rendering::XPolyPolygon2D >&  xPolyPolygon,
+                                            const ::com::sun::star::rendering::ViewState&           viewState,
+                                            const ::com::sun::star::rendering::RenderState&         renderState,
+                                            const ::com::sun::star::uno::Sequence<
+                                                    ::com::sun::star::rendering::Texture >&         textures,
+                                            const ::com::sun::star::uno::Reference<
+                                                    ::com::sun::star::geometry::XMapping2D >&       xMapping,
+                                            const ::com::sun::star::rendering::StrokeAttributes&    strokeAttributes );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >
+            queryStrokeShapes( const ::com::sun::star::rendering::XCanvas*          pCanvas,
+                               const ::com::sun::star::uno::Reference<
+                                    ::com::sun::star::rendering::XPolyPolygon2D >&  xPolyPolygon,
+                               const ::com::sun::star::rendering::ViewState&        viewState,
+                               const ::com::sun::star::rendering::RenderState&      renderState,
+                               const ::com::sun::star::rendering::StrokeAttributes& strokeAttributes );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive >
+            fillPolyPolygon( const ::com::sun::star::rendering::XCanvas*            pCanvas,
+                             const ::com::sun::star::uno::Reference<
+                                    ::com::sun::star::rendering::XPolyPolygon2D >&  xPolyPolygon,
+                             const ::com::sun::star::rendering::ViewState&          viewState,
+                             const ::com::sun::star::rendering::RenderState&        renderState );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive >
+            fillTexturedPolyPolygon( const ::com::sun::star::rendering::XCanvas*            pCanvas,
+                                     const ::com::sun::star::uno::Reference<
+                                            ::com::sun::star::rendering::XPolyPolygon2D >&  xPolyPolygon,
+                                     const ::com::sun::star::rendering::ViewState&          viewState,
+                                     const ::com::sun::star::rendering::RenderState&        renderState,
+                                     const ::com::sun::star::uno::Sequence<
+                                            ::com::sun::star::rendering::Texture >&         textures );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive >
+            fillTextureMappedPolyPolygon( const ::com::sun::star::rendering::XCanvas*           pCanvas,
+                                          const ::com::sun::star::uno::Reference<
+                                                ::com::sun::star::rendering::XPolyPolygon2D >&  xPolyPolygon,
+                                          const ::com::sun::star::rendering::ViewState&         viewState,
+                                          const ::com::sun::star::rendering::RenderState&       renderState,
+                                          const ::com::sun::star::uno::Sequence<
+                                                ::com::sun::star::rendering::Texture >&         textures,
+                                          const ::com::sun::star::uno::Reference<
+                                                ::com::sun::star::geometry::XMapping2D >&       xMapping );
+
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCanvasFont > SAL_CALL
+            createFont( const ::com::sun::star::rendering::XCanvas*             pCanvas,
+                        const ::com::sun::star::rendering::FontRequest&         fontRequest,
+                        const ::com::sun::star::uno::Sequence<
+                                ::com::sun::star::beans::PropertyValue >&       extraFontProperties,
+                        const ::com::sun::star::geometry::Matrix2D&             fontMatrix );
+
+        ::com::sun::star::uno::Sequence< ::com::sun::star::rendering::FontInfo >
+            queryAvailableFonts( const ::com::sun::star::rendering::XCanvas*        pCanvas,
+                                 const ::com::sun::star::rendering::FontInfo&       aFilter,
+                                 const ::com::sun::star::uno::Sequence<
+                                        ::com::sun::star::beans::PropertyValue >&   aFontProperties );
+
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive >
+            drawText( const ::com::sun::star::rendering::XCanvas*           pCanvas,
+                      const ::com::sun::star::rendering::StringContext&     text,
+                      const ::com::sun::star::uno::Reference<
+                            ::com::sun::star::rendering::XCanvasFont >&     xFont,
+                      const ::com::sun::star::rendering::ViewState&         viewState,
+                      const ::com::sun::star::rendering::RenderState&       renderState,
+                      sal_Int8                                              textDirection );
+
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive >
+            drawTextLayout( const ::com::sun::star::rendering::XCanvas*     pCanvas,
+                            const ::com::sun::star::uno::Reference<
+                                ::com::sun::star::rendering::XTextLayout >& layoutetText,
+                            const ::com::sun::star::rendering::ViewState&   viewState,
+                            const ::com::sun::star::rendering::RenderState& renderState );
+
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive >
+            drawBitmap( const ::com::sun::star::rendering::XCanvas*     pCanvas,
+                        const ::com::sun::star::uno::Reference<
+                                ::com::sun::star::rendering::XBitmap >& xBitmap,
+                        const ::com::sun::star::rendering::ViewState&   viewState,
+                        const ::com::sun::star::rendering::RenderState& renderState );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive >
+            drawBitmapModulated( const ::com::sun::star::rendering::XCanvas*        pCanvas,
+                                 const ::com::sun::star::uno::Reference<
+                                        ::com::sun::star::rendering::XBitmap >&     xBitmap,
+                                 const ::com::sun::star::rendering::ViewState&      viewState,
+                                 const ::com::sun::star::rendering::RenderState&    renderState );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XGraphicDevice >
+            getDevice();
+
+        // Flush drawing queue to screen
+        void                    flush() const;
+
+        /** Called from XCanvas base classes, to notify that content
+            is _about_ to change
+        */
+        void modifying() {}
+
+        /** Write out recorded actions
+         */
+        bool renderRecordedActions() const;
+
+    private:
+        // declared, but not defined
+        CanvasHelper( const CanvasHelper& );
+
+        struct Action;
+        typedef o3tl::cow_wrapper< std::vector<Action>,
+                                   o3tl::ThreadSafeRefCountingPolicy > RecordVectorT;
+
+        void setupGraphicsState( Action&                                         o_action,
+                                 const ::com::sun::star::rendering::ViewState&   viewState, 
+                                 const ::com::sun::star::rendering::RenderState& renderState );
+
+        /** Phyical output device
+
+            Deliberately not a refcounted reference, because of
+            potential circular references for spritecanvas.
+         */
+        ::com::sun::star::rendering::XGraphicDevice* mpDevice;
+
+        /** Ptr to array of recorded render calls
+
+            Gets shared copy-on-write, when this CanvasHelper is
+            copied (used e.g. for CanvasBitmap)
+         */
+        RecordVectorT                                mpRecordedActions;
+    };
+}
+
+#endif
diff --git canvas/source/opengl/ogl_spritecanvas.cxx canvas/source/opengl/ogl_spritecanvas.cxx
new file mode 100644
index 0000000..55d0429
--- /dev/null
+++ canvas/source/opengl/ogl_spritecanvas.cxx
@@ -0,0 +1,204 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_canvas.hxx"
+
+#include "ogl_spritecanvas.hxx"
+
+#include <canvas/debug.hxx>
+#include <canvas/verbosetrace.hxx>
+#include <tools/diagnose_ex.h>
+
+#include <osl/mutex.hxx>
+
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/registry/XRegistryKey.hpp>
+#include <com/sun/star/lang/XSingleServiceFactory.hpp>
+#include <com/sun/star/lang/NoSupportException.hpp>
+
+#include <toolkit/helper/vclunohelper.hxx>
+#include <cppuhelper/factory.hxx>
+#include <cppuhelper/implementationentry.hxx>
+#include <comphelper/servicedecl.hxx>
+
+#include "ogl_canvascustomsprite.hxx"
+
+#include <GL/gl.h>
+#include <GL/glext.h>
+
+#define SPRITECANVAS_SERVICE_NAME        "com.sun.star.rendering.SpriteCanvas.OGL"
+#define SPRITECANVAS_IMPLEMENTATION_NAME "com.sun.star.comp.rendering.SpriteCanvas.OGL"
+
+
+using namespace ::com::sun::star;
+
+namespace oglcanvas
+{
+    SpriteCanvas::SpriteCanvas( const uno::Sequence< uno::Any >&                aArguments,
+                                const uno::Reference< uno::XComponentContext >& rxContext ) :
+        maArguments(aArguments),
+        mxComponentContext( rxContext ),
+        maActiveSprites()
+    {
+    }
+
+    void SpriteCanvas::initialize()
+    {
+        // Only call initialize when not in probe mode
+        if( maArguments.getLength() == 0 )
+            return;
+
+        VERBOSE_TRACE( "SpriteCanvas::initialize called" );
+
+        /* aArguments:
+           0: ptr to creating instance (Window or VirtualDevice)
+           1: SystemEnvData as a streamed Any (or empty for VirtualDevice)
+           2: current bounds of creating instance
+           3: bool, denoting always on top state for Window (always false for VirtualDevice)
+           4: XWindow for creating Window (or empty for VirtualDevice)
+           5: SystemGraphicsData as a streamed Any
+         */
+        ENSURE_ARG_OR_THROW( maArguments.getLength() >= 5 &&
+                             maArguments[4].getValueTypeClass() == uno::TypeClass_INTERFACE, 
+                             "OpenGL SpriteCanvas::initialize: wrong number of arguments, or wrong types" );
+
+        uno::Reference< awt::XWindow > xParentWindow;
+        maArguments[4] >>= xParentWindow;
+        Window* pParentWindow = VCLUnoHelper::GetWindow(xParentWindow);
+        if( !pParentWindow )
+            throw lang::NoSupportException(
+                ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(
+                                     "Parent window not VCL window, or canvas out-of-process!")),
+                NULL);            
+
+        // setup helper
+        maDeviceHelper.init( *pParentWindow,
+                             *this );
+        maCanvasHelper.init( *this );
+        maArguments.realloc(0);
+    }
+
+    void SAL_CALL SpriteCanvas::disposing()
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        mxComponentContext.clear();
+
+        // forward to parent
+        SpriteCanvasBaseT::disposing();
+    }
+
+    ::sal_Bool SAL_CALL SpriteCanvas::showBuffer( ::sal_Bool bUpdateAll ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // avoid repaints on hidden window (hidden: not mapped to
+        // screen). Return failure, since the screen really has _not_
+        // been updated (caller should try again later)
+        return !mbIsVisible ? false : SpriteCanvasBaseT::showBuffer( bUpdateAll );
+    }
+
+    ::sal_Bool SAL_CALL SpriteCanvas::switchBuffer( ::sal_Bool bUpdateAll ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // avoid repaints on hidden window (hidden: not mapped to
+        // screen). Return failure, since the screen really has _not_
+        // been updated (caller should try again later)
+        return !mbIsVisible ? false : SpriteCanvasBaseT::switchBuffer( bUpdateAll );
+    }
+
+    uno::Reference< rendering::XAnimatedSprite > SAL_CALL SpriteCanvas::createSpriteFromAnimation( 
+        const uno::Reference< rendering::XAnimation >& /*animation*/ ) throw (lang::IllegalArgumentException, 
+                                                                              uno::RuntimeException)
+    {
+        return uno::Reference< rendering::XAnimatedSprite >();
+    }
+
+    uno::Reference< rendering::XAnimatedSprite > SAL_CALL SpriteCanvas::createSpriteFromBitmaps( 
+        const uno::Sequence< uno::Reference< rendering::XBitmap > >& /*animationBitmaps*/, 
+        ::sal_Int8 /*interpolationMode*/ ) throw (lang::IllegalArgumentException, 
+                                                  rendering::VolatileContentDestroyedException, 
+                                                  uno::RuntimeException)
+    {
+        return uno::Reference< rendering::XAnimatedSprite >();
+    }
+
+    uno::Reference< rendering::XCustomSprite > SAL_CALL SpriteCanvas::createCustomSprite( 
+        const geometry::RealSize2D& spriteSize ) throw (lang::IllegalArgumentException, 
+                                                        uno::RuntimeException)
+    {
+        return uno::Reference< rendering::XCustomSprite >( 
+            new CanvasCustomSprite(spriteSize, this) );
+    }
+
+    uno::Reference< rendering::XSprite > SAL_CALL SpriteCanvas::createClonedSprite( 
+        const uno::Reference< rendering::XSprite >& original ) throw (lang::IllegalArgumentException, 
+                                                                      uno::RuntimeException)
+    {
+        return uno::Reference< rendering::XSprite >();
+    }
+
+    sal_Bool SAL_CALL SpriteCanvas::updateScreen( sal_Bool /*bUpdateAll*/ ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // avoid repaints on hidden window (hidden: not mapped to
+        // screen). Return failure, since the screen really has _not_
+        // been updated (caller should try again later)
+        if( mbIsVisible )
+        {
+            glClearColor(0,0,0,0);
+            glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+        }
+        else
+        {
+            return mbIsVisible;
+        }
+    }
+
+    ::rtl::OUString SAL_CALL SpriteCanvas::getServiceName(  ) throw (uno::RuntimeException)
+    {
+        return ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( SPRITECANVAS_SERVICE_NAME ) );
+    }
+
+    void SpriteCanvas::show( const uno::Reference< rendering::XSprite >& xSprite )
+    {
+        maActiveSprites.insert(xSprite);
+    }
+
+    void SpriteCanvas::hide( const uno::Reference< rendering::XSprite >& xSprite )
+    {
+        maActiveSprites.erase(xSprite);
+    }
+
+    static uno::Reference<uno::XInterface> initCanvas( SpriteCanvas* pCanvas )
+    {
+        uno::Reference<uno::XInterface> xRet(static_cast<cppu::OWeakObject*>(pCanvas));
+        pCanvas->initialize();
+        return xRet;
+    }
+
+    namespace sdecl = comphelper::service_decl;
+    sdecl::class_<SpriteCanvas, sdecl::with_args<true> > serviceImpl(&initCanvas);
+    const sdecl::ServiceDecl oglSpriteCanvasDecl(
+        serviceImpl,
+        SPRITECANVAS_IMPLEMENTATION_NAME,
+        SPRITECANVAS_SERVICE_NAME );
+}
+
+// The C shared lib entry points
+COMPHELPER_SERVICEDECL_EXPORTS1(oglcanvas::oglSpriteCanvasDecl);
diff --git canvas/source/opengl/ogl_spritecanvas.hxx canvas/source/opengl/ogl_spritecanvas.hxx
new file mode 100644
index 0000000..8ac8dca
--- /dev/null
+++ canvas/source/opengl/ogl_spritecanvas.hxx
@@ -0,0 +1,125 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+#ifndef OGL_SPRITECANVAS_HXX_
+#define OGL_SPRITECANVAS_HXX_
+
+#include <rtl/ref.hxx>
+
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/lang/XServiceName.hpp>
+#include <com/sun/star/awt/XWindowListener.hpp>
+#include <com/sun/star/util/XUpdatable.hpp>
+#include <com/sun/star/rendering/XSpriteCanvas.hpp>
+#include <com/sun/star/rendering/XGraphicDevice.hpp>
+#include <com/sun/star/rendering/XBufferController.hpp>
+#include <com/sun/star/rendering/XParametricPolyPolygon2DFactory.hpp>
+
+#include <cppuhelper/compbase8.hxx>
+#include <comphelper/uno3.hxx>
+
+#include <canvas/base/spritecanvasbase.hxx>
+#include <canvas/base/basemutexhelper.hxx>
+#include <canvas/base/bufferedgraphicdevicebase.hxx>
+
+#include "ogl_spritedevicehelper.hxx"
+#include "ogl_canvashelper.hxx"
+
+#include <set>
+
+
+namespace oglcanvas
+{
+    typedef ::cppu::WeakComponentImplHelper8< ::com::sun::star::rendering::XSpriteCanvas,
+                                              ::com::sun::star::rendering::XGraphicDevice,
+                                              ::com::sun::star::rendering::XParametricPolyPolygon2DFactory,
+                                              ::com::sun::star::rendering::XBufferController,
+                                              ::com::sun::star::awt::XWindowListener,
+                                              ::com::sun::star::util::XUpdatable,
+                                              ::com::sun::star::beans::XPropertySet,
+                                              ::com::sun::star::lang::XServiceName >    WindowGraphicDeviceBase_Base;
+    typedef ::canvas::BufferedGraphicDeviceBase< ::canvas::BaseMutexHelper< WindowGraphicDeviceBase_Base >,
+                                                 SpriteDeviceHelper, 
+                                                 ::osl::MutexGuard,
+                                                 ::cppu::OWeakObject >  SpriteCanvasDeviceBaseT;
+
+	typedef ::canvas::CanvasBase< SpriteCanvasDeviceBaseT,
+                                  CanvasHelper,
+                                  ::osl::MutexGuard,
+                                  ::cppu::OWeakObject >			SpriteCanvasBaseT;
+
+    /** Product of this component's factory.
+
+        The SpriteCanvas object combines the actual Window canvas with
+        the XGraphicDevice interface. This is because there's a
+        one-to-one relation between them, anyway, since each window
+        can have exactly one canvas and one associated
+        XGraphicDevice. And to avoid messing around with circular
+        references, this is implemented as one single object.
+     */
+    class SpriteCanvas : public SpriteCanvasBaseT
+    {
+    public:
+        SpriteCanvas( const ::com::sun::star::uno::Sequence< 
+                            ::com::sun::star::uno::Any >&               aArguments,
+                      const ::com::sun::star::uno::Reference< 
+                            ::com::sun::star::uno::XComponentContext >& rxContext );
+
+        void initialize();
+
+#if defined __SUNPRO_CC
+        using SpriteCanvasBaseT::disposing;
+#endif
+
+        /// Dispose all internal references
+        virtual void SAL_CALL disposing();
+
+        // Forwarding the XComponent implementation to the
+        // cppu::ImplHelper templated base
+        //                                    Classname     Base doing refcounting        Base implementing the XComponent interface
+        //                                       |                 |                            |
+        //                                       V                 V                            V
+        DECLARE_UNO3_XCOMPONENT_AGG_DEFAULTS( SpriteCanvas, WindowGraphicDeviceBase_Base, ::cppu::WeakComponentImplHelperBase );
+
+        // XBufferController (partial)
+        virtual ::sal_Bool SAL_CALL showBuffer( ::sal_Bool bUpdateAll ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::sal_Bool SAL_CALL switchBuffer( ::sal_Bool bUpdateAll ) throw (::com::sun::star::uno::RuntimeException);
+
+        // XSpriteCanvas
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XAnimatedSprite > SAL_CALL createSpriteFromAnimation( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XAnimation >& animation ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XAnimatedSprite > SAL_CALL createSpriteFromBitmaps( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmap > >& animationBitmaps, ::sal_Int8 interpolationMode ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::rendering::VolatileContentDestroyedException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCustomSprite > SAL_CALL createCustomSprite( const ::com::sun::star::geometry::RealSize2D& spriteSize ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XSprite > SAL_CALL createClonedSprite( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XSprite >& original ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::sal_Bool SAL_CALL updateScreen( ::sal_Bool bUpdateAll ) throw (::com::sun::star::uno::RuntimeException);
+
+        // XServiceName
+        virtual ::rtl::OUString SAL_CALL getServiceName(  ) throw (::com::sun::star::uno::RuntimeException);
+
+        void show( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XSprite >& );
+        void hide( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XSprite >& );
+
+    private:
+        ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >                maArguments;
+        ::com::sun::star::uno::Reference< ::com::sun::star::uno::XComponentContext > mxComponentContext;
+        std::set< 
+            ::com::sun::star::uno::Reference<
+                ::com::sun::star::rendering::XSprite > >                             maActiveSprites;
+    };
+
+    typedef ::rtl::Reference< SpriteCanvas > SpriteCanvasRef;
+}
+
+#endif
diff --git canvas/source/opengl/ogl_spritedevicehelper.cxx canvas/source/opengl/ogl_spritedevicehelper.cxx
new file mode 100644
index 0000000..c10adfc
--- /dev/null
+++ canvas/source/opengl/ogl_spritedevicehelper.cxx
@@ -0,0 +1,220 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_canvas.hxx"
+
+#include "ogl_spritedevicehelper.hxx"
+#include "ogl_spritecanvas.hxx"
+
+#include <canvas/verbosetrace.hxx>
+#include <basegfx/tools/canvastools.hxx>
+#include <basegfx/tools/unopolypolygon.hxx>
+
+#include <osl/mutex.hxx>
+#include <rtl/instance.hxx>
+#include <com/sun/star/uno/Reference.hxx>
+#include <com/sun/star/rendering/XColorSpace.hpp>
+#include <com/sun/star/rendering/XIntegerBitmapColorSpace.hpp>
+
+#include <GL/gl.h>
+#include <GL/glext.h>
+
+
+using namespace ::com::sun::star;
+
+namespace oglcanvas
+{
+    SpriteDeviceHelper::SpriteDeviceHelper() :
+        mpDevice(NULL),
+        mpSpriteCanvas(NULL)
+    {}
+
+    void SpriteDeviceHelper::init( Window&       /*rWindow*/,
+                                   SpriteCanvas& rSpriteCanvas )
+    {
+        mpSpriteCanvas = &rSpriteCanvas;
+
+        // check for GL_ARB_imaging extension
+        glEnable(GL_POINT_SMOOTH);
+        glEnable(GL_LINE_SMOOTH);
+        glEnable(GL_POLYGON_SMOOTH);
+        glHint(GL_POINT_SMOOTH_HINT,GL_NICEST);
+        glHint(GL_LINE_SMOOTH_HINT,GL_NICEST);
+        glHint(GL_POLYGON_SMOOTH_HINT,GL_NICEST);
+        glShadeModel(GL_FLAT);
+
+        if( mpDevice )
+        {
+            glClearColor(0,0,0,0);
+            glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+        }
+    }
+
+    void SpriteDeviceHelper::disposing()
+    {
+        // release all references
+        mpSpriteCanvas = NULL;
+        mpDevice = NULL;
+    }
+
+    geometry::RealSize2D SpriteDeviceHelper::getPhysicalResolution()
+    {
+        return geometry::RealSize2D( 75, 75 );
+    }
+
+    geometry::RealSize2D SpriteDeviceHelper::getPhysicalSize()
+    {
+        return geometry::RealSize2D( 210, 280 );
+    }
+
+    uno::Reference< rendering::XLinePolyPolygon2D > SpriteDeviceHelper::createCompatibleLinePolyPolygon( 
+        const uno::Reference< rendering::XGraphicDevice >& 				/*rDevice*/,
+        const uno::Sequence< uno::Sequence< geometry::RealPoint2D > >&	points )
+    {
+        // disposed?
+        if( !mpSpriteCanvas )
+            return uno::Reference< rendering::XLinePolyPolygon2D >(); // we're disposed
+
+        return uno::Reference< rendering::XLinePolyPolygon2D >( 
+            new ::basegfx::unotools::UnoPolyPolygon( 
+                ::basegfx::unotools::polyPolygonFromPoint2DSequenceSequence( points )));
+    }
+
+    uno::Reference< rendering::XBezierPolyPolygon2D > SpriteDeviceHelper::createCompatibleBezierPolyPolygon( 
+        const uno::Reference< rendering::XGraphicDevice >& 						/*rDevice*/,
+        const uno::Sequence< uno::Sequence< geometry::RealBezierSegment2D > >&	points )
+    {
+        // disposed?
+        if( !mpSpriteCanvas )
+            return uno::Reference< rendering::XBezierPolyPolygon2D >(); // we're disposed
+
+        return uno::Reference< rendering::XBezierPolyPolygon2D >( 
+            new ::basegfx::unotools::UnoPolyPolygon( 
+                ::basegfx::unotools::polyPolygonFromBezier2DSequenceSequence( points ) ) );
+    }
+
+    uno::Reference< rendering::XBitmap > SpriteDeviceHelper::createCompatibleBitmap( 
+        const uno::Reference< rendering::XGraphicDevice >& 	/*rDevice*/,
+        const geometry::IntegerSize2D& 						/*size*/ )
+    {
+        // disposed?
+        if( !mpSpriteCanvas )
+            return uno::Reference< rendering::XBitmap >(); // we're disposed
+
+        // TODO
+        return uno::Reference< rendering::XBitmap >(); 
+    }
+
+    uno::Reference< rendering::XVolatileBitmap > SpriteDeviceHelper::createVolatileBitmap( 
+        const uno::Reference< rendering::XGraphicDevice >& 	/*rDevice*/,
+        const geometry::IntegerSize2D& 						/*size*/ )
+    {
+        return uno::Reference< rendering::XVolatileBitmap >();
+    }
+
+    uno::Reference< rendering::XBitmap > SpriteDeviceHelper::createCompatibleAlphaBitmap( 
+        const uno::Reference< rendering::XGraphicDevice >& 	/*rDevice*/,
+        const geometry::IntegerSize2D& 						/*size*/ )
+    {
+        // disposed?
+        if( !mpSpriteCanvas )
+            return uno::Reference< rendering::XBitmap >(); // we're disposed
+
+        // TODO
+        return uno::Reference< rendering::XBitmap >(); 
+    }
+
+    uno::Reference< rendering::XVolatileBitmap > SpriteDeviceHelper::createVolatileAlphaBitmap( 
+        const uno::Reference< rendering::XGraphicDevice >& 	/*rDevice*/,
+        const geometry::IntegerSize2D& 						/*size*/ )
+    {
+        return uno::Reference< rendering::XVolatileBitmap >();
+    }
+
+    sal_Bool SpriteDeviceHelper::hasFullScreenMode()
+    {
+        // TODO(F3): offer fullscreen mode the XCanvas way
+        return false;
+    }
+
+    sal_Bool SpriteDeviceHelper::enterFullScreenMode( sal_Bool /*bEnter*/ )
+    {
+        // TODO(F3): offer fullscreen mode the XCanvas way
+        return false;
+    }
+    
+    ::sal_Int32 SpriteDeviceHelper::createBuffers( ::sal_Int32 /*nBuffers*/ )
+    {
+        // TODO(F3): implement XBufferStrategy interface. For now, we
+        // _always_ will have exactly one backbuffer
+        return 1;
+    }
+
+    void SpriteDeviceHelper::destroyBuffers()
+    {
+        // TODO(F3): implement XBufferStrategy interface. For now, we
+        // _always_ will have exactly one backbuffer
+    }
+
+    ::sal_Bool SpriteDeviceHelper::showBuffer( bool bIsVisible, ::sal_Bool bUpdateAll )
+    {
+        // forward to sprite canvas helper
+        if( !bIsVisible || !mpSpriteCanvas )
+            return false;
+
+        return mpSpriteCanvas->updateScreen( bUpdateAll );
+    }
+
+    ::sal_Bool SpriteDeviceHelper::switchBuffer( bool bIsVisible, ::sal_Bool bUpdateAll )
+    {
+        // no difference for VCL canvas
+        return showBuffer( bIsVisible, bUpdateAll );
+    }
+
+    uno::Any SpriteDeviceHelper::isAccelerated() const
+    {
+        return ::com::sun::star::uno::makeAny(false);
+    }
+
+    uno::Any SpriteDeviceHelper::getDeviceHandle() const
+    {
+        return uno::Any();
+    }
+
+    uno::Any SpriteDeviceHelper::getSurfaceHandle() const
+    {
+        return uno::Any();
+    }
+
+    uno::Reference<rendering::XColorSpace> SpriteDeviceHelper::getColorSpace() const
+    {
+        // always the same
+        return uno::Reference<rendering::XColorSpace>(
+            ::canvas::tools::getStdColorSpace(),
+            uno::UNO_QUERY);
+    }
+
+    void SpriteDeviceHelper::notifySizeUpdate( const awt::Rectangle& /*rBounds*/ )
+    {
+        // TODO
+    }
+
+    void SpriteDeviceHelper::dumpScreenContent() const
+    {
+        OSL_TRACE( "%s\n",
+                   BOOST_CURRENT_FUNCTION );
+    }
+}
diff --git canvas/source/opengl/ogl_spritedevicehelper.hxx canvas/source/opengl/ogl_spritedevicehelper.hxx
new file mode 100644
index 0000000..3683dbc
--- /dev/null
+++ canvas/source/opengl/ogl_spritedevicehelper.hxx
@@ -0,0 +1,102 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+#ifndef OGL_SPRITEDEVICEHELPER_HXX
+#define OGL_SPRITEDEVICEHELPER_HXX
+
+#include <com/sun/star/rendering/XGraphicDevice.hpp>
+#include <boost/utility.hpp>
+
+class Window;
+namespace basegfx{ class B2IVector; }
+namespace com { namespace sun { namespace star { namespace awt {
+    struct Rectangle;
+}}}}
+
+namespace oglcanvas
+{
+    class SpriteCanvas;
+
+    class SpriteDeviceHelper : private ::boost::noncopyable
+    {
+    public:
+        SpriteDeviceHelper();
+
+        void init( Window&       rWindow,
+                   SpriteCanvas& rSpriteCanvas );
+
+        /// Dispose all internal references
+        void disposing();
+
+        // XWindowGraphicDevice
+        ::com::sun::star::geometry::RealSize2D getPhysicalResolution();
+        ::com::sun::star::geometry::RealSize2D getPhysicalSize();
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XLinePolyPolygon2D > createCompatibleLinePolyPolygon(
+            const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XGraphicDevice >&                               rDevice,
+            const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::geometry::RealPoint2D > >& points );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBezierPolyPolygon2D > createCompatibleBezierPolyPolygon(
+            const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XGraphicDevice >&                                       rDevice,
+            const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::geometry::RealBezierSegment2D > >& points );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmap > createCompatibleBitmap(
+            const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XGraphicDevice >&  rDevice,
+            const ::com::sun::star::geometry::IntegerSize2D&                                        size );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XVolatileBitmap > createVolatileBitmap(
+            const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XGraphicDevice >&  rDevice,
+            const ::com::sun::star::geometry::IntegerSize2D&                                        size );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmap > createCompatibleAlphaBitmap(
+            const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XGraphicDevice >&  rDevice,
+            const ::com::sun::star::geometry::IntegerSize2D&                                        size );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XVolatileBitmap > createVolatileAlphaBitmap(
+            const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XGraphicDevice >&  rDevice,
+            const ::com::sun::star::geometry::IntegerSize2D&                                        size );
+
+        sal_Bool hasFullScreenMode(  );
+        sal_Bool enterFullScreenMode( sal_Bool bEnter );
+
+        ::sal_Int32 createBuffers( ::sal_Int32 nBuffers );
+        void        destroyBuffers(  );
+        ::sal_Bool  showBuffer( bool bIsVisible, ::sal_Bool bUpdateAll );
+        ::sal_Bool  switchBuffer( bool bIsVisible, ::sal_Bool bUpdateAll );
+
+        ::com::sun::star::uno::Any isAccelerated() const;
+        ::com::sun::star::uno::Any getDeviceHandle() const;
+        ::com::sun::star::uno::Any getSurfaceHandle() const;
+        ::com::sun::star::uno::Reference< 
+            ::com::sun::star::rendering::XColorSpace > getColorSpace() const;
+
+        void notifySizeUpdate( const ::com::sun::star::awt::Rectangle& rBounds );
+
+        /** called when DumpScreenContent property is enabled on
+            XGraphicDevice, and writes out bitmaps of current screen.
+         */
+        void dumpScreenContent() const;
+
+    private:
+        void resize( const ::basegfx::B2IVector& rNewSize );
+
+        /** Phyical output device
+
+            Deliberately not a refcounted reference, because of
+            potential circular references for canvas. Needed to
+            create bitmaps
+         */
+        com::sun::star::rendering::XGraphicDevice* mpDevice;
+
+        /// Pointer to sprite canvas (owner of this helper), needed to create bitmaps
+        SpriteCanvas*                              mpSpriteCanvas;
+    };
+}
+
+#endif
diff --git canvas/source/opengl/ogl_textlayout.cxx canvas/source/opengl/ogl_textlayout.cxx
new file mode 100644
index 0000000..87d1a02
--- /dev/null
+++ canvas/source/opengl/ogl_textlayout.cxx
@@ -0,0 +1,222 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_canvas.hxx"
+
+#include "ogl_textlayout.hxx"
+
+#include <canvas/debug.hxx>
+#include <canvas/verbosetrace.hxx>
+#include <tools/diagnose_ex.h>
+
+#include <basegfx/matrix/b2dhommatrix.hxx>
+#include <basegfx/numeric/ftools.hxx>
+
+
+using namespace ::com::sun::star;
+
+namespace oglcanvas
+{
+    TextLayout::TextLayout( const rendering::StringContext&     aText, 
+                            sal_Int8                            nDirection, 
+                            sal_Int64                           /*nRandomSeed*/,
+                            const CanvasFont::ImplRef&          rFont ) :
+        TextLayoutBaseT( m_aMutex ),
+        maText( aText ),
+        maLogicalAdvancements(),
+        mpFont( rFont ),
+        mnTextDirection( nDirection )
+    {
+    }
+    
+    void SAL_CALL TextLayout::disposing()
+    {
+        mpFont.reset();
+    }
+
+    // XTextLayout
+    uno::Sequence< uno::Reference< rendering::XPolyPolygon2D > > SAL_CALL TextLayout::queryTextShapes(  ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // TODO
+        return uno::Sequence< uno::Reference< rendering::XPolyPolygon2D > >();
+    }
+
+    uno::Sequence< geometry::RealRectangle2D > SAL_CALL TextLayout::queryInkMeasures(  ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // TODO
+        return uno::Sequence< geometry::RealRectangle2D >();
+    }
+
+    uno::Sequence< geometry::RealRectangle2D > SAL_CALL TextLayout::queryMeasures(  ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // TODO
+        return uno::Sequence< geometry::RealRectangle2D >();
+    }
+
+    uno::Sequence< double > SAL_CALL TextLayout::queryLogicalAdvancements(  ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        return maLogicalAdvancements;
+    }
+
+    void SAL_CALL TextLayout::applyLogicalAdvancements( const uno::Sequence< double >& aAdvancements ) throw (lang::IllegalArgumentException, uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        if( aAdvancements.getLength() != maText.Length )
+        {
+            OSL_TRACE( "TextLayout::applyLogicalAdvancements(): mismatching number of advancements" );
+            throw lang::IllegalArgumentException();
+        }
+
+        maLogicalAdvancements = aAdvancements;
+    }
+
+    geometry::RealRectangle2D SAL_CALL TextLayout::queryTextBounds(  ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        ENSURE_OR_THROW( mpFont.get(),
+                         "TextLayout::queryTextBounds(): invalid font" );
+
+        // fake text bounds by either taking the advancement values,
+        // or assuming square glyph boxes (width similar to height)
+        const rendering::FontRequest& rFontRequest( mpFont->getFontRequest() );
+        const double nFontSize( ::std::max( rFontRequest.CellSize,
+                                            rFontRequest.ReferenceAdvancement ) );
+        if( maLogicalAdvancements.getLength() )
+        {
+            return geometry::RealRectangle2D( 0, -nFontSize/2,
+                                              maLogicalAdvancements[ maLogicalAdvancements.getLength()-1 ],
+                                              nFontSize/2 );
+        }
+        else
+        {
+            return geometry::RealRectangle2D( 0, -nFontSize/2,
+                                              nFontSize * maText.Length,
+                                              nFontSize/2 );
+        }
+    }
+
+    double SAL_CALL TextLayout::justify( double /*nSize*/ ) throw (lang::IllegalArgumentException, uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // TODO
+        return 0.0;
+    }
+
+    double SAL_CALL TextLayout::combinedJustify( const uno::Sequence< uno::Reference< rendering::XTextLayout > >& /*aNextLayouts*/, 
+                                                 double /*nSize*/ ) throw (lang::IllegalArgumentException, uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // TODO
+        return 0.0;
+    }
+
+    rendering::TextHit SAL_CALL TextLayout::getTextHit( const geometry::RealPoint2D& /*aHitPoint*/ ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // TODO
+        return rendering::TextHit();
+    }
+
+    rendering::Caret SAL_CALL TextLayout::getCaret( sal_Int32 /*nInsertionIndex*/, 
+                                                    sal_Bool  /*bExcludeLigatures*/ ) throw (lang::IndexOutOfBoundsException, uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // TODO
+        return rendering::Caret();
+    }
+
+    sal_Int32 SAL_CALL TextLayout::getNextInsertionIndex( sal_Int32 /*nStartIndex*/, 
+                                                          sal_Int32 /*nCaretAdvancement*/, 
+                                                          sal_Bool  /*bExcludeLigatures*/ ) throw (lang::IndexOutOfBoundsException, uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // TODO
+        return 0;
+    }
+
+    uno::Reference< rendering::XPolyPolygon2D > SAL_CALL TextLayout::queryVisualHighlighting( sal_Int32 /*nStartIndex*/, 
+                                                                                              sal_Int32 /*nEndIndex*/ ) throw (lang::IndexOutOfBoundsException, uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // TODO
+        return uno::Reference< rendering::XPolyPolygon2D >();
+    }
+
+    uno::Reference< rendering::XPolyPolygon2D > SAL_CALL TextLayout::queryLogicalHighlighting( sal_Int32 /*nStartIndex*/, 
+                                                                                               sal_Int32 /*nEndIndex*/ ) throw (lang::IndexOutOfBoundsException, uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // TODO
+        return uno::Reference< rendering::XPolyPolygon2D >();
+    }
+
+    double SAL_CALL TextLayout::getBaselineOffset(  ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // TODO
+        return 0.0;
+    }
+
+    sal_Int8 SAL_CALL TextLayout::getMainTextDirection(  ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        return mnTextDirection;
+    }
+
+    uno::Reference< rendering::XCanvasFont > SAL_CALL TextLayout::getFont(  ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        return mpFont.getRef();
+    }
+
+    rendering::StringContext SAL_CALL TextLayout::getText(  ) throw (uno::RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        return maText;
+    }
+  
+    bool TextLayout::draw( const rendering::ViewState&                          /*rViewState*/, 
+                           const rendering::RenderState&                        /*rRenderState*/,
+                           const uno::Reference< rendering::XGraphicDevice >&   /*xGraphicDevice*/ ) const
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+
+        // TODO
+
+        return true;
+    }
+}
diff --git canvas/source/opengl/ogl_textlayout.hxx canvas/source/opengl/ogl_textlayout.hxx
new file mode 100644
index 0000000..f822a19
--- /dev/null
+++ canvas/source/opengl/ogl_textlayout.hxx
@@ -0,0 +1,83 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Thorsten Behrens <tbehrens@novell.com>      
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+#ifndef OGL_TEXTLAYOUT_HXX
+#define OGL_TEXTLAYOUT_HXX
+
+#include <cppuhelper/compbase1.hxx>
+#include <comphelper/broadcasthelper.hxx>
+
+#include <com/sun/star/rendering/XTextLayout.hpp>
+
+#include <basegfx/vector/b2isize.hxx>
+
+#include <boost/utility.hpp>
+
+#include "ogl_canvasfont.hxx"
+
+
+/* Definition of TextLayout class */
+
+namespace oglcanvas
+{
+    typedef ::cppu::WeakComponentImplHelper1< ::com::sun::star::rendering::XTextLayout > TextLayoutBaseT;
+
+    class TextLayout : public ::comphelper::OBaseMutex, 
+                       public TextLayoutBaseT,
+                       private ::boost::noncopyable
+    {
+    public:
+        TextLayout( const ::com::sun::star::rendering::StringContext& aText, 
+                    sal_Int8                                          nDirection, 
+                    sal_Int64                                         nRandomSeed,
+                    const CanvasFont::ImplRef&                        rFont );
+
+        /// Dispose all internal references
+        virtual void SAL_CALL disposing();
+
+        // XTextLayout
+        virtual ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D > > SAL_CALL queryTextShapes(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Sequence< ::com::sun::star::geometry::RealRectangle2D > SAL_CALL queryInkMeasures(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Sequence< ::com::sun::star::geometry::RealRectangle2D > SAL_CALL queryMeasures(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Sequence< double > SAL_CALL queryLogicalAdvancements(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual void SAL_CALL applyLogicalAdvancements( const ::com::sun::star::uno::Sequence< double >& aAdvancements ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::geometry::RealRectangle2D SAL_CALL queryTextBounds(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual double SAL_CALL justify( double nSize ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual double SAL_CALL combinedJustify( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XTextLayout > >& aNextLayouts, double nSize ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::rendering::TextHit SAL_CALL getTextHit( const ::com::sun::star::geometry::RealPoint2D& aHitPoint ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::rendering::Caret SAL_CALL getCaret( sal_Int32 nInsertionIndex, sal_Bool bExcludeLigatures ) throw (::com::sun::star::lang::IndexOutOfBoundsException, ::com::sun::star::uno::RuntimeException);
+        virtual sal_Int32 SAL_CALL getNextInsertionIndex( sal_Int32 nStartIndex, sal_Int32 nCaretAdvancement, sal_Bool bExcludeLigatures ) throw (::com::sun::star::lang::IndexOutOfBoundsException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D > SAL_CALL queryVisualHighlighting( sal_Int32 nStartIndex, sal_Int32 nEndIndex ) throw (::com::sun::star::lang::IndexOutOfBoundsException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D > SAL_CALL queryLogicalHighlighting( sal_Int32 nStartIndex, sal_Int32 nEndIndex ) throw (::com::sun::star::lang::IndexOutOfBoundsException, ::com::sun::star::uno::RuntimeException);
+        virtual double SAL_CALL getBaselineOffset(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual sal_Int8 SAL_CALL getMainTextDirection(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCanvasFont > SAL_CALL getFont(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::rendering::StringContext SAL_CALL getText(  ) throw (::com::sun::star::uno::RuntimeException);
+        
+        bool draw( const ::com::sun::star::rendering::ViewState&         rViewState, 
+				   const ::com::sun::star::rendering::RenderState&       rRenderState,
+				   const ::com::sun::star::uno::Reference< 
+                         ::com::sun::star::rendering::XGraphicDevice >&  xGraphicDevice ) const;
+
+    private:
+        ::com::sun::star::rendering::StringContext maText;
+        ::com::sun::star::uno::Sequence< double >  maLogicalAdvancements;
+        CanvasFont::ImplRef                        mpFont;
+        sal_Int8                                   mnTextDirection;
+    };
+
+}
+
+#endif
diff --git offapi/com/sun/star/rendering/XSpriteCanvas.idl offapi/com/sun/star/rendering/XSpriteCanvas.idl
index b3717b2..85a3ca8 100644
--- offapi/com/sun/star/rendering/XSpriteCanvas.idl
+++ offapi/com/sun/star/rendering/XSpriteCanvas.idl
@@ -33,7 +33,7 @@
 #ifndef __com_sun_star_lang_IllegalArgumentException_idl__
 #include <com/sun/star/lang/IllegalArgumentException.idl>
 #endif 
-#ifndef __com_sun_star_rendering_XBitmapCanvas_idl__
+#ifndef __com_sun_star_rendering_XCanvas_idl__
 #include <com/sun/star/rendering/XBitmapCanvas.idl>
 #endif
 #ifndef __com_sun_star_rendering_XAnimation_idl__
@@ -49,7 +49,7 @@ interface XSprite;
 interface XAnimatedSprite;
 interface XCustomSprite;
 
-/** Specialization of a XBitmapCanvas, where moving, animated objects
+/** Specialization of a XCanvas, where moving, animated objects
     (called sprites) are supported.<p>
 
     @attention The screen output of canvas drawing operations is
@@ -63,9 +63,9 @@ interface XCustomSprite;
     (because there's a defined moment in time where content display
     can happen, namely the XBufferController::showBuffer()) call. If
     you don't need sprite functionality, and don't want the
-    updateScreen hassle, simply use the XBitmapCanvas.
+    updateScreen hassle, simply use the XCanvas.
  */
-interface XSpriteCanvas : XBitmapCanvas
+interface XSpriteCanvas : XCanvas
 {
 	/** Create a sprite object from the specified animation
 		sequence. A sprite is a back-buffered object with its own,
@@ -117,9 +117,8 @@ interface XSpriteCanvas : XBitmapCanvas
         object.
 
         The cloned sprite always shows the same content as its
-        original. Furthermore, cloned copies of a hidden original are
-        never visible, although cloned copies of a visible original
-        can of course be invisible.
+        original, but of course the sprite position, visibility, alpha
+        etc. can be modified independently.
 
         @param original
         The original sprite to copy the content from. This sprite must
