diff -up /data4/scratch/oof680-m7/sc/source/filter/excel/expop2.cxx sc/source/filter/excel/expop2.cxx
--- /data4/scratch/oof680-m7/sc/source/filter/excel/expop2.cxx	2006-12-19 13:19:28.000000000 +0000
+++ sc/source/filter/excel/expop2.cxx	2007-05-09 14:45:54.000000000 +0100
@@ -65,7 +65,7 @@
 #ifndef SC_XELINK_HXX
 #include "xelink.hxx"
 #endif
-
+#include <hash_map>
 
 ExportBiff5::ExportBiff5( XclExpRootData& rExpData, SvStream& rStrm ):
     ExportTyp( rStrm, &rExpData.mrDoc, rExpData.meTextEnc ),
@@ -109,11 +109,79 @@ FltError ExportBiff5::Write()
     if( pDocShell && xRootStrg.Is() && bWriteBasicStrg )
 	{
         SvxImportMSVBasic aBasicImport( *pDocShell, *xRootStrg, bWriteBasicCode, bWriteBasicStrg );
-        ULONG nErr = aBasicImport.SaveOrDelMSVBAStorage( TRUE, EXC_STORAGE_VBA_PROJECT );
+
+	// find basic modules in Standard ( that don't match the above )
+	// ( of course we can't yet determine if they are classmodules or form modules etc. and will just assume they are normal modules
+
+	com::sun::star::uno::Reference< com::sun::star::script::XLibraryContainer > xBasicLibContainer ( pDocShell->GetBasicContainer(), com::sun::star::uno::UNO_QUERY );
+	com::sun::star::uno::Reference< com::sun::star::script::XLibraryContainer > xDialogLibContainer ( pDocShell->GetDialogContainer(), com::sun::star::uno::UNO_QUERY );
+	// create the vector
+	vecModuleTypes mods;
+	if ( xBasicLibContainer.is() && xDialogLibContainer.is() )
+	{
+		rtl::OUString sThisWorkbook( RTL_CONSTASCII_USTRINGPARAM("ThisWorkbook") );
+		typedef std::hash_map< rtl::OUString, ModuleDesc, ::rtl::OUStringHash, ::std::equal_to< ::rtl::OUString > > ModuleTypeMap;
+		ModuleTypeMap mModules;
+
+		String sStandard( RTL_CONSTASCII_USTRINGPARAM("Standard") );
+		com::sun::star::uno::Reference< com::sun::star::container::XNameContainer > xLibrary( xBasicLibContainer->getByName( sStandard ), com::sun::star::uno::UNO_QUERY ); 
+		com::sun::star::uno::Reference< com::sun::star::container::XNameContainer > xDlgLibrary( xDialogLibContainer->getByName( sStandard ), com::sun::star::uno::UNO_QUERY ); 
+		if ( xLibrary.is() && xDlgLibrary.is() ) 
+		{
+			// Always a ThisWorkbook
+			mModules[ sThisWorkbook ] =  ModuleDesc( sThisWorkbook, Document );
+			// Get the codenames for the sheets
+			ScExtDocOptions* pOpts = GetDoc().GetExtDocOptions();
+			for ( SCTAB n=0; n< GetDoc().GetTableCount(); ++n )
+			{
+				String sCodeName;
+				if ( pOpts )
+					sCodeName = pOpts->GetCodeName( n );
+				if ( !sCodeName.Len() )
+					GetDoc().GetName( n, sCodeName );
+				mModules[ sCodeName ] =  ModuleDesc( sCodeName, Document );
+			}
+
+			if ( !xBasicLibContainer->isLibraryLoaded( sStandard ) )
+				xBasicLibContainer->loadLibrary( sStandard );
+			if ( !xDialogLibContainer->isLibraryLoaded( sStandard ) )
+				xDialogLibContainer->loadLibrary( sStandard );
+			
+			com::sun::star::uno::Sequence< ::rtl::OUString > aNames = xLibrary->getElementNames();
+			sal_Int32 nElems = aNames.getLength();
+			for ( sal_Int32 index = 0; index < nElems; ++index )
+			{
+				rtl::OUString sModName = aNames[ index ];
+				ModuleTypeMap::iterator it = mModules.find( sModName );
+				OSL_TRACE("->>>>> cheking module %s, exists? %d", rtl::OUStringToOString( aNames[ index ], RTL_TEXTENCODING_UTF8 ).getStr(), it != mModules.end() );
+				if ( it == mModules.end() ) // doesn't exist
+				{
+					if ( sModName.indexOf( rtl::OUString::createFromAscii("class") ) == 0 )
+						mModules[ sModName ] = ModuleDesc( sModName, Class );
+					else
+					{
+						if ( xDlgLibrary->hasByName( sModName ) )
+							mModules[ sModName ] = ModuleDesc( sModName, Form );
+						else	
+							mModules[ sModName ] = ModuleDesc( sModName, Normal );
+					}
+				}
+			}
+			ModuleTypeMap::iterator it =  mModules.begin();
+			ModuleTypeMap::iterator it_end =  mModules.end();
+			for ( ; it != it_end ; ++it )
+			{
+				OSL_TRACE("->>>>> module %s, mode? %d", rtl::OUStringToOString( it->second.first, RTL_TEXTENCODING_UTF8 ).getStr(), it->second.second );
+				mods.push_back( it->second );
+			}
+
+		}	
+	}
+	// 
+        ULONG nErr = aBasicImport.SaveOrDelMSVBAStorageExtra( TRUE, EXC_STORAGE_VBA_PROJECT, mods );
 		if( nErr != ERRCODE_NONE )
             pDocShell->SetError( nErr );
 	}
-
 	pExcDoc->ReadDoc();			// ScDoc -> ExcDoc
 	pExcDoc->Write( aOut );		// wechstreamen
 
diff -rup /data4/scratch/oof680-m7/svx/inc/svxmsbas.hxx svx/inc/svxmsbas.hxx
--- /data4/scratch/oof680-m7/svx/inc/svxmsbas.hxx	2007-04-30 15:31:30.000000000 +0100
+++ svx/inc/svxmsbas.hxx	2007-05-04 14:52:22.000000000 +0100
@@ -45,6 +45,15 @@
 #endif
 
 #include <sot/storage.hxx>
+#include <vector>
+
+// #117718# define internal types to distinguish between
+// module types, form, class & normal
+// #i37965# DR 2004-12-03: add "Document", used in Excel for macros attached to sheet
+enum ModuleType { Unknown = 0, Normal, Class, Form, Document };
+
+typedef ::std::pair< rtl::OUString, ModuleType > ModuleDesc; // type and group combination
+typedef ::std::vector< ModuleDesc > vecModuleTypes;
 
 class SfxObjectShell;
 
@@ -83,6 +92,7 @@ public:
 	// - returns a warning code if a modified basic exist, in all other
 	//   cases return ERRCODE_NONE.
 	ULONG SaveOrDelMSVBAStorage( BOOL bSaveInto, const String& rStorageName );
+	ULONG SaveOrDelMSVBAStorageExtra( BOOL bSaveInto, const String& rStorageName,  const vecModuleTypes& modules );
 
 	// check if the MS-VBA-Storage exist in the RootStorage of the DocShell.
 	// If it exist, then return the WarningId for loosing the information.
@@ -95,6 +105,11 @@ private:
 	BOOL bImport;
 	BOOL bCopy;
 
+	SVX_DLLPRIVATE BOOL GetVBAStorage(const String& rStorageName,
+					   const String &rSubStorageName,
+					   SvStorageRef &rProject,
+					   SvStorageRef &rVBA,
+					   bool  bCreate);
 	SVX_DLLPRIVATE BOOL ImportCode_Impl( const String& rStorageName,
 						  const String &rSubStorageName,
 						  BOOL bAsComment, BOOL bStripped);
diff -rup /data4/scratch/oof680-m7/svx/inc/svxmsbas.hxx.orig svx/inc/svxmsbas.hxx.orig
--- /data4/scratch/oof680-m7/svx/inc/svxmsbas.hxx.orig	2007-04-26 15:55:09.000000000 +0100
+++ svx/inc/svxmsbas.hxx.orig	2007-05-02 09:15:37.000000000 +0100
@@ -95,11 +95,6 @@ private:
 	BOOL bImport;
 	BOOL bCopy;
 
-	SVX_DLLPRIVATE BOOL GetVBAStorage(const String& rStorageName,
-					   const String &rSubStorageName,
-					   SvStorageRef &rProject,
-					   SvStorageRef &rVBA,
-					   bool  bCreate);
 	SVX_DLLPRIVATE BOOL ImportCode_Impl( const String& rStorageName,
 						  const String &rSubStorageName,
 						  BOOL bAsComment, BOOL bStripped);
diff -rup /data4/scratch/oof680-m7/svx/source/msfilter/makefile.mk svx/source/msfilter/makefile.mk
--- /data4/scratch/oof680-m7/svx/source/msfilter/makefile.mk	2007-04-30 15:31:30.000000000 +0100
+++ svx/source/msfilter/makefile.mk	2007-05-08 13:02:46.000000000 +0100
@@ -53,6 +53,7 @@ SLOFILES=\
 	$(SLO)$/msdffimp.obj	\
 	$(SLO)$/msoleexp.obj	\
 	$(SLO)$/msvbasic.obj	\
+	$(SLO)$/msvbasicdir.obj	\
 	$(SLO)$/msashape.obj	\
 	$(SLO)$/svxmsbas.obj	\
 	$(SLO)$/msocximex.obj	\
@@ -65,6 +66,7 @@ EXCEPTIONSFILES= \
 	$(SLO)$/escherex.obj	\
 	$(SLO)$/msdffimp.obj	\
 	$(SLO)$/msashape3d.obj	\
+	$(SLO)$/msvbasicdir.obj	\
 	$(SLO)$/msvbasic.obj	\
 	$(SLO)$/msocximex.obj	\
 	$(SLO)$/msoleexp.obj	\
diff -rup /data4/scratch/oof680-m7/svx/source/msfilter/msvbasic.hxx svx/source/msfilter/msvbasic.hxx
--- /data4/scratch/oof680-m7/svx/source/msfilter/msvbasic.hxx	2006-06-19 17:20:43.000000000 +0100
+++ svx/source/msfilter/msvbasic.hxx	2007-05-02 14:45:57.000000000 +0100
@@ -54,6 +54,7 @@
 #include <vector>
 #endif
 #include<map>
+#include <svxmsbas.hxx>
 
 /* class VBA:
  * The VBA class provides a set of methods to handle Visual Basic For
@@ -74,10 +75,7 @@
 
 DECLARE_DYNARRAY(StringArray,String *)
 
-// #117718# define internal types to distinguish between
-// module types, form, class & normal
-// #i37965# DR 2004-12-03: add "Document", used in Excel for macros attached to sheet
-enum ModuleType { Unknown = 0, Normal, Class, Form, Document };
+
 
 // #117718# define map to hold types of module
 //
diff -rup /data4/scratch/oof680-m7/svx/source/msfilter/svxmsbas.cxx svx/source/msfilter/svxmsbas.cxx
--- /data4/scratch/oof680-m7/svx/source/msfilter/svxmsbas.cxx	2007-04-30 15:31:30.000000000 +0100
+++ svx/source/msfilter/svxmsbas.cxx	2007-05-09 12:50:57.000000000 +0100
@@ -61,7 +61,7 @@
 #include <svxmsbas.hxx>
 #endif
 #ifndef _MSVBASIC_HXX
-#include <msvbasic.hxx>
+#include <msvbasicdir.hxx>
 #endif
 #ifndef _MSOCXIMEX_HXX
 #include <msocximex.hxx>
@@ -110,6 +110,22 @@ bool lcl_hasVBAEnabled()
 	return false;
 }
 
+std::vector< String > lcl_getUserFormNames( SvStorageRef& xVBAStg )
+{
+	std::vector<String> aUserForms;
+	SvStorageInfoList aContents;
+	xVBAStg->FillInfoList(&aContents);
+	OSL_TRACE("lcl_getUserFormNames info list gives %d entries",  aContents.Count() );
+	for (USHORT nI = 0; nI < aContents.Count(); ++nI)
+	{
+		SvStorageInfo& rInfo = aContents.GetObject(nI);
+		OSL_TRACE("substorage item %d is %s ", nI, rtl::OUStringToOString( rInfo.GetName(), RTL_TEXTENCODING_UTF8 ).getStr() );
+		if (!rInfo.IsStream() && rInfo.GetName() != String( RTL_CONSTASCII_USTRINGPARAM( "VBA" ) ) ) 
+			aUserForms.push_back(rInfo.GetName());
+	}	
+	return aUserForms;
+}
+
 int SvxImportMSVBasic::Import( const String& rStorageName,
 								const String &rSubStorageName,
 								BOOL bAsComment, BOOL bStripped )
@@ -138,15 +154,7 @@ bool SvxImportMSVBasic::ImportForms_Impl
     if (!xVBAStg.Is() || xVBAStg->GetError())
         return false;
 
-    std::vector<String> aUserForms;
-    SvStorageInfoList aContents;
-    xVBAStg->FillInfoList(&aContents);
-    for (USHORT nI = 0; nI < aContents.Count(); ++nI)
-    {
-          SvStorageInfo& rInfo = aContents.GetObject(nI);
-          if (!rInfo.IsStream() && rInfo.GetName() != rSubStorageName)
-              aUserForms.push_back(rInfo.GetName());
-    }
+    std::vector<String> aUserForms = lcl_getUserFormNames(xVBAStg);
 
     if (aUserForms.empty())
         return false;
@@ -277,180 +285,43 @@ BOOL SvxImportMSVBasic::CopyStorage_Impl
 	return bValidStg;
 }
 
+BOOL
+SvxImportMSVBasic::GetVBAStorage(const String &rStorageName,
+								 const String &rSubStorageName,
+								 SvStorageRef &rProject,
+								 SvStorageRef &rVBA,
+								 bool bCreate)
+{
+	ULONG nFlags = STREAM_READWRITE | STREAM_SHARE_DENYALL;
+	
+
+	if( !bCreate )
+			nFlags |= STREAM_NOCREATE;
+	OSL_TRACE("VBA Storage is extracted from %s in %s", rtl::OUStringToOString( rSubStorageName, RTL_TEXTENCODING_UTF8 ).getStr(),  rtl::OUStringToOString( rStorageName, RTL_TEXTENCODING_UTF8 ).getStr() );
+	rProject = xRoot->OpenSotStorage( rStorageName, nFlags );
+	if( rProject.Is() && SVSTREAM_OK == rProject->GetError() )
+	{
+		rVBA = rProject->OpenSotStorage( rSubStorageName, nFlags );
+		if( rVBA.Is() && SVSTREAM_OK == rVBA->GetError() )
+			return true;
+		else
+			DBG_WARNING("No Visual Basic in Storage");
+	}
+	else
+		DBG_WARNING("No Macros Storage");
+
+	return false;
+}
 BOOL SvxImportMSVBasic::ImportCode_Impl( const String& rStorageName,
 										const String &rSubStorageName,
 										BOOL bAsComment, BOOL bStripped )
 {
-	BOOL bRet = FALSE;
-	bAsComment = FALSE;
-	VBA_Impl aVBA( *xRoot, bAsComment );
-	if( aVBA.Open(rStorageName,rSubStorageName) )
+	bool bRet = false;
+	SvStorageRef xProject, xVBA;
+	if( GetVBAStorage( rStorageName, rSubStorageName, xProject, xVBA, false ) )
 	{
-		SFX_APP()->EnterBasicCall();
-        Reference<XLibraryContainer> xLibContainer = rDocSh.GetBasicContainer();
-		DBG_ASSERT( xLibContainer.is(), "No BasicContainer!" );
-
-        UINT16 nStreamCount = aVBA.GetNoStreams();
-		Reference<XNameContainer> xLib;
-        if( xLibContainer.is() && nStreamCount )
-        {
-            String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
-		    if( !xLibContainer->hasByName( aLibName ) )
-			    xLibContainer->createLibrary( aLibName );
-
-            Any aLibAny = xLibContainer->getByName( aLibName );
-		    aLibAny >>= xLib;
-        }
-		if( xLib.is() )
-		{
-			for( UINT16 i=0; i<nStreamCount;i++)
-			{
-				StringArray aDecompressed = aVBA.Decompress(i);
-#if 0
-/*  DR 2005-08-11 #124850# Do not filter special characters from module name.
-    Just put the original module name and let the Basic interpreter deal with
-    it. Needed for roundtrip...
- */
-				ByteString sByteBasic(aVBA.GetStreamName(i),
-					RTL_TEXTENCODING_ASCII_US,
-						(RTL_UNICODETOTEXT_FLAGS_UNDEFINED_UNDERLINE|
-						RTL_UNICODETOTEXT_FLAGS_INVALID_UNDERLINE |
-						RTL_UNICODETOTEXT_FLAGS_PRIVATE_MAPTO0 |
-						RTL_UNICODETOTEXT_FLAGS_NOCOMPOSITE)
-				);
-
-				const String sBasicModule(sByteBasic,
-					RTL_TEXTENCODING_ASCII_US);
-#else
-                const String &sBasicModule = aVBA.GetStreamName( i);
-#endif
-                /* #117718# expose information regarding type of Module
-                * Class, Form or plain 'ould VBA module with a REM statment
-                * at the top of the module. Mapping of Module Name
-                * to type is performed in  VBA_Impl::Open() method,
-                * ( msvbasic.cxx ) by examining the PROJECT stream.
-                */
-
-                // using name from aVBA.GetStreamName
-                // because the encoding of the same returned
-                // is the same as the encoding for the names
-                // that are keys in the map used by GetModuleType method
-                const String &sOrigVBAModName = aVBA.GetStreamName( i );
-                ModuleType mType = aVBA.GetModuleType( sOrigVBAModName );
-
-                rtl::OUString sClassRem( RTL_CONSTASCII_USTRINGPARAM( "Rem Attribute VBA_ModuleType=" ) );
-
-                rtl::OUString modeTypeComment;
-
-                switch( mType )
-                {
-                    case Class:
-                        modeTypeComment = sClassRem +
-                            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAClassModule\n" ) );
-                        break;
-                    case Form:
-                        modeTypeComment = sClassRem +
-                            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAFormModule\n" ) );
-                        break;
-                    case Document:
-                        modeTypeComment = sClassRem +
-                            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBADocumentModule\n" ) );
-                        break;
-                    case Normal:
-                        modeTypeComment = sClassRem +
-                            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAModule\n" ) );
-                        break;
-                    case Unknown:
-                        modeTypeComment = sClassRem +
-                            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAUnknown\n" ) );
-                        break;
-                    default:
-                        DBG_ERRORFILE( "SvxImportMSVBasic::ImportCode_Impl - unknown module type" );
-                        break;
-                }
-				static ::rtl::OUString sVBAOption( RTL_CONSTASCII_USTRINGPARAM( "Option VBASupport 1\n" ) ); 
-				static ::rtl::OUString sClassOption( RTL_CONSTASCII_USTRINGPARAM( "Option ClassModule\n" ) ); 
-				if ( !bAsComment )
-				{
-					modeTypeComment = modeTypeComment + sVBAOption;
-					if ( mType == Class )
-						modeTypeComment = modeTypeComment + sClassOption;
-
-				}
-
-				String sModule(sBasicModule); //#i52606# no need to split Macros in 64KB blocks any more!
-				String sTemp;
-				if (bAsComment)
-				{
-					sTemp+=String(RTL_CONSTASCII_USTRINGPARAM( "Sub " ));
-					String sMunge(sModule);
-					//Streams can have spaces in them, but modulenames
-					//cannot !
-					sMunge.SearchAndReplaceAll(' ','_');
-
-					sTemp += sMunge;
-					sTemp.AppendAscii("\n");
-				};
-	            ::rtl::OUString aSource(sTemp);
-
-				for(ULONG j=0;j<aDecompressed.GetSize();j++)
-				{
-					if (bStripped)
-					{
-                        String *pStr = aDecompressed.Get(j);
-                        bool bMac = true;
-                        xub_StrLen nBegin = pStr->Search('\x0D');
-                        if ((STRING_NOTFOUND != nBegin) && (pStr->Len() > 1) && (pStr->GetChar(nBegin+1) == '\x0A'))
-                            bMac = false;
-
-                        const char cLineEnd = bMac ? '\x0D' : '\x0A';
-                        const String sAttribute(String::CreateFromAscii(
-                            bAsComment ? "Rem Attribute" : "Attribute"));
-						nBegin = 0;
-						while (STRING_NOTFOUND != (nBegin =	pStr->Search(sAttribute, nBegin)))
-						{
-                            if ((nBegin) && pStr->GetChar(nBegin-1) != cLineEnd)
-							{
-                                // npower #i63766# Need to skip instances of Attribute
-								// that are NOT Attribute statements
-								nBegin = nBegin + sAttribute.Len();
-                                continue;
-							}
-							xub_StrLen nEnd = pStr->Search(cLineEnd ,nBegin);
-                            // DR #i26521# catch STRING_NOTFOUND, will loop endless otherwise
-                            if( nEnd == STRING_NOTFOUND )
-                                pStr->Erase();
-                            else
-                                pStr->Erase(nBegin, (nEnd-nBegin)+1);
-						}
-					}
-					if( aDecompressed.Get(j)->Len() )
-					{
-			            aSource+=::rtl::OUString( *aDecompressed.Get(j) );
-					}
-
-				}
-				if (bAsComment)
-				{
-						aSource += rtl::OUString::createFromAscii("\nEnd Sub");
-				}
-				::rtl::OUString aModName( sModule );
-				if ( aSource.getLength() )
-				{
-					aSource = modeTypeComment + aSource;
-
-					Any aSourceAny;
-					aSourceAny <<= aSource;
-					if( xLib->hasByName( aModName ) )
-						xLib->replaceByName( aModName, aSourceAny );
-					else
-						xLib->insertByName( aModName, aSourceAny );
-				}                                
-
-				bRet = true;
-			}
-		}
-		SFX_APP()->LeaveBasicCall();
+		VBADir aVBA( xProject, xVBA );
+		bRet = aVBA.readBasic( rDocSh, bAsComment, bStripped );
 	}
 	return bRet;
 }
@@ -458,6 +329,14 @@ BOOL SvxImportMSVBasic::ImportCode_Impl(
 ULONG SvxImportMSVBasic::SaveOrDelMSVBAStorage( BOOL bSaveInto,
 												const String& rStorageName )
 {
+	return SaveOrDelMSVBAStorageExtra( bSaveInto, rStorageName, vecModuleTypes() );
+}
+
+// if vecModuleTypes is empty then then we assume all modules to be stored
+// are ordinary modules
+ULONG SvxImportMSVBasic::SaveOrDelMSVBAStorageExtra( BOOL bSaveInto,
+												const String& rStorageName, const vecModuleTypes& modules )
+{
 	ULONG nRet = ERRCODE_NONE;
     uno::Reference < embed::XStorage > xSrcRoot( rDocSh.GetStorage() );
 	String aDstStgName( GetMSBasicStorageName() );
@@ -468,19 +347,79 @@ ULONG SvxImportMSVBasic::SaveOrDelMSVBAS
 		xVBAStg = 0;
 		if( bSaveInto )
 		{
+			bool bWroteCopy = false;
+			// Why enterbasic call?
+			SFX_APP()->EnterBasicCall();
+
 			BasicManager *pBasicMan = rDocSh.GetBasicManager();
+				bool bIsModified = pBasicMan && pBasicMan->IsBasicModified();
+			SFX_APP()->LeaveBasicCall();
+			if( !bIsModified )
+			{
+				OSL_TRACE("Error - probably bogus unmodified state ..." );
+			}
 			if( pBasicMan && pBasicMan->IsBasicModified() )
 				nRet = ERRCODE_SVX_MODIFIED_VBASIC_STORAGE;
-
-            SotStorageRef xSrc = SotStorage::OpenOLEStorage( xSrcRoot, aDstStgName, STREAM_STD_READ );
-            SotStorageRef xDst = xRoot->OpenSotStorage( rStorageName, STREAM_READWRITE | STREAM_TRUNC );
-            xSrc->CopyTo( xDst );
-            xDst->Commit();
-            ErrCode nError = xDst->GetError();
-            if ( nError == ERRCODE_NONE )
-                nError = xSrc->GetError();
-            if ( nError != ERRCODE_NONE )
-                xRoot->SetError( nError );
+#if 0
+			if( !bIsModified )
+			{
+	            SotStorageRef xSrc = SotStorage::OpenOLEStorage( xSrcRoot, aDstStgName, STREAM_STD_READ );
+	            SotStorageRef xDst = xRoot->OpenSotStorage( rStorageName, STREAM_READWRITE | STREAM_TRUNC );
+	            xSrc->CopyTo( xDst );
+	            xDst->Commit();
+	            ErrCode nError = xDst->GetError();
+	            if ( nError == ERRCODE_NONE )
+	                nError = xSrc->GetError();
+	            if ( nError != ERRCODE_NONE )
+	                xRoot->SetError( nError );
+			}
+#endif
+			if( !bWroteCopy )
+			{
+				OSL_TRACE("Crazy VBA writing hack !" );
+				SvStorageRef xProject, xVBA;
+				OUString sProject = OUString::createFromAscii( "_VBA_PROJECT_CUR" );
+				OUString sVBA = OUString::createFromAscii( "VBA" );
+				if( GetVBAStorage( // HACK:
+					sProject,sVBA,
+					xProject, xVBA, true ) )
+				{
+					SvStorageRef xMSProject = SotStorage::OpenOLEStorage( xSrcRoot, aDstStgName, STREAM_STD_READ );
+					//SvStorageRef xMSProject = xMSBits->OpenOLEStorage( sProject, STREAM_STD_READ );
+					
+					// Copy UserForm Streams
+					std::vector< String > vUserFormNames = lcl_getUserFormNames( xMSProject );
+					OSL_TRACE("Crazy VBA has %d userform streams ", vUserFormNames.size() );
+					if ( !vUserFormNames.empty() )
+					{
+						std::vector< String >::iterator it = vUserFormNames.begin();
+						std::vector< String >::iterator it_end = vUserFormNames.end();
+						for ( ; it != it_end; ++it )
+						{	
+							OSL_TRACE("Attempting to copy %s", rtl::OUStringToOString( *it, RTL_TEXTENCODING_UTF8 ).getStr() );
+							SvStorageRef xFormSrc = xMSProject->OpenOLEStorage( *it, STREAM_STD_READ );
+							SvStorageRef xDst = xProject->OpenSotStorage( *it, STREAM_READWRITE | STREAM_TRUNC );
+
+							xFormSrc->CopyTo( xDst );	
+							xDst->Commit();
+            				ErrCode nError = xDst->GetError();
+				            if ( nError == ERRCODE_NONE )
+				                nError = xFormSrc->GetError();
+				            if ( nError != ERRCODE_NONE )
+							{
+				                xRoot->SetError( nError );
+								break;
+							}
+						}
+					}
+					VBADir aDir( xProject, xVBA, modules );
+					aDir.writeBasic( rDocSh );
+				}
+				else
+				{
+					OSL_TRACE( "Failed to create VBA storage" );
+				}
+			}
 		}
 	}
 
