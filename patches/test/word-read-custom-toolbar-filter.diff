diff --git sw/source/filter/ww8/makefile.mk sw/source/filter/ww8/makefile.mk
index 25cb969..95b12fb 100644
--- sw/source/filter/ww8/makefile.mk
+++ sw/source/filter/ww8/makefile.mk
@@ -95,7 +95,9 @@ SLOFILES =	\
 		$(SLO)$/writerhelper.obj \
 		$(SLO)$/writerwordglue.obj \
         $(SLO)$/WW8TableInfo.obj \
-        $(SLO)$/WW8FFData.obj
+        $(SLO)$/WW8FFData.obj \
+        $(SLO)$/ww8toolbar.obj \
+
 
 
 # --- Tagets -------------------------------------------------------
diff --git sw/source/filter/ww8/ww8par.cxx sw/source/filter/ww8/ww8par.cxx
index a7f122b..1013a3b 100644
--- sw/source/filter/ww8/ww8par.cxx
+++ sw/source/filter/ww8/ww8par.cxx
@@ -142,11 +142,12 @@
 #include <stdio.h>
 #include <comphelper/processfactory.hxx>
 #include <basic/basmgr.hxx>
-
 #ifdef DEBUG
 #include <iostream>
 #include <dbgoutsw.hxx>
 #endif 
+#include <fstream>
+#include "ww8toolbar.hxx"
 
 #define MM_250 1417             // WW-Default fuer Hor. Seitenraender: 2.5 cm
 #define MM_200 1134             // WW-Default fuer u.Seitenrand: 2.0 cm
@@ -4173,7 +4174,39 @@ ULONG SwWW8ImplReader::SetSubStreams(SvStorageStreamRef &rTableStream,
             rTableStream = pStg->OpenSotStream( String::CreateFromAscii(
                 pWwFib->fWhichTblStm ? SL::a1Table : SL::a0Table),
                 STREAM_STD_READ);
+#if 1
+            if ( pWwFib->fWhichTblStm )
+            {
+// dump a1Table stream here !!!
+            OSL_TRACE("About to dump 1table ");
+                long nCur = rTableStream->Tell();
+                std::ofstream fDump( "1Table.dump" );
+                
+                while ( !rTableStream->IsEof() )
+                {
+                    sal_uInt8 aByte;
+                    *rTableStream >> aByte;
+                    fDump << aByte;
+                }
+
+                fDump.flush();
+                rTableStream->Seek( nCur );  // restore stream pointer
 
+// attempt to read where the offset to the Customizations is (
+// also we should be able to find the offset to the macro table too
+                if ( pWwFib->lcbCmds )
+                {
+                    // there is a tgc255 structure
+                    OSL_TRACE(" tgc255 has offset 0x%x with length 0x%x", pWwFib->fcCmds, pWwFib->lcbCmds );
+                    Tcg aTCG;
+                    rTableStream->Seek( pWwFib->fcCmds ); // point at tgc record
+                    if (!aTCG.Read( rTableStream ) )
+                        OSL_TRACE("** Read of Customization data failed!!!! ");
+                    rTableStream->Seek( nCur ); // return to previous position
+                    aTCG.Print( stderr );
+                }
+            }
+#endif
             pTableStream = &rTableStream;
             pTableStream->SetNumberFormatInt( NUMBERFORMAT_INT_LITTLEENDIAN );
 
--- /dev/null	2008-04-22 00:28:44.000000000 +0100
+++ sw/source/filter/ww8/ww8toolbar.hxx	2009-02-01 10:05:39.000000000 +0000
@@ -0,0 +1,555 @@
+#ifndef _WW8TOOLBAR_HXX
+#define _WW8TOOLBAR_HXX
+
+#include <tools/string.hxx>
+#include <sot/storage.hxx>
+#include <ostream>
+#include <memory>
+#include <vector>
+
+class TBCHeader;
+
+class TBBase
+{
+friend class Indent;
+    static int nIndent; // num spaces to indent before printing 
+protected:
+    void indent_printf(FILE* fp, const char* format, ... );
+public:
+    TBBase(){}
+    virtual ~TBBase(){}
+    virtual bool Read(SotStorageStream *pS) = 0;
+    virtual void Print( FILE* ) {} // #FIXME remove this an implement the debug routines in all the classes below to enable some sort of readable output
+};
+
+class Indent
+{
+public:
+    Indent( bool binit = false ) 
+    { 
+        if ( binit )
+            init();
+        else
+            TBBase::nIndent = TBBase::nIndent + 2; 
+    }
+    ~Indent() { TBBase::nIndent = TBBase::nIndent - 2; }
+    void init() { TBBase::nIndent = 0; }
+};
+
+class Xst : public TBBase
+{
+    rtl::OUString sString;
+public:
+    Xst(){}
+    bool Read(SotStorageStream *pS);
+    rtl::OUString getString() { return sString; }
+    void Print( FILE* fp );
+};
+
+class WString : public TBBase
+{
+    rtl::OUString sString;
+
+    WString(const WString&);
+    WString& operator = ( const WString&);
+public:
+    WString(){};
+    ~WString(){};
+    bool Read(SotStorageStream *pS);
+    rtl::OUString getString(){ return sString; }
+};
+
+class TBCExtraInfo : public TBBase
+{
+    WString wstrHelpFile;
+    sal_Int32 idHelpContext;
+    WString wstrTag;
+    WString wstrOnAction;
+    WString wstrParam;
+    sal_Int8 tbcu;
+    sal_Int8 tbmg;
+
+    TBCExtraInfo(const TBCExtraInfo&);
+    TBCExtraInfo& operator = ( const TBCExtraInfo&);
+public:
+    TBCExtraInfo();
+    ~TBCExtraInfo(){}
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class TBCGeneralInfo  : public TBBase
+{
+    sal_uInt8 bFlags;
+    WString customText;
+    WString descriptionText;
+    WString tooltip;
+    TBCExtraInfo extraInfo;
+
+    TBCGeneralInfo(const TBCGeneralInfo&);
+    TBCGeneralInfo& operator = ( const TBCGeneralInfo&);
+public:
+    TBCGeneralInfo();
+    ~TBCGeneralInfo() {}
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class TBCBitMap : public TBBase
+{
+friend class TBCBSpecific; // #FIXME hacky access, need to fix
+    sal_Int32 cbDIB;
+//    BITMapInfoHeader biHeader;  // lets cheat and not read the bit map stuff right now
+    sal_uInt8* pRestOfIt;
+    TBCBitMap(const TBCBitMap&);
+    TBCBitMap& operator = ( const TBCBitMap&);
+public:
+    TBCBitMap();
+    ~TBCBitMap();
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class TBCMenuSpecific : public TBBase
+{
+    sal_Int32 tbid;
+    std::auto_ptr< WString > name; //exist only if tbid equals 0x00000001
+    TBCMenuSpecific(const TBCMenuSpecific&);
+    TBCMenuSpecific& operator = ( const TBCMenuSpecific&);
+public:
+    TBCMenuSpecific();
+    ~TBCMenuSpecific(){}
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class TBCCDData : public TBBase
+{
+    sal_Int16 cwstrItems; //Signed integer that specifies the number of items in wstrList. MUST be positive.
+    WString* wstrList;  // Zero-based index array of WString structures. Number of elements MUST be equal to cwstrItems.
+    sal_Int16 cwstrMRU; // Signed integer that specifies the number of most recently used string
+    sal_Int16 iSel ; // Signed integer that specifies the zero-based index of the selected item in the wstrList field. MUST be equal to 0xFFFF (-1) or greater than or equal to 0x0000.
+    sal_Int16 cLines; // Signed integer that specifies the suggested number of lines that the toolbar control will display at any time when displaying the elements of wstrList of available items. 
+    sal_Int16 dxWidth; // Signed integer that specifies the width in pixels that the interior of the dropdown has. This excludes the width of the toolbar control border and scroll bar.
+    WString wstrEdit; //Structure of type WString. Editable text for editable area of the ComboBox toolbar control.
+
+    TBCCDData(const TBCCDData&);
+    TBCCDData& operator = ( const TBCCDData&);
+public:
+    TBCCDData();
+    ~TBCCDData();
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class TBCComboDropdownSpecific : public TBBase
+{
+    std::auto_ptr< TBCCDData > data;
+    TBCComboDropdownSpecific(const TBCComboDropdownSpecific&);
+    TBCComboDropdownSpecific& operator = ( const TBCComboDropdownSpecific&);
+public:
+    TBCComboDropdownSpecific( const TBCHeader& header );
+    TBCComboDropdownSpecific(){}
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class TBCBSpecific :  public TBBase
+{
+    sal_uInt8 bFlags;
+    std::auto_ptr< TBCBitMap > icon; // optional
+    std::auto_ptr< TBCBitMap > iconMask; // optional
+    std::auto_ptr< sal_uInt16 > iBtnFace; // optional
+    std::auto_ptr< WString > wstrAcc; // optional
+   
+    TBCBSpecific(const TBCBSpecific&);
+    TBCBSpecific& operator = ( const TBCBSpecific&);
+public:
+    TBCBSpecific();
+    ~TBCBSpecific(){}
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+/* TBCHeader.tct                   controlSpecificInfo type
+
+0x01 (Button control)              TBCBSpecific
+0x10 (ExpandingGrid control)       TBCBSpecific
+0x0A (Popup control)               TBCMenuSpecific
+0x0C (ButtonPopup control)         TBCMenuSpecific
+0x0D (SplitButtonPopup control)    TBCMenuSpecific
+0x0E (SplitButtonMRUPopup control) TBCMenuSpecific
+0x02 (Edit control)                TBCComboDropdow nSpecific
+0x04 (ComboBox control)            TBCComboDropdow nSpecific
+0x14 (GraphicCombo control)        TBCComboDropdow nSpecific
+0x03 (DropDown control)            TBCComboDropdow nSpecific
+0x06 (SplitDropDown control)       TBCComboDropdow nSpecific
+0x09 (GraphicDropDown control)     TBCComboDropdow nSpecific
+0x07 (OCXDropDown control)         controlSpecificInfo MUST NOT exist
+0x0F (Label control)               controlSpecificInfo MUST NOT exist
+0x12 (Grid control)                controlSpecificInfo MUST NOT exist
+0x13 (Gauge control)               controlSpecificInfo MUST NOT exist
+0x16 (ActiveX control)             controlSpecificInfo MUST NOT exist
+
+*/
+
+class TBCData : public TBBase
+{
+    const TBCHeader& rHeader;
+    TBCGeneralInfo controlGeneralInfo;
+    std::auto_ptr< TBBase > controlSpecificInfo; // can be one of TBCBSpecific, TBCMenuSpecific or TBCComboDropdow nSpecific depending on the control type specified by TBCHeader.tct 
+    TBCData(const TBCData&);
+    TBCData& operator = ( const TBCData&);
+public:
+    TBCData( const TBCHeader& Header ) : rHeader( Header ) {}
+    ~TBCData(){}
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class TBCHeader : public TBBase
+{
+    sal_Int8 bSignature; 
+    sal_Int8 bVersion; 
+    sal_uInt8 bFlagsTCR; 
+    sal_uInt8 tct; 
+    sal_uInt16 tcid;
+    sal_uInt32 tbct;
+    sal_uInt8 bPriority;
+    sal_uInt16* width;  //optional
+    sal_uInt16* height; //optional
+
+    TBCHeader(const TBCHeader&);
+    TBCHeader& operator = ( const TBCHeader&);
+public:
+    TBCHeader();
+    ~TBCHeader();
+    sal_uInt8 getTct() const { return tct; }
+    sal_uInt16 getTcID() const { return tcid; }
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class TBC : public TBBase
+{
+    TBCHeader tbch;
+    sal_uInt32* cid; // optional
+    std::auto_ptr<TBCData> tbcd;
+    TBC(const TBC&);
+    TBC& operator = ( const TBC&);
+public:
+    TBC();
+    ~TBC();
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class TB : public TBBase
+{
+    sal_Int8 bSignature; //Signed integer that specifies the toolbar signature number. MUST be 0x02.
+    sal_Int8 bVersion; //Signed integer that specifies the toolbar version number. MUST be 0x01.
+    sal_Int16 cCL; //Signed integer that SHOULD  specify the number of toolbar controls contained in this toolbar.
+    sal_Int32 ltbid; //Signed integer that specifies the toolbar ID. MUST be 0x0001 (custom toolbar ID).
+    sal_uInt32 ltbtr; //Unsigned integer of type TBTRFlags that specifies the toolbar type and toolbar restrictions.
+    sal_uInt16 cRowsDefault; //Unsigned integer that specifies the number of preferred rows for the toolbar when the toolbar is not docked. MUST be less than or equal to 255.
+    sal_uInt16 bFlags; //Unsigned integer of type TBFlags.
+    WString name; //Structure of type WString that specifies the toolbar name.
+    TB(const TB&);
+    TB& operator = ( const TB&);
+public:
+    TB();
+    ~TB(){}
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class CTB : public TBBase
+{
+    Xst name;
+    sal_Int32 cbTBData;
+    TB tb;
+    sal_uInt8 rVisualData[ 100 ];
+    sal_Int32 iWCTBl;
+    sal_uInt16 reserved;
+    sal_uInt16 unused;
+    sal_Int32 cCtls;
+    TBC* rTBC;
+
+    CTB(const CTB&);
+    CTB& operator = ( const CTB&);
+public:
+    CTB();
+    ~CTB();
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* fp );
+};
+
+class TBDelta : public TBBase
+{
+    sal_uInt8 doprfatendFlags;
+    sal_uInt8 ibts;
+    sal_Int32 cidNext; 
+    sal_Int32 cid;
+    sal_Int32 fc;
+    sal_uInt8 CiTBDE[2]; // careful of this ( endian matters etc. )
+    sal_uInt16 cbTBC;
+    TBDelta(const TBDelta&);
+    TBDelta& operator = ( const TBDelta&);
+public:
+    TBDelta();
+    ~TBDelta(){}
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class Tcg255SubStruct : public TBBase
+{
+friend class Tcg255;
+    bool mbReadId;
+    Tcg255SubStruct(const Tcg255SubStruct&);
+    Tcg255SubStruct& operator = ( const Tcg255SubStruct&);
+protected:
+    sal_uInt8 ch;
+public:
+    Tcg255SubStruct( bool bReadId );
+    ~Tcg255SubStruct(){}
+    virtual sal_uInt8 id() { return ch; }
+    bool Read(SotStorageStream *pS);
+};
+
+class Customization : public TBBase
+{
+    sal_Int32 tbidForTBD;
+    sal_uInt16 reserved1;
+    sal_Int16 ctbds;
+
+    CTB* customizationDataCTB;
+    TBDelta* customizationDataTBDelta; // we don't read these yet
+    
+    Customization(const Customization&);
+    Customization& operator = ( const Customization&);
+public:    
+    Customization();
+    ~Customization();
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class CTBWrapper : public Tcg255SubStruct
+{
+    // reserved1 is the ch field of Tcg255SubStruct
+    sal_uInt16 reserved2;
+    sal_uInt8 reserved3;
+    sal_uInt16 reserved4;
+    sal_uInt16 reserved5;
+
+    sal_Int16 cbTBD;
+    sal_Int16 cCust;
+
+    sal_Int32 cbDTBC;
+
+    sal_uInt8* rtbdc; // array of TBC's - we don't read these yet 
+    Customization* rCustomizations; // array of Customizations
+
+    CTBWrapper(const CTBWrapper&);
+    CTBWrapper& operator = ( const CTBWrapper&);
+public:
+    CTBWrapper( bool bReadId = true );
+    ~CTBWrapper();
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class MCD : public TBBase
+{
+    sal_Int8 reserved1; //  A signed integer that MUST be 0x56. 
+    sal_uInt8 reserved2; // MUST be 0.
+    sal_uInt16 ibst; // Unsigned integer that specifies the name of the macro. Macro name is specified by MacroName.xstz of the MacroName entry in the MacroNames such that MacroName.ibst equals ibst. MacroNames MUST contain such an entry.
+    sal_uInt16 ibstName; // An unsigned integer that specifies the index into the Command String Table (TcgSttbf.sttbf) where the macro‘s name and arguments are specified.
+    sal_uInt16 reserved3; // An unsigned integer that MUST be 0xFFFF.
+    sal_uInt32 reserved4; //MUST be ignored. 
+    sal_uInt32 reserved5; //MUST be 0. 
+    sal_uInt32 reserved6; //MUST be ignored. 
+    sal_uInt32 reserved7; //MUST be ignored   
+
+    MCD(const MCD&);
+    MCD& operator = ( const MCD&);
+public:
+    MCD();
+    ~MCD(){}
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class PlfMcd : public Tcg255SubStruct
+{
+    sal_Int32 iMac;
+    MCD* rgmcd; // array of MCD's
+    PlfMcd(const PlfMcd&);
+    PlfMcd& operator = ( const PlfMcd&);
+public:
+    PlfMcd( bool bReadId = true );
+    ~PlfMcd();
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class Acd : public TBBase
+{
+    sal_Int16 ibst;
+    sal_uInt16 fciBasedOnABC; //  fciBasedOn(13 bits) A(1bit)B(1bit)C(1Bit)
+    Acd(const Acd&);
+    Acd& operator = ( const Acd&);
+public:
+    Acd();
+    ~Acd(){}
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class PlfAcd: public Tcg255SubStruct
+{
+    sal_Int32 iMac;
+    Acd* rgacd;
+    PlfAcd(const PlfAcd&);
+    PlfAcd& operator = ( const PlfAcd&);
+public:
+    PlfAcd( bool bReadId = true );
+    ~PlfAcd();
+    bool Read(SotStorageStream *pS);
+    void Print(FILE*);
+};
+
+class Kme : public TBBase
+{
+    sal_Int16 reserved1; //MUST be zero. 
+    sal_Int16 reserved2; //MUST be zero.
+    sal_uInt16 kcm1; //A Kcm that specifies the primary shortcut key.
+    sal_uInt16 kcm2; //A Kcm that specifies the secondary shortcut key, or 0x00FF if there is no secondary shortcut key.
+    sal_uInt16 kt; //A Kt that specifies the type of action to be taken when the key combination is pressed. 
+    sal_uInt32 param; //The meaning of this field depends on the value of kt
+
+    Kme(const Kme&);
+    Kme& operator = ( const Kme&);
+public:
+    Kme();
+    ~Kme();
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class PlfKme : public Tcg255SubStruct
+{
+    sal_Int32 iMac;
+    Kme* rgkme;
+    PlfKme(const PlfKme&);
+    PlfKme& operator = ( const PlfKme&);
+public:
+    PlfKme( bool bReadId = true );
+    ~PlfKme();
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class TcgSttbfCore : public TBBase
+{
+struct SBBItem
+{
+    sal_uInt16 cchData;
+    rtl::OUString data; 
+    sal_uInt16 extraData;
+    SBBItem() : cchData(0), extraData(0){}
+};
+    sal_uInt16 fExtend;
+    sal_uInt16 cData;
+    sal_uInt16 cbExtra;
+    SBBItem* dataItems;
+    TcgSttbfCore(const TcgSttbfCore&);
+    TcgSttbfCore& operator = ( const TcgSttbfCore&);
+public:
+    TcgSttbfCore();
+    ~TcgSttbfCore();
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* fp );
+};
+
+class TcgSttbf : public Tcg255SubStruct
+{
+    TcgSttbfCore sttbf;
+    TcgSttbf(const TcgSttbf&);
+    TcgSttbf& operator = ( const TcgSttbf&);
+public:
+    TcgSttbf( bool bReadId = true );
+    ~TcgSttbf(){}
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* fp );
+};
+
+class Xstz : public TBBase
+{
+    Xst xst; //An Xst specifying the string with its pre-pended length. 
+    sal_uInt16 chTerm;
+
+    Xstz(const Xstz&);
+    Xstz& operator = ( const Xstz&);
+public:
+    Xstz();
+    ~Xstz(){}
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* fp );
+};
+
+class MacroName : public TBBase
+{
+    sal_uInt16 ibst; //An unsigned integer that specifies the index of the current entry in the macro name table. MUST NOT be the same as the index of any other entry.
+    Xstz xstz;
+    MacroName(const MacroName&);
+    MacroName& operator = ( const MacroName&);
+public:
+    MacroName();
+    ~MacroName(){}
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class MacroNames : public Tcg255SubStruct
+{
+    sal_uInt16 iMac; //An unsigned integer that specifies the number of MacroName structures in rgNames.
+    MacroName* rgNames;
+
+    MacroNames(const MacroNames&);
+    MacroNames& operator = ( const MacroNames&);
+public:
+    MacroNames( bool bReadId = true );
+    ~MacroNames();
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class Tcg255 : public TBBase
+{
+    std::vector< Tcg255SubStruct* > rgtcgData; // array of sub structures
+    Tcg255(const Tcg255&);
+    Tcg255& operator = ( const Tcg255&);
+    bool processSubStruct( sal_uInt8 nId, SotStorageStream*  );
+public:
+    Tcg255();
+    ~Tcg255();
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class Tcg: public TBBase
+{
+    sal_Int8 nTcgVer; 
+    std::auto_ptr< Tcg255 > tcg;
+    Tcg(const Tcg&);
+    Tcg& operator = ( const Tcg&);
+public:
+    Tcg();
+    ~Tcg(){}
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+#endif
--- /dev/null	2008-04-22 00:28:44.000000000 +0100
+++ sw/source/filter/ww8/ww8toolbar.cxx	2009-02-01 10:05:39.000000000 +0000
@@ -0,0 +1,1220 @@
+#include "ww8toolbar.hxx"
+#include <rtl/ustrbuf.hxx>
+#include <stdarg.h>
+
+int TBBase::nIndent = 0;
+
+#define INDENT_INIT Indent a(true);
+
+#define INDENT Indent a;
+
+void
+TBBase::indent_printf( FILE* fp, const char* format, ... )
+{
+   va_list ap;
+   va_start ( ap, format );
+
+   // indent nIndent spaces
+   for ( int i=0; i<nIndent; ++i)
+      fprintf(fp," ");
+   // append the rest of the message
+   vfprintf( fp, format, ap );
+   va_end( ap );
+}
+
+rtl::OUString readUnicodeString( SotStorageStream* pS, sal_Int32 nChars )
+{
+    rtl::OUStringBuffer buf(40);
+    for ( sal_Int32 index = 0; index < nChars; ++index )
+    {
+        sal_uInt16 ch = 0;
+        *pS >> ch;
+        sal_Unicode uni = static_cast< sal_Unicode >( ch );
+        buf.append( &uni, 1 );
+    }
+    return buf.makeStringAndClear();
+}
+
+CTBWrapper::CTBWrapper( bool bReadId ) : Tcg255SubStruct( bReadId )
+,reserved2(0)
+,reserved3(0)
+,reserved4(0)
+,reserved5(0)
+,cbTBD(0)
+,cCust(0)
+,cbDTBC(0)
+,rtbdc(0)
+,rCustomizations(0)
+{
+}
+
+CTBWrapper::~CTBWrapper()
+{
+    if ( rtbdc )
+        delete [] rtbdc; 
+    if ( rCustomizations )
+        delete [] rCustomizations; 
+}
+
+bool CTBWrapper::Read( SotStorageStream* pS )
+{
+    OSL_TRACE("CTBWrapper::Read() stream pos 0x%x", pS->Tell() );
+    Tcg255SubStruct::Read( pS );
+    *pS >> reserved2 >> reserved3 >> reserved4 >> reserved5;
+    *pS >> cbTBD >> cCust >> cbDTBC;
+    if ( cbDTBC )
+    {
+        // cbDTBC is the size in bytes of the TBC array
+        // but the size of a TBC element is dynamic ( and this relates to TBDelta's
+        // which we don't read right now )
+        pS->SeekRel( cbDTBC );
+    }
+    if ( cCust )
+    {
+        rCustomizations = new Customization[ cCust ];
+        for ( sal_Int32 index = 0; index < cCust; ++index )
+        {
+            if ( !rCustomizations[ index ].Read( pS ) )
+                return false;
+        } 
+    } 
+    return true;
+}
+
+void CTBWrapper::Print( FILE* fp )
+{
+    INDENT;
+    indent_printf(fp,"CTBWrapper - dump\n");
+    bool bRes = ( ch == 0x12 && reserved2 == 0x0 && reserved3 == 0x7 && reserved4 == 0x6 && reserved5 == 0xC );
+    if ( bRes )
+        indent_printf(fp,"  sanity check ( first 8 bytes conform )\n");
+    else 
+    {
+        indent_printf(fp,"    reserved1(0x%x)\n",ch);
+        indent_printf(fp,"    reserved2(0x%x)\n",reserved2);
+        indent_printf(fp,"    reserved3(0x%x)\n",reserved3);
+        indent_printf(fp,"    reserved4(0x%x)\n",reserved4);
+        indent_printf(fp,"    reserved5(0x%x)\n",reserved5);
+        indent_printf(fp,"Quiting dump");
+        return;
+    }
+    indent_printf(fp,"  cbTBD: no. of TBDelta structures ( skipped if present ) 0x%x\n", cbTBD );
+    indent_printf(fp,"  cCust: no. of cCust structures 0x%x\n",cCust);
+    indent_printf(fp,"  cbDTBC: no. of bytes in rtbdc array 0x%x\n", static_cast< unsigned int >( cbDTBC ));
+    indent_printf(fp,"  .... skipping rtbdc\n");
+    if ( rCustomizations )
+    {
+        for ( sal_Int32 index = 0; index < cCust; ++index )
+        {
+            indent_printf(fp,"  Dumping custimization [%d]\n", static_cast< int >( index ));
+            INDENT;
+            rCustomizations[ index ].Print(fp);
+        }
+    }
+}
+Customization::Customization() : tbidForTBD( 0 )
+,reserved1( 0 )
+, ctbds( 0 )
+, customizationDataCTB( 0 )
+, customizationDataTBDelta( 0 )
+{
+}
+
+Customization::~Customization()
+{
+    if ( customizationDataCTB )
+        delete customizationDataCTB;
+    if ( customizationDataTBDelta )
+        delete [] customizationDataTBDelta;
+}
+
+bool Customization::Read( SotStorageStream *pS)
+{
+    OSL_TRACE("Custimization::Read() stream pos 0x%x", pS->Tell() );
+    *pS >> tbidForTBD >> reserved1 >> ctbds;
+    if ( tbidForTBD && ctbds )
+    {
+        customizationDataTBDelta = new TBDelta[ ctbds ];
+        for ( sal_Int32 index = 0; index < ctbds; ++index )
+        {
+            if (!customizationDataTBDelta[ index ].Read( pS ) )
+                return false;
+        }
+    }
+    else
+    {
+        customizationDataCTB = new CTB();
+        if ( !customizationDataCTB->Read( pS ) )
+                return false;
+    }
+    return true;
+}
+
+void Customization::Print( FILE* fp )
+{
+    INDENT;
+    indent_printf( fp,"Customization -- dump \n");
+    indent_printf( fp,"  tbidForTBD 0x%x ( should be 0 for CTBs )\n", static_cast< unsigned int >( tbidForTBD ));
+    indent_printf( fp,"  reserved1 0x%x \n", reserved1);
+    indent_printf( fp,"  ctbds - number of customisations %d(0x%x) \n", ctbds, ctbds );
+    if ( !tbidForTBD && !ctbds )
+        customizationDataCTB->Print( fp );
+    else
+    {
+        for ( sal_Int32 index = 0; index < ctbds; ++index )
+            customizationDataTBDelta[ index ].Print( fp );
+    }
+    
+}
+
+TBDelta::TBDelta() : doprfatendFlags(0)
+,ibts(0)
+,cidNext(0)
+,cid(0)
+,fc(0)
+,cbTBC(0)
+{
+}
+
+bool TBDelta::Read(SotStorageStream *pS)
+{
+    OSL_TRACE("TBDelta::Read() stream pos 0x%x", pS->Tell() );
+    *pS >> doprfatendFlags >> ibts >> cidNext >> cid >> fc ;
+    pS->Read( CiTBDE, sizeof( CiTBDE ) );
+    *pS >> cbTBC;
+    return true;
+}
+
+void TBDelta::Print( FILE* fp )
+{
+    // Like most of the debug output, it's raw and little ( no )
+    // interpretation of the data is output ( e.g. flag values etc. )
+    indent_printf( fp, "TBDelta -- dump\n" );
+    indent_printf( fp, " doprfatendFlags 0x%x\n",doprfatendFlags );
+    
+    indent_printf( fp, " ibts 0x%x\n",ibts );
+    indent_printf( fp, " cidNext 0x%x\n", static_cast< unsigned int >( cidNext ) );
+    indent_printf( fp, " cid 0x%x\n", static_cast< unsigned int >( cid ) );
+    indent_printf( fp, " fc 0x%x\n", static_cast< unsigned int >( fc ) );
+    indent_printf( fp, " CiTBDE[0] 0x%x\n",CiTBDE[0] );
+    indent_printf( fp, " CiTBDE[1] 0x%x\n",CiTBDE[1] );
+    indent_printf( fp, " cbTCB 0x%x\n", cbTBC );
+}
+
+CTB::CTB() : cbTBData( 0 )
+,iWCTBl( 0 )
+,reserved( 0 )
+,unused( 0 )
+,cCtls( 0 )
+,rTBC( 0 )
+{
+}
+
+CTB::~CTB()
+{
+    if ( rTBC )
+        delete [] rTBC;
+}
+
+bool CTB::Read( SotStorageStream *pS)
+{
+    OSL_TRACE("CTB::Read() stream pos 0x%x", pS->Tell() );
+    if ( !name.Read( pS ) )
+        return false;
+    *pS >> cbTBData;
+    // sal_Int32 nTBSize = cbTBData - sizeof(rVisualData) - 12;
+    if ( !tb.Read( pS ) )
+        return false;
+    pS->Read( &rVisualData, sizeof( rVisualData ) );
+
+    *pS >> iWCTBl >> reserved >> unused >> cCtls;
+    
+    if ( cCtls )
+    {
+        rTBC = new TBC[ cCtls ];
+        for ( sal_Int32 index = 0; index < cCtls; ++index )
+        {
+            if ( !rTBC[ index ].Read( pS ) )
+                return false;
+        }
+    }
+    return true;
+}
+
+void
+CTB::Print( FILE* fp )
+{
+    INDENT;
+    indent_printf(fp, "CTB - dump\n");
+    indent_printf(fp, "  name %s\n", rtl::OUStringToOString( name.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf(fp, "  cbTBData size, in bytes, of this structure excluding the name, cCtls, and rTBC fields.  %x\n", static_cast< unsigned int >( cbTBData ) );
+    
+    tb.Print(fp);
+    indent_printf(fp, "  iWCTBl 0x%x reserved 0x%x unused 0x%x cCtls( toolbar controls ) 0x%x \n", static_cast< unsigned int >( iWCTBl ), reserved, unused, static_cast< unsigned int >( cCtls ) );
+    if ( cCtls )
+    {
+        for ( sal_Int32 index = 0; index < cCtls; ++index )
+        {
+        
+            indent_printf(fp, "  dumping toolbar control 0x%x\n", static_cast< unsigned int >( index ) );
+            rTBC[ index ].Print( fp );
+        }
+    }
+}
+
+TB::TB() : bSignature( 0 )
+,bVersion( 0 )
+,cCL( 0 )
+,ltbid( 0 )
+,ltbtr( 0 )
+,cRowsDefault( 0 )
+,bFlags( 0 )
+{
+}
+
+bool TB::Read( SotStorageStream* pS )
+{
+    OSL_TRACE("TB::Read() stream pos 0x%x", pS->Tell() );
+    *pS >> bSignature >> bVersion >> cCL >> ltbid >> ltbtr >> cRowsDefault >> bFlags;
+    return name.Read( pS );
+}
+
+void TB::Print( FILE* fp )
+{
+    INDENT;
+    indent_printf( fp, "TB -- dump\n");
+    indent_printf( fp, "  bSignature (0x%x), bVersion(0x%x), cCL(0x%x), ltbid(0x%x), cRowsDefault (0x%x), ltbtr(0x%x), bFlags(0x%x)\n", bSignature, bVersion, cCL, static_cast< unsigned int >( ltbid ), static_cast< unsigned int >( ltbtr ), cRowsDefault, bFlags );
+    indent_printf( fp, "  name %s\n", rtl::OUStringToOString( name.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+
+}
+
+TBC::TBC() : cid( 0 )
+{
+}
+
+TBC::~TBC()
+{
+    if ( cid )
+        delete cid;
+}
+
+bool TBC::Read( SotStorageStream *pS )
+{
+    OSL_TRACE("TBC::Read() stream pos 0x%x", pS->Tell() );
+    if ( !tbch.Read( pS ) )
+        return false;
+    if ( tbch.getTcID() != 0x1 && tbch.getTcID() != 0x1051 )
+    {
+        cid = new sal_uInt32;
+        *pS >> *cid;
+    }
+    // MUST exist if tbch.tct is not equal to 0x16
+    if ( tbch.getTct() != 0x16 )
+    {
+        tbcd.reset(  new TBCData( tbch ) );
+        if ( !tbcd->Read( pS ) )
+            return false;
+    }
+    return true;
+}
+
+void TBC::Print( FILE* fp )
+{
+    INDENT;
+    indent_printf(fp,"TCB -- dump\n");
+    indent_printf(fp,"  dumping header ( TBCHeader )\n");
+    tbch.Print( fp );
+    if ( cid )
+        indent_printf(fp,"  cid = 0x%x\n", static_cast< unsigned int >( *cid ) );
+    if ( tbcd.get() )
+    {
+        indent_printf(fp,"  dumping toolbar data TBCData \n");
+        tbcd->Print(fp);
+    }
+}
+
+TBCHeader::TBCHeader() : bSignature( 0x3 )
+,bVersion( 0x01 )
+,bFlagsTCR( 0 )
+,tct(0x1) // default to Button
+,tcid(0)
+,tbct(0)
+,width(NULL)
+,height(NULL)
+{
+}
+
+
+TBCHeader::~TBCHeader()
+{
+    if ( width )
+        delete width;
+    if ( height )
+        delete height;
+}
+
+bool TBCHeader::Read( SotStorageStream* pS )
+{
+    OSL_TRACE("TBCHeader::Read() stream pos 0x%x", pS->Tell() );
+    *pS >> bSignature >> bVersion >> bFlagsTCR >> tct >> tcid >> tbct >> bPriority;
+    //  bit 4 ( from lsb ) 
+    if ( bFlagsTCR & 0x10 )
+    {
+        width = new sal_uInt16;
+        height = new sal_uInt16;
+        *pS >> *width >> *height;
+    }
+    return true;
+}
+
+void TBCHeader::Print( FILE* fp )
+{
+    INDENT;
+    indent_printf(fp,"TBCHeader -- dump\n");
+    indent_printf(fp,"  bSignature 0x%xn", bSignature );
+    indent_printf(fp,"  bVersion 0x%x\n", bVersion );
+    indent_printf(fp,"  bFlagsTCR 0x%x\n", bFlagsTCR );
+    indent_printf(fp,"  tct 0x%x\n", tct );
+    indent_printf(fp,"  tcid 0x%x\n", tcid );
+    indent_printf(fp,"  tbct 0x%x\n", static_cast< unsigned int >( tbct ));
+    indent_printf(fp,"  bPriority 0x%x\n", bPriority );
+    if ( width )
+        indent_printf(fp,"  width 0x%d(0x%x)\n", *width, *width);
+    if ( height )
+        indent_printf(fp,"  height 0x%d(0x%x)\n", *height, *height);
+}
+
+bool TBCData::Read(SotStorageStream *pS)
+{
+    OSL_TRACE("TBCData::Read() stream pos 0x%x", pS->Tell() );
+    if ( !controlGeneralInfo.Read(pS) /*|| !controlSpecificInfo.Read(pS)*/ )
+        return false;
+    switch ( rHeader.getTct() )
+    {
+        case 0x01: // (Button control)
+        case 0x10: // (ExpandingGrid control)
+            controlSpecificInfo.reset( new TBCBSpecific() );
+            break;
+        case 0x0A: // (Popup control)
+        case 0x0C: // (ButtonPopup control)
+        case 0x0D: // (SplitButtonPopup control)
+        case 0x0E: // (SplitButtonMRUPopup control)
+            controlSpecificInfo.reset( new TBCMenuSpecific() );
+            break;
+        case 0x02: // (Edit control)
+        case 0x04: // (ComboBox control)
+        case 0x14: // (GraphicCombo control)
+        case 0x03: // (DropDown control)
+        case 0x06: // (SplitDropDown control)
+        case 0x09: // (GraphicDropDown control)
+            controlSpecificInfo.reset( new TBCComboDropdownSpecific( rHeader ) );
+            break;
+        default:
+            break;
+    }
+    if ( controlSpecificInfo.get() )
+        return controlSpecificInfo->Read( pS );
+    return true;
+
+    OSL_TRACE("#FIXME I need to be able to handle different controlSpecificInfo types.");
+    return false;
+}
+
+void TBCData::Print( FILE* fp )
+{
+    INDENT;
+    indent_printf(fp,"TBCData -- dump\n");
+    indent_printf(fp,"  dumping controlGeneralInfo( TBCGeneralInfo )\n");
+    controlGeneralInfo.Print( fp );
+    if ( rHeader.getTct() == 1 )
+    {
+        indent_printf(fp,"  dumping controlSpecificInfo( TBCBSpecificInfo )\n");
+        controlSpecificInfo->Print( fp );
+    }
+}
+
+bool
+WString::Read( SotStorageStream *pS )
+{
+    OSL_TRACE("WString::Read() stream pos 0x%x", pS->Tell() );
+    sal_Int8 nChars = 0;
+    *pS >> nChars;
+    sString = readUnicodeString( pS, static_cast< sal_Int32 >( nChars  ) );
+    return true;
+}
+
+bool 
+Xst::Read( SotStorageStream* pS )
+{
+    OSL_TRACE("Xst::Read() stream pos 0x%x", pS->Tell() );
+    sal_Int16 nChars = 0;
+    *pS >> nChars;
+    sString = readUnicodeString( pS, static_cast< sal_Int32 >( nChars  ) );
+    return true;
+}
+
+void
+Xst::Print( FILE* fp )
+{
+    INDENT;
+    indent_printf( fp, "Xst -- dump\n");
+    indent_printf( fp, " %s",  rtl::OUStringToOString( sString, RTL_TEXTENCODING_UTF8 ).getStr() );
+}
+TBCExtraInfo::TBCExtraInfo() : idHelpContext( 0 )
+{
+}
+
+bool
+TBCExtraInfo::Read( SotStorageStream *pS )
+{
+    OSL_TRACE("TBCExtraInfo::Read() stream pos 0x%x", pS->Tell() );
+    if( !wstrHelpFile.Read( pS )  )
+        return false;
+
+    *pS >> idHelpContext;
+
+    if ( !wstrTag.Read( pS ) || !wstrOnAction.Read( pS ) || !wstrParam.Read( pS ) )
+        return false;
+
+    *pS >> tbcu >> tbmg;    
+    return true;
+}
+
+void
+TBCExtraInfo::Print( FILE* fp )
+{
+    INDENT;
+    indent_printf( fp, "TBCExtraInfo -- dump\n");
+    indent_printf( fp, "  wstrHelpFile %s\n", 
+        rtl::OUStringToOString( wstrHelpFile.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf( fp, "  idHelpContext 0x%x\n", static_cast< unsigned int >( idHelpContext ) );
+    indent_printf( fp, "  wstrTag %s\n", 
+        rtl::OUStringToOString( wstrTag.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf( fp, "  wstrOnAction %s\n", 
+        rtl::OUStringToOString( wstrOnAction.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf( fp, "  wstrParam %s\n", 
+        rtl::OUStringToOString( wstrParam.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf( fp, "  tbcu 0x%x\n", tbcu );
+    indent_printf( fp, "  tbmg 0x%x\n", tbmg );
+    
+}
+
+TBCGeneralInfo::TBCGeneralInfo() : bFlags( 0 )
+{
+}
+
+bool TBCGeneralInfo::Read( SotStorageStream *pS )
+{
+    OSL_TRACE("TBCGeneralInfo::Read() stream pos 0x%x", pS->Tell() );
+    *pS >> bFlags;
+
+    if ( ( bFlags & 0x1 ) && !customText.Read( pS ) )
+        return false;
+    if ( ( bFlags & 0x2 ) && ( !descriptionText.Read( pS ) ||  !tooltip.Read( pS ) ) )
+        return false;
+    if ( ( bFlags & 0x4 ) && !extraInfo.Read( pS ) )
+        return false;
+    return true;
+}
+
+void 
+TBCGeneralInfo::Print( FILE* fp )
+{
+    INDENT;
+    indent_printf( fp, "TBCGeneralInfo -- dump\n");
+    indent_printf( fp, "  bFlags 0x%x\n", bFlags );
+    indent_printf( fp, "  customText %s\n", 
+        rtl::OUStringToOString( customText.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf( fp, "  description %s\n", 
+        rtl::OUStringToOString( descriptionText.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf( fp, "  tooltip %s\n", 
+        rtl::OUStringToOString( tooltip.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    extraInfo.Print( fp );
+}
+
+TBCMenuSpecific::TBCMenuSpecific() : tbid( 0 )
+{
+}
+
+bool
+TBCMenuSpecific::Read( SotStorageStream *pS)
+{
+    OSL_TRACE("TBCMenuSpecific::Read() stream pos 0x%x", pS->Tell() );
+    *pS >> tbid;
+    if ( tbid == 1 ) 
+    {
+        name.reset( new WString() );
+        return name->Read( pS );
+    }
+    return true;
+}
+
+void 
+TBCMenuSpecific::Print( FILE* fp )
+{
+    INDENT;
+    indent_printf( fp, "TBCMenuSpecific -- dump\n");
+    indent_printf( fp, "  tbid 0x%x\n", static_cast< unsigned int >( tbid ) );
+    if ( tbid == 1 )
+        indent_printf( fp, "  name %s", rtl::OUStringToOString( name->getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+
+}
+
+TBCBSpecific::TBCBSpecific() : bFlags( 0 )
+{
+}
+
+bool TBCBSpecific::Read( SotStorageStream *pS)
+{
+    OSL_TRACE("TBCBSpecific::Read() stream pos 0x%x", pS->Tell() );
+    *pS >> bFlags;
+
+    // bFlags determines what we read next
+
+    // bFlags.fCustomBitmap = 1 ( 0x8 ) set 
+    if ( bFlags & 0x8 )
+    {
+        icon.reset( new TBCBitMap() );
+        iconMask.reset( new TBCBitMap() );
+        if ( !icon->Read( pS ) || !iconMask->Read( pS ) )
+            return false;
+    }
+    // if bFlags.fCustomBtnFace = 1 ( 0x10 )
+    if ( bFlags & 0x10 )
+    {
+        iBtnFace.reset( new sal_uInt16 );
+        *pS >> *iBtnFace.get();
+    }
+    // if bFlags.fAccelerator equals 1 ( 0x04 )
+    if ( bFlags & 0x04 )
+    {
+        wstrAcc.reset( new WString() );
+        return wstrAcc->Read( pS );
+    }
+    return true;
+}
+
+
+void TBCBSpecific::Print( FILE* fp )
+{
+    INDENT;
+    indent_printf( fp, "TBCBSpecific -- dump\n");
+    indent_printf( fp, "  bFlags 0x%x\n", bFlags );
+    bool bResult = ( icon.get() != NULL );
+    indent_printf( fp, "  icon present? %s\n", bResult ? "true" : "false" );
+    if ( bResult )
+    {
+        INDENT;
+        indent_printf( fp, "  icon: \n");
+        icon->Print( fp ); // will dump size
+    }
+    bResult = ( iconMask.get() != NULL );
+    indent_printf( fp, "  icon mask present? %s\n", bResult ? "true" : "false" );
+    if ( bResult )
+    {
+        INDENT;
+        indent_printf( fp, "  icon mask: \n");
+        iconMask->Print( fp ); // will dump size
+    }
+    if ( iBtnFace.get() )
+    {
+        indent_printf( fp, "  iBtnFace 0x%x\n", *(iBtnFace.get()) );
+    }
+    bResult = ( wstrAcc.get() != NULL );
+    indent_printf( fp, "  option string present? %s ->%s<-\n", bResult ? "true" : "false", bResult ? rtl::OUStringToOString( wstrAcc->getString(), RTL_TEXTENCODING_UTF8 ).getStr() : "N/A" );
+}
+
+TBCComboDropdownSpecific::TBCComboDropdownSpecific(const TBCHeader& header ) 
+{
+    if ( header.getTcID() == 0x01 )
+        data.reset( new TBCCDData() );
+}
+
+bool TBCComboDropdownSpecific::Read( SotStorageStream *pS)
+{
+    if ( data.get() )
+        return data->Read( pS );
+    return true;
+}
+
+void TBCComboDropdownSpecific::Print( FILE* fp)
+{
+    INDENT;
+    indent_printf(fp,"TBCComboDropdownSpecific -- dump" );
+    if ( data.get() )
+        data->Print( fp );
+    else
+        indent_printf(fp," no data " );
+}
+
+TBCCDData::TBCCDData() : cwstrItems( 0 )
+,wstrList( NULL ) 
+,iSel( 0 )
+,cLines( 0 )
+,dxWidth( 0 )
+{
+}
+
+TBCCDData::~TBCCDData()
+{
+    if ( wstrList )
+        delete[] wstrList;
+}
+
+bool TBCCDData::Read( SotStorageStream *pS)
+{
+    *pS >> cwstrItems;
+    if ( cwstrItems )
+    {
+        wstrList = new WString[ cwstrItems ];
+        for( sal_Int32 index=0; index < cwstrItems; ++index )
+        {
+            if ( !wstrList[ index ].Read( pS ) )
+                return false;
+        } 
+    }
+    *pS >> cwstrMRU >> iSel >> cLines >> dxWidth;
+
+    return wstrEdit.Read( pS );
+}
+
+void TBCCDData::Print( FILE* fp)
+{
+    INDENT;
+    indent_printf(fp,"TBCCDData -- dump\n");
+    indent_printf(fp,"  cwstrItems items in wstrList 0x%d\n", cwstrItems);
+    for ( sal_Int32 index=0; index < cwstrItems; ++index )
+    {
+        INDENT;
+        indent_printf(fp, "  wstrList[%d] %s", static_cast< int >( index ), rtl::OUStringToOString( wstrList[index].getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    }
+    indent_printf(fp,"  cwstrMRU num most recently used string 0x%d item\n", cwstrMRU);
+    indent_printf(fp,"  iSel index of selected item 0x%d item\n", iSel);
+    indent_printf(fp,"  cLines num of suggested lines to display 0x%d", cLines);
+    indent_printf(fp,"  dxWidth width in pixels 0x%d", dxWidth);
+    indent_printf(fp,"  wstrEdit %s", rtl::OUStringToOString( wstrEdit.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+}
+
+TBCBitMap::TBCBitMap() : cbDIB( 0 ), pRestOfIt( NULL )
+{
+}
+
+TBCBitMap::~TBCBitMap()
+{
+    if ( pRestOfIt )
+        delete [] pRestOfIt;
+}
+
+bool TBCBitMap::Read( SotStorageStream* pS)
+{
+    OSL_TRACE("TBCBitMap::Read() stream pos 0x%x", pS->Tell() );
+    *pS >> cbDIB;
+    // cbDIB = sizeOf(biHeader) + sizeOf(colors) + sizeOf(bitmapData) + 10
+    // slurp the rest of the structure as a blob ( we'll get to it later )
+
+    pRestOfIt = new sal_uInt8[ cbDIB - 10 ];
+    pS->Read( pRestOfIt, cbDIB - 10 );
+    return true;
+}
+
+void TBCBitMap::Print( FILE* fp )
+{
+    INDENT;
+    indent_printf(fp, "TBCBitMap -- dump\n");
+    indent_printf(fp, "  TBCBitMap size of bitmap data 0x%x\n", static_cast< unsigned int > ( cbDIB ) );
+}
+
+Tcg::Tcg() : nTcgVer( 255 )
+{
+}
+
+bool Tcg::Read(SotStorageStream *pS)
+{
+    OSL_TRACE("Tcg::Read() stream pos 0x%x", pS->Tell() );
+    *pS >> nTcgVer;
+    if ( nTcgVer != (sal_Int8)255 )
+        return false;
+    tcg.reset( new Tcg255() );
+    return tcg->Read( pS );
+}
+
+void Tcg::Print( FILE* fp )
+{
+    INDENT_INIT;
+    indent_printf(fp, "Tcg - dump %d\n", nTcgVer);
+    indent_printf(fp,"  nTcgVer %d\n", nTcgVer);
+    tcg->Print( fp );
+}
+
+Tcg255::Tcg255()
+{
+}
+
+Tcg255::~Tcg255()
+{
+    std::vector< Tcg255SubStruct* >::iterator it = rgtcgData.begin();
+    for ( ; it != rgtcgData.end(); ++it )
+        delete *it;
+}
+
+bool Tcg255::processSubStruct( sal_uInt8 nId, SotStorageStream *pS )
+{
+     Tcg255SubStruct* pSubStruct = NULL;
+     switch ( nId )
+     {
+         case 0x1:
+         {
+             pSubStruct = new PlfMcd( false ); // don't read the id
+             break;
+         }
+         case 0x2: 
+         {
+             pSubStruct = new PlfAcd( false );
+             break;
+         }
+         case 0x3: 
+         case 0x4: 
+         {
+             pSubStruct = new PlfKme( false );
+             break;
+         }
+         case 0x10: 
+         {
+             pSubStruct = new TcgSttbf( false );
+             break;
+         }
+         case 0x11: 
+         {
+             pSubStruct = new MacroNames( false );
+             break;
+         }
+         case 0x12: 
+         {
+             pSubStruct = new CTBWrapper( false );
+             break;
+         }
+         default:
+             OSL_TRACE("Unknown id 0x%x",nId);
+             return false;
+    }
+    pSubStruct->ch = nId;
+    if ( !pSubStruct->Read( pS ) )
+        return false;
+    rgtcgData.push_back( pSubStruct );
+    return true;
+}
+
+bool Tcg255::Read(SotStorageStream *pS)
+{
+    OSL_TRACE("Tcg255::Read() stream pos 0x%x", pS->Tell() );
+    sal_uInt8 nId = 0; // 
+    *pS >> nId;
+    while (  nId != 0x40  )
+    {
+        if ( !processSubStruct( nId, pS ) )
+            return false;
+        *pS >> nId;
+    } 
+    return true;
+    // Peek at  
+}
+
+void Tcg255::Print( FILE* fp)
+{
+    INDENT;
+    indent_printf(fp, "Tcg255 - dump\n");
+    indent_printf(fp, "  contains %d sub records\n", rgtcgData.size() );
+    std::vector< Tcg255SubStruct* >::iterator it = rgtcgData.begin(); 
+    std::vector< Tcg255SubStruct* >::iterator it_end = rgtcgData.end(); 
+    
+    for( sal_Int32 count = 1; it != it_end ; ++it, ++count )
+    {
+        INDENT;
+        indent_printf(fp, "  [%d] Tcg255SubStruct \n", static_cast< unsigned int >( count ) );
+        (*it)->Print(fp);
+    }
+}
+
+
+Tcg255SubStruct::Tcg255SubStruct( bool bReadId ) : mbReadId( bReadId ), ch(0)
+{
+}
+
+bool Tcg255SubStruct::Read(SotStorageStream *pS)
+{
+    OSL_TRACE("Tcg255SubStruct::Read() stream pos 0x%x", pS->Tell() );
+    if ( mbReadId )
+        *pS >> ch;
+    return true;
+}
+
+PlfMcd::PlfMcd( bool bReadId ): Tcg255SubStruct( bReadId ), rgmcd( NULL )
+{
+}
+PlfMcd::~PlfMcd()
+{
+    if ( rgmcd )
+        delete[] rgmcd;
+}
+
+bool PlfMcd::Read(SotStorageStream *pS)
+{
+    OSL_TRACE("PffMcd::Read() stream pos 0x%x", pS->Tell() );
+    Tcg255SubStruct::Read( pS );
+    *pS >> iMac;
+    if ( iMac )
+    { 
+        rgmcd = new MCD[ iMac ];
+        for ( sal_Int32 index = 0; index < iMac; ++index )
+        {
+            if ( !rgmcd[ index ].Read( pS ) )
+                return false; 
+        } 
+    }
+    return true;
+}
+
+void PlfMcd::Print( FILE* fp )
+{
+    INDENT;
+    indent_printf(fp, "PlfMcd ( Tcg255SubStruct ) - dump\n");
+    indent_printf(fp, " contains %d MCD records\n", static_cast<int>( iMac ) );
+    for ( sal_Int32 count=0; count < iMac; ++count )
+    {
+        INDENT;
+        indent_printf(fp, "[%d] MCD\n", static_cast< int >( count ) );
+        rgmcd[ count ].Print( fp );
+    }
+    
+}
+
+PlfAcd::PlfAcd( bool bReadId ) : Tcg255SubStruct( bReadId )
+,iMac(0)
+,rgacd(NULL)
+{
+}
+
+
+PlfAcd::~PlfAcd()
+{
+    if ( rgacd )
+        delete[] rgacd;
+}
+
+bool PlfAcd::Read( SotStorageStream *pS)
+{
+    OSL_TRACE("PffAcd::Read() stream pos 0x%x", pS->Tell() );
+    Tcg255SubStruct::Read( pS );
+    *pS >> iMac;
+    if ( iMac )
+    {
+        rgacd = new Acd[ iMac ];
+        for ( sal_Int32 index = 0; index < iMac; ++index )
+        {
+            if ( !rgacd[ index ].Read( pS ) ) 
+                return false;
+        }
+    }
+    return true;
+}
+void PlfAcd::Print( FILE* fp )
+{
+    INDENT;
+    indent_printf(fp, "PlfAcd ( Tcg255SubStruct ) - dump\n");
+    indent_printf(fp, " contains %d ACD records\n", static_cast< int >( iMac ) );
+    for ( sal_Int32 count=0; count < iMac; ++count )
+    {
+        INDENT;
+        indent_printf(fp, "[%d] ACD\n", static_cast< int >( count ) );
+        rgacd[ count ].Print( fp );
+    }
+    
+}
+
+PlfKme::PlfKme( bool bReadId ) : Tcg255SubStruct( bReadId )
+,iMac( 0 )
+,rgkme( NULL )
+{
+}
+
+PlfKme::~PlfKme()
+{
+    if ( rgkme )
+        delete[] rgkme;
+}
+
+bool PlfKme::Read(SotStorageStream *pS)
+{
+    OSL_TRACE("PlfKme::Read() stream pos 0x%x", pS->Tell() );
+    Tcg255SubStruct::Read( pS );
+    *pS >> iMac;
+    if ( iMac )
+    {
+        rgkme = new Kme[ iMac ];
+        for( sal_Int32 index=0; index<iMac; ++index )
+        {
+            if ( !rgkme[ index ].Read( pS ) )
+                return false;
+        }
+    }
+    return true;
+}
+ 
+void PlfKme::Print( FILE* fp )
+{
+    INDENT;
+    indent_printf(fp, "PlfKme ( Tcg255SubStruct ) - dump\n");
+    indent_printf(fp, " contains %d Kme records\n", static_cast< int >( iMac ) );
+    for ( sal_Int32 count=0; count < iMac; ++count )
+    {
+        INDENT;
+        indent_printf(fp, "[%d] Kme\n", static_cast< int >( count ) );
+        rgkme[ count ].Print( fp );
+    }
+    
+}
+
+TcgSttbf::TcgSttbf( bool bReadId ) : Tcg255SubStruct( bReadId )
+{
+}
+
+bool TcgSttbf::Read( SotStorageStream *pS) 
+{
+    OSL_TRACE("TcgSttbf::Read() stream pos 0x%x", pS->Tell() );
+    Tcg255SubStruct::Read( pS );
+    return sttbf.Read( pS );
+}
+
+void TcgSttbf::Print( FILE* fp )
+{
+    INDENT;
+    indent_printf(fp,"TcgSttbf - dump\n");
+    sttbf.Print( fp );
+}
+
+TcgSttbfCore::TcgSttbfCore() : fExtend( 0 )
+,cData( 0 )
+,cbExtra( 0 )
+,dataItems( NULL )
+{
+}
+
+TcgSttbfCore::~TcgSttbfCore()
+{
+    if ( dataItems )
+        delete[] dataItems;
+}
+
+bool TcgSttbfCore::Read( SotStorageStream* pS )
+{
+    OSL_TRACE("TcgSttbfCore::Read() stream pos 0x%x", pS->Tell() );
+    *pS >> fExtend >> cData >> cbExtra;
+    if ( cData )
+    {
+        dataItems = new SBBItem[ cData ];
+        for ( sal_Int32 index = 0; index < cData; ++index )
+        {
+            *pS >> dataItems[ index ].cchData;
+            dataItems[ index ].data = readUnicodeString( pS, dataItems[ index ].cchData );
+            *pS >> dataItems[ index ].extraData;
+        }
+    }
+    return true;
+}
+
+void TcgSttbfCore::Print( FILE* fp )
+{
+    INDENT;
+    indent_printf( fp, "TcgSttbfCore - dump\n");
+    indent_printf( fp, " fExtend 0x%x [expected 0xFFFF ]\n", fExtend );
+    indent_printf( fp, " cbExtra 0x%x [expected 0x02 ]\n", cbExtra );
+    indent_printf( fp, " cData no. or string data items %d (0x%x)\n", cData, cData );
+    
+    if ( cData )
+    {
+        for ( sal_Int32 index = 0; index < cData; ++index )
+            indent_printf(fp,"   string dataItem[ %d(0x%x) ] has name %s and if referenced %d times.\n", static_cast< int >( index ), static_cast< unsigned int >( index ), rtl::OUStringToOString( dataItems[ index ].data, RTL_TEXTENCODING_UTF8 ).getStr(), dataItems[ index ].extraData );
+    }
+
+}
+MacroNames::MacroNames( bool bReadId ) : Tcg255SubStruct( bReadId )
+,iMac( 0 )
+,rgNames( NULL )
+{
+}
+
+MacroNames::~MacroNames()
+{
+    if ( rgNames )
+        delete[] rgNames;
+}
+
+bool MacroNames::Read( SotStorageStream *pS)
+{
+    OSL_TRACE("MacroNames::Read() stream pos 0x%x", pS->Tell() );
+    Tcg255SubStruct::Read( pS );
+    *pS >> iMac;
+    if ( iMac )
+    {
+        rgNames = new MacroName[ iMac ]; 
+        for ( sal_Int32 index = 0; index < iMac; ++index )
+        {
+            if ( !rgNames[ index ].Read( pS ) )
+                return false;
+        }
+    }
+    return true;
+}
+
+void MacroNames::Print( FILE* fp )
+{
+    INDENT;
+    indent_printf(fp, "MacroNames ( Tcg255SubStruct ) - dump\n");
+    indent_printf(fp, " contains %d MacroName records\n", iMac );
+    for ( sal_Int32 count=0; count < iMac; ++count )
+    {
+        INDENT;
+        indent_printf(fp, "[%d] MacroName\n", static_cast<int>( count ) );
+        rgNames[ count ].Print( fp );
+    }
+    
+}
+
+MacroName::MacroName():ibst(0)
+{
+}
+
+
+bool MacroName::Read(SotStorageStream *pS)
+{
+    OSL_TRACE("MacroName::Read() stream pos 0x%x", pS->Tell() );
+    *pS >> ibst;
+    return xstz.Read( pS );
+}
+
+void MacroName::Print( FILE* fp )
+{
+    INDENT;
+    indent_printf( fp, "MacroName - dump");
+    indent_printf( fp,"  index - 0x%x has associated following record\n", ibst );
+    xstz.Print( fp );
+}
+
+
+
+Xstz::Xstz():chTerm(0)
+{
+}
+
+bool 
+Xstz::Read(SotStorageStream *pS)
+{
+    OSL_TRACE("Xstz::Read() stream pos 0x%x", pS->Tell() );
+    if ( !xst.Read( pS ) )
+        return false;
+    *pS >> chTerm;
+    if ( chTerm != 0 ) // should be an assert 
+        return false;
+    return true;
+}
+
+void Xstz::Print( FILE* fp )
+{
+    INDENT;
+    indent_printf(fp,"Xstz -- dump\n");
+    indent_printf(fp,"  Xst\n");
+    xst.Print( fp ); 
+    indent_printf(fp,"  chterm 0x%x ( should be zero )\n", chTerm);
+}
+
+Kme::Kme() : reserved1(0)
+,reserved2(0)
+,kcm1(0)
+,kcm2(0)
+,kt(0)
+,param(0)
+{
+}
+
+Kme::~Kme()
+{
+}
+
+bool
+Kme::Read(SotStorageStream *pS)
+{
+    OSL_TRACE("Kme::Read() stream pos 0x%x", pS->Tell() );
+    *pS >> reserved1 >> reserved2 >> kcm1 >> kcm2 >> param;
+    return true;
+}
+
+void Kme::Print( FILE* fp )
+{
+    INDENT;
+    
+   indent_printf( fp, "Kme - dump\n");
+   indent_printf( fp, " reserved1 0x%x [expected 0x0 ]\n", reserved1 );
+   indent_printf( fp, " reserved2 0x%x [expected 0x0 ]\n", reserved2 );
+   indent_printf( fp, " kcm1 0x%x [shortcut key]\n", kcm1 );
+   indent_printf( fp, " kcm2 0x%x [shortcut key]\n", kcm2 );
+   indent_printf( fp, " kt 0x%x \n", kt );
+   indent_printf( fp, " param 0x%x \n", static_cast< unsigned int >( param ) );
+}
+
+Acd::Acd() : ibst( 0 )
+, fciBasedOnABC( 0 )
+{
+}
+
+bool Acd::Read(SotStorageStream *pS)
+{
+    OSL_TRACE("Acd::Read() stream pos 0x%x", pS->Tell() );
+    *pS >> ibst >> fciBasedOnABC;
+    return true;
+}
+
+void Acd::Print( FILE* fp )
+{
+    INDENT;
+    indent_printf( fp,"ACD - dump\n");
+    // #TODO flesh out interpretation of these values
+    indent_printf( fp,"  ibst 0x%x\n", ibst);
+    indent_printf( fp,"  fciBaseObABC 0x%x\n", fciBasedOnABC);
+}
+
+MCD::MCD() :  reserved1(0x56)
+,reserved2( 0 )
+,ibst( 0 )
+,ibstName( 0 )
+,reserved3( 0xFFFF )
+,reserved4( 0 )
+,reserved5( 0 )
+,reserved6( 0 )
+,reserved7( 0 )
+{
+}
+
+bool  MCD::Read(SotStorageStream *pS)
+{
+    OSL_TRACE("MCD::Read() stream pos 0x%x", pS->Tell() );
+    *pS >> reserved1 >> reserved2 >> ibst >> ibstName >> reserved3;
+    *pS >> reserved4 >> reserved5 >> reserved6 >> reserved7;
+    return true;
+}
+
+void MCD::Print( FILE* fp )
+{
+    INDENT;
+    indent_printf( fp, "MCD - dump\n");
+    indent_printf( fp, " reserved1 0x%x [expected 0x56 ]\n", reserved1 );
+    indent_printf( fp, " reserved2 0x%x [expected 0x0 ]\n", reserved2 );
+    indent_printf( fp, " ibst 0x%x specifies macro with MacroName.xstz = 0x%x\n", ibst, ibst );
+    indent_printf( fp, " ibstName 0x%x index into command string table ( TcgSttbf.sttbf )\n", ibstName );
+
+    indent_printf( fp, " reserved3 0x%x [expected 0xFFFF ]\n", reserved3 );
+    indent_printf( fp, " reserved4 0x%x\n", static_cast< unsigned int >( reserved4 ) );
+    indent_printf( fp, " reserved5 0x%x [expected 0x0 ]\n", static_cast< unsigned int >( reserved5 ) );
+    indent_printf( fp, " reserved6 0x%x\n", static_cast< unsigned int >( reserved6 ) );
+    indent_printf( fp, " reserved7 0x%x\n", static_cast< unsigned int >( reserved7 ) );
+}
+
