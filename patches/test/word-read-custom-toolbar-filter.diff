diff --git sw/source/filter/ww8/makefile.mk sw/source/filter/ww8/makefile.mk
index 25cb969..95b12fb 100644
--- sw/source/filter/ww8/makefile.mk
+++ sw/source/filter/ww8/makefile.mk
@@ -95,7 +95,9 @@ SLOFILES =	\
 		$(SLO)$/writerhelper.obj \
 		$(SLO)$/writerwordglue.obj \
         $(SLO)$/WW8TableInfo.obj \
-        $(SLO)$/WW8FFData.obj
+        $(SLO)$/WW8FFData.obj \
+        $(SLO)$/ww8toolbar.obj \
+
 
 
 # --- Tagets -------------------------------------------------------
diff --git sw/source/filter/ww8/ww8par.cxx sw/source/filter/ww8/ww8par.cxx
index a7f122b..c9a478b 100644
--- sw/source/filter/ww8/ww8par.cxx
+++ sw/source/filter/ww8/ww8par.cxx
@@ -142,11 +142,12 @@
 #include <stdio.h>
 #include <comphelper/processfactory.hxx>
 #include <basic/basmgr.hxx>
-
 #ifdef DEBUG
 #include <iostream>
 #include <dbgoutsw.hxx>
 #endif 
+#include <fstream>
+#include "ww8toolbar.hxx"
 
 #define MM_250 1417             // WW-Default fuer Hor. Seitenraender: 2.5 cm
 #define MM_200 1134             // WW-Default fuer u.Seitenrand: 2.0 cm
@@ -4173,7 +4174,37 @@ ULONG SwWW8ImplReader::SetSubStreams(SvStorageStreamRef &rTableStream,
             rTableStream = pStg->OpenSotStream( String::CreateFromAscii(
                 pWwFib->fWhichTblStm ? SL::a1Table : SL::a0Table),
                 STREAM_STD_READ);
+#if 1
+            if ( pWwFib->fWhichTblStm )
+            {
+// dump a1Table stream here !!!
+            OSL_TRACE("About to dump 1table ");
+                long nCur = rTableStream->Tell();
+                std::ofstream fDump( "1Table.dump" );
+                
+                while ( !rTableStream->IsEof() )
+                {
+                    sal_uInt8 aByte;
+                    *rTableStream >> aByte;
+                    fDump << aByte;
+                }
+
+                rTableStream->Seek( nCur );  // restore stream pointer
 
+// attempt to read where the offset to the Customizations is (
+// also we should be able to find the offset to the macro table too
+                if ( pWwFib->lcbCmds )
+                {
+                    // there is a tgc255 structure
+                    OSL_TRACE(" tgc255 has offset 0x%x with length 0x%x", pWwFib->fcCmds, pWwFib->lcbCmds );
+                    Tcg aTCG;
+                    rTableStream->Seek( pWwFib->fcCmds ); // point at tgc record
+                    aTCG.Read( rTableStream );
+                    rTableStream->Seek( nCur ); // return to previous position
+                    //aTCG.Print( stderr ); // print routines not chained yet
+                }
+            }
+#endif
             pTableStream = &rTableStream;
             pTableStream->SetNumberFormatInt( NUMBERFORMAT_INT_LITTLEENDIAN );
 
--- /dev/null	2008-04-22 00:28:44.000000000 +0100
+++ sw/source/filter/ww8/ww8toolbar.hxx	2009-01-28 17:48:04.000000000 +0000
@@ -0,0 +1,421 @@
+#ifndef _WW8TOOLBAR_HXX
+#define _WW8TOOLBAR_HXX
+
+#include <tools/string.hxx>
+#include <sot/storage.hxx>
+#include <ostream>
+#include <memory>
+#include <vector>
+
+class TBBase
+{
+public:
+    virtual ~TBBase(){}
+    virtual bool Read(SotStorageStream *pS) = 0;
+    virtual void Print( FILE* ) {} // #FIXME remove this an implement the debug routines in all the classes below to enable some sort of readable output
+};
+
+class Xst : public TBBase
+{
+    rtl::OUString sString;
+public:
+    Xst(){}
+    bool Read(SotStorageStream *pS);
+    rtl::OUString getString() { return sString; }
+};
+
+class WString : public TBBase
+{
+    rtl::OUString sString;
+
+    WString(const WString&);
+    WString& operator = ( const WString&);
+public:
+    WString(){};
+    ~WString(){};
+    bool Read(SotStorageStream *pS);
+    rtl::OUString getString(){ return sString; }
+};
+
+class TBCExtraInfo : public TBBase
+{
+    WString wstrHelpFile;
+    sal_Int32 idHelpContext;
+    WString wstrTag;
+    WString wstrOnAction;
+    WString wstrParam;
+    sal_Int8 tbcu;
+    sal_Int8 tbmg;
+
+    TBCExtraInfo(const TBCExtraInfo&);
+    TBCExtraInfo& operator = ( const TBCExtraInfo&);
+public:
+    TBCExtraInfo();
+    ~TBCExtraInfo(){}
+    bool Read(SotStorageStream *pS);
+};
+
+class TBCGeneralInfo  : public TBBase
+{
+    sal_uInt8 bFlags;
+    WString customText;
+    WString descriptionText;
+    WString tooltip;
+    TBCExtraInfo extraInfo;
+
+    TBCGeneralInfo(const TBCGeneralInfo&);
+    TBCGeneralInfo& operator = ( const TBCGeneralInfo&);
+public:
+    TBCGeneralInfo();
+    ~TBCGeneralInfo() {}
+    bool Read(SotStorageStream *pS);
+};
+
+class TBCBitMap : public TBBase
+{
+    sal_Int32 cbDIB;
+//    BITMapInfoHeader biHeader;  // lets cheat and not read the bit map stuff right now
+    sal_uInt8* pRestOfIt;
+    TBCBitMap(const TBCBitMap&);
+    TBCBitMap& operator = ( const TBCBitMap&);
+public:
+    TBCBitMap();
+    ~TBCBitMap();
+    bool Read(SotStorageStream *pS);
+};
+
+class TBCSpecific :  public TBBase
+{
+    sal_uInt8 bFlags;
+    std::auto_ptr< TBCBitMap > icon; // optional
+    std::auto_ptr< TBCBitMap > iconMask; // optional
+    std::auto_ptr< sal_uInt16 > iBtnFace; // optional
+    std::auto_ptr< WString > wstrAcc; // optional
+   
+    TBCSpecific(const TBCSpecific&);
+    TBCSpecific& operator = ( const TBCSpecific&);
+public:
+    TBCSpecific();
+    ~TBCSpecific(){}
+    bool Read(SotStorageStream *pS);
+};
+
+class TBCData : public TBBase
+{
+    TBCGeneralInfo controlGeneralInfo;
+    TBCSpecific controlSpecificInfo; // can be one of TBCSpecific, TBCMenuSpecific or TBCComboDropdow nSpecific depending on the control type specified by TBCHeader.tct ( initially lets just implement TBCSpecific 
+    TBCData(const TBCData&);
+    TBCData& operator = ( const TBCData&);
+public:
+    TBCData(){}
+    ~TBCData(){}
+    bool Read(SotStorageStream *pS);
+};
+
+class TBCHeader : public TBBase
+{
+friend class TBC;
+    sal_Int8 bSignature; 
+    sal_Int8 bVersion; 
+    sal_uInt8 bFlagsTCR; 
+    sal_uInt8 tct; 
+    sal_uInt16 tcid;
+    sal_uInt32 tbct;
+    sal_uInt8 bPriority;
+    sal_uInt16* width;  //optional
+    sal_uInt16* height; //optional
+
+    TBCHeader(const TBCHeader&);
+    TBCHeader& operator = ( const TBCHeader&);
+public:
+    TBCHeader();
+    ~TBCHeader();
+    bool Read(SotStorageStream *pS);
+};
+
+class TBC : public TBBase
+{
+    TBCHeader tbch;
+    sal_uInt32* cid; // optional
+    std::auto_ptr<TBCData> tbcd;
+    TBC(const TBC&);
+    TBC& operator = ( const TBC&);
+public:
+    TBC();
+    ~TBC();
+    bool Read(SotStorageStream *pS);
+};
+class CTB : public TBBase
+{
+    Xst name;
+    sal_Int32 cbTBData;
+    sal_uInt8* tb; // array of toolbar data ( currently not read )
+    sal_uInt8 rVisualData[ 100 ];
+    sal_Int32 iWCTBl;
+    sal_uInt16 reserved;
+    sal_uInt16 unused;
+    sal_Int32 cCtls;
+    TBC* rTBC;
+
+    CTB(const CTB&);
+    CTB& operator = ( const CTB&);
+public:
+    CTB();
+    ~CTB();
+    bool Read(SotStorageStream *pS);
+};
+
+class TBDelta : TBBase
+{
+    sal_uInt8 doprfatendFlags;
+    sal_uInt8 ibts;
+    sal_Int32 cidNext; 
+    sal_Int32 cid;
+    sal_Int32 fc;
+    sal_uInt8 CiTBDE[2]; // careful of this ( endian matters etc. )
+    sal_uInt16 cbTBC;
+    TBDelta(const TBDelta&);
+    TBDelta& operator = ( const TBDelta&);
+public:
+    TBDelta();
+    ~TBDelta(){}
+    bool Read(SotStorageStream *pS);
+};
+
+class Tcg255SubStruct : public TBBase
+{
+friend class Tcg255;
+    bool mbReadId;
+    Tcg255SubStruct(const Tcg255SubStruct&);
+    Tcg255SubStruct& operator = ( const Tcg255SubStruct&);
+protected:
+    sal_uInt8 ch;
+public:
+    Tcg255SubStruct( bool bReadId );
+    ~Tcg255SubStruct(){}
+    virtual sal_uInt8 id() { return ch; }
+    bool Read(SotStorageStream *pS);
+};
+
+class Customization : public TBBase
+{
+    sal_Int32 tbidForTBD;
+    sal_uInt16 reserved1;
+    sal_Int16 ctbds;
+
+    CTB* customizationDataCTB;
+    TBDelta* customizationDataTBDelta; // we don't read these yet
+    
+    Customization(const Customization&);
+    Customization& operator = ( const Customization&);
+public:    
+    Customization();
+    ~Customization();
+    bool Read(SotStorageStream *pS);
+};
+
+class CTBWrapper : public Tcg255SubStruct
+{
+    // reserved1 is the ch field of Tcg255SubStruct
+    sal_uInt16 reserved2;
+    sal_uInt8 reserved3;
+    sal_uInt16 reserved4;
+    sal_uInt16 reserved5;
+
+    sal_Int16 cbTBD;
+    sal_Int16 cCust;
+
+    sal_Int32 cbDTBC;
+
+    sal_uInt8* rtbdc; // array of TBC's - we don't read these yet 
+    Customization* rCustomizations; // array of Customizations
+
+    CTBWrapper(const CTBWrapper&);
+    CTBWrapper& operator = ( const CTBWrapper&);
+public:
+    CTBWrapper( bool bReadId = true );
+    ~CTBWrapper();
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class MCD : public TBBase
+{
+    sal_Int8 reserved1; //  A signed integer that MUST be 0x56. 
+    sal_uInt8 reserved2; // MUST be 0.
+    sal_uInt16 ibst; // Unsigned integer that specifies the name of the macro. Macro name is specified by MacroName.xstz of the MacroName entry in the MacroNames such that MacroName.ibst equals ibst. MacroNames MUST contain such an entry.
+    sal_uInt16 ibstName; // An unsigned integer that specifies the index into the Command String Table (TcgSttbf.sttbf) where the macroâ€˜s name and arguments are specified.
+    sal_uInt16 reserved3; // An unsigned integer that MUST be 0xFFFF.
+    sal_uInt32 reserved4; //MUST be ignored. 
+    sal_uInt32 reserved5; //MUST be 0. 
+    sal_uInt32 reserved6; //MUST be ignored. 
+    sal_uInt32 reserved7; //MUST be ignored   
+
+    MCD(const MCD&);
+    MCD& operator = ( const MCD&);
+public:
+    MCD();
+    ~MCD(){}
+    bool Read(SotStorageStream *pS);
+};
+
+class PlfMcd : public Tcg255SubStruct
+{
+    sal_Int32 iMac;
+    MCD* rgmcd; // array of MCD's
+    PlfMcd(const PlfMcd&);
+    PlfMcd& operator = ( const PlfMcd&);
+public:
+    PlfMcd( bool bReadId = true );
+    ~PlfMcd();
+    bool Read(SotStorageStream *pS);
+};
+
+class Acd : public TBBase
+{
+    sal_Int16 ibst;
+    sal_uInt16 fciBasedOnABC; //  fciBasedOn(13 bits) A(1bit)B(1bit)C(1Bit)
+    Acd(const Acd&);
+    Acd& operator = ( const Acd&);
+public:
+    Acd();
+    ~Acd(){}
+    bool Read(SotStorageStream *pS);
+};
+
+class PlfAcd: public Tcg255SubStruct
+{
+    sal_Int32 iMac;
+    Acd* rgacd;
+    PlfAcd(const PlfAcd&);
+    PlfAcd& operator = ( const PlfAcd&);
+public:
+    PlfAcd( bool bReadId = true );
+    ~PlfAcd();
+    bool Read(SotStorageStream *pS);
+};
+
+class Kme : public TBBase
+{
+    sal_Int16 reserved1; //MUST be zero. 
+    sal_Int16 reserved2; //MUST be zero.
+    sal_uInt16 kcm1; //A Kcm that specifies the primary shortcut key.
+    sal_uInt16 kcm2; //A Kcm that specifies the secondary shortcut key, or 0x00FF if there is no secondary shortcut key.
+    sal_uInt16 kt; //A Kt that specifies the type of action to be taken when the key combination is pressed. 
+    sal_uInt32 param; //The meaning of this field depends on the value of kt
+
+    Kme(const Kme&);
+    Kme& operator = ( const Kme&);
+public:
+    Kme();
+    ~Kme();
+    bool Read(SotStorageStream *pS);
+};
+
+class PlfKme : public Tcg255SubStruct
+{
+    sal_Int32 iMac;
+    Kme* rgkme;
+    PlfKme(const PlfKme&);
+    PlfKme& operator = ( const PlfKme&);
+public:
+    PlfKme( bool bReadId = true );
+    ~PlfKme();
+    bool Read(SotStorageStream *pS);
+};
+
+class TcgSttbfCore : public TBBase
+{
+struct SBBItem
+{
+    sal_uInt16 cchData;
+    rtl::OUString data; // maybe substitute with a string
+    sal_uInt16 extraData;
+    SBBItem() : cchData(0), extraData(0){}
+};
+    sal_uInt16 fExtend;
+    sal_uInt16 cData;
+    sal_uInt16 cbExtra;
+    SBBItem* dataItems;
+    TcgSttbfCore(const TcgSttbfCore&);
+    TcgSttbfCore& operator = ( const TcgSttbfCore&);
+public:
+    TcgSttbfCore();
+    ~TcgSttbfCore();
+    bool Read(SotStorageStream *pS);
+};
+
+class TcgSttbf : public Tcg255SubStruct
+{
+    TcgSttbfCore sttbf;
+    TcgSttbf(const TcgSttbf&);
+    TcgSttbf& operator = ( const TcgSttbf&);
+public:
+    TcgSttbf( bool bReadId = true );
+    ~TcgSttbf(){}
+    bool Read(SotStorageStream *pS);
+};
+
+class Xstz : public TBBase
+{
+    Xst xst; //An Xst specifying the string with its pre-pended length. 
+    sal_uInt16 chTerm;
+
+    Xstz(const Xstz&);
+    Xstz& operator = ( const Xstz&);
+public:
+    Xstz();
+    ~Xstz(){}
+    bool Read(SotStorageStream *pS);
+};
+
+class MacroName : public TBBase
+{
+    sal_uInt16 ibst; //An unsigned integer that specifies the index of the current entry in the macro name table. MUST NOT be the same as the index of any other entry.
+    Xstz xstz;
+    MacroName(const MacroName&);
+    MacroName& operator = ( const MacroName&);
+public:
+    MacroName();
+    ~MacroName(){}
+    bool Read(SotStorageStream *pS);
+};
+
+class MacroNames : public Tcg255SubStruct
+{
+    sal_uInt16 iMac; //An unsigned integer that specifies the number of MacroName structures in rgNames.
+    MacroName* rgNames;
+
+    MacroNames(const MacroNames&);
+    MacroNames& operator = ( const MacroNames&);
+public:
+    MacroNames( bool bReadId = true );
+    ~MacroNames();
+    bool Read(SotStorageStream *pS);
+};
+
+class Tcg255 : public TBBase
+{
+    std::vector< Tcg255SubStruct* > rgtcgData; // array of sub structures
+    Tcg255(const Tcg255&);
+    Tcg255& operator = ( const Tcg255&);
+    bool processSubStruct( sal_uInt8 nId, SotStorageStream*  );
+public:
+    Tcg255();
+    ~Tcg255();
+    bool Read(SotStorageStream *pS);
+};
+
+class Tcg: public TBBase
+{
+    sal_Int8 nTcgVer; 
+    std::auto_ptr< Tcg255 > tcg;
+    Tcg(const Tcg&);
+    Tcg& operator = ( const Tcg&);
+public:
+    Tcg();
+    ~Tcg(){}
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+#endif
--- /dev/null	2008-04-22 00:28:44.000000000 +0100
+++ sw/source/filter/ww8/ww8toolbar.cxx	2009-01-28 18:11:23.000000000 +0000
@@ -0,0 +1,679 @@
+#include "ww8toolbar.hxx"
+#include <rtl/ustrbuf.hxx>
+
+rtl::OUString readUnicodeString( SotStorageStream* pS, sal_Int32 nChars )
+{
+    rtl::OUStringBuffer buf(40);
+    for ( sal_Int32 index = 0; index < nChars; ++index )
+    {
+        sal_uInt16 ch = 0;
+        *pS >> ch;
+        sal_Unicode uni = static_cast< sal_Unicode >( ch );
+        buf.append( &uni, 1 );
+    }
+    return buf.makeStringAndClear();
+}
+
+CTBWrapper::CTBWrapper( bool bReadId ) : Tcg255SubStruct( bReadId )
+,reserved2(0)
+,reserved3(0)
+,reserved4(0)
+,reserved5(0)
+,cbTBD(0)
+,cCust(0)
+,cbDTBC(0)
+,rtbdc(0)
+,rCustomizations(0)
+{
+}
+
+CTBWrapper::~CTBWrapper()
+{
+    if ( rtbdc )
+        delete [] rtbdc; 
+    if ( rCustomizations )
+        delete [] rCustomizations; 
+}
+
+bool CTBWrapper::Read( SotStorageStream* pS )
+{
+    Tcg255SubStruct::Read( pS );
+    *pS >> reserved2 >> reserved3 >> reserved4 >> reserved5;
+    *pS >> cbTBD >> cCust >> cbDTBC;
+    if ( cbDTBC )
+    {
+        // cbDTBC is the size in bytes of the TBC array
+        // but the size of a TBC element is dynamic ( and this relates to TBDelta's
+        // which we don't read right now )
+        pS->SeekRel( cbDTBC );
+    }
+    if ( cCust )
+    {
+        rCustomizations = new Customization[ cCust ];
+        for ( sal_Int32 index = 0; index < cCust; ++index )
+        {
+            if ( !rCustomizations[ index ].Read( pS ) )
+                return false;
+        } 
+    } 
+    OSL_TRACE("Cheating debug, call Print directly 'cause its not tied into the top level classes yet" );
+    Print( stderr );
+    return true;
+}
+
+void CTBWrapper::Print( FILE* fp )
+{
+    fprintf(fp,"CTBWrapper - dump\n");
+    bool bRes = ( ch == 0x12 && reserved2 == 0x0 && reserved3 == 0x7 && reserved4 == 0x6 && reserved5 == 0xC );
+    if ( bRes )
+        fprintf(fp,"  sanity check ( first 8 bytes conform )\n");
+    else 
+    {
+        fprintf(fp,"    reserved1(0x%x)\n",ch);
+        fprintf(fp,"    reserved2(0x%x)\n",reserved2);
+        fprintf(fp,"    reserved3(0x%x)\n",reserved3);
+        fprintf(fp,"    reserved4(0x%x)\n",reserved4);
+        fprintf(fp,"    reserved5(0x%x)\n",reserved5);
+        fprintf(fp,"Quiting dump");
+        return;
+    }
+    fprintf(fp,"  cbTBD: no. of TBDelta structures ( skipped if present ) 0x%x\n", cbTBD );
+    fprintf(fp,"  cCust: no. of cCust structures 0x%x\n",cCust);
+    fprintf(fp,"  cbDTBC: no. of bytes in rtbdc array 0x%x\n",cbDTBC);
+    fprintf(fp,"  .... skipping rtbdc\n");
+    if ( rCustomizations )
+        rCustomizations->Print( fp );
+}
+Customization::Customization() : tbidForTBD( 0 )
+,reserved1( 0 )
+, ctbds( 0 )
+, customizationDataCTB( 0 )
+, customizationDataTBDelta( 0 )
+{
+}
+
+Customization::~Customization()
+{
+    if ( customizationDataCTB )
+        delete [] customizationDataCTB;
+/* we don't read TBDelta structures yet
+    if ( customizationDataTBDelta )
+        delete [] customizationDataTBDelta;
+*/
+}
+
+bool Customization::Read( SotStorageStream *pS)
+{
+    *pS >> tbidForTBD >> reserved1 >> ctbds;
+    if ( tbidForTBD ) //TBDelta - which we don't read yet
+        return false;
+    if ( ctbds )
+    {
+        customizationDataCTB = new CTB[ ctbds ];
+        for ( sal_Int32 index=0; index < ctbds; ++index )
+        {
+            if ( !customizationDataCTB[ index ].Read( pS ) )
+                return false;
+        }
+    }
+    return true;
+}
+
+TBDelta::TBDelta() : doprfatendFlags(0)
+,ibts(0)
+,cidNext(0)
+,cid(0)
+,fc(0)
+,cbTBC(0)
+{
+}
+
+bool TBDelta::Read(SotStorageStream *pS)
+{
+    *pS >> doprfatendFlags >> ibts >> cidNext >> cid >> fc ;
+    pS->Read( CiTBDE, sizeof( CiTBDE ) );
+    *pS >> cbTBC;
+    return true;
+}
+
+CTB::CTB() : cbTBData( 0 )
+,tb( 0 )
+,iWCTBl( 0 )
+,reserved( 0 )
+,unused( 0 )
+,cCtls( 0 )
+,rTBC( 0 )
+{
+}
+
+CTB::~CTB()
+{
+    if ( tb )
+        delete [] tb;
+    if ( rTBC )
+        delete [] rTBC;
+}
+
+bool CTB::Read( SotStorageStream *pS)
+{
+
+    if ( !name.Read( pS ) )
+        return false;
+    *pS >> cbTBData;
+    sal_Int32 nTBSize = cbTBData - sizeof(rVisualData) - 12;
+    if  ( nTBSize ) 
+        tb = new sal_uInt8[ nTBSize ];
+    pS->Read( &rVisualData, sizeof( rVisualData ) );
+
+    *pS >> iWCTBl >> reserved >> unused >> cCtls;
+    
+    if ( cCtls )
+    {
+        rTBC = new TBC[ cCtls ];
+        for ( sal_Int32 index = 0; index < cCtls; ++index )
+        {
+            if ( !rTBC[ index ].Read( pS ) )
+                return false;
+        }
+    }
+    return true;
+}
+
+TBC::TBC() : cid( 0 )
+{
+}
+
+TBC::~TBC()
+{
+    if ( cid )
+        delete cid;
+}
+
+bool TBC::Read( SotStorageStream *pS )
+{
+    if ( !tbch.Read( pS ) )
+        return false;
+    if ( tbch.tcid != 0x1 && tbch.tcid != 0x1051 )
+    {
+        cid = new sal_uInt32;
+        *pS >> *cid;
+    }
+    // MUST exist if tbch.tct is not equal to 0x16
+    if ( tbch.tct != 0x16 )
+    {
+        tbcd.reset(  new TBCData() );
+        if ( !tbcd->Read( pS ) )
+            return false;
+    }
+    return true;
+}
+
+TBCHeader::TBCHeader() : bSignature( 0x3 )
+,bVersion( 0x01 )
+,bFlagsTCR( 0 )
+,tct(0x1) // default to Button
+,tcid(0)
+,tbct(0)
+,width(NULL)
+,height(NULL)
+{
+}
+
+
+TBCHeader::~TBCHeader()
+{
+    if ( width )
+        delete width;
+    if ( height )
+        delete height;
+}
+
+bool TBCHeader::Read( SotStorageStream* pS )
+{
+    *pS >> bSignature >> bVersion >> bFlagsTCR >> tct >> tcid >> tbct >> bPriority;
+    //  bit 4 ( from lsb ) 
+    if ( bFlagsTCR & 0x10 )
+    {
+        width = new sal_uInt16;
+        height = new sal_uInt16;
+        *pS >> *width >> *height;
+    }
+    return true;
+}
+
+
+bool TBCData::Read(SotStorageStream *pS)
+{
+    if ( !controlGeneralInfo.Read(pS) /*|| !controlSpecificInfo.Read(pS)*/ )
+        return false;
+    return true;
+}
+
+bool
+WString::Read( SotStorageStream *pS )
+{
+    sal_Int8 nChars = 0;
+    *pS >> nChars;
+    sString = readUnicodeString( pS, static_cast< sal_Int32 >( nChars  ) );
+    return true;
+}
+
+bool 
+Xst::Read( SotStorageStream* pS )
+{
+    sal_Int16 nChars = 0;
+    *pS >> nChars;
+    sString = readUnicodeString( pS, static_cast< sal_Int32 >( nChars  ) );
+    return true;
+}
+
+TBCExtraInfo::TBCExtraInfo() : idHelpContext( 0 )
+{
+}
+
+bool
+TBCExtraInfo::Read( SotStorageStream *pS )
+{
+    if( !wstrHelpFile.Read( pS )  )
+        return false;
+
+    *pS >> idHelpContext;
+
+    if ( !wstrTag.Read( pS ) || !wstrOnAction.Read( pS ) || !wstrParam.Read( pS ) )
+        return false;
+
+    *pS >> tbcu >> tbmg;    
+    return true;
+}
+
+TBCGeneralInfo::TBCGeneralInfo() : bFlags( 0 )
+{
+}
+
+bool TBCGeneralInfo::Read( SotStorageStream *pS )
+{
+    *pS >> bFlags;
+    if ( !customText.Read( pS ) || !descriptionText.Read( pS ) || !tooltip.Read( pS )
+    || extraInfo.Read( pS ) )
+        return false;
+    return true;
+}
+
+TBCSpecific::TBCSpecific() : bFlags( 0 )
+{
+}
+
+bool TBCSpecific::Read( SotStorageStream *pS)
+{
+    *pS >> bFlags;
+
+    // bFlags determines what we read next
+
+    // bFlags.fCustomBitmap = 1 ( 0x8 ) set 
+    if ( bFlags & 0x8 )
+    {
+        icon.reset( new TBCBitMap() );
+        iconMask.reset( new TBCBitMap() );
+        if ( !icon->Read( pS ) || !iconMask->Read( pS ) )
+            return false;
+    }
+    // if bFlags.fCustomBtnFace = 1 ( 0x10 )
+    if ( bFlags & 0x10 )
+    {
+        iBtnFace.reset( new sal_uInt16 );
+        *pS >> *iBtnFace.get();
+    }
+    // if bFlags.fAccelerator equals 1 ( 0x04 )
+    if ( bFlags & 0x04 )
+    {
+        wstrAcc.reset( new WString() );
+        return wstrAcc->Read( pS );
+    }
+    return true;
+}
+
+TBCBitMap::TBCBitMap() : cbDIB( 0 ), pRestOfIt( NULL )
+{
+}
+
+TBCBitMap::~TBCBitMap()
+{
+    if ( pRestOfIt )
+        delete [] pRestOfIt;
+}
+
+bool TBCBitMap::Read( SotStorageStream* pS)
+{
+    *pS >> cbDIB;
+    // cbDIB = sizeOf(biHeader) + sizeOf(colors) + sizeOf(bitmapData) + 10
+    // slurp the rest of the structure as a blob ( we'll get to it later )
+
+    pRestOfIt = new sal_uInt8[ cbDIB - 10 ];
+    pS->Read( pRestOfIt, sizeof( pRestOfIt ) );
+    return true;
+}
+
+Tcg::Tcg() : nTcgVer( 255 )
+{
+}
+
+bool Tcg::Read(SotStorageStream *pS)
+{
+    *pS >> nTcgVer;
+    if ( nTcgVer != (sal_Int8)255 )
+        return false;
+    tcg.reset( new Tcg255() );
+    return tcg->Read( pS );
+}
+
+void Tcg::Print( FILE* fp )
+{
+  //  fprint(" 
+}
+
+Tcg255::Tcg255()
+{
+}
+
+Tcg255::~Tcg255()
+{
+    std::vector< Tcg255SubStruct* >::iterator it = rgtcgData.begin();
+    for ( ; it != rgtcgData.end(); ++it )
+        delete *it;
+}
+
+bool Tcg255::processSubStruct( sal_uInt8 nId, SotStorageStream *pS )
+{
+     Tcg255SubStruct* pSubStruct = NULL;
+     switch ( nId )
+     {
+         case 0x1:
+         {
+             pSubStruct = new PlfMcd( false ); // don't read the id
+             break;
+         }
+         case 0x2: 
+         {
+             pSubStruct = new PlfAcd( false );
+             break;
+         }
+         case 0x3: 
+         case 0x4: 
+         {
+             pSubStruct = new PlfKme( false );
+             break;
+         }
+         case 0x10: 
+         {
+             pSubStruct = new TcgSttbf( false );
+             break;
+         }
+         case 0x11: 
+         {
+             pSubStruct = new MacroNames( false );
+             break;
+         }
+         case 0x12: 
+         {
+             pSubStruct = new CTBWrapper( false );
+             break;
+         }
+         default:
+             OSL_TRACE("Unknown id 0x%x",nId);
+             return false;
+    }
+    pSubStruct->ch = nId;
+    if ( !pSubStruct->Read( pS ) )
+        return false;
+    rgtcgData.push_back( pSubStruct );
+    return true;
+}
+
+bool Tcg255::Read(SotStorageStream *pS)
+{
+    sal_uInt8 nId = 0; // 
+    *pS >> nId;
+    while (  nId != 0x40  )
+    {
+        if ( !processSubStruct( nId, pS ) )
+            return false;
+        *pS >> nId;
+    } 
+    return true;
+    // Peek at  
+}
+
+Tcg255SubStruct::Tcg255SubStruct( bool bReadId ) : mbReadId( bReadId ), ch(0)
+{
+}
+
+bool Tcg255SubStruct::Read(SotStorageStream *pS)
+{
+    if ( mbReadId )
+        *pS >> ch;
+    return true;
+}
+
+PlfMcd::PlfMcd( bool bReadId ): Tcg255SubStruct( bReadId ), rgmcd( NULL )
+{
+}
+PlfMcd::~PlfMcd()
+{
+    if ( rgmcd )
+        delete[] rgmcd;
+}
+
+bool PlfMcd::Read(SotStorageStream *pS)
+{
+    Tcg255SubStruct::Read( pS );
+    *pS >> iMac;
+    if ( iMac )
+    { 
+        rgmcd = new MCD[ iMac ];
+        for ( sal_Int32 index; index < iMac; ++index )
+        {
+            if ( !rgmcd[ index ].Read( pS ) )
+                return false; 
+        } 
+    }
+    return true;
+}
+
+PlfAcd::PlfAcd( bool bReadId ) : Tcg255SubStruct( bReadId )
+,iMac(0)
+,rgacd(NULL)
+{
+}
+
+
+PlfAcd::~PlfAcd()
+{
+    if ( rgacd )
+        delete[] rgacd;
+}
+
+bool PlfAcd::Read( SotStorageStream *pS)
+{
+    Tcg255SubStruct::Read( pS );
+    *pS >> iMac;
+    if ( iMac )
+    {
+        rgacd = new Acd[ iMac ];
+        for ( sal_Int32 index = 0; index < iMac; ++index )
+        {
+            if ( !rgacd[ index ].Read( pS ) ) 
+                return false;
+        }
+    }
+    return true;
+}
+
+PlfKme::PlfKme( bool bReadId ) : Tcg255SubStruct( bReadId )
+,iMac( 0 )
+,rgkme( NULL )
+{
+}
+
+PlfKme::~PlfKme()
+{
+    if ( rgkme )
+        delete[] rgkme;
+}
+
+bool PlfKme::Read(SotStorageStream *pS)
+{
+    Tcg255SubStruct::Read( pS );
+    *pS >> iMac;
+    if ( iMac )
+    {
+        rgkme = new Kme[ iMac ];
+        for( sal_Int32 index=0; index<iMac; ++index )
+        {
+            if ( !rgkme[ index ].Read( pS ) )
+                return false;
+        }
+    }
+    return true;
+}
+
+TcgSttbf::TcgSttbf( bool bReadId ) : Tcg255SubStruct( bReadId )
+{
+}
+
+bool TcgSttbf::Read( SotStorageStream *pS) 
+{
+    Tcg255SubStruct::Read( pS );
+    return sttbf.Read( pS );
+}
+
+TcgSttbfCore::TcgSttbfCore() : fExtend( 0 )
+,cData( 0 )
+,cbExtra( 0 )
+,dataItems( NULL )
+{
+}
+
+TcgSttbfCore::~TcgSttbfCore()
+{
+    if ( dataItems )
+        delete[] dataItems;
+}
+
+bool TcgSttbfCore::Read( SotStorageStream* pS )
+{
+    *pS >> fExtend >> cData >> cbExtra;
+    if ( cData )
+    {
+        dataItems = new SBBItem[ cData ];
+        for ( sal_Int32 index = 0; index < cData; ++index )
+        {
+            *pS >> dataItems[ index ].cchData;
+            dataItems[ index ].data = readUnicodeString( pS, dataItems[ index ].cchData );
+            *pS >> dataItems[ index ].extraData;
+        }
+    }
+    return true;
+}
+
+MacroNames::MacroNames( bool bReadId ) : Tcg255SubStruct( bReadId )
+,iMac( 0 )
+,rgNames( NULL )
+{
+}
+
+MacroNames::~MacroNames()
+{
+    if ( rgNames )
+        delete[] rgNames;
+}
+
+bool MacroNames::Read( SotStorageStream *pS)
+{
+    Tcg255SubStruct::Read( pS );
+    *pS >> iMac;
+    if ( iMac )
+    {
+        rgNames = new MacroName[ iMac ]; 
+        for ( sal_Int32 index = 0; index < 0; ++index )
+        {
+            if ( !rgNames[ index ].Read( pS ) )
+                return false;
+        }
+    }
+    return true;
+}
+
+MacroName::MacroName():ibst(0)
+{
+}
+
+bool MacroName::Read(SotStorageStream *pS)
+{
+    *pS >> ibst;
+    return xstz.Read( pS );
+}
+
+Xstz::Xstz():chTerm(0)
+{
+}
+
+bool 
+Xstz::Read(SotStorageStream *pS)
+{
+    if ( !xst.Read( pS ) )
+        return false;
+    *pS >> chTerm;
+    if ( chTerm != 0 ) // should be an assert 
+        return false;
+    return true;
+}
+
+Kme::Kme() : reserved1(0)
+,reserved2(0)
+,kcm1(0)
+,kcm2(0)
+,kt(0)
+,param(0)
+{
+}
+
+Kme::~Kme()
+{
+}
+
+bool
+Kme::Read(SotStorageStream *pS)
+{
+    *pS >> reserved1 >> reserved2 >> kcm1 >> kcm2 >> param;
+    return true;
+}
+
+Acd::Acd() : ibst( 0 )
+, fciBasedOnABC( 0 )
+{
+}
+
+bool Acd::Read(SotStorageStream *pS)
+{
+    *pS >> ibst >> fciBasedOnABC;
+    return true;
+}
+
+MCD::MCD() :  reserved1(0x56)
+,reserved2( 0 )
+,ibst( 0 )
+,ibstName( 0 )
+,reserved3( 0xFFFF )
+,reserved4( 0 )
+,reserved5( 0 )
+,reserved6( 0 )
+,reserved7( 0 )
+{
+}
+
+bool  MCD::Read(SotStorageStream *pS)
+{
+    *pS >> reserved1 >> reserved2 >> ibst >> ibstName >> reserved3 >> 
+    *pS >> reserved4 >> reserved5 >> reserved6 >> reserved7;
+    return true;
+}
