--- /dev/null	2008-06-06 20:39:59.000000000 +0100
+++ sw/source/filter/ww8/ww8toolbar.hxx	2009-01-26 17:22:40.000000000 +0000
@@ -0,0 +1,210 @@
+#ifndef _WW8TOOLBAR_HXX
+#define _WW8TOOLBAR_HXX
+
+#include <tools/string.hxx>
+#include <sot/storage.hxx>
+#include <ostream>
+#include <memory>
+
+class TBBase
+{
+public:
+    virtual ~TBBase(){}
+    virtual bool Read(SotStorageStream *pS) = 0;
+//    virtual Print( ostream& ) = 0; // for debugging
+    virtual void Print( std::ostream& ) {} // #FIXME remove this an implement the debug routines in all the classes below to enable some sort of readable output
+};
+
+class Xst : public TBBase
+{
+    rtl::OUString sString;
+public:
+    Xst();
+    bool Read(SotStorageStream *pS);
+    rtl::OUString getString() { return sString; }
+};
+
+class WString : public TBBase
+{
+    rtl::OUString sString;
+
+    WString(const WString&);
+    WString& operator = ( const WString&);
+public:
+    WString(){};
+    ~WString(){};
+    bool Read(SotStorageStream *pS);
+    rtl::OUString getString(){ return sString; }
+};
+
+class TBCExtraInfo : public TBBase
+{
+    WString wstrHelpFile;
+    sal_Int32 idHelpContext;
+    WString wstrTag;
+    WString wstrOnAction;
+    WString wstrParam;
+    sal_Int8 tbcu;
+    sal_Int8 tbmg;
+
+    TBCExtraInfo(const TBCExtraInfo&);
+    TBCExtraInfo& operator = ( const TBCExtraInfo&);
+public:
+    TBCExtraInfo();
+    ~TBCExtraInfo(){}
+    bool Read(SotStorageStream *pS);
+};
+
+class TBCGeneralInfo  : public TBBase
+{
+    sal_Int8 bFlags;
+    WString customText;
+    WString descriptionText;
+    WString tooltip;
+    TBCExtraInfo extraInfo;
+
+    TBCGeneralInfo(const TBCGeneralInfo&);
+    TBCGeneralInfo& operator = ( const TBCGeneralInfo&);
+public:
+    TBCGeneralInfo();
+    ~TBCGeneralInfo() {}
+    bool Read(SotStorageStream *pS);
+};
+
+class TBCBitMap : public TBBase
+{
+    sal_Int32 cbDIB;
+//    BITMapInfoHeader biHeader;  // lets cheat and not read the bit map stuff right now
+    sal_Int8* pRestOfIt;
+    TBCBitMap(const TBCBitMap&);
+    TBCBitMap& operator = ( const TBCBitMap&);
+public:
+    TBCBitMap();
+    ~TBCBitMap();
+    bool Read(SotStorageStream *pS);
+};
+
+class TBCSpecific :  public TBBase
+{
+    sal_Int8 bFlags;
+    std::auto_ptr< TBCBitMap > icon; // optional
+    std::auto_ptr< TBCBitMap > iconMask; // optional
+    std::auto_ptr< sal_Int16 > iBtnFace; // optional
+    std::auto_ptr< WString > wstrAcc; // optional
+   
+    TBCSpecific(const TBCSpecific&);
+    TBCSpecific& operator = ( const TBCSpecific&);
+public:
+    TBCSpecific();
+    ~TBCSpecific(){}
+    bool Read(SotStorageStream *pS);
+};
+
+class TBCData : public TBBase
+{
+    TBCGeneralInfo controlGeneralInfo;
+    TBCSpecific controlSpecificInfo; // can be one of TBCSpecific, TBCMenuSpecific or TBCComboDropdow nSpecific depending on the control type specified by TBCHeader.tct ( initially lets just implement TBCSpecific 
+    TBCData(const TBCData&);
+    TBCData& operator = ( const TBCData&);
+public:
+    TBCData(){}
+    ~TBCData(){}
+    bool Read(SotStorageStream *pS);
+};
+
+class TBCHeader : public TBBase
+{
+friend class TBC;
+    sal_Int8 bSignature; 
+    sal_Int8 bVersion; 
+    sal_Int8 bFlagsTCR; 
+    sal_Int8 tct; 
+    sal_Int16 tcid;
+    sal_Int32 tbct;
+    sal_Int8 bPriority;
+    sal_Int16* width;  //optional
+    sal_Int16* height; //optional
+
+    TBCHeader(const TBCHeader&);
+    TBCHeader& operator = ( const TBCHeader&);
+public:
+    TBCHeader();
+    ~TBCHeader();
+    bool Read(SotStorageStream *pS);
+};
+
+class TBC : public TBBase
+{
+    TBCHeader tbch;
+    sal_Int32* cid; // optional
+    TBCData tbcd;
+    TBC(const TBC&);
+    TBC& operator = ( const TBC&);
+public:
+    TBC();
+    ~TBC();
+    bool Read(SotStorageStream *pS);
+};
+class CTB : public TBBase
+{
+    Xst name;
+    sal_Int32 cbTBData;
+    sal_Int8* tb; // array of toolbar data ( currently not read )
+    sal_Int8 rVisualData[ 100 ];
+    sal_Int32 iWCTBl;
+    sal_Int16 reserved;
+    sal_Int16 unused;
+    sal_Int32 cCtls;
+    TBC* rTBC; // more unread data TBC structures
+
+    CTB(const CTB&);
+    CTB& operator = ( const CTB&);
+public:
+    CTB();
+    ~CTB();
+    bool Read(SotStorageStream *pS);
+};
+
+class TBDelta;
+class Customization : public TBBase
+{
+    sal_Int32 tbidForTBD;
+    sal_Int16 reserved1;
+    sal_Int16 ctbds;
+
+    CTB* customizationDataCTB;
+    TBDelta* customizationDataTBDelta; // we don't read these yet
+    
+    Customization(const Customization&);
+    Customization& operator = ( const Customization&);
+public:    
+    Customization();
+    ~Customization();
+    bool Read(SotStorageStream *pS);
+};
+
+class CTBWrapper : public TBBase
+{
+    sal_Int8 reserved1;
+    sal_Int16 reserved2;
+    sal_Int8 reserved3;
+    sal_Int16 reserved4;
+    sal_Int16 reserved5;
+
+    sal_Int16 cbTBD;
+    sal_Int16 cCust;
+
+    sal_Int32 cbDTBC;
+
+    sal_Int8* rtbdc; // array of TBC's - we don't read these yet 
+    Customization* rCustomizations; // array of Customizations
+
+    CTBWrapper(const CTBWrapper&);
+    CTBWrapper& operator = ( const CTBWrapper&);
+public:
+    CTBWrapper();
+    ~CTBWrapper();
+    bool Read(SotStorageStream *pS);
+
+};
+#endif
--- /dev/null	2008-06-06 20:39:59.000000000 +0100
+++ sw/source/filter/ww8/ww8toolbar.cxx	2009-01-26 17:23:27.000000000 +0000
@@ -0,0 +1,293 @@
+#include "ww8toolbar.hxx"
+#include <rtl/ustrbuf.hxx>
+
+rtl::OUString readUnicodeString( SotStorageStream* pS, sal_Int32 nChars )
+{
+    rtl::OUStringBuffer buf(40);
+    for ( sal_Int32 index = 0; index < nChars; ++index )
+    {
+        sal_uInt16 ch = 0;
+        *pS >> ch;
+        sal_Unicode uni = static_cast< sal_Unicode >( ch );
+        buf.append( &uni, 1 );
+    }
+    return buf.makeStringAndClear();
+}
+
+CTBWrapper::CTBWrapper() : reserved1(0)
+,reserved2(0)
+,reserved3(0)
+,reserved4(0)
+,reserved5(0)
+,cbTBD(0)
+,cCust(0)
+,cbDTBC(0)
+,rtbdc(0)
+,rCustomizations(0)
+{
+}
+
+CTBWrapper::~CTBWrapper()
+{
+    if ( rtbdc )
+        delete [] rtbdc; 
+    if ( rCustomizations )
+        delete [] rCustomizations; 
+}
+
+bool CTBWrapper::Read( SotStorageStream* pS )
+{
+
+    *pS >> reserved1 >> reserved2 >> reserved3 >> reserved4 >> reserved5;
+    *pS >> cbTBD >> cCust >> cbDTBC;
+    if ( cbDTBC )
+        return false; // currently we only try to read custom toolbars
+    if ( cCust )
+    {
+        rCustomizations = new Customization[ cCust ];
+        for ( sal_Int32 index = 0; index < cCust; ++index )
+        {
+            if ( !rCustomizations[ index ].Read( pS ) )
+                return false;
+        } 
+    } 
+    return true;
+}
+
+Customization::Customization() : tbidForTBD( 0 )
+,reserved1( 0 )
+, ctbds( 0 )
+, customizationDataCTB( 0 )
+, customizationDataTBDelta( 0 )
+{
+}
+
+Customization::~Customization()
+{
+    if ( customizationDataCTB )
+        delete [] customizationDataCTB;
+/* we don't read TBDelta structures yet
+    if ( customizationDataTBDelta )
+        delete [] customizationDataTBDelta;
+*/
+}
+
+bool Customization::Read( SotStorageStream *pS)
+{
+    *pS >> tbidForTBD >> reserved1 >> ctbds;
+    if ( !tbidForTBD ) //TBDelta - which we don't read yet
+        return false;
+    if ( ctbds )
+    {
+        customizationDataCTB = new CTB[ ctbds ];
+        for ( sal_Int32 index=0; index < ctbds; ++index )
+        {
+            if ( !customizationDataCTB[ index ].Read( pS ) )
+                return false;
+        }
+    }
+    return true;
+}
+
+CTB::CTB() : cbTBData( 0 )
+,tb( 0 )
+,iWCTBl( 0 )
+,reserved( 0 )
+,unused( 0 )
+,cCtls( 0 )
+,rTBC( 0 )
+{
+}
+
+CTB::~CTB()
+{
+    if ( tb )
+        delete [] tb;
+    if ( rTBC )
+        delete [] rTBC;
+}
+
+bool CTB::Read( SotStorageStream *pS)
+{
+
+    if ( !name.Read( pS ) )
+        return false;
+    *pS >> cbTBData;
+    sal_Int32 nTBSize = cbTBData - sizeof(rVisualData) - 12;
+    if  ( nTBSize ) 
+        tb = new sal_Int8[ nTBSize ];
+    pS->Read( &rVisualData, sizeof( rVisualData ) );
+
+    *pS >> iWCTBl >> reserved >> unused >> cCtls;
+    
+    if ( cCtls )
+    {
+        rTBC = new TBC[ cCtls ];
+        for ( sal_Int32 index = 0; index < cCtls; ++index )
+        {
+            if ( !rTBC[ index ].Read( pS ) )
+                return false;
+        }
+    }
+    return true;
+}
+
+TBC::TBC() : cid( 0 )
+{
+}
+
+TBC::~TBC()
+{
+    if ( cid )
+        delete cid;
+}
+
+bool TBC::Read( SotStorageStream *pS )
+{
+    if ( !tbch.Read( pS ) )
+        return false;
+    if ( tbch.tcid != 0x1 && tbch.tcid != 0x1051 )
+    {
+        cid = new sal_Int32;
+        *pS >> *cid;
+    }
+    if ( !tbcd.Read( pS ) )
+        return false;
+    return true;
+}
+
+TBCHeader::TBCHeader() : bSignature( 0x3 )
+,bVersion( 0x01 )
+,bFlagsTCR( 0 )
+,tct(0x1) // default to Button
+,tcid(0)
+,tbct(0)
+,width(NULL)
+,height(NULL)
+{
+}
+
+
+TBCHeader::~TBCHeader()
+{
+    if ( width )
+        delete width;
+    if ( height )
+        delete height;
+}
+
+bool TBCHeader::Read( SotStorageStream* pS )
+{
+    *pS >> bSignature >> bVersion >> bFlagsTCR >> tct >> tcid >> tbct >> bPriority;
+    //  bit 4 ( from lsb ) 
+    if ( bFlagsTCR & 0x10 )
+    {
+        width = new sal_Int16;
+        height = new sal_Int16;
+        *pS >> *width >> *height;
+    }
+    return true;
+}
+
+
+bool TBCData::Read(SotStorageStream *pS)
+{
+    if ( !controlGeneralInfo.Read(pS) /*|| !controlSpecificInfo.Read(pS)*/ )
+        return false;
+    return true;
+}
+
+bool
+WString::Read( SotStorageStream *pS )
+{
+    sal_Int8 nChars = 0;
+    *pS >> nChars;
+    sString = readUnicodeString( pS, static_cast< sal_Int32 >( nChars  ) );
+    return true;
+}
+
+TBCExtraInfo::TBCExtraInfo() : idHelpContext( 0 )
+{
+}
+
+bool
+TBCExtraInfo::Read( SotStorageStream *pS )
+{
+    if( !wstrHelpFile.Read( pS )  )
+        return false;
+
+    *pS >> idHelpContext;
+
+    if ( !wstrTag.Read( pS ) || !wstrOnAction.Read( pS ) || !wstrParam.Read( pS ) )
+        return false;
+
+    *pS >> tbcu >> tbmg;    
+    return true;
+}
+
+TBCGeneralInfo::TBCGeneralInfo() : bFlags( 0 )
+{
+}
+
+bool TBCGeneralInfo::Read( SotStorageStream *pS )
+{
+    *pS >> bFlags;
+    if ( !customText.Read( pS ) || !descriptionText.Read( pS ) || !tooltip.Read( pS )
+    || extraInfo.Read( pS ) )
+        return false;
+    return true;
+}
+
+TBCSpecific::TBCSpecific() : bFlags( 0 )
+{
+}
+
+bool TBCSpecific::Read( SotStorageStream *pS)
+{
+    *pS >> bFlags;
+
+    // bFlags determines what we read next
+
+    // bFlags.fCustomBitmap = 1 ( 0x8 ) set 
+    if ( bFlags & 0x8 )
+    {
+        icon.reset( new TBCBitMap() );
+        iconMask.reset( new TBCBitMap() );
+        if ( !icon->Read( pS ) || !iconMask->Read( pS ) )
+            return false;
+    }
+    // if bFlags.fCustomBtnFace = 1 ( 0x10 )
+    if ( bFlags & 0x10 )
+    {
+        iBtnFace.reset( new sal_Int16 );
+        *pS >> *iBtnFace.get();
+    }
+    // if bFlags.fAccelerator equals 1 ( 0x04 )
+    if ( bFlags & 0x04 )
+    {
+        wstrAcc.reset( new WString() );
+        return wstrAcc->Read( pS );
+    }
+    return true;
+}
+
+TBCBitMap::TBCBitMap() : cbDIB( 0 ), pRestOfIt( NULL )
+{
+}
+
+TBCBitMap::~TBCBitMap()
+{
+    if ( pRestOfIt )
+        delete [] pRestOfIt;
+}
+
+bool TBCBitMap::Read( SotStorageStream* pS)
+{
+    *pS >> cbDIB;
+    // cbDIB = sizeOf(biHeader) + sizeOf(colors) + sizeOf(bitmapData) + 10
+    // slurp the rest of the structure as a blob ( we'll get to it later )
+
+    pRestOfIt = new sal_Int8[ cbDIB - 10 ];
+    pS->Read( pRestOfIt, sizeof( pRestOfIt ) );
+    return true;
+}
diff --git sw/source/filter/ww8/makefile.mk sw/source/filter/ww8/makefile.mk
index 25cb969..95b12fb 100644
--- sw/source/filter/ww8/makefile.mk
+++ sw/source/filter/ww8/makefile.mk
@@ -95,7 +95,9 @@ SLOFILES =	\
 		$(SLO)$/writerhelper.obj \
 		$(SLO)$/writerwordglue.obj \
         $(SLO)$/WW8TableInfo.obj \
-        $(SLO)$/WW8FFData.obj
+        $(SLO)$/WW8FFData.obj \
+        $(SLO)$/ww8toolbar.obj \
+
 
 
 # --- Tagets -------------------------------------------------------
