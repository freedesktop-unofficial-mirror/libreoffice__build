diff --git sw/source/filter/ww8/makefile.mk sw/source/filter/ww8/makefile.mk
index 25cb969..95b12fb 100644
--- sw/source/filter/ww8/makefile.mk
+++ sw/source/filter/ww8/makefile.mk
@@ -95,7 +95,9 @@ SLOFILES =	\
 		$(SLO)$/writerhelper.obj \
 		$(SLO)$/writerwordglue.obj \
         $(SLO)$/WW8TableInfo.obj \
-        $(SLO)$/WW8FFData.obj
+        $(SLO)$/WW8FFData.obj \
+        $(SLO)$/ww8toolbar.obj \
+
 
 
 # --- Tagets -------------------------------------------------------
diff --git sw/source/filter/ww8/ww8par.cxx sw/source/filter/ww8/ww8par.cxx
index a7f122b..d1a582c 100644
--- sw/source/filter/ww8/ww8par.cxx
+++ sw/source/filter/ww8/ww8par.cxx
@@ -142,11 +142,12 @@
 #include <stdio.h>
 #include <comphelper/processfactory.hxx>
 #include <basic/basmgr.hxx>
-
 #ifdef DEBUG
 #include <iostream>
 #include <dbgoutsw.hxx>
 #endif 
+#include <fstream>
+#include "ww8toolbar.hxx"
 
 #define MM_250 1417             // WW-Default fuer Hor. Seitenraender: 2.5 cm
 #define MM_200 1134             // WW-Default fuer u.Seitenrand: 2.0 cm
@@ -4173,7 +4174,37 @@ ULONG SwWW8ImplReader::SetSubStreams(SvStorageStreamRef &rTableStream,
             rTableStream = pStg->OpenSotStream( String::CreateFromAscii(
                 pWwFib->fWhichTblStm ? SL::a1Table : SL::a0Table),
                 STREAM_STD_READ);
+#if 1
+            if ( pWwFib->fWhichTblStm )
+            {
+// dump a1Table stream here !!!
+            OSL_TRACE("About to dump 1table ");
+                long nCur = rTableStream->Tell();
+                std::ofstream fDump( "1Table.dump" );
+                
+                while ( !rTableStream->IsEof() )
+                {
+                    sal_uInt8 aByte;
+                    *rTableStream >> aByte;
+                    fDump << aByte;
+                }
+
+                rTableStream->Seek( nCur );  // restore stream pointer
 
+// attempt to read where the offset to the Customizations is (
+// also we should be able to find the offset to the macro table too
+                if ( pWwFib->lcbCmds )
+                {
+                    // there is a tgc255 structure
+                    OSL_TRACE(" tgc255 has offset 0x%x with length 0x%x", pWwFib->fcCmds, pWwFib->lcbCmds );
+                    Tcg aTCG;
+                    rTableStream->Seek( pWwFib->fcCmds ); // point at tgc record
+                    aTCG.Read( rTableStream );
+                    rTableStream->Seek( nCur ); // return to previous position
+                    aTCG.Print( stderr );
+                }
+            }
+#endif
             pTableStream = &rTableStream;
             pTableStream->SetNumberFormatInt( NUMBERFORMAT_INT_LITTLEENDIAN );
 
--- /dev/null	2008-04-22 00:28:44.000000000 +0100
+++ sw/source/filter/ww8/ww8toolbar.hxx	2009-01-29 17:40:04.000000000 +0000
@@ -0,0 +1,489 @@
+#ifndef _WW8TOOLBAR_HXX
+#define _WW8TOOLBAR_HXX
+
+#include <tools/string.hxx>
+#include <sot/storage.hxx>
+#include <ostream>
+#include <memory>
+#include <vector>
+
+class TBBase
+{
+public:
+    virtual ~TBBase(){}
+    virtual bool Read(SotStorageStream *pS) = 0;
+    virtual void Print( FILE* ) {} // #FIXME remove this an implement the debug routines in all the classes below to enable some sort of readable output
+};
+
+class Xst : public TBBase
+{
+    rtl::OUString sString;
+public:
+    Xst(){}
+    bool Read(SotStorageStream *pS);
+    rtl::OUString getString() { return sString; }
+    void Print( FILE* fp );
+};
+
+class WString : public TBBase
+{
+    rtl::OUString sString;
+
+    WString(const WString&);
+    WString& operator = ( const WString&);
+public:
+    WString(){};
+    ~WString(){};
+    bool Read(SotStorageStream *pS);
+    rtl::OUString getString(){ return sString; }
+};
+
+class TBCExtraInfo : public TBBase
+{
+    WString wstrHelpFile;
+    sal_Int32 idHelpContext;
+    WString wstrTag;
+    WString wstrOnAction;
+    WString wstrParam;
+    sal_Int8 tbcu;
+    sal_Int8 tbmg;
+
+    TBCExtraInfo(const TBCExtraInfo&);
+    TBCExtraInfo& operator = ( const TBCExtraInfo&);
+public:
+    TBCExtraInfo();
+    ~TBCExtraInfo(){}
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class TBCGeneralInfo  : public TBBase
+{
+    sal_uInt8 bFlags;
+    WString customText;
+    WString descriptionText;
+    WString tooltip;
+    TBCExtraInfo extraInfo;
+
+    TBCGeneralInfo(const TBCGeneralInfo&);
+    TBCGeneralInfo& operator = ( const TBCGeneralInfo&);
+public:
+    TBCGeneralInfo();
+    ~TBCGeneralInfo() {}
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class TBCBitMap : public TBBase
+{
+friend class TBCSpecific; // #FIXME hacky access, need to fix
+    sal_Int32 cbDIB;
+//    BITMapInfoHeader biHeader;  // lets cheat and not read the bit map stuff right now
+    sal_uInt8* pRestOfIt;
+    TBCBitMap(const TBCBitMap&);
+    TBCBitMap& operator = ( const TBCBitMap&);
+public:
+    TBCBitMap();
+    ~TBCBitMap();
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class TBCSpecific :  public TBBase
+{
+    sal_uInt8 bFlags;
+    std::auto_ptr< TBCBitMap > icon; // optional
+    std::auto_ptr< TBCBitMap > iconMask; // optional
+    std::auto_ptr< sal_uInt16 > iBtnFace; // optional
+    std::auto_ptr< WString > wstrAcc; // optional
+   
+    TBCSpecific(const TBCSpecific&);
+    TBCSpecific& operator = ( const TBCSpecific&);
+public:
+    TBCSpecific();
+    ~TBCSpecific(){}
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+/* TBCHeader.tct                   controlSpecificInfo type
+
+0x01 (Button control)              TBCBSpecific
+0x10 (ExpandingGrid control)       TBCBSpecific
+0x0A (Popup control)               TBCMenuSpecific
+0x0C (ButtonPopup control)         TBCMenuSpecific
+0x0D (SplitButtonPopup control)    TBCMenuSpecific
+0x0E (SplitButtonMRUPopup control) TBCMenuSpecific
+0x02 (Edit control)                TBCComboDropdow nSpecific
+0x04 (ComboBox control)            TBCComboDropdow nSpecific
+0x14 (GraphicCombo control)        TBCComboDropdow nSpecific
+0x03 (DropDown control)            TBCComboDropdow nSpecific
+0x06 (SplitDropDown control)       TBCComboDropdow nSpecific
+0x09 (GraphicDropDown control)     TBCComboDropdow nSpecific
+0x07 (OCXDropDown control)         controlSpecificInfo MUST NOT exist
+0x0F (Label control)               controlSpecificInfo MUST NOT exist
+0x12 (Grid control)                controlSpecificInfo MUST NOT exist
+0x13 (Gauge control)               controlSpecificInfo MUST NOT exist
+0x16 (ActiveX control)             controlSpecificInfo MUST NOT exist
+
+*/
+class TBCHeader;
+class TBCData : public TBBase
+{
+    const TBCHeader& rHeader;
+    TBCGeneralInfo controlGeneralInfo;
+    TBCSpecific controlSpecificInfo; // can be one of TBCSpecific, TBCMenuSpecific or TBCComboDropdow nSpecific depending on the control type specified by TBCHeader.tct ( initially lets just implement TBCSpecific 
+    TBCData(const TBCData&);
+    TBCData& operator = ( const TBCData&);
+public:
+    TBCData( const TBCHeader& Header ) : rHeader( Header ) {}
+    ~TBCData(){}
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class TBCHeader : public TBBase
+{
+friend class TBC;
+friend class TBCData;
+    sal_Int8 bSignature; 
+    sal_Int8 bVersion; 
+    sal_uInt8 bFlagsTCR; 
+    sal_uInt8 tct; 
+    sal_uInt16 tcid;
+    sal_uInt32 tbct;
+    sal_uInt8 bPriority;
+    sal_uInt16* width;  //optional
+    sal_uInt16* height; //optional
+
+    TBCHeader(const TBCHeader&);
+    TBCHeader& operator = ( const TBCHeader&);
+public:
+    TBCHeader();
+    ~TBCHeader();
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class TBC : public TBBase
+{
+    TBCHeader tbch;
+    sal_uInt32* cid; // optional
+    std::auto_ptr<TBCData> tbcd;
+    TBC(const TBC&);
+    TBC& operator = ( const TBC&);
+public:
+    TBC();
+    ~TBC();
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class TB : public TBBase
+{
+    sal_Int8 bSignature; //Signed integer that specifies the toolbar signature number. MUST be 0x02.
+    sal_Int8 bVersion; //Signed integer that specifies the toolbar version number. MUST be 0x01.
+    sal_Int16 cCL; //Signed integer that SHOULD  specify the number of toolbar controls contained in this toolbar.
+    sal_Int32 ltbid; //Signed integer that specifies the toolbar ID. MUST be 0x0001 (custom toolbar ID).
+    sal_uInt32 ltbtr; //Unsigned integer of type TBTRFlags that specifies the toolbar type and toolbar restrictions.
+    sal_uInt16 cRowsDefault; //Unsigned integer that specifies the number of preferred rows for the toolbar when the toolbar is not docked. MUST be less than or equal to 255.
+    sal_uInt16 bFlags; //Unsigned integer of type TBFlags.
+    WString name; //Structure of type WString that specifies the toolbar name.
+    TB(const TB&);
+    TB& operator = ( const TB&);
+public:
+    TB();
+    ~TB(){}
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class CTB : public TBBase
+{
+    Xst name;
+    sal_Int32 cbTBData;
+    TB tb; // array of toolbar data ( currently not read )
+    sal_uInt8 rVisualData[ 100 ];
+    sal_Int32 iWCTBl;
+    sal_uInt16 reserved;
+    sal_uInt16 unused;
+    sal_Int32 cCtls;
+    TBC* rTBC;
+
+    CTB(const CTB&);
+    CTB& operator = ( const CTB&);
+public:
+    CTB();
+    ~CTB();
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* fp );
+};
+
+class TBDelta : TBBase
+{
+    sal_uInt8 doprfatendFlags;
+    sal_uInt8 ibts;
+    sal_Int32 cidNext; 
+    sal_Int32 cid;
+    sal_Int32 fc;
+    sal_uInt8 CiTBDE[2]; // careful of this ( endian matters etc. )
+    sal_uInt16 cbTBC;
+    TBDelta(const TBDelta&);
+    TBDelta& operator = ( const TBDelta&);
+public:
+    TBDelta();
+    ~TBDelta(){}
+    bool Read(SotStorageStream *pS);
+};
+
+class Tcg255SubStruct : public TBBase
+{
+friend class Tcg255;
+    bool mbReadId;
+    Tcg255SubStruct(const Tcg255SubStruct&);
+    Tcg255SubStruct& operator = ( const Tcg255SubStruct&);
+protected:
+    sal_uInt8 ch;
+public:
+    Tcg255SubStruct( bool bReadId );
+    ~Tcg255SubStruct(){}
+    virtual sal_uInt8 id() { return ch; }
+    bool Read(SotStorageStream *pS);
+};
+
+class Customization : public TBBase
+{
+    sal_Int32 tbidForTBD;
+    sal_uInt16 reserved1;
+    sal_Int16 ctbds;
+
+    CTB* customizationDataCTB;
+    TBDelta* customizationDataTBDelta; // we don't read these yet
+    
+    Customization(const Customization&);
+    Customization& operator = ( const Customization&);
+public:    
+    Customization();
+    ~Customization();
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class CTBWrapper : public Tcg255SubStruct
+{
+    // reserved1 is the ch field of Tcg255SubStruct
+    sal_uInt16 reserved2;
+    sal_uInt8 reserved3;
+    sal_uInt16 reserved4;
+    sal_uInt16 reserved5;
+
+    sal_Int16 cbTBD;
+    sal_Int16 cCust;
+
+    sal_Int32 cbDTBC;
+
+    sal_uInt8* rtbdc; // array of TBC's - we don't read these yet 
+    Customization* rCustomizations; // array of Customizations
+
+    CTBWrapper(const CTBWrapper&);
+    CTBWrapper& operator = ( const CTBWrapper&);
+public:
+    CTBWrapper( bool bReadId = true );
+    ~CTBWrapper();
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class MCD : public TBBase
+{
+    sal_Int8 reserved1; //  A signed integer that MUST be 0x56. 
+    sal_uInt8 reserved2; // MUST be 0.
+    sal_uInt16 ibst; // Unsigned integer that specifies the name of the macro. Macro name is specified by MacroName.xstz of the MacroName entry in the MacroNames such that MacroName.ibst equals ibst. MacroNames MUST contain such an entry.
+    sal_uInt16 ibstName; // An unsigned integer that specifies the index into the Command String Table (TcgSttbf.sttbf) where the macro‘s name and arguments are specified.
+    sal_uInt16 reserved3; // An unsigned integer that MUST be 0xFFFF.
+    sal_uInt32 reserved4; //MUST be ignored. 
+    sal_uInt32 reserved5; //MUST be 0. 
+    sal_uInt32 reserved6; //MUST be ignored. 
+    sal_uInt32 reserved7; //MUST be ignored   
+
+    MCD(const MCD&);
+    MCD& operator = ( const MCD&);
+public:
+    MCD();
+    ~MCD(){}
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class PlfMcd : public Tcg255SubStruct
+{
+    sal_Int32 iMac;
+    MCD* rgmcd; // array of MCD's
+    PlfMcd(const PlfMcd&);
+    PlfMcd& operator = ( const PlfMcd&);
+public:
+    PlfMcd( bool bReadId = true );
+    ~PlfMcd();
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class Acd : public TBBase
+{
+    sal_Int16 ibst;
+    sal_uInt16 fciBasedOnABC; //  fciBasedOn(13 bits) A(1bit)B(1bit)C(1Bit)
+    Acd(const Acd&);
+    Acd& operator = ( const Acd&);
+public:
+    Acd();
+    ~Acd(){}
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class PlfAcd: public Tcg255SubStruct
+{
+    sal_Int32 iMac;
+    Acd* rgacd;
+    PlfAcd(const PlfAcd&);
+    PlfAcd& operator = ( const PlfAcd&);
+public:
+    PlfAcd( bool bReadId = true );
+    ~PlfAcd();
+    bool Read(SotStorageStream *pS);
+    void Print(FILE*);
+};
+
+class Kme : public TBBase
+{
+    sal_Int16 reserved1; //MUST be zero. 
+    sal_Int16 reserved2; //MUST be zero.
+    sal_uInt16 kcm1; //A Kcm that specifies the primary shortcut key.
+    sal_uInt16 kcm2; //A Kcm that specifies the secondary shortcut key, or 0x00FF if there is no secondary shortcut key.
+    sal_uInt16 kt; //A Kt that specifies the type of action to be taken when the key combination is pressed. 
+    sal_uInt32 param; //The meaning of this field depends on the value of kt
+
+    Kme(const Kme&);
+    Kme& operator = ( const Kme&);
+public:
+    Kme();
+    ~Kme();
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class PlfKme : public Tcg255SubStruct
+{
+    sal_Int32 iMac;
+    Kme* rgkme;
+    PlfKme(const PlfKme&);
+    PlfKme& operator = ( const PlfKme&);
+public:
+    PlfKme( bool bReadId = true );
+    ~PlfKme();
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class TcgSttbfCore : public TBBase
+{
+struct SBBItem
+{
+    sal_uInt16 cchData;
+    rtl::OUString data; 
+    sal_uInt16 extraData;
+    SBBItem() : cchData(0), extraData(0){}
+};
+    sal_uInt16 fExtend;
+    sal_uInt16 cData;
+    sal_uInt16 cbExtra;
+    SBBItem* dataItems;
+    TcgSttbfCore(const TcgSttbfCore&);
+    TcgSttbfCore& operator = ( const TcgSttbfCore&);
+public:
+    TcgSttbfCore();
+    ~TcgSttbfCore();
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* fp );
+};
+
+class TcgSttbf : public Tcg255SubStruct
+{
+    TcgSttbfCore sttbf;
+    TcgSttbf(const TcgSttbf&);
+    TcgSttbf& operator = ( const TcgSttbf&);
+public:
+    TcgSttbf( bool bReadId = true );
+    ~TcgSttbf(){}
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* fp );
+};
+
+class Xstz : public TBBase
+{
+    Xst xst; //An Xst specifying the string with its pre-pended length. 
+    sal_uInt16 chTerm;
+
+    Xstz(const Xstz&);
+    Xstz& operator = ( const Xstz&);
+public:
+    Xstz();
+    ~Xstz(){}
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* fp );
+};
+
+class MacroName : public TBBase
+{
+    sal_uInt16 ibst; //An unsigned integer that specifies the index of the current entry in the macro name table. MUST NOT be the same as the index of any other entry.
+    Xstz xstz;
+    MacroName(const MacroName&);
+    MacroName& operator = ( const MacroName&);
+public:
+    MacroName();
+    ~MacroName(){}
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class MacroNames : public Tcg255SubStruct
+{
+    sal_uInt16 iMac; //An unsigned integer that specifies the number of MacroName structures in rgNames.
+    MacroName* rgNames;
+
+    MacroNames(const MacroNames&);
+    MacroNames& operator = ( const MacroNames&);
+public:
+    MacroNames( bool bReadId = true );
+    ~MacroNames();
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class Tcg255 : public TBBase
+{
+    std::vector< Tcg255SubStruct* > rgtcgData; // array of sub structures
+    Tcg255(const Tcg255&);
+    Tcg255& operator = ( const Tcg255&);
+    bool processSubStruct( sal_uInt8 nId, SotStorageStream*  );
+public:
+    Tcg255();
+    ~Tcg255();
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+class Tcg: public TBBase
+{
+    sal_Int8 nTcgVer; 
+    std::auto_ptr< Tcg255 > tcg;
+    Tcg(const Tcg&);
+    Tcg& operator = ( const Tcg&);
+public:
+    Tcg();
+    ~Tcg(){}
+    bool Read(SotStorageStream *pS);
+    void Print( FILE* );
+};
+
+#endif
--- /dev/null	2008-04-22 00:28:44.000000000 +0100
+++ sw/source/filter/ww8/ww8toolbar.cxx	2009-01-29 18:02:16.000000000 +0000
@@ -0,0 +1,978 @@
+#include "ww8toolbar.hxx"
+#include <rtl/ustrbuf.hxx>
+
+rtl::OUString readUnicodeString( SotStorageStream* pS, sal_Int32 nChars )
+{
+    rtl::OUStringBuffer buf(40);
+    for ( sal_Int32 index = 0; index < nChars; ++index )
+    {
+        sal_uInt16 ch = 0;
+        *pS >> ch;
+        sal_Unicode uni = static_cast< sal_Unicode >( ch );
+        buf.append( &uni, 1 );
+    }
+    return buf.makeStringAndClear();
+}
+
+CTBWrapper::CTBWrapper( bool bReadId ) : Tcg255SubStruct( bReadId )
+,reserved2(0)
+,reserved3(0)
+,reserved4(0)
+,reserved5(0)
+,cbTBD(0)
+,cCust(0)
+,cbDTBC(0)
+,rtbdc(0)
+,rCustomizations(0)
+{
+}
+
+CTBWrapper::~CTBWrapper()
+{
+    if ( rtbdc )
+        delete [] rtbdc; 
+    if ( rCustomizations )
+        delete [] rCustomizations; 
+}
+
+bool CTBWrapper::Read( SotStorageStream* pS )
+{
+    Tcg255SubStruct::Read( pS );
+    *pS >> reserved2 >> reserved3 >> reserved4 >> reserved5;
+    *pS >> cbTBD >> cCust >> cbDTBC;
+    if ( cbDTBC )
+    {
+        // cbDTBC is the size in bytes of the TBC array
+        // but the size of a TBC element is dynamic ( and this relates to TBDelta's
+        // which we don't read right now )
+        pS->SeekRel( cbDTBC );
+    }
+    if ( cCust )
+    {
+        rCustomizations = new Customization[ cCust ];
+        for ( sal_Int32 index = 0; index < cCust; ++index )
+        {
+            if ( !rCustomizations[ index ].Read( pS ) )
+                return false;
+        } 
+    } 
+    return true;
+}
+
+void CTBWrapper::Print( FILE* fp )
+{
+    fprintf(fp,"CTBWrapper - dump\n");
+    bool bRes = ( ch == 0x12 && reserved2 == 0x0 && reserved3 == 0x7 && reserved4 == 0x6 && reserved5 == 0xC );
+    if ( bRes )
+        fprintf(fp,"  sanity check ( first 8 bytes conform )\n");
+    else 
+    {
+        fprintf(fp,"    reserved1(0x%x)\n",ch);
+        fprintf(fp,"    reserved2(0x%x)\n",reserved2);
+        fprintf(fp,"    reserved3(0x%x)\n",reserved3);
+        fprintf(fp,"    reserved4(0x%x)\n",reserved4);
+        fprintf(fp,"    reserved5(0x%x)\n",reserved5);
+        fprintf(fp,"Quiting dump");
+        return;
+    }
+    fprintf(fp,"  cbTBD: no. of TBDelta structures ( skipped if present ) 0x%x\n", cbTBD );
+    fprintf(fp,"  cCust: no. of cCust structures 0x%x\n",cCust);
+    fprintf(fp,"  cbDTBC: no. of bytes in rtbdc array 0x%x\n", static_cast< unsigned int >( cbDTBC ));
+    fprintf(fp,"  .... skipping rtbdc\n");
+    if ( rCustomizations )
+    {
+        for ( sal_Int32 index = 0; index < cCust; ++index )
+        {
+            fprintf(fp,"  Dumping custimization [%d]\n", static_cast< int >( index ));
+            rCustomizations[ index ].Print(fp);
+        }
+    }
+}
+Customization::Customization() : tbidForTBD( 0 )
+,reserved1( 0 )
+, ctbds( 0 )
+, customizationDataCTB( 0 )
+, customizationDataTBDelta( 0 )
+{
+}
+
+Customization::~Customization()
+{
+    if ( customizationDataCTB )
+        delete customizationDataCTB;
+/* we don't read TBDelta structures yet
+    if ( customizationDataTBDelta )
+        delete [] customizationDataTBDelta;
+*/
+}
+
+bool Customization::Read( SotStorageStream *pS)
+{
+    *pS >> tbidForTBD >> reserved1 >> ctbds;
+    if ( tbidForTBD ) //TBDelta - which we don't read yet
+        return false;
+    if ( !ctbds ) // should be 0 for CTB 
+    {
+        customizationDataCTB = new CTB();
+        if ( !customizationDataCTB->Read( pS ) )
+                return false;
+    }
+    return true;
+}
+
+void Customization::Print( FILE* fp )
+{
+    fprintf( fp,"Customization -- dump \n");
+    fprintf( fp,"  tbidForTBD 0x%x ( should be 0 for CTBs )\n", static_cast< unsigned int >( tbidForTBD ));
+    fprintf( fp,"  reserved1 0x%x \n", reserved1);
+    fprintf( fp,"  ctbds - number of customisations %d(0x%x) \n", ctbds, ctbds );
+    if ( !tbidForTBD && !ctbds )
+        customizationDataCTB->Print( fp );
+    else
+        fprintf( fp,"  quiting... we don't handle TBDelta's yet\n" );
+    
+    
+}
+
+TBDelta::TBDelta() : doprfatendFlags(0)
+,ibts(0)
+,cidNext(0)
+,cid(0)
+,fc(0)
+,cbTBC(0)
+{
+}
+
+bool TBDelta::Read(SotStorageStream *pS)
+{
+    *pS >> doprfatendFlags >> ibts >> cidNext >> cid >> fc ;
+    pS->Read( CiTBDE, sizeof( CiTBDE ) );
+    *pS >> cbTBC;
+    return true;
+}
+
+CTB::CTB() : cbTBData( 0 )
+,iWCTBl( 0 )
+,reserved( 0 )
+,unused( 0 )
+,cCtls( 0 )
+,rTBC( 0 )
+{
+}
+
+CTB::~CTB()
+{
+    if ( rTBC )
+        delete [] rTBC;
+}
+
+bool CTB::Read( SotStorageStream *pS)
+{
+    if ( !name.Read( pS ) )
+        return false;
+    *pS >> cbTBData;
+    // sal_Int32 nTBSize = cbTBData - sizeof(rVisualData) - 12;
+    if ( !tb.Read( pS ) )
+        return false;
+    pS->Read( &rVisualData, sizeof( rVisualData ) );
+
+    *pS >> iWCTBl >> reserved >> unused >> cCtls;
+    
+    if ( cCtls )
+    {
+        rTBC = new TBC[ cCtls ];
+        for ( sal_Int32 index = 0; index < cCtls; ++index )
+        {
+            if ( !rTBC[ index ].Read( pS ) )
+                return false;
+        }
+    }
+    return true;
+}
+
+void
+CTB::Print( FILE* fp )
+{
+    fprintf(fp, "CTB - dump\n");
+    fprintf(fp, "  name %s\n", rtl::OUStringToOString( name.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    fprintf(fp, "  cbTBData size, in bytes, of this structure excluding the name, cCtls, and rTBC fields.  %x\n", static_cast< unsigned int >( cbTBData ) );
+    
+    tb.Print(fp);
+    fprintf(fp, "  iWCTBl 0x%x reserved 0x%x unused 0x%x cCtls( toolbar controls ) 0x%x \n", static_cast< unsigned int >( iWCTBl ), reserved, unused, static_cast< unsigned int >( cCtls ) );
+    if ( cCtls )
+    {
+        for ( sal_Int32 index = 0; index < cCtls; ++index )
+        {
+        
+            fprintf(fp, "  dumping toolbar control 0x%x\n", static_cast< unsigned int >( index ) );
+            rTBC[ index ].Print( fp );
+        }
+    }
+}
+
+TB::TB() : bSignature( 0 )
+,bVersion( 0 )
+,cCL( 0 )
+,ltbid( 0 )
+,ltbtr( 0 )
+,cRowsDefault( 0 )
+,bFlags( 0 )
+{
+}
+
+bool TB::Read( SotStorageStream* pS )
+{
+    *pS >> bSignature >> bVersion >> cCL >> ltbid >> ltbtr >> cRowsDefault >> bFlags;
+    return name.Read( pS );
+}
+
+void TB::Print( FILE* fp )
+{
+    fprintf( fp, "TB -- dump\n");
+    fprintf( fp, "  bSignature (0x%x), bVersion(0x%x), cCL(0x%x), ltbid(0x%x), cRowsDefault (0x%x), ltbtr(0x%x), bFlags(0x%x)\n", bSignature, bVersion, cCL, static_cast< unsigned int >( ltbid ), static_cast< unsigned int >( ltbtr ), cRowsDefault, bFlags );
+    fprintf( fp, "  name %s\n", rtl::OUStringToOString( name.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+
+}
+
+TBC::TBC() : cid( 0 )
+{
+}
+
+TBC::~TBC()
+{
+    if ( cid )
+        delete cid;
+}
+
+bool TBC::Read( SotStorageStream *pS )
+{
+    if ( !tbch.Read( pS ) )
+        return false;
+    if ( tbch.tcid != 0x1 && tbch.tcid != 0x1051 )
+    {
+        cid = new sal_uInt32;
+        *pS >> *cid;
+    }
+    // MUST exist if tbch.tct is not equal to 0x16
+    if ( tbch.tct != 0x16 )
+    {
+        tbcd.reset(  new TBCData( tbch ) );
+        if ( !tbcd->Read( pS ) )
+            return false;
+    }
+    return true;
+}
+
+void TBC::Print( FILE* fp )
+{
+    fprintf(fp,"TCB -- dump\n");
+    fprintf(fp,"  dumping header ( TBCHeader )\n");
+    tbch.Print( fp );
+    if ( cid )
+        fprintf(fp,"  cid = 0x%x\n", static_cast< unsigned int >( *cid ) );
+    if ( tbcd.get() )
+    {
+        fprintf(fp,"  dumping toolbar data TBCData \n");
+        tbcd->Print(fp);
+    }
+}
+
+TBCHeader::TBCHeader() : bSignature( 0x3 )
+,bVersion( 0x01 )
+,bFlagsTCR( 0 )
+,tct(0x1) // default to Button
+,tcid(0)
+,tbct(0)
+,width(NULL)
+,height(NULL)
+{
+}
+
+
+TBCHeader::~TBCHeader()
+{
+    if ( width )
+        delete width;
+    if ( height )
+        delete height;
+}
+
+bool TBCHeader::Read( SotStorageStream* pS )
+{
+    *pS >> bSignature >> bVersion >> bFlagsTCR >> tct >> tcid >> tbct >> bPriority;
+    //  bit 4 ( from lsb ) 
+    if ( bFlagsTCR & 0x10 )
+    {
+        width = new sal_uInt16;
+        height = new sal_uInt16;
+        *pS >> *width >> *height;
+    }
+    return true;
+}
+
+void TBCHeader::Print( FILE* fp )
+{
+    fprintf(fp,"TBCHeader -- dump\n");
+    fprintf(fp,"  bSignature 0x%x\n  bVersion 0x%x\n  bFlagsTCR 0x%x\n", bSignature, bVersion, bFlagsTCR );
+    fprintf(fp,"  tct 0x%x\n  tcid 0x%x\n  tbct 0x%x\n  bPriority 0x%x\n", tct, tcid, static_cast< unsigned int >( tbct ), bPriority );
+    if ( width )
+        fprintf(fp,"  width 0x%d(0x%x)\n", *width, *width);
+    if ( height )
+        fprintf(fp,"  height 0x%d(0x%x)\n", *height, *height);
+}
+
+bool TBCData::Read(SotStorageStream *pS)
+{
+    if ( !controlGeneralInfo.Read(pS) /*|| !controlSpecificInfo.Read(pS)*/ )
+        return false;
+    if ( rHeader.tct == 1 )
+        return controlSpecificInfo.Read( pS );
+
+    OSL_TRACE("#FIXME I need to be able to handle different controlSpecificInfo types.");
+    return false;
+}
+
+void TBCData::Print( FILE* fp )
+{
+    fprintf(fp,"TBCData -- dump\n");
+    fprintf(fp,"  dumping controlGeneralInfo( TBCGeneralInfo )\n");
+    controlGeneralInfo.Print( fp );
+    if ( rHeader.tct == 1 )
+    {
+        fprintf(fp,"  dumping controlSpecificInfo( TBCSpecificInfo )\n");
+        controlSpecificInfo.Print( fp );
+    }
+}
+
+bool
+WString::Read( SotStorageStream *pS )
+{
+    sal_Int8 nChars = 0;
+    *pS >> nChars;
+    sString = readUnicodeString( pS, static_cast< sal_Int32 >( nChars  ) );
+    return true;
+}
+
+bool 
+Xst::Read( SotStorageStream* pS )
+{
+    sal_Int16 nChars = 0;
+    *pS >> nChars;
+    sString = readUnicodeString( pS, static_cast< sal_Int32 >( nChars  ) );
+    return true;
+}
+
+void
+Xst::Print( FILE* fp )
+{
+    fprintf( fp, "Xst -- dump\n");
+    fprintf( fp, " %s",  rtl::OUStringToOString( sString, RTL_TEXTENCODING_UTF8 ).getStr() );
+}
+TBCExtraInfo::TBCExtraInfo() : idHelpContext( 0 )
+{
+}
+
+bool
+TBCExtraInfo::Read( SotStorageStream *pS )
+{
+    if( !wstrHelpFile.Read( pS )  )
+        return false;
+
+    *pS >> idHelpContext;
+
+    if ( !wstrTag.Read( pS ) || !wstrOnAction.Read( pS ) || !wstrParam.Read( pS ) )
+        return false;
+
+    *pS >> tbcu >> tbmg;    
+    return true;
+}
+
+void
+TBCExtraInfo::Print( FILE* fp )
+{
+    fprintf( fp, "TBCExtraInfo -- dump\n");
+    fprintf( fp, "  wstrHelpFile %s\n", 
+        rtl::OUStringToOString( wstrHelpFile.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    fprintf( fp, "  idHelpContext 0x%x\n", static_cast< unsigned int >( idHelpContext ) );
+    fprintf( fp, "  wstrTag %s\n", 
+        rtl::OUStringToOString( wstrTag.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    fprintf( fp, "  wstrOnAction %s\n", 
+        rtl::OUStringToOString( wstrOnAction.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    fprintf( fp, "  wstrParam %s\n", 
+        rtl::OUStringToOString( wstrParam.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    fprintf( fp, "  tbcu 0x%x\n", tbcu );
+    fprintf( fp, "  tbmg 0x%x\n", tbmg );
+    
+}
+
+TBCGeneralInfo::TBCGeneralInfo() : bFlags( 0 )
+{
+}
+
+bool TBCGeneralInfo::Read( SotStorageStream *pS )
+{
+    *pS >> bFlags;
+    if ( !customText.Read( pS ) || !descriptionText.Read( pS ) || !tooltip.Read( pS )
+    || !extraInfo.Read( pS ) )
+        return false;
+    return true;
+}
+
+void 
+TBCGeneralInfo::Print( FILE* fp )
+{
+    fprintf( fp, "TBCGeneralInfo -- dump\n");
+    fprintf( fp, "  bFlags 0x%x\n", bFlags );
+    fprintf( fp, "  customText %s\n", 
+        rtl::OUStringToOString( customText.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    fprintf( fp, "  description %s\n", 
+        rtl::OUStringToOString( descriptionText.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    fprintf( fp, "  tooltip %s\n", 
+        rtl::OUStringToOString( tooltip.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    extraInfo.Print( fp );
+}
+
+TBCSpecific::TBCSpecific() : bFlags( 0 )
+{
+}
+
+bool TBCSpecific::Read( SotStorageStream *pS)
+{
+    *pS >> bFlags;
+
+    // bFlags determines what we read next
+
+    // bFlags.fCustomBitmap = 1 ( 0x8 ) set 
+    if ( bFlags & 0x8 )
+    {
+        icon.reset( new TBCBitMap() );
+        iconMask.reset( new TBCBitMap() );
+        if ( !icon->Read( pS ) || !iconMask->Read( pS ) )
+            return false;
+    }
+    // if bFlags.fCustomBtnFace = 1 ( 0x10 )
+    if ( bFlags & 0x10 )
+    {
+        iBtnFace.reset( new sal_uInt16 );
+        *pS >> *iBtnFace.get();
+    }
+    // if bFlags.fAccelerator equals 1 ( 0x04 )
+    if ( bFlags & 0x04 )
+    {
+        wstrAcc.reset( new WString() );
+        return wstrAcc->Read( pS );
+    }
+    return true;
+}
+
+
+void TBCSpecific::Print( FILE* fp )
+{
+    fprintf( fp, "TBCSpecific -- dump\n");
+    fprintf( fp, "  bFlags 0x%x\n", bFlags );
+    bool bResult = ( icon.get() != NULL );
+    fprintf( fp, "  icon present? %s\n", bResult ? "true" : "false" );
+    if ( bResult )
+        icon->Print( fp ); // will dump size
+    bResult = ( iconMask.get() != NULL );
+    fprintf( fp, "  icon mask present? %s\n", bResult ? "true" : "false" );
+    if ( bResult )
+        iconMask->Print( fp ); // will dump size
+    if ( iBtnFace.get() )
+        fprintf( fp, "  iBtnFace 0x%x\n", *(iBtnFace.get()) );
+    bResult = ( wstrAcc.get() != NULL );
+    fprintf( fp, "  option string present? %s ->%s<-\n", bResult ? "true" : "false", bResult ? rtl::OUStringToOString( wstrAcc->getString(), RTL_TEXTENCODING_UTF8 ).getStr() : "N/A" );
+}
+
+TBCBitMap::TBCBitMap() : cbDIB( 0 ), pRestOfIt( NULL )
+{
+}
+
+TBCBitMap::~TBCBitMap()
+{
+    if ( pRestOfIt )
+        delete [] pRestOfIt;
+}
+
+bool TBCBitMap::Read( SotStorageStream* pS)
+{
+    *pS >> cbDIB;
+    // cbDIB = sizeOf(biHeader) + sizeOf(colors) + sizeOf(bitmapData) + 10
+    // slurp the rest of the structure as a blob ( we'll get to it later )
+
+    pRestOfIt = new sal_uInt8[ cbDIB - 10 ];
+    pS->Read( pRestOfIt, sizeof( pRestOfIt ) );
+    return true;
+}
+
+void TBCBitMap::Print( FILE* fp )
+{
+    fprintf(fp, "TBCBitMap -- dump\n");
+    fprintf(fp, "  TBCBitMap size of bitmap data 0x%x\n", static_cast< unsigned int > ( cbDIB ) );
+}
+
+Tcg::Tcg() : nTcgVer( 255 )
+{
+}
+
+bool Tcg::Read(SotStorageStream *pS)
+{
+    *pS >> nTcgVer;
+    if ( nTcgVer != (sal_Int8)255 )
+        return false;
+    tcg.reset( new Tcg255() );
+    return tcg->Read( pS );
+}
+
+void Tcg::Print( FILE* fp )
+{
+    fprintf(fp, "Tcg - dump %d\n", nTcgVer);
+    fprintf(fp,"  nTcgVer %d\n", nTcgVer);
+    tcg->Print( fp );
+}
+
+Tcg255::Tcg255()
+{
+}
+
+Tcg255::~Tcg255()
+{
+    std::vector< Tcg255SubStruct* >::iterator it = rgtcgData.begin();
+    for ( ; it != rgtcgData.end(); ++it )
+        delete *it;
+}
+
+bool Tcg255::processSubStruct( sal_uInt8 nId, SotStorageStream *pS )
+{
+     Tcg255SubStruct* pSubStruct = NULL;
+     switch ( nId )
+     {
+         case 0x1:
+         {
+             pSubStruct = new PlfMcd( false ); // don't read the id
+             break;
+         }
+         case 0x2: 
+         {
+             pSubStruct = new PlfAcd( false );
+             break;
+         }
+         case 0x3: 
+         case 0x4: 
+         {
+             pSubStruct = new PlfKme( false );
+             break;
+         }
+         case 0x10: 
+         {
+             pSubStruct = new TcgSttbf( false );
+             break;
+         }
+         case 0x11: 
+         {
+             pSubStruct = new MacroNames( false );
+             break;
+         }
+         case 0x12: 
+         {
+             pSubStruct = new CTBWrapper( false );
+             break;
+         }
+         default:
+             OSL_TRACE("Unknown id 0x%x",nId);
+             return false;
+    }
+    pSubStruct->ch = nId;
+    if ( !pSubStruct->Read( pS ) )
+        return false;
+    rgtcgData.push_back( pSubStruct );
+    return true;
+}
+
+bool Tcg255::Read(SotStorageStream *pS)
+{
+    sal_uInt8 nId = 0; // 
+    *pS >> nId;
+    while (  nId != 0x40  )
+    {
+        if ( !processSubStruct( nId, pS ) )
+            return false;
+        *pS >> nId;
+    } 
+    return true;
+    // Peek at  
+}
+
+void Tcg255::Print( FILE* fp)
+{
+    fprintf(fp, "Tcg255 - dump\n");
+    fprintf(fp, "  contains %d sub records\n", rgtcgData.size() );
+    std::vector< Tcg255SubStruct* >::iterator it = rgtcgData.begin(); 
+    std::vector< Tcg255SubStruct* >::iterator it_end = rgtcgData.end(); 
+    
+    for( sal_Int32 count = 1; it != it_end ; ++it, ++count )
+    {
+        fprintf(fp, "[%d] \n", static_cast< unsigned int >( count ) );
+        (*it)->Print(fp);
+    }
+}
+
+
+Tcg255SubStruct::Tcg255SubStruct( bool bReadId ) : mbReadId( bReadId ), ch(0)
+{
+}
+
+bool Tcg255SubStruct::Read(SotStorageStream *pS)
+{
+    if ( mbReadId )
+        *pS >> ch;
+    return true;
+}
+
+PlfMcd::PlfMcd( bool bReadId ): Tcg255SubStruct( bReadId ), rgmcd( NULL )
+{
+}
+PlfMcd::~PlfMcd()
+{
+    if ( rgmcd )
+        delete[] rgmcd;
+}
+
+bool PlfMcd::Read(SotStorageStream *pS)
+{
+    Tcg255SubStruct::Read( pS );
+    *pS >> iMac;
+    if ( iMac )
+    { 
+        rgmcd = new MCD[ iMac ];
+        for ( sal_Int32 index = 0; index < iMac; ++index )
+        {
+            if ( !rgmcd[ index ].Read( pS ) )
+                return false; 
+        } 
+    }
+    return true;
+}
+
+void PlfMcd::Print( FILE* fp )
+{
+    fprintf(fp, "PlfMcd ( Tcg255SubStruct ) - dump\n");
+    fprintf(fp, " contains %d MCD records\n", static_cast<int>( iMac ) );
+    for ( sal_Int32 count=0; count < iMac; ++count )
+    {
+        fprintf(fp, "[%d] MCD\n", static_cast< int >( count ) );
+        rgmcd[ count ].Print( fp );
+    }
+    
+}
+
+PlfAcd::PlfAcd( bool bReadId ) : Tcg255SubStruct( bReadId )
+,iMac(0)
+,rgacd(NULL)
+{
+}
+
+
+PlfAcd::~PlfAcd()
+{
+    if ( rgacd )
+        delete[] rgacd;
+}
+
+bool PlfAcd::Read( SotStorageStream *pS)
+{
+    Tcg255SubStruct::Read( pS );
+    *pS >> iMac;
+    if ( iMac )
+    {
+        rgacd = new Acd[ iMac ];
+        for ( sal_Int32 index = 0; index < iMac; ++index )
+        {
+            if ( !rgacd[ index ].Read( pS ) ) 
+                return false;
+        }
+    }
+    return true;
+}
+void PlfAcd::Print( FILE* fp )
+{
+    fprintf(fp, "PlfAcd ( Tcg255SubStruct ) - dump\n");
+    fprintf(fp, " contains %d ACD records\n", static_cast< int >( iMac ) );
+    for ( sal_Int32 count=0; count < iMac; ++count )
+    {
+        fprintf(fp, "[%d] ACD\n", static_cast< int >( count ) );
+        rgacd[ count ].Print( fp );
+    }
+    
+}
+
+PlfKme::PlfKme( bool bReadId ) : Tcg255SubStruct( bReadId )
+,iMac( 0 )
+,rgkme( NULL )
+{
+}
+
+PlfKme::~PlfKme()
+{
+    if ( rgkme )
+        delete[] rgkme;
+}
+
+bool PlfKme::Read(SotStorageStream *pS)
+{
+    Tcg255SubStruct::Read( pS );
+    *pS >> iMac;
+    if ( iMac )
+    {
+        rgkme = new Kme[ iMac ];
+        for( sal_Int32 index=0; index<iMac; ++index )
+        {
+            if ( !rgkme[ index ].Read( pS ) )
+                return false;
+        }
+    }
+    return true;
+}
+ 
+void PlfKme::Print( FILE* fp )
+{
+    fprintf(fp, "PlfKme ( Tcg255SubStruct ) - dump\n");
+    fprintf(fp, " contains %d Kme records\n", static_cast< int >( iMac ) );
+    for ( sal_Int32 count=0; count < iMac; ++count )
+    {
+        fprintf(fp, "[%d] Kme\n", static_cast< int >( count ) );
+        rgkme[ count ].Print( fp );
+    }
+    
+}
+
+TcgSttbf::TcgSttbf( bool bReadId ) : Tcg255SubStruct( bReadId )
+{
+}
+
+bool TcgSttbf::Read( SotStorageStream *pS) 
+{
+    Tcg255SubStruct::Read( pS );
+    return sttbf.Read( pS );
+}
+
+void TcgSttbf::Print( FILE* fp )
+{
+    fprintf(fp,"TcgSttbf - dump\n");
+    sttbf.Print( fp );
+}
+
+TcgSttbfCore::TcgSttbfCore() : fExtend( 0 )
+,cData( 0 )
+,cbExtra( 0 )
+,dataItems( NULL )
+{
+}
+
+TcgSttbfCore::~TcgSttbfCore()
+{
+    if ( dataItems )
+        delete[] dataItems;
+}
+
+bool TcgSttbfCore::Read( SotStorageStream* pS )
+{
+    *pS >> fExtend >> cData >> cbExtra;
+    if ( cData )
+    {
+        dataItems = new SBBItem[ cData ];
+        for ( sal_Int32 index = 0; index < cData; ++index )
+        {
+            *pS >> dataItems[ index ].cchData;
+            dataItems[ index ].data = readUnicodeString( pS, dataItems[ index ].cchData );
+            *pS >> dataItems[ index ].extraData;
+        }
+    }
+    return true;
+}
+
+void TcgSttbfCore::Print( FILE* fp )
+{
+    fprintf( fp, "TcgSttbfCore - dump\n");
+    fprintf( fp, " fExtend 0x%x [expected 0xFFFF ]\n", fExtend );
+    fprintf( fp, " cbExtra 0x%x [expected 0x02 ]\n", cbExtra );
+    fprintf( fp, " cData no. or string data items %d (0x%x)\n", cData, cData );
+    
+    if ( cData )
+    {
+        for ( sal_Int32 index = 0; index < cData; ++index )
+            fprintf(fp,"   string dataItem[ %d(0x%x) ] has name %s and if referenced %d times.\n", static_cast< int >( index ), static_cast< unsigned int >( index ), rtl::OUStringToOString( dataItems[ index ].data, RTL_TEXTENCODING_UTF8 ).getStr(), dataItems[ index ].extraData );
+    }
+
+}
+MacroNames::MacroNames( bool bReadId ) : Tcg255SubStruct( bReadId )
+,iMac( 0 )
+,rgNames( NULL )
+{
+}
+
+MacroNames::~MacroNames()
+{
+    if ( rgNames )
+        delete[] rgNames;
+}
+
+bool MacroNames::Read( SotStorageStream *pS)
+{
+    Tcg255SubStruct::Read( pS );
+    *pS >> iMac;
+    if ( iMac )
+    {
+        rgNames = new MacroName[ iMac ]; 
+        for ( sal_Int32 index = 0; index < 0; ++index )
+        {
+            if ( !rgNames[ index ].Read( pS ) )
+                return false;
+        }
+    }
+    return true;
+}
+
+void MacroNames::Print( FILE* fp )
+{
+    fprintf(fp, "MacroNames ( Tcg255SubStruct ) - dump\n");
+    fprintf(fp, " contains %d MacroName records\n", iMac );
+    for ( sal_Int32 count=0; count < iMac; ++count )
+    {
+        fprintf(fp, "[%d] MacroName\n", static_cast<int>( count ) );
+        rgNames[ count ].Print( fp );
+    }
+    
+}
+
+MacroName::MacroName():ibst(0)
+{
+}
+
+
+bool MacroName::Read(SotStorageStream *pS)
+{
+    *pS >> ibst;
+    return xstz.Read( pS );
+}
+
+void MacroName::Print( FILE* fp )
+{
+    fprintf( fp, "MacroName - dump");
+    fprintf( fp,"  index - 0x%x has associated following record\n", ibst );
+    xstz.Print( fp );
+}
+
+
+
+Xstz::Xstz():chTerm(0)
+{
+}
+
+bool 
+Xstz::Read(SotStorageStream *pS)
+{
+    if ( !xst.Read( pS ) )
+        return false;
+    *pS >> chTerm;
+    if ( chTerm != 0 ) // should be an assert 
+        return false;
+    return true;
+}
+
+void Xstz::Print( FILE* fp )
+{
+    fprintf(fp,"Xstz -- dump\n");
+    fprintf(fp,"  Xst\n");
+    xst.Print( fp ); 
+    fprintf(fp,"  chterm 0x%x ( should be zero )\n", chTerm);
+}
+
+Kme::Kme() : reserved1(0)
+,reserved2(0)
+,kcm1(0)
+,kcm2(0)
+,kt(0)
+,param(0)
+{
+}
+
+Kme::~Kme()
+{
+}
+
+bool
+Kme::Read(SotStorageStream *pS)
+{
+    *pS >> reserved1 >> reserved2 >> kcm1 >> kcm2 >> param;
+    return true;
+}
+
+void Kme::Print( FILE* fp )
+{
+    
+   fprintf( fp, "Kme - dump\n");
+   fprintf( fp, " reserved1 0x%x [expected 0x0 ]\n", reserved1 );
+   fprintf( fp, " reserved2 0x%x [expected 0x0 ]\n", reserved2 );
+   fprintf( fp, " kcm1 0x%x [shortcut key]\n", kcm1 );
+   fprintf( fp, " kcm2 0x%x [shortcut key]\n", kcm2 );
+   fprintf( fp, " kt 0x%x \n", kt );
+   fprintf( fp, " param 0x%x \n", static_cast< unsigned int >( param ) );
+}
+
+Acd::Acd() : ibst( 0 )
+, fciBasedOnABC( 0 )
+{
+}
+
+bool Acd::Read(SotStorageStream *pS)
+{
+    *pS >> ibst >> fciBasedOnABC;
+    return true;
+}
+
+void Acd::Print( FILE* fp )
+{
+    fprintf( fp,"ACD - dump\n");
+    // #TODO flesh out interpretation of these values
+    fprintf( fp,"  ibst 0x%x\n", ibst);
+    fprintf( fp,"  fciBaseObABC 0x%x\n", fciBasedOnABC);
+}
+
+MCD::MCD() :  reserved1(0x56)
+,reserved2( 0 )
+,ibst( 0 )
+,ibstName( 0 )
+,reserved3( 0xFFFF )
+,reserved4( 0 )
+,reserved5( 0 )
+,reserved6( 0 )
+,reserved7( 0 )
+{
+}
+
+bool  MCD::Read(SotStorageStream *pS)
+{
+    
+    OSL_TRACE("*** MCD before read 0x%x", pS->Tell());
+    *pS >> reserved1 >> reserved2 >> ibst >> ibstName >> reserved3;
+    *pS >> reserved4 >> reserved5 >> reserved6 >> reserved7;
+    OSL_TRACE("*** MCD after read 0x%x", pS->Tell());
+    return true;
+}
+
+void MCD::Print( FILE* fp )
+{
+   fprintf( fp, "MCD - dump\n");
+   fprintf( fp, " reserved1 0x%x [expected 0x56 ]\n", reserved1 );
+   fprintf( fp, " reserved2 0x%x [expected 0x0 ]\n", reserved2 );
+   fprintf( fp, " ibst 0x%x specifies macro with MacroName.xstz = 0x%x\n", ibst, ibst );
+   fprintf( fp, " ibstName 0x%x index into command string table ( TcgSttbf.sttbf )\n", ibstName );
+
+   fprintf( fp, " reserved3 0x%x [expected 0xFFFF ]\n", reserved3 );
+   fprintf( fp, " reserved4 0x%x\n", static_cast< unsigned int >( reserved4 ) );
+   fprintf( fp, " reserved5 0x%x [expected 0x0 ]\n", static_cast< unsigned int >( reserved5 ) );
+   fprintf( fp, " reserved6 0x%x\n", static_cast< unsigned int >( reserved6 ) );
+   fprintf( fp, " reserved7 0x%x\n", static_cast< unsigned int >( reserved7 ) );
+}
+
