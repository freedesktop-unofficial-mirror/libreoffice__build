diff -urp --exclude=CVS --exclude=unxlngi6.pro --exclude=officecfg.vpj officecfg.clean/registry/schema/org/openoffice/Office/Common.xcs officecfg/registry/schema/org/openoffice/Office/Common.xcs
--- officecfg.clean/registry/schema/org/openoffice/Office/Common.xcs	2008-02-20 15:04:19.000000000 -0500
+++ officecfg/registry/schema/org/openoffice/Office/Common.xcs	2008-02-25 18:29:09.000000000 -0500
@@ -1194,6 +1194,15 @@ Dymamic border coloring means that when 
 				</info>
 				<value>false</value>
 			</prop>
+			<prop oor:name="CorrectAccidentalCapsLock" oor:type="xs:boolean">
+				<!-- UIHints: Tools  AutoCorrect/AutoFormat  Options  Correct accidental use of cAPS LOCK key -->
+				<info>
+					<author>Kohei Yoshida</author>
+					<desc>Specifies whether or not to correct accidental use of CAPS lock key.</desc>
+					<label>Correct accidental use of cAPS LOCK key</label>
+				</info>
+				<value>true</value>
+			</prop>
 			<prop oor:name="ReplaceSingleQuote" oor:type="xs:boolean">
 				<!-- OldPath: AutoCorrect/Options/All -->
 				<!-- OldLocation: Soffice.cfg -->
diff -urp --exclude=CVS --exclude=unxlngi6.pro --exclude=svx.vpj svx.clean/inc/svx/svxacorr.hxx svx/inc/svx/svxacorr.hxx
--- svx.clean/inc/svx/svxacorr.hxx	2008-02-25 11:50:16.000000000 -0500
+++ svx/inc/svx/svxacorr.hxx	2008-02-26 12:56:02.000000000 -0500
@@ -90,6 +90,7 @@ const long SaveWordCplSttLst= 0x00000200
 const long SaveWordWrdSttLst= 0x00000400;	// 2 GrB. am WortAnf. auto. aufnehmen
 const long IngnoreDoubleSpace= 0x00000800;	// 2 Spaces ignorieren
 const long ChgSglQuotes		= 0x00001000;	// einfache Quotes ersetzen
+const long CorrectCapsLock  = 0x00002000;   // Correct accidental use of cAPS LOCK key
 
 const long ChgWordLstLoad	= 0x20000000;	// Ersetzungsliste geladen
 const long CplSttLstLoad	= 0x40000000;	// Exceptionlist fuer CplStart geladen
@@ -277,7 +278,7 @@ public:
 	// fuehre eine AutoKorrektur aus.
 	// returnt was ausgefuehrt wurde; entsprechend den obigen Flags
 	ULONG AutoCorrect( SvxAutoCorrDoc& rDoc, const String& rTxt,
-						xub_StrLen nPos, sal_Unicode cInsChar, BOOL bInsert );
+						xub_StrLen nPos, sal_Unicode cInsChar, BOOL bInsert, bool bLockKeyOn );
 
 	// return fuer die Autotext Expandierung das vorherige Wort, was dem
 	// AutoCorrect - Algorythmus entspricht.
@@ -402,6 +403,10 @@ public:
 								xub_StrLen nSttPos, xub_StrLen nEndPos,
 								LanguageType eLang  = LANGUAGE_SYSTEM);
 
+    bool FnCorrectCapsLock( SvxAutoCorrDoc&, const String&, 
+                            xub_StrLen nSttPos, xub_StrLen nEndPos,
+                            LanguageType eLang  = LANGUAGE_SYSTEM );
+
 	static long			GetDefaultFlags();
 
 // returns TRUE for charcters where the function
diff -urp --exclude=CVS --exclude=unxlngi6.pro --exclude=svx.vpj svx.clean/source/dialog/autocdlg.cxx svx/source/dialog/autocdlg.cxx
--- svx.clean/source/dialog/autocdlg.cxx	2008-02-25 11:50:19.000000000 -0500
+++ svx/source/dialog/autocdlg.cxx	2008-02-25 23:26:30.000000000 -0500
@@ -260,7 +260,8 @@ OfaAutocorrOptionsPage::OfaAutocorrOptio
     sNoDblSpaces        (SVX_RES(STR_NO_DBL_SPACES    )),
     sHalf               (SVX_RES(ST_FRACTION          )),
 	sDash    			(SVX_RES(ST_DASH	         	)),
-    sFirst              (SVX_RES(ST_ORDINAL           ))
+    sFirst              (SVX_RES(ST_ORDINAL           )),
+    sAccidentalCaps     (SVX_RES(ST_CORRECT_ACCIDENTAL_CAPS_LOCK))
 {
 	FreeResource();
 
@@ -306,6 +307,7 @@ BOOL OfaAutocorrOptionsPage::FillItemSet
 	pAutoCorrect->SetAutoCorrFlag(ChgFractionSymbol,	aCheckLB.IsChecked(nPos++));
 	pAutoCorrect->SetAutoCorrFlag(ChgToEnEmDash,		aCheckLB.IsChecked(nPos++));
 	pAutoCorrect->SetAutoCorrFlag(IngnoreDoubleSpace,	aCheckLB.IsChecked(nPos++));
+    pAutoCorrect->SetAutoCorrFlag(CorrectCapsLock,      aCheckLB.IsChecked(nPos++));
 
 	BOOL bReturn = nFlags != pAutoCorrect->GetFlags();
 	if(bReturn )
@@ -347,6 +349,7 @@ void OfaAutocorrOptionsPage::Reset( cons
 	aCheckLB.InsertEntry(sHalf);
 	aCheckLB.InsertEntry(sDash);
 	aCheckLB.InsertEntry(sNoDblSpaces);
+    aCheckLB.InsertEntry(sAccidentalCaps);
 
 	USHORT nPos = 0;
 	aCheckLB.CheckEntryPos( nPos++, 0 != (nFlags & Autocorrect) );
@@ -358,6 +361,7 @@ void OfaAutocorrOptionsPage::Reset( cons
 	aCheckLB.CheckEntryPos( nPos++, 0 != (nFlags & ChgFractionSymbol) );
 	aCheckLB.CheckEntryPos( nPos++, 0 != (nFlags & ChgToEnEmDash) );
 	aCheckLB.CheckEntryPos( nPos++, 0 != (nFlags & IngnoreDoubleSpace) );
+    aCheckLB.CheckEntryPos( nPos++, 0 != (nFlags & CorrectCapsLock) );
 
 	aCheckLB.SetUpdateMode(TRUE);
 }
@@ -490,6 +494,7 @@ enum OfaAutoFmtOptions
 	DEL_SPACES_AT_STT_END,
 	DEL_SPACES_BETWEEN_LINES,
 	IGNORE_DBLSPACE,
+    CORRECT_CAPS_LOCK,
 	APPLY_NUMBERING,
 	INSERT_BORDER,
 	CREATE_TABLE,
@@ -519,6 +524,7 @@ OfaSwAutoFmtOptionsPage::OfaSwAutoFmtOpt
 	sBullet				(SVX_RES(	ST_BULLET       )),
 	sBoldUnder			(SVX_RES(	ST_BOLD_UNDER   )),
 	sNoDblSpaces		(SVX_RES(	STR_NO_DBL_SPACES)),
+    sCorrectCapsLock    (SVX_RES(   ST_CORRECT_ACCIDENTAL_CAPS_LOCK)),
 	sFraction			(SVX_RES(	ST_FRACTION     )),
 	sDetectURL			(SVX_RES(	ST_DETECT_URL   )),
 	sDash				(SVX_RES(	ST_DASH         )),
@@ -659,6 +665,9 @@ BOOL OfaSwAutoFmtOptionsPage::FillItemSe
 	pAutoCorrect->SetAutoCorrFlag(IngnoreDoubleSpace,
 						aCheckLB.IsChecked(IGNORE_DBLSPACE, CBCOL_SECOND));
 
+    pAutoCorrect->SetAutoCorrFlag(CorrectCapsLock,
+                        aCheckLB.IsChecked(CORRECT_CAPS_LOCK, CBCOL_SECOND));
+
 	bCheck = aCheckLB.IsChecked(DETECT_URL, CBCOL_FIRST);
 	bModified |= pOpt->bSetINetAttr != bCheck;
 	pOpt->bSetINetAttr = bCheck;
@@ -790,6 +799,7 @@ void OfaSwAutoFmtOptionsPage::Reset( con
 	aCheckLB.GetModel()->Insert(CreateEntry(sDelSpaceBetweenLines, CBCOL_BOTH  ));
 
 	aCheckLB.GetModel()->Insert(CreateEntry(sNoDblSpaces,		CBCOL_SECOND));
+    aCheckLB.GetModel()->Insert(CreateEntry(sCorrectCapsLock,   CBCOL_SECOND));
 	aCheckLB.GetModel()->Insert(CreateEntry(sNum,				CBCOL_SECOND));
 	aCheckLB.GetModel()->Insert(CreateEntry(sBorder,			CBCOL_SECOND));
 	aCheckLB.GetModel()->Insert(CreateEntry(sTable,				CBCOL_SECOND));
@@ -809,6 +819,7 @@ void OfaSwAutoFmtOptionsPage::Reset( con
 	aCheckLB.CheckEntryPos( BOLD_UNDERLINE,		CBCOL_FIRST,	pOpt->bChgWeightUnderl );
 	aCheckLB.CheckEntryPos( BOLD_UNDERLINE,		CBCOL_SECOND,	0 != (nFlags & ChgWeightUnderl) );
 	aCheckLB.CheckEntryPos( IGNORE_DBLSPACE,	CBCOL_SECOND,	0 != (nFlags & IngnoreDoubleSpace) );
+    aCheckLB.CheckEntryPos( CORRECT_CAPS_LOCK,  CBCOL_SECOND,   0 != (nFlags & CorrectCapsLock) );
 	aCheckLB.CheckEntryPos( DETECT_URL,			CBCOL_FIRST,	pOpt->bSetINetAttr );
 	aCheckLB.CheckEntryPos( DETECT_URL,			CBCOL_SECOND,	0 != (nFlags & SetINetAttr) );
 	aCheckLB.CheckEntryPos( REPLACE_1ST,		CBCOL_FIRST,	pOpt->bChgOrdinalNumber );
diff -urp --exclude=CVS --exclude=unxlngi6.pro --exclude=svx.vpj svx.clean/source/dialog/autocdlg.hrc svx/source/dialog/autocdlg.hrc
--- svx.clean/source/dialog/autocdlg.hrc	2008-02-25 11:50:19.000000000 -0500
+++ svx/source/dialog/autocdlg.hrc	2008-02-25 17:43:51.000000000 -0500
@@ -157,6 +157,7 @@
 #define ST_DASH                         208
 #define FT_LANG                         209
 #define LB_LANG                         210
+#define ST_CORRECT_ACCIDENTAL_CAPS_LOCK 211
 
 #define CB_SMARTTAGS                    220
 #define FT_SMARTTAGS                    221
diff -urp --exclude=CVS --exclude=unxlngi6.pro --exclude=svx.vpj svx.clean/source/dialog/autocdlg.hxx svx/source/dialog/autocdlg.hxx
--- svx.clean/source/dialog/autocdlg.hxx	2008-02-25 11:50:19.000000000 -0500
+++ svx/source/dialog/autocdlg.hxx	2008-02-25 19:07:16.000000000 -0500
@@ -149,6 +149,7 @@ private:
 	String		sHalf;
 	String		sDash;
 	String		sFirst;
+    String      sAccidentalCaps;
 
 public:
 						OfaAutocorrOptionsPage( Window* pParent, const SfxItemSet& rSet );
@@ -187,6 +188,7 @@ class OfaSwAutoFmtOptionsPage : public S
 	String			sByInputBullet;
 	String			sBoldUnder;
 	String			sNoDblSpaces;
+    String          sCorrectCapsLock;
 	String			sFraction;
 	String			sDetectURL;
 	String          sDash;
diff -urp --exclude=CVS --exclude=unxlngi6.pro --exclude=svx.vpj svx.clean/source/dialog/autocdlg.src svx/source/dialog/autocdlg.src
--- svx.clean/source/dialog/autocdlg.src	2008-02-25 11:50:19.000000000 -0500
+++ svx/source/dialog/autocdlg.src	2008-02-25 17:46:00.000000000 -0500
@@ -145,7 +145,11 @@ TabDialog RID_OFA_AUTOCORR_DLG
     String ST_DASH \
     { \
         Text [ en-US ] = "Replace dashes" ; \
-	};
+	}; \
+    String ST_CORRECT_ACCIDENTAL_CAPS_LOCK \
+    { \
+        Text [ en-US ] = "Correct accidental use of cAPS LOCK key" ; \
+    };
 
 /**************************************************************************/
 /*                                                                        */
diff -urp --exclude=CVS --exclude=unxlngi6.pro --exclude=svx.vpj svx.clean/source/editeng/acorrcfg.cxx svx/source/editeng/acorrcfg.cxx
--- svx.clean/source/editeng/acorrcfg.cxx	2008-02-25 11:50:18.000000000 -0500
+++ svx/source/editeng/acorrcfg.cxx	2008-02-25 19:15:21.000000000 -0500
@@ -139,9 +139,10 @@ Sequence<OUString> 	SvxBaseAutoCorrCfg::
 		"SingleQuoteAtEnd",						// 13
 		"ReplaceDoubleQuote",					// 14
 		"DoubleQuoteAtStart",					// 15
-		"DoubleQuoteAtEnd"						// 16
+		"DoubleQuoteAtEnd",						// 16
+        "CorrectAccidentalCapsLock"             // 17
 	};
-	const int nCount = 17;
+	const int nCount = 18;
 	Sequence<OUString> aNames(nCount);
 	OUString* pNames = aNames.getArray();
 	for(int i = 0; i < nCount; i++)
@@ -241,6 +242,10 @@ void SvxBaseAutoCorrCfg::Load(sal_Bool b
 						rParent.pAutoCorrect->SetEndDoubleQuote(
                             sal::static_int_cast< sal_Unicode >( nTemp ) );
 					break;//"DoubleQuoteAtEnd"
+                    case 17:
+                        if(*(sal_Bool*)pValues[nProp].getValue())
+                            nFlags |= CorrectCapsLock;
+                    break;//"CorrectAccidentalCapsLock"
 				}
 			}
 		}
@@ -345,6 +350,10 @@ void SvxBaseAutoCorrCfg::Commit()
 			case 16:
 				pValues[nProp] <<= (sal_Int32) rParent.pAutoCorrect->GetEndDoubleQuote();
 			break;//"DoubleQuoteAtEnd"
+            case 17:
+                bVal = 0 != (nFlags & CorrectCapsLock);
+                pValues[nProp].setValue(&bVal, rType);
+            break;//"CorrectAccidentalCapsLock"
 		}
 	}
 	PutProperties(aNames, aValues);
diff -urp --exclude=CVS --exclude=unxlngi6.pro --exclude=svx.vpj svx.clean/source/editeng/editeng.cxx svx/source/editeng/editeng.cxx
--- svx.clean/source/editeng/editeng.cxx	2008-02-25 11:50:18.000000000 -0500
+++ svx/source/editeng/editeng.cxx	2008-02-26 12:59:22.000000000 -0500
@@ -117,6 +117,7 @@
 #endif
 
 #include <srchdlg.hxx>
+#include <stdio.h>
 
 #if OSL_DEBUG_LEVEL > 1
 #include <svx/frmdiritem.hxx>
@@ -844,6 +845,8 @@ sal_Bool EditEngine::PostKeyEvent( const
 	sal_Bool bAllowIdle = sal_True;
 	sal_Bool bReadOnly	= pEditView->IsReadOnly();
 
+    BYTE nExtraMod = rKeyEvent.GetExtraMod();
+
     USHORT nNewCursorFlags = 0;
     BOOL bSetCursorFlags = TRUE;
 
@@ -1018,7 +1021,7 @@ sal_Bool EditEngine::PostKeyEvent( const
 						if ( bSel )
 							pImpEditEngine->UndoActionStart( EDITUNDO_INSERT );
 						if ( pImpEditEngine->GetStatus().DoAutoCorrect() )
-							aCurSel = pImpEditEngine->AutoCorrect( aCurSel, 0, !pEditView->IsInsertMode() );
+							aCurSel = pImpEditEngine->AutoCorrect( aCurSel, 0, !pEditView->IsInsertMode(), (nExtraMod & MODKEY_LOCK) );
 						aCurSel = pImpEditEngine->InsertTab( aCurSel );
 						if ( bSel )
 							pImpEditEngine->UndoActionEnd( EDITUNDO_INSERT );
@@ -1039,7 +1042,7 @@ sal_Bool EditEngine::PostKeyEvent( const
 						pImpEditEngine->UndoActionStart( EDITUNDO_INSERT );
 						if ( rKeyEvent.GetKeyCode().IsShift() )
                         {
-                            aCurSel = pImpEditEngine->AutoCorrect( aCurSel, 0, !pEditView->IsInsertMode() );
+                            aCurSel = pImpEditEngine->AutoCorrect( aCurSel, 0, !pEditView->IsInsertMode(), (nExtraMod & MODKEY_LOCK) );
 							aCurSel = pImpEditEngine->InsertLineBreak( aCurSel );
                         }
 						else
@@ -1047,7 +1050,7 @@ sal_Bool EditEngine::PostKeyEvent( const
 							if ( !aAutoText.Len() )
 							{
 								if ( pImpEditEngine->GetStatus().DoAutoCorrect() )
-									aCurSel = pImpEditEngine->AutoCorrect( aCurSel, 0, !pEditView->IsInsertMode() );
+									aCurSel = pImpEditEngine->AutoCorrect( aCurSel, 0, !pEditView->IsInsertMode(), (nExtraMod & MODKEY_LOCK) );
 								aCurSel = pImpEditEngine->InsertParaBreak( aCurSel );
 							}
 							else
@@ -1095,7 +1098,8 @@ sal_Bool EditEngine::PostKeyEvent( const
 						 	( nCharCode == '\"' ) || ( nCharCode == '\'' ) ||
 							( nCharCode == '_' )  ))
 					{
-						aCurSel = pImpEditEngine->AutoCorrect( aCurSel, nCharCode, !pEditView->IsInsertMode() );
+						aCurSel = pImpEditEngine->AutoCorrect( 
+                            aCurSel, nCharCode, !pEditView->IsInsertMode(), (nExtraMod & MODKEY_LOCK) );
 					}
 					else
 					{
diff -urp --exclude=CVS --exclude=unxlngi6.pro --exclude=svx.vpj svx.clean/source/editeng/editview.cxx svx/source/editeng/editview.cxx
--- svx.clean/source/editeng/editview.cxx	2008-02-25 11:50:18.000000000 -0500
+++ svx/source/editeng/editview.cxx	2008-02-26 13:00:02.000000000 -0500
@@ -944,7 +944,7 @@ void EditView::CompleteAutoCorrect()
 		EditSelection aSel = pImpEditView->GetEditSelection();
 		aSel = PIMPEE->EndOfWord( aSel.Max() );
 		// MT 06/00: Why pass EditSelection to AutoCorrect, not EditPaM?!
-		aSel = PIMPEE->AutoCorrect( aSel, 0, !IsInsertMode() );
+		aSel = PIMPEE->AutoCorrect( aSel, 0, !IsInsertMode(), false );
 		pImpEditView->SetEditSelection( aSel );
 		if ( PIMPEE->IsModified() )
 			PIMPEE->FormatAndUpdate( this );
diff -urp --exclude=CVS --exclude=unxlngi6.pro --exclude=svx.vpj svx.clean/source/editeng/impedit2.cxx svx/source/editeng/impedit2.cxx
--- svx.clean/source/editeng/impedit2.cxx	2008-02-25 11:50:18.000000000 -0500
+++ svx/source/editeng/impedit2.cxx	2008-02-26 13:00:33.000000000 -0500
@@ -559,7 +559,7 @@ void ImpEditEngine::Command( const Comma
 				if ( ( GetStatus().DoAutoCorrect() ) && ( ( nCharCode == '\"' ) || ( nCharCode == '\'' ) ) )
 				{
 					aSel = DeleteSelected( aSel );
-					aSel = AutoCorrect( aSel, nCharCode, mpIMEInfos->bWasCursorOverwrite );
+					aSel = AutoCorrect( aSel, nCharCode, mpIMEInfos->bWasCursorOverwrite, false );
 					pView->pImpEditView->SetEditSelection( aSel );
 				}
 			}
@@ -2428,7 +2428,7 @@ void ImpEditEngine::ImpRemoveParagraph( 
 	}
 }
 
-EditPaM ImpEditEngine::AutoCorrect( const EditSelection& rCurSel, xub_Unicode c, BOOL bOverwrite )
+EditPaM ImpEditEngine::AutoCorrect( const EditSelection& rCurSel, xub_Unicode c, BOOL bOverwrite, bool bLockKeyOn )
 {
 	EditSelection aSel( rCurSel );
 #ifndef SVX_LIGHT
@@ -2478,7 +2478,7 @@ EditPaM ImpEditEngine::AutoCorrect( cons
 		ContentNode* pNode = aSel.Max().GetNode();
 		USHORT nIndex = aSel.Max().GetIndex();
 		EdtAutoCorrDoc aAuto( this, pNode, nIndex, c );
-		pAutoCorrect->AutoCorrect( aAuto, *pNode, nIndex, c, !bOverwrite );
+		pAutoCorrect->AutoCorrect( aAuto, *pNode, nIndex, c, !bOverwrite, bLockKeyOn );
 		aSel.Max().SetIndex( aAuto.GetCursor() );
 
 		// #i78661 since the SvxAutoCorrect object used here is
diff -urp --exclude=CVS --exclude=unxlngi6.pro --exclude=svx.vpj svx.clean/source/editeng/impedit.hxx svx/source/editeng/impedit.hxx
--- svx.clean/source/editeng/impedit.hxx	2008-02-25 11:50:18.000000000 -0500
+++ svx/source/editeng/impedit.hxx	2008-02-26 12:56:13.000000000 -0500
@@ -833,7 +833,7 @@ public:
 	EditPaM			DeleteSelected( EditSelection aEditSelection);
     EditPaM         InsertText( const EditSelection& rCurEditSelection, sal_Unicode c, sal_Bool bOverwrite, sal_Bool bIsUserInput = sal_False );
 	EditPaM			InsertText( EditSelection aCurEditSelection, const String& rStr );
-	EditPaM			AutoCorrect( const EditSelection& rCurEditSelection, sal_Unicode c, sal_Bool bOverwrite );
+	EditPaM			AutoCorrect( const EditSelection& rCurEditSelection, sal_Unicode c, sal_Bool bOverwrite, bool bLockKeyOn );
 	EditPaM			DeleteLeftOrRight( const EditSelection& rEditSelection, BYTE nMode, BYTE nDelMode = DELMODE_SIMPLE );
 	EditPaM			InsertParaBreak( EditSelection aEditSelection );
 	EditPaM			InsertLineBreak( EditSelection aEditSelection );
diff -urp --exclude=CVS --exclude=unxlngi6.pro --exclude=svx.vpj svx.clean/source/editeng/svxacorr.cxx svx/source/editeng/svxacorr.cxx
--- svx.clean/source/editeng/svxacorr.cxx	2008-02-25 11:50:18.000000000 -0500
+++ svx/source/editeng/svxacorr.cxx	2008-02-26 13:04:10.000000000 -0500
@@ -158,6 +158,8 @@
 #include <xmloff/xmltoken.hxx>
 #endif
 
+#include <stdio.h>
+
 using namespace ::com::sun::star::ucb;
 using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star;
@@ -412,7 +414,8 @@ long SvxAutoCorrect::GetDefaultFlags()
 					| SetINetAttr
 					| ChgQuotes
 					| SaveWordCplSttLst
-					| SaveWordWrdSttLst;
+					| SaveWordWrdSttLst
+                    | CorrectCapsLock;
 	LanguageType eLang = GetAppLang();
 	switch( eLang )
 	{
@@ -1113,6 +1116,53 @@ BOOL SvxAutoCorrect::FnCptlSttSntnc( Svx
 
 	return bRet;
 }
+
+bool SvxAutoCorrect::FnCorrectCapsLock( SvxAutoCorrDoc& rDoc, const String& rTxt,
+                                        xub_StrLen nSttPos, xub_StrLen nEndPos,
+                                        LanguageType eLang )
+{
+    fprintf(stdout, "SvxAutoCorrect::FnCorrectCapsLock: --begin (%s)  stt pos = %ld  end pos = %ld  lang type = %ld\n",
+            rtl::OUStringToOString(rTxt, RTL_TEXTENCODING_UTF8).getStr(),
+            nSttPos, nEndPos, eLang);
+
+    if (nEndPos - nSttPos < 2)
+        // string must be at least 2-character long.
+        return false;
+
+    CharClass& rCC = GetCharClass( eLang );
+
+    // Check the first 2 letters.
+    if ( !IsLowerLetter(rCC.getCharacterType(rTxt, nSttPos)) )
+        return false;
+
+    if ( !IsUpperLetter(rCC.getCharacterType(rTxt, nSttPos+1)) )
+        return false;
+
+    String aConverted;
+    aConverted.Append( rCC.upper(rTxt.GetChar(nSttPos)) );
+    aConverted.Append( rCC.lower(rTxt.GetChar(nSttPos+1)) );
+
+    for (xub_StrLen i = nSttPos+2; i < nEndPos; ++i)
+    {
+        if ( IsLowerLetter(rCC.getCharacterType(rTxt, i)) )
+            // A lowercase letter disqualifies the whole text.
+            return false;
+
+        if ( IsUpperLetter(rCC.getCharacterType(rTxt, i)) )
+            // Another uppercase letter.  Convert it.
+            aConverted.Append( rCC.lower(rTxt.GetChar(i)) );
+        else
+            // This is not an alphabetic letter.  Leave it as-is.
+            aConverted.Append(rTxt.GetChar(i));
+    }
+
+    // Replace the word.
+    rDoc.Delete(nSttPos, nEndPos);
+    rDoc.Insert(nSttPos, aConverted);
+
+    return true;
+}
+
 //The method below is renamed from _GetQuote to GetQuote by BerryJia for Bug95846 Time:2002-8-13 15:50
 sal_Unicode SvxAutoCorrect::GetQuote( sal_Unicode cInsChar, BOOL bSttQuote,
 										LanguageType eLang ) const
@@ -1226,8 +1276,12 @@ String SvxAutoCorrect::GetQuote( SvxAuto
 
 ULONG SvxAutoCorrect::AutoCorrect( SvxAutoCorrDoc& rDoc, const String& rTxt,
 									xub_StrLen nInsPos, sal_Unicode cChar,
-									BOOL bInsert )
+									BOOL bInsert, bool bLockKeyOn )
 {
+    fprintf(stdout, "SvxAutoCorrect::AutoCorrect: --begin text = '%s' (lock key %s)\n",
+            rtl::OUStringToOString(rTxt, RTL_TEXTENCODING_UTF8).getStr(),
+            bLockKeyOn?"yes":"no");fflush(stdout);
+
 	ULONG nRet = 0;
 	do{		                            // only for middle check loop !!
 		if( cChar )
@@ -1383,6 +1437,12 @@ ULONG SvxAutoCorrect::AutoCorrect( SvxAu
 			if( IsAutoCorrFlag( ChgToEnEmDash ) &&
 				FnChgToEnEmDash( rDoc, rTxt, nCapLttrPos, nInsPos, eLang ) )
 				nRet |= ChgToEnEmDash;
+
+            if ( bLockKeyOn && IsAutoCorrFlag( CorrectCapsLock ) &&
+                 FnCorrectCapsLock( rDoc, rTxt, nCapLttrPos, nInsPos, eLang ) )
+                // Correct accidental use of cAPS LOCK key (do this only when 
+                // the caps or shift lock key is pressed).
+                nRet |= CorrectCapsLock;
 		}
 
 	} while( FALSE );
@@ -1426,7 +1486,7 @@ ULONG SvxAutoCorrect::AutoCorrect( SvxAu
 		}
 	}
 
-
+    fprintf(stdout, "SvxAutoCorrect::AutoCorrect: --end\n");fflush(stdout);
 	return nRet;
 }
 
Only in vcl: Debug
diff -urp --exclude=CVS --exclude=unxlngi6.pro --exclude=vcl.vpj vcl.clean/inc/vcl/event.hxx vcl/inc/vcl/event.hxx
--- vcl.clean/inc/vcl/event.hxx	2007-04-11 13:52:30.000000000 -0400
+++ vcl/inc/vcl/event.hxx	2008-02-26 12:26:46.000000000 -0500
@@ -74,16 +74,18 @@ class VCL_DLLPUBLIC KeyEvent
 private:
     KeyCode         maKeyCode;
     USHORT          mnRepeat;
+    BYTE            mnExtraMod;
     xub_Unicode     mnCharCode;
 
 public:
                     KeyEvent();
                     KeyEvent( xub_Unicode nChar, const KeyCode& rKeyCode,
-                              USHORT nRepeat = 0 );
+                              USHORT nRepeat = 0, BYTE nExtraMod = 0 );
 
     xub_Unicode     GetCharCode() const     { return mnCharCode; }
     const KeyCode&  GetKeyCode() const      { return maKeyCode;  }
     USHORT          GetRepeat() const       { return mnRepeat;   }
+    BYTE            GetExtraMod() const     { return mnExtraMod; }
 
     KeyEvent        LogicalTextDirectionality (TextDirectionality eMode) const;
                     KeyEvent (const KeyEvent& rKeyEvent);
@@ -94,15 +96,16 @@ inline KeyEvent::KeyEvent()
 {
     mnCharCode  = 0;
     mnRepeat    = 0;
+    mnExtraMod  = 0;
 }
 
 inline KeyEvent::KeyEvent( xub_Unicode nChar, const KeyCode& rKeyCode,
-                           USHORT nRepeat ) :
-            maKeyCode( rKeyCode )
-
+                           USHORT nRepeat, BYTE nExtraMod ) :
+            maKeyCode( rKeyCode ),
+            mnRepeat( nRepeat ),
+            mnExtraMod( nExtraMod ),
+            mnCharCode( nChar )
 {
-    mnCharCode  = nChar;
-    mnRepeat    = nRepeat;
 }
 
 // --------------------
diff -urp --exclude=CVS --exclude=unxlngi6.pro --exclude=vcl.vpj vcl.clean/inc/vcl/keycodes.hxx vcl/inc/vcl/keycodes.hxx
--- vcl.clean/inc/vcl/keycodes.hxx	2008-01-14 11:20:04.000000000 -0500
+++ vcl/inc/vcl/keycodes.hxx	2008-02-26 11:41:08.000000000 -0500
@@ -182,15 +182,18 @@
 #define KEY_ALLMODTYPE	((USHORT)0xF000)
 
 // extended Modifier-Keys (only used for modkey events)
-#define MODKEY_LSHIFT    0x0001
-#define MODKEY_RSHIFT    0x0002
-#define MODKEY_LMOD1     0x0004
-#define MODKEY_RMOD1     0x0008
-#define MODKEY_LMOD2     0x0010
-#define MODKEY_RMOD2     0x0020
-#define MODKEY_SHIFT     (MODKEY_LSHIFT|MODKEY_RSHIFT)
-#define MODKEY_MOD1      (MODKEY_LMOD1|MODKEY_RMOD1)
-#define MODKEY_MOD2      (MODKEY_LMOD2|MODKEY_RMOD2)
+#define MODKEY_LSHIFT       0x0001
+#define MODKEY_RSHIFT       0x0002
+#define MODKEY_LMOD1        0x0004
+#define MODKEY_RMOD1        0x0008
+#define MODKEY_LMOD2        0x0010
+#define MODKEY_RMOD2        0x0020
+#define MODKEY_CAPS_LOCK    0x0040
+#define MODKEY_SHIFT_LOCK   0x0080
+#define MODKEY_SHIFT        (MODKEY_LSHIFT|MODKEY_RSHIFT)
+#define MODKEY_MOD1         (MODKEY_LMOD1|MODKEY_RMOD1)
+#define MODKEY_MOD2         (MODKEY_LMOD2|MODKEY_RMOD2)
+#define MODKEY_LOCK         (MODKEY_CAPS_LOCK|MODKEY_SHIFT_LOCK)
 
 // ---------------
 // - Mouse-Types -
diff -urp --exclude=CVS --exclude=unxlngi6.pro --exclude=vcl.vpj vcl.clean/inc/vcl/salwtype.hxx vcl/inc/vcl/salwtype.hxx
--- vcl.clean/inc/vcl/salwtype.hxx	2007-10-09 11:18:22.000000000 -0400
+++ vcl/inc/vcl/salwtype.hxx	2008-02-26 10:52:26.000000000 -0500
@@ -140,6 +140,7 @@ struct SalKeyEvent
     USHORT          mnCode;         // SV-KeyCode (KEY_xxx | KEY_SHIFT | KEY_MOD1 | KEY_MOD2)
     USHORT          mnCharCode;     // SV-CharCode
     USHORT          mnRepeat;       // Repeat-Count (KeyInputs-1)
+    BYTE            mnExtraMod;
 };
 
 // MENUEVENT
diff -urp --exclude=CVS --exclude=unxlngi6.pro --exclude=vcl.vpj vcl.clean/source/window/winproc.cxx vcl/source/window/winproc.cxx
--- vcl.clean/source/window/winproc.cxx	2008-01-29 11:18:55.000000000 -0500
+++ vcl/source/window/winproc.cxx	2008-02-26 14:29:58.000000000 -0500
@@ -1034,7 +1034,7 @@ static Window* ImplGetKeyInputWindow( Wi
 // -----------------------------------------------------------------------
 
 static long ImplHandleKey( Window* pWindow, USHORT nSVEvent,
-                           USHORT nKeyCode, USHORT nCharCode, USHORT nRepeat, BOOL bForward )
+                           USHORT nKeyCode, USHORT nCharCode, USHORT nRepeat, BYTE nExtraMod, BOOL bForward )
 {
     ImplSVData* pSVData = ImplGetSVData();
     KeyCode     aKeyCode( nKeyCode, nKeyCode );
@@ -1043,7 +1043,7 @@ static long ImplHandleKey( Window* pWind
     // allow application key listeners to remove the key event
     // but make sure we're not forwarding external KeyEvents, (ie where bForward is FALSE)
     // becasue those are coming back from the listener itself and MUST be processed
-    KeyEvent aKeyEvent( (xub_Unicode)nCharCode, aKeyCode, nRepeat );
+    KeyEvent aKeyEvent( (xub_Unicode)nCharCode, aKeyCode, nRepeat, nExtraMod );
     if( bForward )
     {
         USHORT nVCLEvent;
@@ -1175,7 +1175,7 @@ static long ImplHandleKey( Window* pWind
     ImplDelData aDelData;
     pChild->ImplAddDel( &aDelData );
 
-	KeyEvent    aKeyEvt( (xub_Unicode)nCharCode, aKeyCode, nRepeat );
+	KeyEvent    aKeyEvt( (xub_Unicode)nCharCode, aKeyCode, nRepeat, nExtraMod );
     NotifyEvent aNotifyEvt( nSVEvent, pChild, &aKeyEvt );
     BOOL        bKeyPreNotify = (ImplCallPreNotify( aNotifyEvt ) != 0);
     long        nRet = 1;
@@ -1288,7 +1288,7 @@ static long ImplHandleKey( Window* pWind
 
         // call handler
         ImplDelData aChildDelData( pChild );
-        KeyEvent    aKEvt( (xub_Unicode)nCharCode, aKeyCode, nRepeat );
+        KeyEvent    aKEvt( (xub_Unicode)nCharCode, aKeyCode, nRepeat, nExtraMod );
         NotifyEvent aNEvt( nSVEvent, pChild, &aKEvt );
         BOOL        bPreNotify = (ImplCallPreNotify( aNEvt ) != 0);
         if ( aChildDelData.IsDelete() )
@@ -2392,28 +2392,28 @@ long ImplWindowFrameProc( Window* pWindo
             {
             SalKeyEvent* pKeyEvt = (SalKeyEvent*)pEvent;
             nRet = ImplHandleKey( pWindow, EVENT_KEYINPUT,
-                pKeyEvt->mnCode, pKeyEvt->mnCharCode, pKeyEvt->mnRepeat, TRUE );
+                pKeyEvt->mnCode, pKeyEvt->mnCharCode, pKeyEvt->mnRepeat, pKeyEvt->mnExtraMod, TRUE );
             }
             break;
         case SALEVENT_EXTERNALKEYINPUT:
             {
             KeyEvent* pKeyEvt = (KeyEvent*) pEvent;
             nRet = ImplHandleKey( pWindow, EVENT_KEYINPUT,
-                pKeyEvt->GetKeyCode().GetFullCode(), pKeyEvt->GetCharCode(), pKeyEvt->GetRepeat(), FALSE );
+                pKeyEvt->GetKeyCode().GetFullCode(), pKeyEvt->GetCharCode(), pKeyEvt->GetRepeat(), 0, FALSE );
             }
             break;
         case SALEVENT_KEYUP:
             {
             SalKeyEvent* pKeyEvt = (SalKeyEvent*)pEvent;
             nRet = ImplHandleKey( pWindow, EVENT_KEYUP,
-                pKeyEvt->mnCode, pKeyEvt->mnCharCode, pKeyEvt->mnRepeat, TRUE );
+                pKeyEvt->mnCode, pKeyEvt->mnCharCode, pKeyEvt->mnRepeat, pKeyEvt->mnExtraMod, TRUE );
             }
             break;
         case SALEVENT_EXTERNALKEYUP:
             {
             KeyEvent* pKeyEvt = (KeyEvent*) pEvent;
             nRet = ImplHandleKey( pWindow, EVENT_KEYUP,
-                pKeyEvt->GetKeyCode().GetFullCode(), pKeyEvt->GetCharCode(), pKeyEvt->GetRepeat(), FALSE );
+                pKeyEvt->GetKeyCode().GetFullCode(), pKeyEvt->GetCharCode(), pKeyEvt->GetRepeat(), 0, FALSE );
             }
             break;
         case SALEVENT_KEYMODCHANGE:
diff -urp --exclude=CVS --exclude=unxlngi6.pro --exclude=vcl.vpj vcl.clean/unx/gtk/window/gtkframe.cxx vcl/unx/gtk/window/gtkframe.cxx
--- vcl.clean/unx/gtk/window/gtkframe.cxx	2008-01-29 11:21:11.000000000 -0500
+++ vcl/unx/gtk/window/gtkframe.cxx	2008-02-26 14:31:19.000000000 -0500
@@ -84,9 +84,13 @@ using namespace com::sun::star;
 
 int GtkSalFrame::m_nFloats = 0;
 
-static USHORT GetKeyModCode( guint state )
+static USHORT GetKeyModCode( guint state, BYTE& rExtraMod )
 {
     USHORT nCode = 0;
+    rExtraMod = 0;
+    if ((state & GDK_LOCK_MASK))
+        rExtraMod |= MODKEY_LOCK;
+
     if( (state & GDK_SHIFT_MASK) )
         nCode |= KEY_SHIFT;
     if( (state & GDK_CONTROL_MASK)
@@ -108,7 +112,8 @@ static USHORT GetKeyModCode( guint state
 
 static USHORT GetMouseModCode( guint state )
 {
-    USHORT nCode = GetKeyModCode( state );
+    BYTE extmod;
+    USHORT nCode = GetKeyModCode( state, extmod );
     if( (state & GDK_BUTTON1_MASK) )
         nCode |= MOUSE_LEFT;
     if( (state & GDK_BUTTON2_MASK) )
@@ -367,7 +372,7 @@ void GtkSalFrame::doKeyCallback( guint s
             aEvent.mnCode	= GetKeyCode( updated_keyval );
         }
     }
-    aEvent.mnCode	|= GetKeyModCode( state );
+    aEvent.mnCode	|= GetKeyModCode( state, aEvent.mnExtraMod );
     
     if( bDown )
     {
@@ -2773,8 +2778,8 @@ gboolean GtkSalFrame::signalKey( GtkWidg
         pEvent->keyval == GDK_Meta_L || pEvent->keyval == GDK_Meta_R )
     {
 		SalKeyModEvent aModEvt;
-
-		USHORT nModCode = GetKeyModCode( pEvent->state );
+        BYTE nExtraMod;
+		USHORT nModCode = GetKeyModCode( pEvent->state, nExtraMod );
 
         aModEvt.mnModKeyCode = 0; // emit no MODKEYCHANGE events
         if( pEvent->type == GDK_KEY_PRESS && !pThis->m_nKeyModifiers )
