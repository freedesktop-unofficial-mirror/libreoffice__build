--- /dev/null	2007-05-04 18:54:36.000000000 +0800
+++ udkapi/com/sun/star/script/ModuleInfo.idl	2008-03-19 15:12:14.000000000 +0800
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: ModuleInfo.idl,v $
+ *
+ *  $Revision: 1.2 $
+ *
+ *  last change: $Author: rt $ $Date: 2006/05/05 10:14:46 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __com_sun_star_script_ModuleInfo_idl__
+#define __com_sun_star_script_ModuleInfo_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+//=============================================================================
+module com {  module sun {  module star { module script {
+interface XObjectProvider;
+struct ModuleInfo
+{
+	string ModuleName; 
+	string ModuleSource; 
+	XObjectProvider ModuleObjectProvider; 
+	short ModuleType; // string?
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
--- /dev/null	2007-05-04 18:54:36.000000000 +0800
+++ udkapi/com/sun/star/script/ModuleType.idl	2008-03-19 15:12:14.000000000 +0800
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: ModuleType.idl,v $
+ *
+ *  $Revision: 1.2 $
+ *
+ *  last change: $Author: rt $ $Date: 2006/05/05 10:14:46 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __com_sun_star_script_ModuleType_idl__
+#define __com_sun_star_script_ModuleType_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+//=============================================================================
+module com {  module sun {  module star { module script {
+published constants ModuleType
+{
+    const long Unknown = 0;
+    const long Normal = 1;  
+    const long Class = 2;
+    const long Form = 3;
+    const long Document = 4;
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
--- /dev/null	2007-05-04 18:54:36.000000000 +0800
+++ udkapi/com/sun/star/script/XObjectProvider.idl	2008-03-19 15:12:14.000000000 +0800
@@ -0,0 +1,52 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: XDefaultMethod.idl,v $
+ *
+ *  $Revision: 1.3 $
+ *
+ *  last change: $Author: vg $ $Date: 2006/11/02 16:34:45 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __com_sun_star_script_XObjectProvider_idl__
+#define __com_sun_star_script_XObjectProvider_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+module com { module sun { module star { module script {
+//==============================================================================
+interface XObjectProvider : ::com::sun::star::uno::XInterface
+{
+  any getObject();
+
+};
+
+};  };  };  };
+#endif
--- udkapi/com/sun/star/script/makefile.mk.orig	2008-03-19 15:03:09.000000000 +0800
+++ udkapi/com/sun/star/script/makefile.mk	2008-03-19 15:12:14.000000000 +0800
@@ -89,6 +89,9 @@ IDLFILES=\
 	XScriptEventsAttacher.idl\
 	XDefaultMethod.idl\
 	XDefaultProperty.idl\
+    ModuleInfo.idl\
+    ModuleType.idl\
+    XObjectProvider.idl\
 	DateType.idl\
 
 # ------------------------------------------------------------------
--- svx/source/msfilter/msvbasic.hxx.orig	2008-03-19 15:03:09.000000000 +0800
+++ svx/source/msfilter/msvbasic.hxx	2008-03-19 15:43:24.000000000 +0800
@@ -50,11 +50,13 @@
 #ifndef _DYNARY_HXX
 #include <tools/dynary.hxx>
 #endif
+#include <com/sun/star/script/ModuleType.hpp>
 #ifndef __SGI_STL_VECTOR
 #include <vector>
 #endif
 #include<map>
 
+using namespace ::com::sun::star::script::ModuleType;
 /* class VBA:
  * The VBA class provides a set of methods to handle Visual Basic For
  * Applications streams, the constructor is given the root ole2 stream
@@ -77,13 +79,13 @@ DECLARE_DYNARRAY(StringArray,String *)
 // #117718# define internal types to distinguish between
 // module types, form, class & normal
 // #i37965# DR 2004-12-03: add "Document", used in Excel for macros attached to sheet
-enum ModuleType { Unknown = 0, Normal, Class, Form, Document };
+//enum ModuleType { Unknown = 0, Normal, Class, Form, Document };
 
 // #117718# define map to hold types of module
 //
-
+typedef sal_Int32 ModType;
 typedef ::std::map< UniString,
-    ModuleType > ModuleTypeHash;
+    ModType > ModuleTypeHash;
 
 class VBA_Impl
 {
@@ -104,7 +106,7 @@ public:
     void Output(int len, const sal_uInt8 *data);
     //
     // #117718# member map of module names to types of module
-    ModuleType GetModuleType( const UniString& rModuleName );
+    ModType GetModuleType( const UniString& rModuleName );
 
     std::vector<String> maReferences;
 private:
--- svx/source/msfilter/svxmsbas.cxx.orig	2008-03-19 15:03:09.000000000 +0800
+++ svx/source/msfilter/svxmsbas.cxx	2008-03-19 15:46:59.000000000 +0800
@@ -88,6 +88,7 @@ using namespace com::sun::star::awt;
 
 #include <com/sun/star/container/XNameContainer.hpp>
 #include <com/sun/star/script/XLibraryContainer.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
 using namespace com::sun::star::container;
 using namespace com::sun::star::script;
 using namespace com::sun::star::uno;
@@ -319,7 +320,7 @@ BOOL SvxImportMSVBasic::ImportCode_Impl(
                 // is the same as the encoding for the names
                 // that are keys in the map used by GetModuleType method
                 const String &sOrigVBAModName = aVBA.GetStreamName( i );
-                ModuleType mType = aVBA.GetModuleType( sOrigVBAModName );
+                ModType mType = aVBA.GetModuleType( sOrigVBAModName );
 
                 rtl::OUString sClassRem( RTL_CONSTASCII_USTRINGPARAM( "Rem Attribute VBA_ModuleType=" ) );
 
@@ -327,23 +328,23 @@ BOOL SvxImportMSVBasic::ImportCode_Impl(
 
                 switch( mType )
                 {
-                    case Class:
+                    case ::com::sun::star::script::ModuleType::Class:
                         modeTypeComment = sClassRem +
                             ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAClassModule\n" ) );
                         break;
-                    case Form:
+                    case ::com::sun::star::script::ModuleType::Form:
                         modeTypeComment = sClassRem +
                             ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAFormModule\n" ) );
                         break;
-                    case Document:
+                    case ::com::sun::star::script::ModuleType::Document:
                         modeTypeComment = sClassRem +
                             ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBADocumentModule\n" ) );
                         break;
-                    case Normal:
+                    case ::com::sun::star::script::ModuleType::Normal:
                         modeTypeComment = sClassRem +
                             ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAModule\n" ) );
                         break;
-                    case Unknown:
+                    case ::com::sun::star::script::ModuleType::Unknown:
                         modeTypeComment = sClassRem +
                             ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAUnknown\n" ) );
                         break;
@@ -356,7 +357,7 @@ BOOL SvxImportMSVBasic::ImportCode_Impl(
 				if ( !bAsComment )
 				{
 					modeTypeComment = modeTypeComment + sVBAOption;
-					if ( mType == Class )
+					if ( mType == ::com::sun::star::script::ModuleType::Class )
 						modeTypeComment = modeTypeComment + sClassOption;
 
 				}
@@ -418,12 +419,36 @@ BOOL SvxImportMSVBasic::ImportCode_Impl(
 						aSource += rtl::OUString::createFromAscii("\nEnd Sub");
 				}
 				::rtl::OUString aModName( sModule );
-				if ( aSource.getLength() )
 				{
+                    Reference< script::XObjectProvider > xVBAObjectProvider;
+                    if( mType == ::com::sun::star::script::ModuleType::Document )
+                    {
+                        Reference< XMultiServiceFactory> xSF(rDocSh.GetModel(), UNO_QUERY);
+                        if ( xSF.is() )
+                        {
+                            try
+                            {
+                                uno::Sequence< uno::Any > aArgs(1);
+                                aArgs[0] = uno::Any( aModName );
+                                    xVBAObjectProvider.set( xSF->createInstanceWithArguments( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "org.openoffice.vba.VBAObjectModuleObjectProvider")), aArgs), UNO_QUERY );
+                            }
+                            catch( Exception& ) { }
+                        }
+                    }
 					aSource = modeTypeComment + aSource;
 
 					Any aSourceAny;
-					aSourceAny <<= aSource;
+                    if ( xVBAObjectProvider.is() && mType == ::com::sun::star::script::ModuleType::Document )
+                    {
+                        script::ModuleInfo sModuleInfo;
+                        sModuleInfo.ModuleName = aModName;
+                        sModuleInfo.ModuleSource = aSource;
+                        sModuleInfo.ModuleType == ::com::sun::star::script::ModuleType::Document;
+                        sModuleInfo.ModuleObjectProvider.set( xVBAObjectProvider, UNO_QUERY );
+                        aSourceAny <<= sModuleInfo;
+                    }
+                    else
+					    aSourceAny <<= aSource;
 					if( xLib->hasByName( aModName ) )
 						xLib->replaceByName( aModName, aSourceAny );
 					else
@@ -433,6 +458,8 @@ BOOL SvxImportMSVBasic::ImportCode_Impl(
 				bRet = true;
 			}
 		}
+        if( bRet )
+            rDocSh.GetBasic()->SetVBAEnabled( true );
 		SFX_APP()->LeaveBasicCall();
 	}
 	return bRet;
--- svx/source/msfilter/msvbasic.cxx.orig	2008-03-19 15:03:09.000000000 +0800
+++ svx/source/msfilter/msvbasic.cxx	2008-03-19 15:44:51.000000000 +0800
@@ -445,7 +445,7 @@ int VBA_Impl::ReadVBAProject(const SvSto
  *
 */
 
-ModuleType VBA_Impl::GetModuleType( const UniString& rModuleName )
+ModType VBA_Impl::GetModuleType( const UniString& rModuleName )
 {
     ModuleTypeHash::iterator iter = mhModHash.find( rModuleName );
     ModuleTypeHash::iterator iterEnd = mhModHash.end();
@@ -453,7 +453,7 @@ ModuleType VBA_Impl::GetModuleType( cons
     {
         return iter->second;
     }
-    return Unknown;
+    return ::com::sun::star::script::ModuleType::Unknown;
 }
 
 bool VBA_Impl::Open( const String &rToplevel, const String &rSublevel )
@@ -496,7 +496,7 @@ bool VBA_Impl::Open( const String &rTopl
         static const String sClass(     RTL_CONSTASCII_USTRINGPARAM( "Class" ) );
         static const String sBaseClass( RTL_CONSTASCII_USTRINGPARAM( "BaseClass" ) );
         static const String sDocument(  RTL_CONSTASCII_USTRINGPARAM( "Document" ) );
-        mhModHash[ sThisDoc ] = Class;
+        mhModHash[ sThisDoc ] = ::com::sun::star::script::ModuleType::Class;
         while ( pStp->ReadByteStringLine( tmp, meCharSet ) )
         {
             xub_StrLen index = tmp.Search( '=' );
@@ -506,14 +506,14 @@ bool VBA_Impl::Open( const String &rTopl
                 String value = tmp.Copy( index + 1 );
                 if ( key == sClass )
                 {
-                    mhModHash[ value ] = Class;
+                    mhModHash[ value ] = ::com::sun::star::script::ModuleType::Class;
                     OSL_TRACE("Module %s is of type Class",
                         ::rtl::OUStringToOString( value ,
                             RTL_TEXTENCODING_ASCII_US ).pData->buffer );
                 }
                 else if ( key == sBaseClass )
                 {
-                    mhModHash[ value ] =  Form;
+                    mhModHash[ value ] =  ::com::sun::star::script::ModuleType::Form;
                     OSL_TRACE("Module %s is of type Form",
                         ::rtl::OUStringToOString( value ,
                             RTL_TEXTENCODING_ASCII_US ).pData->buffer );
@@ -526,14 +526,14 @@ bool VBA_Impl::Open( const String &rTopl
                     // value is of form <name>/&H<identifier>, strip the identifier
                     value.Erase( value.Search( '/' ) );
 
-                    mhModHash[ value ] = Document;
+                    mhModHash[ value ] = ::com::sun::star::script::ModuleType::Document;
                     OSL_TRACE("Module %s is of type Document VBA",
                         ::rtl::OUStringToOString( value ,
                             RTL_TEXTENCODING_ASCII_US ).pData->buffer );
                 }
                 else if ( key == sModule )
                 {
-                    mhModHash[ value ] = Normal;
+                    mhModHash[ value ] = ::com::sun::star::script::ModuleType::Normal;
                     OSL_TRACE("Module %s is of type Normal VBA",
                         ::rtl::OUStringToOString( value ,
                             RTL_TEXTENCODING_ASCII_US ).pData->buffer );
--- sc/inc/servuno.hxx.orig	2008-03-19 15:03:09.000000000 +0800
+++ sc/inc/servuno.hxx	2008-03-19 15:12:14.000000000 +0800
@@ -103,7 +103,8 @@ class ScDocShell;
 #define SC_SERVICE_FORMULAPARS  38
 #define SC_SERVICE_OPCODEMAPPER 39
 
-#define SC_SERVICE_COUNT        40
+#define SC_SERVICE_VBAOBJECTPROVIDER   40
+#define SC_SERVICE_COUNT        41
 #define SC_SERVICE_INVALID		USHRT_MAX
 
 
--- sc/source/ui/unoobj/servuno.cxx.orig	2008-03-19 15:03:09.000000000 +0800
+++ sc/source/ui/unoobj/servuno.cxx	2008-03-19 15:12:14.000000000 +0800
@@ -77,8 +77,94 @@
 #include <svx/xmlgrhlp.hxx>
 #endif
 
+#include "scextopt.hxx"
+#include <com/sun/star/script/XObjectProvider.hpp>
+#include <comphelper/processfactory.hxx>
+
 using namespace ::com::sun::star;
 
+class ScVbaObjectProvider : public ::cppu::WeakImplHelper2< script::XObjectProvider, lang::XInitialization >
+{
+    ScDocShell* mpDocShell;
+    uno::Any aObj;
+    String msName;
+public:
+    ScVbaObjectProvider( const rtl::OUString& sName, ScDocShell* pDocShell ) : mpDocShell( pDocShell ), msName(sName) {}
+    ScVbaObjectProvider( ScDocShell* pDocShell ) : mpDocShell( pDocShell ) {}
+    virtual void SAL_CALL initialize( const uno::Sequence< uno::Any >& aArguments ) throw (uno::Exception, uno::RuntimeException)
+    {
+        OSL_TRACE("ScVbaObjectProvider::initialize ");
+        if(aArguments.getLength() != 1)
+        {
+            throw lang::IllegalArgumentException(rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("give a string instanciating this component!") ), static_cast< script::XObjectProvider * >(this), 0 );
+        }
+        rtl::OUString sName;
+        aArguments[0] >>= sName;
+        msName = sName;
+    }
+    virtual uno::Any SAL_CALL getObject() throw (uno::RuntimeException)
+    {
+        if ( !aObj.hasValue() )
+        {
+            BOOL bWorkbook = FALSE;
+            uno::Type aType;
+            uno::Reference<lang::XMultiServiceFactory> xSF(comphelper::getProcessServiceFactory());
+            uno::Reference<beans::XPropertySet> xProps(xSF, uno::UNO_QUERY);
+            if( xProps.is() )
+            {
+                ScDocument* pDoc = mpDocShell->GetDocument();
+                if ( !pDoc )
+                    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("")), uno::Reference< uno::XInterface >() );
+                String sGlobCodeName = pDoc->GetCodeName();
+                uno::Reference< uno::XInterface > xIf;
+
+                uno::Sequence< uno::Any > aArgs(2);
+                aArgs[0] = uno::Any( uno::Reference< uno::XInterface >() );
+                aArgs[1] = uno::Any( mpDocShell->GetModel() );
+                uno::Reference< uno::XInterface > xWorkbook( xSF->createInstanceWithArguments(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.excel.Workbook") ), aArgs ), uno::UNO_QUERY );
+                if( sGlobCodeName == msName )
+                {
+                    xIf.set( xWorkbook, uno::UNO_QUERY );
+                    bWorkbook = TRUE;
+                }
+                 else
+                 {
+                    String sCodeName;
+                    SCTAB nCount = pDoc->GetTableCount();
+                    for( SCTAB i = 0; i < nCount; i++ )
+                    {
+                        pDoc->GetCodeName( i, sCodeName );
+                        if( sCodeName == msName )
+                        {
+                            String sSheetName;
+                            if( pDoc->GetName( i, sSheetName ) )
+                            {
+                            uno::Reference< frame::XModel > xModel( mpDocShell->GetModel() );
+                            uno::Reference <sheet::XSpreadsheetDocument> xSpreadDoc( xModel, uno::UNO_QUERY_THROW );
+                            uno::Reference<sheet::XSpreadsheets > xSheets( xSpreadDoc->getSheets(), uno::UNO_QUERY_THROW );
+                            uno::Reference< container::XIndexAccess > xIndexAccess( xSheets, uno::UNO_QUERY_THROW );
+                            uno::Reference< sheet::XSpreadsheet > xSheet( xIndexAccess->getByIndex( i ), uno::UNO_QUERY_THROW );
+                            uno::Sequence< uno::Any > aArgs(3);
+                            aArgs[0] = uno::Any( xWorkbook );
+                            aArgs[1] = uno::Any( xModel );
+                            aArgs[2] = uno::Any( rtl::OUString( sSheetName ) );
+                            uno::Reference< uno::XInterface > xWorksheet( xSF->createInstanceWithArguments(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.excel.Worksheet") ), aArgs ), uno::UNO_QUERY );
+                            xIf.set( xWorksheet, uno::UNO_QUERY );
+                            bWorkbook = FALSE;
+                            break;
+                            }
+                        }
+                    }
+                 }
+                 if( xIf.is() )
+                 {
+                    aObj <<= xIf;
+                 }
+            }
+        }
+        return aObj;
+    }
+};
 
 //------------------------------------------------------------------------
 
@@ -128,7 +214,8 @@ static const sal_Char* __FAR_DATA aProvN
 
         SC_SERVICENAME_CHDATAPROV,                  // SC_SERVICE_CHDATAPROV
         SC_SERVICENAME_FORMULAPARS,                 // SC_SERVICE_FORMULAPARS
-        SC_SERVICENAME_OPCODEMAPPER                 // SC_SERVICE_OPCODEMAPPER
+        SC_SERVICENAME_OPCODEMAPPER,                 // SC_SERVICE_OPCODEMAPPER
+        "org.openoffice.vba.VBAObjectModuleObjectProvider",// SC_SERVICE_VBAOBJECTPROVIDER
 	};
 
 //
@@ -180,6 +267,7 @@ static const sal_Char* __FAR_DATA aOldNa
         "",                                         // SC_SERVICE_SHEETDOCSET
         "",                                         // SC_SERVICE_CHDATAPROV
         "",                                         // SC_SERVICE_FORMULAPARS
+        "",                                         // SC_SERVICE_VBAOBJECTPROVIDER
         ""                                          // SC_SERVICE_OPCODEMAPPER
 	};
 
@@ -373,6 +461,8 @@ uno::Reference<uno::XInterface> ScServic
         case SC_SERVICE_OPCODEMAPPER:
             xRet.set(static_cast<sheet::XFormulaOpCodeMapper*>(new ScFormulaOpCodeMapperObj));
             break;
+        case SC_SERVICE_VBAOBJECTPROVIDER:
+            xRet.set(static_cast<script::XObjectProvider*>(new ScVbaObjectProvider( pDocShell )));
 	}
 	return xRet;
 }
--- sc/source/ui/unoobj/makefile.mk.orig	2008-03-19 15:03:09.000000000 +0800
+++ sc/source/ui/unoobj/makefile.mk	2008-03-19 15:12:14.000000000 +0800
@@ -54,6 +54,7 @@ AUTOSEG=true
 .INCLUDE :  sc.mk
 .INCLUDE :  $(PRJ)$/util$/makefile.pmk
 
+INCPRE=$(INCCOM)$/vbaobj
 # --- Files --------------------------------------------------------
 SLO1FILES =  \
         $(SLO)$/docuno.obj \
--- basctl/source/basicide/scriptdocument.cxx.orig	2008-03-19 15:03:09.000000000 +0800
+++ basctl/source/basicide/scriptdocument.cxx	2008-03-19 15:12:14.000000000 +0800
@@ -61,6 +61,7 @@
 #include <com/sun/star/frame/XModel2.hpp>
 #include <com/sun/star/awt/XWindow2.hpp>
 #include <com/sun/star/document/XEmbeddedScripts.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
 /** === end UNO includes === **/
 
 #include <sfx2/objsh.hxx>
@@ -146,6 +147,7 @@ namespace basctl
     using ::com::sun::star::uno::RuntimeException;
     using ::com::sun::star::document::XEventBroadcaster;
     using ::com::sun::star::document::XEmbeddedScripts;
+    using ::com::sun::star::script::ModuleInfo;
     /** === end UNO using === **/
     namespace MacroExecMode = ::com::sun::star::document::MacroExecMode;
     namespace FrameSearchFlag = ::com::sun::star::frame::FrameSearchFlag;
@@ -678,6 +680,15 @@ namespace basctl
             }
 
 		    // insert element by new name in container
+            if ( _eType == E_SCRIPTS )
+            {
+                ModuleInfo sModuleInfo;
+                if ( aElement >>= sModuleInfo )
+                {
+                    sModuleInfo.ModuleName = _rNewName;
+                    aElement <<= sModuleInfo;
+                }
+            }
 		    xLib->insertByName( _rNewName, aElement );
             return true;
         }
@@ -1433,7 +1444,18 @@ namespace basctl
         Any aCode;
         if ( !m_pImpl->getModuleOrDialog( E_SCRIPTS, _rLibName, _rModName, aCode ) )
             return false;
-        OSL_VERIFY( aCode >>= _out_rModuleSource );
+        ModuleInfo sModuleInfo;
+        rtl::OUString sMod;
+        if ( aCode >>= sModuleInfo )
+        {
+            sMod = sModuleInfo.ModuleSource;
+        }
+        else
+        {
+            aCode >>= sMod;
+        }
+        Any aMod(sMod);
+        OSL_VERIFY( aMod >>= _out_rModuleSource );
         return true;
     }
 
--- /dev/null	2007-05-04 18:54:36.000000000 +0800
+++ basic/inc/basic/sbobjmod.hxx	2008-03-19 15:12:14.000000000 +0800
@@ -0,0 +1,67 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: sbobjmod.hxx,v $
+ *
+ *  $Revision: 1.4 $
+ *
+ *  last change: $Author:  $ $Date: 2007/08/27 16:31:39 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef _SB_OBJMOD_HXX
+#define _SB_OBJMOD_HXX
+
+#include <basic/sbmod.hxx>
+#include <basic/sbstar.hxx>
+#include <com/sun/star/script/ModuleInfo.hpp>
+
+// Basic-Module for excel object.
+
+class SbObjModule : public SbModule
+{
+    com::sun::star::script::ModuleInfo m_mInfo;
+    SbxObjectRef pDocObject; // a excel object.
+protected:
+	//virtual ~SbObjModule();
+    void InitObject( const XubString& rName );
+public:
+    TYPEINFO();
+	SBX_DECL_PERSIST_NODATA(SBXCR_SBX,SBXID_DOCUMENTMOD,2);
+    SbObjModule( const rtl::OUString& rName, const com::sun::star::script::ModuleInfo& mInfo );
+    virtual SbxVariable* Find( const XubString& rName, SbxClassType t );
+    virtual SbxVariable* GetObject();
+	virtual BOOL  IsClass( const String& );
+};
+#ifndef __SB_SBOBJMODULEREF_HXX
+#define __SB_SBOBJMODULEREF_HXX
+
+SV_DECL_IMPL_REF(SbObjModule);
+
+#endif
+#endif
+
--- basic/prj/d.lst.orig	2008-03-19 15:03:09.000000000 +0800
+++ basic/prj/d.lst	2008-03-19 15:12:14.000000000 +0800
@@ -27,6 +27,7 @@ mkdir: %_DEST%\inc%_EXT%\basic
 
 ..\inc\basic\sbdef.hxx %_DEST%\inc%_EXT%\basic\sbdef.hxx
 ..\inc\basic\sbmod.hxx %_DEST%\inc%_EXT%\basic\sbmod.hxx
+..\inc\basic\sbobjmod.hxx %_DEST%\inc%_EXT%\basic\sbobjmod.hxx
 ..\inc\basic\sbjsmod.hxx %_DEST%\inc%_EXT%\basic\sbjsmod.hxx
 ..\inc\basic\sbmeth.hxx %_DEST%\inc%_EXT%\basic\sbmeth.hxx
 ..\inc\basic\sbprop.hxx %_DEST%\inc%_EXT%\basic\sbprop.hxx
--- basic/source/classes/sbxmod.cxx.orig	2008-03-19 15:03:09.000000000 +0800
+++ basic/source/classes/sbxmod.cxx	2008-03-19 16:39:23.000000000 +0800
@@ -62,6 +62,9 @@
 #include "sbunoobj.hxx"
 #include <basic/hilight.hxx>
 #include <basic/basrdll.hxx>
+#include <basic/sbobjmod.hxx>
+#include <com/sun/star/script/XObjectProvider.hpp>
+#include <com/sun/star/lang/XServiceInfo.hpp>
 
 #ifndef _VOS_MUTEX_HXX_
 #include <vos/mutex.hxx>
@@ -88,6 +91,7 @@ TYPEINIT1(SbProperty,SbxProperty)
 TYPEINIT1(SbProcedureProperty,SbxProperty)
 TYPEINIT1(SbJScriptModule,SbModule)
 TYPEINIT1(SbJScriptMethod,SbMethod)
+TYPEINIT1(SbObjModule,SbModule)
 
 SV_DECL_VARARR(SbiBreakpoints,USHORT,4,4)
 SV_IMPL_VARARR(SbiBreakpoints,USHORT)
@@ -1903,6 +1907,79 @@ void SyntaxHighlighter::getHighlightPort
 	m_pSimpleTokenizer->getHighlightPortions( nLine, rLine, portions );
 }
 
+/////////////////////////////////////////////////////////////////////////
+SbObjModule::SbObjModule( const rtl::OUString& rName, const com::sun::star::script::ModuleInfo& mInfo )
+    :SbModule( rName ), pDocObject( NULL )
+{
+    m_mInfo = mInfo;
+    SetSource32( mInfo.ModuleSource );
+}
+
+BOOL
+SbObjModule::IsClass( const XubString& rName )
+{
+    GetObject();
+    return SbxObject::IsClass( rName );
+}
+
+SbxVariable*
+SbObjModule::GetObject() 
+{
+    if( !pDocObject )
+        InitObject( GetName() );
+    return pDocObject;
+}
+SbxVariable*
+SbObjModule::Find( const XubString& rName, SbxClassType t )
+{
+    OSL_TRACE("SbObjectModule find for %s", rtl::OUStringToOString(  rName, RTL_TEXTENCODING_UTF8 ).getStr() );
+    if ( !pDocObject )
+        InitObject( GetName() );
+    OSL_TRACE("!!!!try to find in derived module " );
+    SbxVariable* pVar = NULL;
+    if ( !pVar && pDocObject)
+    {
+        pVar = pDocObject->Find( rName, t );
+        if ( pVar )
+        {
+           OSL_TRACE("found in uno (psuedo-base) object" );
+        }
+        else
+           OSL_TRACE("NOT found in uno (psuedo-base) object" );
+    }
+    if ( !pVar )
+    {
+        pVar = SbModule::Find( rName, t );
+        if ( pVar )
+           OSL_TRACE("! found in (normal) module " );
+    }
+
+    return pVar;
+}
+
+void
+SbObjModule::InitObject( const XubString& rName )
+{
+    OSL_TRACE("Initialize pDocObject");
+    try
+    {
+        com::sun::star::uno::Reference< com::sun::star::script::XObjectProvider > xObjectProvider( m_mInfo.ModuleObjectProvider, com::sun::star::uno::UNO_QUERY_THROW );
+        com::sun::star::uno::Any aObject = xObjectProvider->getObject();
+        pDocObject = new SbUnoObject( rName, aObject );
+        com::sun::star::uno::Reference< com::sun::star::lang::XServiceInfo > xServiceInfo( aObject, com::sun::star::uno::UNO_QUERY_THROW );
+        if( xServiceInfo->supportsService( rtl::OUString::createFromAscii( "org.openoffice.excel.Worksheet" ) ) )
+        {
+            SetClassName( rtl::OUString::createFromAscii( "Worksheet" ) );
+        }
+        else if( xServiceInfo->supportsService( rtl::OUString::createFromAscii( "org.openoffice.excel.Workbook" ) ) )
+        {
+            SetClassName( rtl::OUString::createFromAscii( "Workbook" ) );
+        }
+    }catch( com::sun::star::uno::RuntimeException e )
+    {
+        OSL_TRACE("Object is not exist." );
+    }
+}
 
 /////////////////////////////////////////////////////////////////////////
 // Implementation SbJScriptModule (Basic-Modul fuer JavaScript-Sourcen)
--- basic/source/classes/sb.cxx.orig	2008-03-19 15:03:09.000000000 +0800
+++ basic/source/classes/sb.cxx	2008-03-19 15:12:14.000000000 +0800
@@ -70,6 +70,7 @@
 #include "disas.hxx"
 #include "runtime.hxx"
 #include <basic/sbuno.hxx>
+#include <basic/sbobjmod.hxx>
 #include "stdobj.hxx"
 #include "filefmt.hxx"
 #include "sb.hrc"
@@ -667,6 +668,7 @@ StarBASIC::StarBASIC( StarBASIC* p, BOOL
 	SetParent( p );
 	pLibInfo = NULL;
 	bNoRtl = bBreak = FALSE;
+    bVBAEnabled = FALSE;
 	pModules = new SbxArray;
 
 	if( !GetSbData()->nInst++ )
@@ -769,13 +771,21 @@ SbModule* StarBASIC::MakeModule( const S
 
 SbModule* StarBASIC::MakeModule32( const String& rName, const ::rtl::OUString& rSrc )
 {
-	SbModule* p = new SbModule( rName );
+    SbModule* p = new SbModule( rName );
 	p->SetSource32( rSrc );
 	p->SetParent( this );
 	pModules->Insert( p, pModules->Count() );
 	SetModified( TRUE );
 	return p;
 }
+SbModule* StarBASIC::MakeObjModule( const String& rName, const com::sun::star::script::ModuleInfo& mInfo )
+{
+    SbObjModule* p = new SbObjModule( rName, mInfo );
+	p->SetParent( this );
+	pModules->Insert( p, pModules->Count() );
+	SetModified( TRUE );
+    return p;
+}
 
 void StarBASIC::Insert( SbxVariable* pVar )
 {
@@ -948,6 +958,8 @@ SbxVariable* StarBASIC::Find( const Stri
 				}
 				pNamed = p;
 			}
+            if ( p->GetSbxId() == SBXID_DOCUMENTMOD )
+                 continue;
 			// Sonst testen, ob das Element vorhanden ist
 			// GBLSEARCH-Flag rausnehmen (wg. Rekursion)
 			USHORT nGblFlag = p->GetFlags() & SBX_GBLSEARCH;
--- basic/source/runtime/methods1.cxx.orig	2008-03-19 15:03:09.000000000 +0800
+++ basic/source/runtime/methods1.cxx	2008-03-19 15:12:14.000000000 +0800
@@ -60,6 +60,9 @@
 #ifndef _SBX_HXX
 #include <basic/sbx.hxx>
 #endif
+#ifndef _SBSTAR_HXX
+#include <basic/sbstar.hxx>
+#endif
 #ifndef _ZFORLIST_HXX //autogen
 #include <svtools/zforlist.hxx>
 #endif
@@ -86,6 +89,7 @@
 #endif
 
 #include <vcl/jobset.hxx>
+#include <basic/sbobjmod.hxx>
 
 #include "sbintern.hxx"
 #include "runtime.hxx"
@@ -2613,7 +2617,14 @@ RTLFUNC(Me)
 	SbClassModuleObject* pClassModuleObject = PTR_CAST(SbClassModuleObject,pActiveModule);
 	if( pClassModuleObject == NULL )
 	{
-		StarBASIC::Error( SbERR_INVALID_USAGE_OBJECT );
+        SbObjModule* pMod = PTR_CAST(SbObjModule,pActiveModule);
+        if ( pMod == NULL )
+		    StarBASIC::Error( SbERR_INVALID_USAGE_OBJECT );
+        else
+        {
+            SbxVariableRef refVar = rPar.Get(0);
+            refVar->PutObject( pMod );
+        }
 	}
 	else
 	{
--- basic/source/basmgr/basmgr.cxx.orig	2008-03-19 15:03:09.000000000 +0800
+++ basic/source/basmgr/basmgr.cxx	2008-03-19 15:28:47.000000000 +0800
@@ -102,6 +102,8 @@
 #include <com/sun/star/script/XStarBasicDialogInfo.hpp>
 #include <com/sun/star/script/XStarBasicLibraryInfo.hpp>
 #include <com/sun/star/script/XLibraryContainerPassword.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
+#include <com/sun/star/script/ModuleType.hpp>
 
 #include <cppuhelper/implbase1.hxx>
 
@@ -145,6 +147,7 @@ static const char* szScriptLanguage = "S
 static const String BasicStreamName( String::CreateFromAscii(szBasicStorage) );
 static const String ManagerStreamName( String::CreateFromAscii(szManagerStream) );
 
+//enum ModuleType { Unknown = 0, Normal, Class, Form, Document };
 
 #define	DEFINE_CONST_UNICODE(CONSTASCII)    UniString(RTL_CONSTASCII_USTRINGPARAM(CONSTASCII))
 
@@ -280,9 +283,22 @@ void BasMgrContainerListenerImpl::addLib
 		{
 			OUString aModuleName = pNames[ j ];
 			Any aElement = xLibNameAccess->getByName( aModuleName );
+            ModuleInfo mInfo;
 			OUString aMod;
-			aElement >>= aMod;
-			pLib->MakeModule32( aModuleName, aMod );
+            sal_Int16 mType;
+            if ( aElement >>= mInfo )
+            {
+                aMod = mInfo.ModuleSource;
+                mType = mInfo.ModuleType;
+                OSL_TRACE("#1 - aMod");
+                //pLib->MakeModule32( aModuleName, aMod, SBXID_DOCUMENTMOD );
+                pLib->MakeObjModule( aModuleName, mInfo );
+            }
+            else
+            {
+			    aElement >>= aMod;
+			    pLib->MakeModule32( aModuleName, aMod );
+            }
 		}
 	}
 
@@ -319,8 +335,16 @@ void SAL_CALL BasMgrContainerListenerImp
 	}
 	else
 	{
+        ModuleInfo mInfo;
 		OUString aMod;
-		Event.Element >>= aMod;
+        sal_Int16 mType;
+        if( Event.Element >>= mInfo )
+        {
+            aMod = mInfo.ModuleSource;
+            mType = mInfo.ModuleType;
+        }
+        else
+		    Event.Element >>= aMod;
 
 		StarBASIC* pLib = mpMgr->GetLib( maLibName );
 		DBG_ASSERT( pLib, "BasMgrContainerListenerImpl::elementInserted: Unknown lib!");
@@ -329,7 +353,15 @@ void SAL_CALL BasMgrContainerListenerImp
     		SbModule* pMod = pLib->FindModule( aName );
             if( !pMod )
             {
-			    pLib->MakeModule32( aName, aMod );
+                if ( mType == ::com::sun::star::script::ModuleType::Document )
+                {
+                    //pLib->MakeModule32( aName, aMod, SBXID_DOCUMENTMOD );
+                    pLib->MakeObjModule( aName, mInfo );
+                }
+                else
+                {
+			        pLib->MakeModule32( aName, aMod );
+                }
 			    pLib->SetModified( FALSE );
             }
 		}
@@ -356,12 +388,27 @@ void SAL_CALL BasMgrContainerListenerImp
 	if( pLib )
 	{
 		SbModule* pMod = pLib->FindModule( aName );
+        ModuleInfo mInfo;
 		OUString aMod;
+        sal_Int16 mType;
 		Event.Element >>= aMod;
 		if( pMod )
 			pMod->SetSource32( aMod );
 		else
-			pLib->MakeModule32( aName, aMod );
+        {
+            if( Event.Element >>= mInfo )
+            {
+                aMod = mInfo.ModuleSource;
+                mType = mInfo.ModuleType;
+                //pLib->MakeModule32( aName, aMod, SBXID_DOCUMENTMOD );
+                pLib->MakeObjModule( aName, mInfo );
+            }
+            else
+            {
+                Event.Element >>= aMod;
+			    pLib->MakeModule32( aName, aMod );
+            }
+        }
 
 		pLib->SetModified( FALSE );
 	}
--- basic/inc/basic/sbstar.hxx.orig	2008-03-19 15:03:09.000000000 +0800
+++ basic/inc/basic/sbstar.hxx	2008-03-19 15:12:14.000000000 +0800
@@ -51,6 +51,7 @@
 
 #include <basic/sbdef.hxx>
 #include <basic/sberrors.hxx>
+#include <com/sun/star/script/ModuleInfo.hpp>
 
 class SbModule;                     // fertiges Modul
 class SbiInstance;                  // Laufzeit-Instanz
@@ -82,6 +83,7 @@ class StarBASIC : public SbxObject
 	BOOL			bNoRtl;				// TRUE: RTL nicht durchsuchen
 	BOOL			bBreak;				// TRUE: Break, sonst Step
 	BOOL			bDocBasic;
+    BOOL            bVBAEnabled;
 	BasicLibInfo*	pLibInfo;			// Infoblock fuer Basic-Manager
 	SbLanguageMode	eLanguageMode;		// LanguageMode des Basic-Objekts
 protected:
@@ -124,7 +126,8 @@ public:
 
 	// Compiler-Interface
 	SbModule*   	MakeModule( const String& rName, const String& rSrc );
-    SbModule*   	MakeModule32( const String& rName, const ::rtl::OUString& rSrc );
+    SbModule*       MakeModule32( const String& rName, const ::rtl::OUString& rSrc );
+    SbModule*       MakeObjModule( const String& rName, const com::sun::star::script::ModuleInfo& mInfo );
 	BOOL			Compile( SbModule* );
 	BOOL 			Disassemble( SbModule*, String& rText );
 	static void 	Stop();
@@ -196,6 +199,8 @@ public:
 					( const String& rName, USHORT& rStatus );
 	static SbMethod* GetActiveMethod( USHORT nLevel = 0 );
 	static SbModule* GetActiveModule();
+    void SetVBAEnabled( BOOL bEnabled );
+    BOOL isVBAEnabled();
 
 	// #60175 TRUE: SFX-Resource wird bei Basic-Fehlern nicht angezogen
 	static void StaticSuppressSfxResource( BOOL bSuppress );
--- basic/inc/basic/sbdef.hxx.orig	2008-03-19 15:03:09.000000000 +0800
+++ basic/inc/basic/sbdef.hxx	2008-03-19 15:12:14.000000000 +0800
@@ -100,6 +100,7 @@ void setBasicWatchMode( bool bOn );
 
 #define SBXID_BASIC			0x6273			// sb: StarBASIC
 #define	SBXID_BASICMOD		0x6d62			// bm: StarBASIC-Modul
+#define SBXID_DOCUMENTMOD   0x6d63          // Special document Module
 #define SBXID_BASICPROP		0x7262			// pr: StarBASIC-Property
 #define	SBXID_BASICMETHOD	0x6d65          // me: StarBASIC-Methode
 #define	SBXID_JSCRIPTMOD	0x6a62			// jm: JavaScript-Modul
--- basic/source/uno/namecont.cxx.orig	2008-03-19 15:03:09.000000000 +0800
+++ basic/source/uno/namecont.cxx	2008-03-19 15:12:14.000000000 +0800
@@ -139,6 +139,9 @@
 #endif
 #include <basic/sbmod.hxx>
 
+#ifndef _COM_SUN_STAR_SCRIPT_MODULEINFO_HPP_
+#include <com/sun/star/script/ModuleInfo.hpp>
+#endif
 
 namespace basic
 {
@@ -217,7 +220,7 @@ void NameContainer::replaceByName( const
 	throw(IllegalArgumentException, NoSuchElementException, WrappedTargetException, RuntimeException)
 {
 	Type aAnyType = aElement.getValueType();
-	if( mType != aAnyType )
+    if( mType != aAnyType && aAnyType != getCppuType( static_cast< ModuleInfo* >( NULL ) ) )
 		throw IllegalArgumentException();
 
 	NameContainerNameMap::iterator aIt = mHashMap.find( aName );
@@ -259,7 +262,7 @@ void NameContainer::insertByName( const 
 	throw(IllegalArgumentException, ElementExistException, WrappedTargetException, RuntimeException)
 {
 	Type aAnyType = aElement.getValueType();
-	if( mType != aAnyType )
+    if( mType != aAnyType && aAnyType != getCppuType( static_cast< ModuleInfo* >( NULL ) ) )
 		throw IllegalArgumentException();
 
 	NameContainerNameMap::iterator aIt = mHashMap.find( aName );
--- sfx2/source/doc/docmacromode.cxx.orig	2008-03-19 15:03:09.000000000 +0800
+++ sfx2/source/doc/docmacromode.cxx	2008-03-19 15:12:14.000000000 +0800
@@ -45,6 +45,7 @@
 #include <com/sun/star/task/DocumentMacroConfirmationRequest.hpp>
 #include <com/sun/star/task/InteractionClassification.hpp>
 #include <com/sun/star/security/XDocumentDigitalSignatures.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
 /** === end UNO includes === **/
 
 #include <comphelper/componentcontext.hxx>
@@ -80,8 +81,11 @@ namespace sfx2
     using ::com::sun::star::document::XEmbeddedScripts;
     using ::com::sun::star::uno::UNO_SET_THROW;
     using ::com::sun::star::script::XLibraryContainer;
+    using ::com::sun::star::script::ModuleInfo;
     using ::com::sun::star::container::XNameAccess;
+    using ::com::sun::star::container::XNameContainer;
     using ::com::sun::star::uno::UNO_QUERY_THROW;
+    using ::com::sun::star::uno::Sequence;
 	/** === end UNO using === **/
     namespace MacroExecMode = ::com::sun::star::document::MacroExecMode;
 
@@ -427,7 +431,7 @@ namespace sfx2
                     bHasMacroLib = sal_False;
                 else
 			    {
-				    ::rtl::OUString aStdLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+				    ::rtl::OUString aStdLibName( ::rtl::OUString::intern( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) ) );
 				    Sequence< ::rtl::OUString > aElements = xContainer->getElementNames();
 				    if ( aElements.getLength() )
 				    {
@@ -447,8 +451,43 @@ namespace sfx2
 						    Any aAny = xContainer->getByName( aStdLibName );
 						    aAny >>= xLib;
 						    if ( xLib.is() )
+                            {
 							    bHasMacroLib = xLib->hasElements();
-					    }
+                                if( !bHasMacroLib )
+                                    return bHasMacroLib;
+                                // VBA will introduce some empty Object Module
+                                // If all module only include
+                                // "Rem Attribute VBA_ModuleType=VBADocumentModule\nOption VBASupport"
+                                // it should be set bHasMacros as false
+                                Sequence< ::rtl::OUString > sNames = xLib->getElementNames();
+                                Reference < XNameContainer > xNameContainer( xContainer->getByName( aStdLibName ), UNO_QUERY_THROW );
+                                sal_Int32 nCount = sNames.getLength();
+                                ::rtl::OUString sName;
+                                Any aCode;
+                                ModuleInfo sModuleInfo;
+                                ::rtl::OUString sMod;
+                                ::rtl::OUString sVbaOptiona( ::rtl::OUString::intern( RTL_CONSTASCII_USTRINGPARAM( "Rem Attribute VBA_ModuleType=VBADocumentModule\nOption VBASupport 1\n" )));
+                                ::rtl::OUString sVbaOptionb( ::rtl::OUString::intern( RTL_CONSTASCII_USTRINGPARAM( "\r\n" )));
+                                sVbaOptionb = sVbaOptiona + sVbaOptionb;
+                                for ( sal_Int32 nMod = 0; nMod < nCount; nMod++ )
+                                {
+                                    sName = sNames[nMod];
+                                    if ( xNameContainer->hasByName( sName ) )
+                                        aCode = xNameContainer->getByName( sName );
+                                    if ( aCode >>= sModuleInfo )
+                                    {
+                                        sMod = sModuleInfo.ModuleSource;
+                                        if ( sMod.getLength() && !( sMod.equals( sVbaOptiona ) || sMod.equals( sVbaOptionb ) ) )
+                                            return bHasMacroLib;
+                                    }
+                                    else
+                                    {
+                                        return bHasMacroLib;
+                                    }
+                                }
+                                bHasMacroLib = sal_False;
+					        }
+                        }
 				    }
 			    }
 		    }
--- basic/inc/basic/sbxobj.hxx.orig	2008-03-19 15:03:09.000000000 +0800
+++ basic/inc/basic/sbxobj.hxx	2008-03-19 15:12:14.000000000 +0800
@@ -80,7 +80,7 @@ public:
 	virtual SbxClassType GetClass() const;
 	virtual void Clear();
 
-	virtual BOOL  IsClass( const String& ) const;
+	virtual BOOL  IsClass( const String& );
 	const String& GetClassName() const { return aClassName; }
 	void		  SetClassName( const String &rNew ) { aClassName = rNew; }
 	// Default-Property
--- basic/source/sbx/sbxobj.cxx.orig	2008-03-19 15:03:09.000000000 +0800
+++ basic/source/sbx/sbxobj.cxx	2008-03-19 15:12:14.000000000 +0800
@@ -187,7 +187,7 @@ void SbxObject::SFX_NOTIFY( SfxBroadcast
 	}
 }
 
-BOOL SbxObject::IsClass( const XubString& rName ) const
+BOOL SbxObject::IsClass( const XubString& rName )
 {
 	return BOOL( aClassName.EqualsIgnoreCaseAscii( rName ) );
 }
--- sc/inc/document.hxx.orig	2008-03-19 15:03:23.000000000 +0800
+++ sc/inc/document.hxx	2008-03-19 15:12:14.000000000 +0800
@@ -308,6 +308,7 @@ private:
 
 	com::sun::star::uno::Sequence<sal_Int8>	aProtectPass;
 	String              aDocName;                       // opt: Dokumentname
+	String              aDocCodeName;                       // opt: Dokumentname
 	ScRangePairListRef	xColNameRanges;
 	ScRangePairListRef	xRowNameRanges;
 
@@ -451,6 +452,8 @@ public:
 
 	const String& 	GetName() const { return aDocName; }
 	void			SetName( const String& r ) { aDocName = r; }
+	const String& 	GetCodeName() const { return aDocCodeName; }
+	void			SetCodeName( const String& r ) { aDocCodeName = r; }
 
 	void			GetDocStat( ScDocStat& rDocStat );
 
@@ -538,6 +541,8 @@ SC_DLLPUBLIC	ScDBCollection*	GetDBCollec
 
 	BOOL			HasTable( SCTAB nTab ) const;
 	SC_DLLPUBLIC BOOL			GetName( SCTAB nTab, String& rName ) const;
+	SC_DLLPUBLIC BOOL			GetCodeName( SCTAB nTab, String& rName ) const;
+	SC_DLLPUBLIC BOOL			SetCodeName( SCTAB nTab, String& rName );
 	BOOL			GetTable( const String& rName, SCTAB& rTab ) const;
 	inline SCTAB	GetTableCount() const { return nMaxTableNumber; }
 	SvNumberFormatterIndexTable* GetFormatExchangeList() const { return pFormatExchangeList; }
--- sc/inc/table.hxx.orig	2008-03-19 15:03:23.000000000 +0800
+++ sc/inc/table.hxx	2008-03-19 15:12:14.000000000 +0800
@@ -104,6 +104,7 @@ private:
 	ScColumn		aCol[MAXCOLCOUNT];
 
 	String			aName;
+	String			aCodeName;
 	String			aComment;
 	BOOL			bScenario;
 	BOOL			bLayoutRTL;
@@ -237,6 +238,9 @@ public:
 	void		GetName( String& rName ) const;
 	void		SetName( const String& rNewName );
 
+	void		GetCodeName( String& rName ) const {  rName = aCodeName; }
+	void		SetCodeName( const String& rNewName ) { aCodeName = rNewName; }
+
     const String&   GetUpperName() const;
 
 	const String&	GetPageStyle() const					{ return aPageStyle; }
--- sc/source/core/data/document.cxx.orig	2008-03-19 15:03:23.000000000 +0800
+++ sc/source/core/data/document.cxx	2008-03-19 15:12:14.000000000 +0800
@@ -101,6 +101,7 @@
 #include "scextopt.hxx"
 #include "postit.hxx"
 
+
 struct ScDefaultAttr
 {
 	const ScPatternAttr*	pAttr;
@@ -155,6 +156,32 @@ BOOL ScDocument::GetName( SCTAB nTab, St
 	return FALSE;
 }
 
+BOOL ScDocument::SetCodeName( SCTAB nTab, String& rName ) 
+{
+	if (VALIDTAB(nTab))
+	{
+		if (pTab[nTab])
+		{
+			pTab[nTab]->SetCodeName( rName );
+			return TRUE;
+		}
+	}
+	OSL_TRACE( "**** can't set code name %s", rtl::OUStringToOString( rName, RTL_TEXTENCODING_UTF8 ).getStr() );
+	return FALSE;
+}
+
+BOOL ScDocument::GetCodeName( SCTAB nTab, String& rName ) const
+{
+	if (VALIDTAB(nTab))
+		if (pTab[nTab])
+		{
+			pTab[nTab]->GetCodeName( rName );
+			return TRUE;
+		}
+	rName.Erase();
+	return FALSE;
+}
+
 
 BOOL ScDocument::GetTable( const String& rName, SCTAB& rTab ) const
 {
@@ -280,7 +307,6 @@ void ScDocument::CreateValidTabName(Stri
 	}
 }
 
-
 BOOL ScDocument::InsertTab( SCTAB nPos, const String& rName,
 			BOOL bExternalDocument )
 {
@@ -294,12 +320,7 @@ BOOL ScDocument::InsertTab( SCTAB nPos, 
 		if (nPos == SC_TAB_APPEND || nPos == nTabCount)
 		{
 			pTab[nTabCount] = new ScTable(this, nTabCount, rName);
-			// if we are mapping codenames then a new tab always has has
-			// codename = sheetname
-			if ( pExtOptions && ( pExtOptions->GetCodeNameCount() > 0 ) )
-			{
-					pExtOptions->SetCodeName( rName, nTabCount );
-			}
+            pTab[nTabCount]->SetCodeName( rName );
 			++nMaxTableNumber;
 			if ( bExternalDocument )
 				pTab[nTabCount]->SetVisible( FALSE );
@@ -334,24 +355,10 @@ BOOL ScDocument::InsertTab( SCTAB nPos, 
 				for (i = nTabCount; i > nPos; i--)
 				{
 					pTab[i] = pTab[i - 1];
-					if ( pTab[i] && pExtOptions && ( pExtOptions->GetCodeNameCount() > 0 ) )
-					{
-						String sCodeName = pExtOptions->GetCodeName( i - 1 );
-						if ( sCodeName.Len() )
-						{
-							OSL_TRACE("Associating codeName %s with tab %d", rtl::OUStringToOString( sCodeName, RTL_TEXTENCODING_UTF8 ).getStr(), i );
-							pExtOptions->SetCodeName( sCodeName, i );
-						}
-					}
-				}
-
-				if ( pExtOptions && ( pExtOptions->GetCodeNameCount() > 0 ) )
-				{
-						OSL_TRACE("Inserting codeName %s with tab %d", rtl::OUStringToOString( rName, RTL_TEXTENCODING_UTF8 ).getStr(),nPos );
-						pExtOptions->SetCodeName( rName, nPos );
 				}
 
 				pTab[nPos] = new ScTable(this, nPos, rName);
+                pTab[nPos]->SetCodeName( rName );
 				++nMaxTableNumber;
 
 				for (i = 0; i <= MAXTAB; i++)
@@ -441,22 +448,7 @@ BOOL ScDocument::DeleteTab( SCTAB nTab, 
 				delete pTab[nTab];
 				for (i=nTab + 1; i < nTabCount; i++)
 				{
-					if ( pTab[i - 1 ] && pExtOptions && ( pExtOptions->GetCodeNameCount() > 0 ) )
-					{
-						String sCodeName = pExtOptions->GetCodeName( i );
-						if ( sCodeName.Len() )
-						{
-							OSL_TRACE("Associating codeName %s with tab %d", rtl::OUStringToOString( sCodeName, RTL_TEXTENCODING_UTF8 ).getStr(), i - 1 );
-							pExtOptions->SetCodeName( sCodeName, i - 1 );
-						}
-					}
 					pTab[i - 1] = pTab[i];
-
-				}
-				if ( pTab[i - 1 ] && pExtOptions && ( pExtOptions->GetCodeNameCount() > 0 ) )
-				{
-					OSL_TRACE("Deleting codename %s as %d", rtl::OUStringToOString(  pExtOptions->GetCodeName( nTabCount-1 ), RTL_TEXTENCODING_UTF8 ).getStr(),  nTabCount - 1 ) ;
-					pExtOptions->DeleteCodeName( nTabCount - 1 );
 				}
 
 				pTab[nTabCount - 1] = NULL;
--- sc/source/core/data/table1.cxx.orig	2008-03-19 15:03:23.000000000 +0800
+++ sc/source/core/data/table1.cxx	2008-03-19 15:12:14.000000000 +0800
@@ -130,6 +130,7 @@ extern BOOL bIsOlk, bOderSo;
 ScTable::ScTable( ScDocument* pDoc, SCTAB nNewTab, const String& rNewName,
 					BOOL bColInfo, BOOL bRowInfo ) :
 	aName( rNewName ),
+	aCodeName( rNewName ),
 	bScenario( FALSE ),
 	bLayoutRTL( FALSE ),
     bLoadingRTL( FALSE ),
--- sc/source/filter/excel/excdoc.cxx.orig	2008-03-19 15:03:23.000000000 +0800
+++ sc/source/filter/excel/excdoc.cxx	2008-03-19 15:12:14.000000000 +0800
@@ -168,7 +168,7 @@ void ExcTable::FillAsHeader( ExcBoundshe
 	String	aTmpString;
     SCTAB  nScTabCount     = rTabInfo.GetScTabCount();
     UINT16  nExcTabCount    = rTabInfo.GetXclTabCount();
-    UINT16  nCodenames      = static_cast< UINT16 >( GetExtDocOptions().GetCodeNameCount() );
+    UINT16  nCodenames      = nScTabCount;
 
 	rR.pObjRecs = NULL;				// per sheet
 
@@ -182,7 +182,7 @@ void ExcTable::FillAsHeader( ExcBoundshe
         if( HasVbaStorage() )
 		{
 			Add( new XclObproj );
-            const String& rCodeName = GetExtDocOptions().GetDocSettings().maGlobCodeName;
+            const String rCodeName = GetDoc().GetCodeName();
             if( rCodeName.Len() )
                 Add( new XclCodename( rCodeName ) );
 		}
@@ -403,8 +403,12 @@ void ExcTable::FillAsTable( size_t nCode
         Add( new XclExpCondFormatBuffer( GetRoot() ) );
 
         if( HasVbaStorage() )
-            if( nCodeNameIdx < GetExtDocOptions().GetCodeNameCount() )
-                Add( new XclCodename( GetExtDocOptions().GetCodeName( nCodeNameIdx ) ) );
+            if( nCodeNameIdx < GetTabInfo().GetScTabCount() )
+            {
+                String sCodeName;
+                rDoc.GetCodeName( nCodeNameIdx, sCodeName );
+                Add( new XclCodename( sCodeName ) );
+            }
 	}
 
     // list of HLINK records, generated by the cell table
@@ -429,7 +433,7 @@ void ExcTable::FillAsEmptyTable( size_t 
 {
     InitializeTable( mnScTab );
 
-    if( HasVbaStorage() && (nCodeNameIdx < GetExtDocOptions().GetCodeNameCount()) )
+    if( HasVbaStorage() && (nCodeNameIdx < GetTabInfo().GetScTabCount()) )
     {
         if( GetBiff() <= EXC_BIFF5 )
         {
@@ -438,7 +442,9 @@ void ExcTable::FillAsEmptyTable( size_t 
         else
         {
             Add( new ExcBof8 );
-            Add( new XclCodename( GetExtDocOptions().GetCodeName( nCodeNameIdx ) ) );
+            String sCodeName;
+            GetDoc().GetCodeName( nCodeNameIdx, sCodeName );
+            Add( new XclCodename( sCodeName  ) );
         }
         // sheet view settings: WINDOW2, SCL, PANE, SELECTION
         aRecList.AppendNewRecord( new XclExpTabViewSettings( GetRoot(), mnScTab ) );
@@ -480,7 +486,7 @@ void ExcDocument::ReadDoc( void )
     aHeader.FillAsHeader( maBoundsheetList );
 
     SCTAB nScTab = 0, nScTabCount = GetTabInfo().GetScTabCount();
-    size_t nCodeNameIdx = 0, nCodeNameCount = GetExtDocOptions().GetCodeNameCount();
+    size_t nCodeNameIdx = 0, nCodeNameCount = nScTabCount;
 
     for( ; nScTab < nScTabCount; ++nScTab )
     {
--- sc/source/filter/excel/xelink.cxx.orig	2008-03-19 15:03:23.000000000 +0800
+++ sc/source/filter/excel/xelink.cxx	2008-03-19 15:12:14.000000000 +0800
@@ -1296,7 +1296,6 @@ XclExpSupbookBuffer::XclExpSupbookBuffer
 {
     XclExpTabInfo& rTabInfo = GetTabInfo();
     sal_uInt16 nXclCnt = rTabInfo.GetXclTabCount();
-    sal_uInt16 nCodeCnt = static_cast< sal_uInt16 >( GetExtDocOptions().GetCodeNameCount() );
     size_t nCount = nXclCnt + rTabInfo.GetXclExtTabCount();
 
     DBG_ASSERT( nCount > 0, "XclExpSupbookBuffer::XclExpSupbookBuffer - no sheets to export" );
@@ -1305,7 +1304,7 @@ XclExpSupbookBuffer::XclExpSupbookBuffer
         maSBIndexVec.resize( nCount );
 
         // self-ref SUPBOOK first of list
-        XclExpSupbookRef xSupbook( new XclExpSupbook( GetRoot(), ::std::max( nXclCnt, nCodeCnt ) ) );
+        XclExpSupbookRef xSupbook( new XclExpSupbook( GetRoot(), nXclCnt ) );
         mnOwnDocSB = Append( xSupbook );
         for( sal_uInt16 nXclTab = 0; nXclTab < nXclCnt; ++nXclTab )
             maSBIndexVec[ nXclTab ].Set( mnOwnDocSB, nXclTab );
--- sc/source/filter/excel/xlocx.cxx.orig	2008-03-19 15:03:23.000000000 +0800
+++ sc/source/filter/excel/xlocx.cxx	2008-03-19 15:12:14.000000000 +0800
@@ -88,7 +88,7 @@
 #include <cppuhelper/bootstrap.hxx>
 #endif
 #include <sfx2/objsh.hxx>
-
+#include "document.hxx"
 using org::openoffice::vba::XVBAToOOEventDescGen;
 using com::sun::star::uno::XComponentContext;
 using com::sun::star::awt::XControl;
@@ -372,7 +372,9 @@ void XclImpOcxConverter::RegisterOleMacr
             if( StarBASIC* pBasic = pDocShell->GetBasic() )
             {
                 // Seach in the CodeName ( Module ) associated with this sheet
-                if( SbModule* pModule = dynamic_cast< SbModule* >( pBasic->Find( GetExtDocOptions().GetCodeName(rOcxCtrlObj.GetScTab() ), SbxCLASS_OBJECT ) ) )
+		String sCodeName;
+		GetDoc().GetCodeName( rOcxCtrlObj.GetScTab(), sCodeName );
+                if( SbModule* pModule = dynamic_cast< SbModule* >( pBasic->Find( sCodeName , SbxCLASS_OBJECT ) ) )
                 {
                     Reference<XComponentContext > xContext( ::cppu::defaultBootstrap_InitialComponentContext(), UNO_QUERY_THROW ); // Fatal error anyway
                     if ( SbxArray* pMethods = pModule->GetMethods() )
--- sc/source/filter/inc/excimp8.hxx.orig	2008-03-19 15:03:23.000000000 +0800
+++ sc/source/filter/inc/excimp8.hxx	2008-03-19 15:12:14.000000000 +0800
@@ -69,6 +69,7 @@ class XclImpStream;
 
 class ImportExcel8 : public ImportExcel
 {
+        SCTAB mnTab;
 	protected:
         ExcScenarioList         aScenList;
 
--- sc/source/ui/docshell/docsh.cxx.orig	2008-03-19 15:03:23.000000000 +0800
+++ sc/source/ui/docshell/docsh.cxx	2008-03-19 15:12:14.000000000 +0800
@@ -207,11 +207,8 @@ const static rtl::OUString sUrlPart2 = r
 	rtl::OUString sCodeName = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ThisWorkbook") );
 	if ( pShell )
 	{
-		if ( ScExtDocOptions* pExtDocOpts = pShell->GetDocument()->GetExtDocOptions() )
-		{
-			if ( pExtDocOpts->GetDocSettings().maGlobCodeName.Len() > 0 ) 
-				sCodeName = pExtDocOpts->GetDocSettings().maGlobCodeName;
-		}
+		if ( ScDocument* pDoc  = pShell->GetDocument() )
+			sCodeName = pDoc->GetCodeName();
 	}
 	return sCodeName;
 }	
--- sc/source/ui/view/tabview5.cxx.orig	2008-03-19 15:03:23.000000000 +0800
+++ sc/source/ui/view/tabview5.cxx	2008-03-19 15:12:14.000000000 +0800
@@ -347,10 +347,10 @@ void ScTabView::TabChanged()
 	aViewData.GetDocument()->BroadcastUno( SfxSimpleHint( SC_HINT_TABLECHANGED ) );
 	ScExtDocOptions* pExtOptions = aViewData.GetDocument()->GetExtDocOptions();
 	String sSheetModuleName;
-	aViewData.GetDocument()->GetName( aViewData.GetTabNo(), sSheetModuleName);
-	// Use code name if that exists
-	if ( pExtOptions )
-		sSheetModuleName = pExtOptions->GetCodeName( aViewData. GetTabNo() );
+	aViewData.GetDocument()->GetCodeName( aViewData.GetTabNo(), sSheetModuleName);
+	if ( !sSheetModuleName.Len() > 0 )
+		aViewData.GetDocument()->GetName( aViewData.GetTabNo(), sSheetModuleName);
+
 	static String sUrl( RTL_CONSTASCII_USTRINGPARAM("vnd.sun.star.script:Standard") );
 	static String sUrl2( RTL_CONSTASCII_USTRINGPARAM("?language=Basic&location=document") );
 	static String sSheetActivateScript( RTL_CONSTASCII_USTRINGPARAM("Worksheet_Activate") );
--- sc/source/filter/excel/excimp8.cxx.orig	2008-03-19 15:03:23.000000000 +0800
+++ sc/source/filter/excel/excimp8.cxx	2008-03-19 15:12:14.000000000 +0800
@@ -148,7 +148,7 @@ using namespace com::sun::star;
 
 
 ImportExcel8::ImportExcel8( XclImpRootData& rImpData, SvStream& rStrm ) :
-    ImportExcel( rImpData, rStrm )
+    ImportExcel( rImpData, rStrm ), mnTab(0)
 {
 	delete pFormConv;
 
@@ -290,9 +290,15 @@ void ImportExcel8::Codename( BOOL bWorkb
         if( aName.Len() )
         {
             if( bWorkbookGlobals )
-                GetExtDocOptions().GetDocSettings().maGlobCodeName = aName;
+            {
+                //GetExtDocOptions().GetDocSettings().maGlobCodeName = aName;
+                GetDoc().SetCodeName( aName );
+            }
             else
-                GetExtDocOptions().AppendCodeName( aName );
+            {
+                //GetExtDocOptions().AppendCodeName( aName );
+                GetDoc().SetCodeName( mnTab++, aName );
+            }
         }
 	}
 }
--- sc/source/ui/unoobj/viewuno.cxx.orig	2008-03-19 15:03:23.000000000 +0800
+++ sc/source/ui/unoobj/viewuno.cxx	2008-03-19 15:12:14.000000000 +0800
@@ -1778,10 +1778,8 @@ void ScTabViewObj::SelectionChanged()
 		{
 			ScExtDocOptions* pExtOptions = pViewData->GetDocument()->GetExtDocOptions();
 			String sSheetModuleName;
-			pViewData->GetDocument()->GetName( pViewData->GetTabNo(), sSheetModuleName);
 			// Use code name if that exists
-			if ( pExtOptions )
-				sSheetModuleName = pExtOptions->GetCodeName( pViewData->GetTabNo() );
+			pViewData->GetDocument()->GetName( pViewData->GetTabNo(), sSheetModuleName);
 			
 			String sSheetSelectionScript( RTL_CONSTASCII_USTRINGPARAM("Worksheet_SelectionChange") );
 			String sWorkBookSheetSelectionScript( RTL_CONSTASCII_USTRINGPARAM("Workbook_SheetSelectionChange") );
--- sc/source/ui/vba/vbaworksheet.cxx.orig	2008-03-19 15:03:23.000000000 +0800
+++ sc/source/ui/vba/vbaworksheet.cxx	2008-03-19 15:12:14.000000000 +0800
@@ -815,8 +815,10 @@ ScVbaWorksheet::getCodeName() throw (css
     {
         uno::Reference< frame::XModel > xModel( getModel(), uno::UNO_QUERY_THROW );
         ScDocument* pDoc = getDocShell( xModel )->GetDocument();
-        ScExtDocOptions* pExtOptions = pDoc->GetExtDocOptions();
-        rtl::OUString sCodeName = pExtOptions->GetCodeName( nTab );
+        /*ScExtDocOptions* pExtOptions = pDoc->GetExtDocOptions();
+        rtl::OUString sCodeName = pExtOptions->GetCodeName( nTab );*/
+        String sCodeName;
+        pDoc->GetCodeName( nTab, sCodeName );
         return sCodeName;
     }
     else
@@ -839,8 +841,10 @@ ScVbaWorksheet::setCodeName( const rtl::
     {
         uno::Reference< frame::XModel > xModel( getModel(), uno::UNO_QUERY_THROW );
         ScDocument* pDoc = getDocShell( xModel )->GetDocument();
-        ScExtDocOptions* pExtOptions = pDoc->GetExtDocOptions();
-        pExtOptions->SetCodeName( sCodeName, nTab );
+        /*ScExtDocOptions* pExtOptions = pDoc->GetExtDocOptions();
+        pExtOptions->SetCodeName( sCodeName, nTab );*/
+        String sNewCodeName( sCodeName );
+        pDoc->SetCodeName( nTab, sNewCodeName );
     }
     else
                throw uno::RuntimeException(::rtl::OUString(
--- sc/source/ui/vba/vbaworkbook.cxx.orig	2008-03-19 15:03:23.000000000 +0800
+++ sc/source/ui/vba/vbaworkbook.cxx	2008-03-19 15:12:14.000000000 +0800
@@ -471,9 +471,10 @@ ScVbaWorkbook::getCodeName() throw (css:
 #ifdef VBA_OOBUILD_HACK 
     uno::Reference< frame::XModel > xModel( getModel(), uno::UNO_QUERY_THROW );
     ScDocument* pDoc = getDocShell( xModel )->GetDocument();
-    ScExtDocOptions* pExtOptions = pDoc->GetExtDocOptions();
+    /*ScExtDocOptions* pExtOptions = pDoc->GetExtDocOptions();
     ScExtDocSettings pExtSettings = pExtOptions->GetDocSettings();
-    ::rtl::OUString sGlobCodeName = pExtSettings.maGlobCodeName;
+    ::rtl::OUString sGlobCodeName = pExtSettings.maGlobCodeName; */
+    ::rtl::OUString sGlobCodeName = pDoc->GetCodeName(); 
     return sGlobCodeName;
 #else
     throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
@@ -485,9 +486,10 @@ ScVbaWorkbook::setCodeName( const ::rtl:
 {
     uno::Reference< frame::XModel > xModel( getModel(), uno::UNO_QUERY_THROW );
     ScDocument* pDoc = getDocShell( xModel )->GetDocument();
-    ScExtDocOptions* pExtOptions = pDoc->GetExtDocOptions();
+    /*ScExtDocOptions* pExtOptions = pDoc->GetExtDocOptions();
     ScExtDocSettings pExtSettings = pExtOptions->GetDocSettings();
-    pExtSettings.maGlobCodeName = sGlobCodeName;
+    pExtSettings.maGlobCodeName = sGlobCodeName;*/
+    pDoc->SetCodeName( sGlobCodeName );
 #else
 void SAL_CALL
 ScVbaWorkbook::setCodeName( const ::rtl::OUString& ) throw (css::uno::RuntimeException)
--- basic/source/runtime/runtime.cxx.orig	2008-03-19 15:03:15.000000000 +0800
+++ basic/source/runtime/runtime.cxx	2008-03-19 15:12:14.000000000 +0800
@@ -82,6 +82,17 @@ void StarBASIC::StaticEnableReschedule( 
 {
     bStaticGlobalEnableReschedule = bReschedule;
 }
+void StarBASIC::SetVBAEnabled( BOOL bEnabled )
+{
+    bVBAEnabled = bEnabled;
+}
+
+BOOL StarBASIC::isVBAEnabled()
+{
+    if( SbiRuntime::isVBAEnabled() )
+        return TRUE;
+    return bVBAEnabled;
+}
 
 
 struct SbiArgvStack {					// Argv stack:
--- sc/source/ui/docshell/docfunc.cxx.orig	2008-03-19 15:03:15.000000000 +0800
+++ sc/source/ui/docshell/docfunc.cxx	2008-03-19 16:15:15.000000000 +0800
@@ -58,6 +58,12 @@
 #include <svtools/PasswordHelper.hxx>
 #endif
 
+#include <basic/sbstar.hxx>
+#include <com/sun/star/container/XNameContainer.hpp>
+#include <com/sun/star/script/XLibraryContainer.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
+#include <com/sun/star/script/ModuleType.hpp>
+
 #include <list>
 
 #include "docfunc.hxx"
@@ -101,6 +107,7 @@
 #include "scui_def.hxx" //CHINA001
 using namespace com::sun::star;
 
+
 // STATIC DATA -----------------------------------------------------------
 
 //========================================================================
@@ -2022,6 +2029,86 @@ BOOL ScDocFunc::MoveBlock( const ScRange
 }
 
 //------------------------------------------------------------------------
+script::ModuleInfo lcl_InitModuleInfo( ScDocShell& rDocSh, String& sModule )
+{
+    ::rtl::OUString aModName( sModule );
+    uno::Reference< lang::XMultiServiceFactory> xSF(rDocSh.GetModel(), uno::UNO_QUERY);
+    uno::Reference< script::XObjectProvider > xVBAObjectProvider;
+    if ( xSF.is() )
+    {
+        uno::Sequence< uno::Any > aArgs(1);
+        aArgs[0] = uno::Any( aModName );
+        xVBAObjectProvider.set( xSF->createInstanceWithArguments( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "org.openoffice.vba.VBAObjectModuleObjectProvider")), aArgs), uno::UNO_QUERY );    
+    }
+    script::ModuleInfo sModuleInfo;
+    ::rtl::OUString sVbaOption( RTL_CONSTASCII_USTRINGPARAM( "Rem Attribute VBA_ModuleType=VBADocumentModule\nOption VBASupport 1\n" ));
+    sModuleInfo.ModuleName = aModName;
+    sModuleInfo.ModuleSource = sVbaOption;
+    sModuleInfo.ModuleType = script::ModuleType::Document;
+    sModuleInfo.ModuleObjectProvider.set( xVBAObjectProvider, uno::UNO_QUERY );
+    return sModuleInfo;
+}
+
+void lcl_InsertModule( ScDocShell& rDocSh, SCTAB nTab, String& sModuleName )
+{
+    SFX_APP()->EnterBasicCall();
+    script::ModuleInfo sModuleInfo = lcl_InitModuleInfo(  rDocSh, sModuleName );
+    uno::Reference< script::XLibraryContainer > xLibContainer = rDocSh.GetBasicContainer();
+    DBG_ASSERT( xLibContainer.is(), "No BasicContainer!" );
+
+    uno::Reference< container::XNameContainer > xLib;
+    if( xLibContainer.is() )
+    {
+        String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+        uno::Any aLibAny = xLibContainer->getByName( aLibName );
+        aLibAny >>= xLib;
+    }
+    if( xLib.is() )
+    {
+        // test Module has exist
+        // if the Module is exist. changed to another name
+        // and at this time the string like "SheetX"
+        rtl::OUString sModuleName( sModuleInfo.ModuleName );
+        sal_Int32 nNum = 1;
+        while( xLib->hasByName( sModuleName ) )
+        {
+            sModuleName = rtl::OUString::createFromAscii( "Sheet" ) + rtl::OUString::valueOf( nNum );
+            nNum += 1;
+        }
+        sModuleInfo.ModuleName = sModuleName;
+        uno::Any aSourceAny;
+        aSourceAny <<= sModuleInfo;
+        xLib->insertByName( sModuleName, aSourceAny );
+        ScDocument* pDoc = rDocSh.GetDocument();
+        String sCodeName( sModuleName );
+        pDoc->SetCodeName( nTab, sCodeName );
+    }
+    SFX_APP()->LeaveBasicCall();
+}
+
+void lcl_DeleteModule( ScDocShell& rDocSh, String& sModuleName )
+{
+    SFX_APP()->EnterBasicCall();
+    uno::Reference< script::XLibraryContainer > xLibContainer = rDocSh.GetBasicContainer();
+    DBG_ASSERT( xLibContainer.is(), "No BasicContainer!" );
+
+    uno::Reference< container::XNameContainer > xLib;
+    if( xLibContainer.is() )
+    {
+        String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+        uno::Any aLibAny = xLibContainer->getByName( aLibName );
+        aLibAny >>= xLib;
+    }
+    if( xLib.is() )
+    {
+        if( xLib->hasByName( sModuleName ) )
+        {
+            xLib->removeByName( sModuleName );
+        }
+    }
+    SFX_APP()->LeaveBasicCall();
+}
+
 
 BOOL ScDocFunc::InsertTable( SCTAB nTab, const String& rName, BOOL bRecord, BOOL bApi )
 {
@@ -2031,8 +2118,12 @@ BOOL ScDocFunc::InsertTable( SCTAB nTab,
 	ScDocShellModificator aModificator( rDocShell );
 
 	ScDocument* pDoc = rDocShell.GetDocument();
+    StarBASIC* pStarBASIC = rDocShell.GetBasic();
+    BOOL bVbaEnabled = pStarBASIC->isVBAEnabled();
 	if (bRecord && !pDoc->IsUndoEnabled())
 		bRecord = FALSE;
+    if ( bVbaEnabled )
+        bRecord = FALSE;
 	if (bRecord)
 		pDoc->BeginDrawUndo();							//	InsertTab erzeugt ein SdrUndoNewPage
 
@@ -2047,6 +2138,11 @@ BOOL ScDocFunc::InsertTable( SCTAB nTab,
 			rDocShell.GetUndoManager()->AddUndoAction(
 						new ScUndoInsertTab( &rDocShell, nTab, bAppend, rName));
 		//	Views updaten:
+        if( bVbaEnabled )
+        {
+            String sCodeName( rName );
+            lcl_InsertModule( rDocShell, nTab, sCodeName );
+        }
 		rDocShell.Broadcast( ScTablesHint( SC_TAB_INSERTED, nTab ) );
 
 		rDocShell.PostPaintExtras();
@@ -2068,8 +2164,12 @@ BOOL ScDocFunc::DeleteTable( SCTAB nTab,
 
 	BOOL bSuccess = FALSE;
 	ScDocument* pDoc = rDocShell.GetDocument();
+    StarBASIC* pStarBASIC = rDocShell.GetBasic();
+    BOOL bVbaEnabled = pStarBASIC->isVBAEnabled();
 	if (bRecord && !pDoc->IsUndoEnabled())
 		bRecord = FALSE;
+    if ( bVbaEnabled )
+        bRecord = FALSE;
 	BOOL bWasLinked = pDoc->IsLinked(nTab);
 	ScDocument* pUndoDoc = NULL;
 	ScRefUndoData* pUndoData = NULL;
@@ -2110,6 +2210,8 @@ BOOL ScDocFunc::DeleteTable( SCTAB nTab,
 		pUndoData = new ScRefUndoData( pDoc );
 	}
 
+    String sCodeName;
+    BOOL bHasCodeName = pDoc->GetCodeName( nTab, sCodeName );
 	if (pDoc->DeleteTab( nTab, pUndoDoc ))
 	{
 		if (bRecord)
@@ -2120,6 +2222,13 @@ BOOL ScDocFunc::DeleteTable( SCTAB nTab,
 						new ScUndoDeleteTab( &rDocShell, theTabs, pUndoDoc, pUndoData ));
 		}
 		//	Views updaten:
+        if( bVbaEnabled )
+        {
+            if( bHasCodeName )
+            {
+                lcl_DeleteModule( rDocShell, sCodeName );
+            }
+        }
 		rDocShell.Broadcast( ScTablesHint( SC_TAB_DELETED, nTab ) );
 
 		if (bWasLinked)
--- basctl/source/basicide/basidesh.cxx.orig	2008-03-19 15:03:15.000000000 +0800
+++ basctl/source/basicide/basidesh.cxx	2008-03-20 13:34:01.000000000 +0800
@@ -97,6 +97,8 @@
 #ifndef _COM_SUN_STAR_CONTAINER_XNAMECONTAINER_HPP_
 #include <com/sun/star/container/XNameContainer.hpp>
 #endif
+#include <com/sun/star/container/XContainer.hpp>
+#include <com/sun/star/script/XLibraryContainer.hpp>
 
 #include <svx/xmlsecctrl.hxx>
 
@@ -104,7 +106,6 @@ using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star;
 using ::rtl::OUString;
 
-
 TYPEINIT1( BasicIDEShell, SfxViewShell );
 
 SFX_IMPL_VIEWFACTORY( BasicIDEShell, IDEResId( SVX_INTERFACE_BASIDE_VIEWSH ) )
@@ -258,6 +259,10 @@ __EXPORT BasicIDEShell::~BasicIDEShell()
 	delete pTabBar;
 	delete pObjectCatalog;
 	DestroyModulWindowLayout();
+
+    // Destroy all ContainerListeners for Basic Container.
+    removeContainerListener( m_aCurDocument );
+    
 	// MI: Das gab einen GPF im SDT beim Schliessen da dann der ViewFrame die
 	// ObjSh loslaesst. Es wusste auch keiner mehr wozu das gut war.
 	// GetViewFrame()->GetObjectShell()->Broadcast( SfxSimpleHint( SFX_HINT_DYING ) );
@@ -275,6 +280,7 @@ sal_Bool BasicIDEShell::HasBasic() const
 
 void BasicIDEShell::onDocumentCreated( const ScriptDocument& /*_rDocument*/ )
 {
+    // _rDocument is not a valid ScriptDocument.
     UpdateWindows();
 }
 
@@ -302,6 +308,64 @@ void BasicIDEShell::onDocumentSaveAsDone
 {
     // not interested in
 }
+// XEventListener
+//----------------------------------------------------------------------------
+void SAL_CALL BasicIDEShell::disposing( const lang::EventObject& /*Source*/ )
+    throw( uno::RuntimeException )
+{
+}
+
+// XContainerListener
+//----------------------------------------------------------------------------
+static const rtl::OUString sStandardLibName(  rtl::OUString::createFromAscii("Standard") );
+void SAL_CALL BasicIDEShell::elementInserted( const container::ContainerEvent& Event )
+    throw( uno::RuntimeException )
+{
+    rtl::OUString sModuleName;
+    if( Event.Accessor >>= sModuleName )
+    {
+        IDEBaseWindow* pWin = 0;
+        pWin = FindWindow( m_aCurDocument, sStandardLibName, sModuleName, BASICIDE_TYPE_MODULE, TRUE );
+    }
+}
+
+void SAL_CALL BasicIDEShell::elementReplaced( const container::ContainerEvent& Event )
+    throw( uno::RuntimeException )
+{
+    /* we don't interest here, because of the container 
+    make rename a module as delete old one and create a new one. */
+    (void)Event;
+}
+
+void SAL_CALL BasicIDEShell::elementRemoved( const container::ContainerEvent& Event )
+    throw( uno::RuntimeException )
+{
+    rtl::OUString sModuleName;
+    if( Event.Accessor >>= sModuleName )
+    {
+        IDEBaseWindow* pWin = FindWindow( m_aCurDocument, sStandardLibName, sModuleName, BASICIDE_TYPE_MODULE, TRUE );
+        if( pWin )
+            RemoveWindow( pWin, FALSE, TRUE );
+    }
+}
+void SAL_CALL BasicIDEShell::addContainerListener( const ScriptDocument& rScriptDocument )
+{
+    rtl::OUString sLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+    uno::Reference< container::XNameContainer > xNameContainer( rScriptDocument.getLibrary( E_SCRIPTS, sLibName, FALSE ) );
+    uno::Reference< container::XContainer > xContainer( xNameContainer, uno::UNO_QUERY_THROW );
+    uno::Reference< container::XContainerListener > xContainerListener( this );
+    xContainer->addContainerListener( xContainerListener );
+}
+void SAL_CALL BasicIDEShell::removeContainerListener( const ScriptDocument& rScriptDocument )
+{
+    rtl::OUString sLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+    uno::Reference< container::XNameContainer > xNameContainer( rScriptDocument.getLibrary( E_SCRIPTS, sLibName, FALSE ) );
+    uno::Reference< container::XContainer > xContainer( xNameContainer, uno::UNO_QUERY_THROW );
+    uno::Reference< container::XContainerListener > xContainerListener( this );
+    xContainer->removeContainerListener( xContainerListener );
+}
+
+//============================================================================
 
 void BasicIDEShell::onDocumentClosed( const ScriptDocument& _rDocument )
 {
@@ -402,7 +466,6 @@ void BasicIDEShell::StoreAllWindowData( 
 	}
 }
 
-
 USHORT __EXPORT BasicIDEShell::PrepareClose( BOOL bUI, BOOL bForBrowsing )
 {
 	(void)bForBrowsing;
@@ -600,7 +663,6 @@ void BasicIDEShell::ShowObjectDialog( BO
 }
 
 
-
 void __EXPORT BasicIDEShell::SFX_NOTIFY( SfxBroadcaster& rBC, const TypeId&,
 										const SfxHint& rHint, const TypeId& )
 {
@@ -680,8 +742,6 @@ void __EXPORT BasicIDEShell::SFX_NOTIFY(
     }
 }
 
-
-
 void BasicIDEShell::CheckWindows()
 {
 	BOOL bSetCurWindow = FALSE;
@@ -983,7 +1043,9 @@ void BasicIDEShell::SetCurLib( const Scr
 {
     if ( !bCheck || ( rDocument != m_aCurDocument || aLibName != m_aCurLibName ) )
     {
+        removeContainerListener( m_aCurDocument );
         m_aCurDocument = rDocument;
+        addContainerListener( m_aCurDocument );
         m_aCurLibName = aLibName;
         if ( bUpdateWindows )
             UpdateWindows();
--- sc/source/ui/view/viewfun2.cxx.orig	2008-03-19 15:03:15.000000000 +0800
+++ sc/source/ui/view/viewfun2.cxx	2008-03-19 15:12:14.000000000 +0800
@@ -62,6 +62,11 @@
 #include <vcl/sound.hxx>
 #include <vcl/waitobj.hxx>
 
+#include <basic/sbstar.hxx>
+#include <com/sun/star/container/XNameContainer.hpp>
+#include <com/sun/star/script/XLibraryContainer.hpp>
+using namespace com::sun::star;
+
 #include "viewfunc.hxx"
 
 #include "sc.hrc"
@@ -2091,15 +2096,42 @@ BOOL ScViewFunc::DeleteTable( SCTAB nTab
 	return bSuccess;
 }
 
+void lcl_DeleteModule( ScDocShell* rDocSh, String& sModuleName )
+{
+    SFX_APP()->EnterBasicCall();
+    uno::Reference< script::XLibraryContainer > xLibContainer = rDocSh->GetBasicContainer();
+    DBG_ASSERT( xLibContainer.is(), "No BasicContainer!" );
+
+    uno::Reference< container::XNameContainer > xLib;
+    if( xLibContainer.is() )
+    {
+        String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+        uno::Any aLibAny = xLibContainer->getByName( aLibName );
+        aLibAny >>= xLib;
+    }
+    if( xLib.is() )
+    {
+        if( xLib->hasByName( sModuleName ) )
+        {
+            xLib->removeByName( sModuleName );
+        }
+    }
+    SFX_APP()->LeaveBasicCall();
+}
+
 BOOL ScViewFunc::DeleteTables(const SvShorts &TheTabs, BOOL bRecord )
 {
 	ScDocShell* pDocSh	= GetViewData()->GetDocShell();
 	ScDocument* pDoc 	= pDocSh->GetDocument();
+    StarBASIC* pStarBASIC = pDocSh->GetBasic();
+    BOOL bVbaEnabled = pStarBASIC->isVBAEnabled();
 	SCTAB		nNewTab = TheTabs[0];
 	int			i;
 	WaitObject aWait( GetFrameWin() );
 	if (bRecord && !pDoc->IsUndoEnabled())
 		bRecord = FALSE;
+    if ( bVbaEnabled )
+        bRecord = FALSE;
 
 	while ( nNewTab > 0 && !pDoc->IsVisible( nNewTab ) )
 		--nNewTab;
@@ -2166,9 +2198,18 @@ BOOL ScViewFunc::DeleteTables(const SvSh
 
 	for(i=TheTabs.Count()-1;i>=0;i--)
 	{
+        String sCodeName;
+        BOOL bHasCodeName = pDoc->GetCodeName( TheTabs[sal::static_int_cast<USHORT>(i)], sCodeName );
         if (pDoc->DeleteTab( TheTabs[sal::static_int_cast<USHORT>(i)], pUndoDoc ))
 		{
 			bDelDone = TRUE;
+            if( bVbaEnabled )
+            {
+                if( bHasCodeName )
+                {
+                    lcl_DeleteModule( pDocSh, sCodeName );
+                }
+            }
             pDocSh->Broadcast( ScTablesHint( SC_TAB_DELETED, TheTabs[sal::static_int_cast<USHORT>(i)] ) );
 		}
 	}
@@ -2196,6 +2237,7 @@ BOOL ScViewFunc::DeleteTables(const SvSh
 		pDocSh->PostPaintExtras();
 		pDocSh->SetDocumentModified();
 
+
         SfxApplication* pSfxApp = SFX_APP();                                // Navigator
         pSfxApp->Broadcast( SfxSimpleHint( SC_HINT_TABLES_CHANGED ) );
         pSfxApp->Broadcast( SfxSimpleHint( SC_HINT_DBAREAS_CHANGED ) );
--- basctl/source/inc/basidesh.hxx.orig	2008-03-19 15:03:15.000000000 +0800
+++ basctl/source/inc/basidesh.hxx	2008-03-20 13:29:57.000000000 +0800
@@ -62,7 +62,8 @@
 #ifndef _COM_SUN_STAR_IO_XINPUTSTREAMPROVIDER_HXX_
 #include <com/sun/star/io/XInputStreamProvider.hpp>
 #endif
-
+#include <com/sun/star/container/XContainerListener.hpp>
+#include <cppuhelper/implbase1.hxx>
 
 //----------------------------------------------------------------------------
 
@@ -89,9 +90,11 @@ DECLARE_TABLE( IDEWindowTable, IDEBaseWi
 #else
 typedef Table IDEWindowTable;
 #endif
+typedef ::cppu::ImplHelper1<com::sun::star::container::XContainerListener> ContainerListenerHelper;
 
 class BasicIDEShell :public SfxViewShell
                     ,public ::basctl::DocumentEventListener
+                    ,public ContainerListenerHelper
 {
 friend class JavaDebuggingListenerImpl;
 friend class LocalizationMgr;
@@ -185,7 +188,25 @@ protected:
     virtual void onDocumentTitleChanged( const ScriptDocument& _rDocument );
     virtual void onDocumentModeChanged( const ScriptDocument& _rDocument );
 
+    void SAL_CALL addContainerListener( const ScriptDocument& pScriptDocument );
+    void SAL_CALL removeContainerListener( const ScriptDocument& pScriptDocument );
+
 public:
+    // XInterface
+    virtual void SAL_CALL acquire() throw () {}
+    virtual void SAL_CALL release() throw () {}
+    // XEventListener
+    virtual void SAL_CALL disposing( const com::sun::star::lang::EventObject& Source )
+        throw( com::sun::star::uno::RuntimeException );
+
+    // XContainerListener
+    virtual void SAL_CALL elementInserted( const com::sun::star::container::ContainerEvent& Event )
+        throw( com::sun::star::uno::RuntimeException );
+    virtual void SAL_CALL elementReplaced( const com::sun::star::container::ContainerEvent& Event )
+        throw( com::sun::star::uno::RuntimeException );
+    virtual void SAL_CALL elementRemoved( const com::sun::star::container::ContainerEvent& Event )
+        throw( com::sun::star::uno::RuntimeException );
+    
 						TYPEINFO();
 						SFX_DECL_INTERFACE( SVX_INTERFACE_BASIDE_VIEWSH )
 						SFX_DECL_VIEWFACTORY(BasicIDEShell);
--- basctl/source/basicide/basides2.cxx.orig	2008-03-19 15:03:15.000000000 +0800
+++ basctl/source/basicide/basides2.cxx	2008-03-19 15:12:14.000000000 +0800
@@ -252,9 +252,12 @@ ModulWindow* BasicIDEShell::CreateBasWin
 
         if ( bSuccess )
         {
-			// new module window
-			pWin = new ModulWindow( pModulLayout, rDocument, aLibName, aModName, aModule );
-			nKey = InsertWindowInTable( pWin );
+			pWin = FindBasWin( rDocument, aLibName, aModName, FALSE, TRUE );
+            if( !pWin )
+			{    // new module window
+			    pWin = new ModulWindow( pModulLayout, rDocument, aLibName, aModName, aModule );
+			    nKey = InsertWindowInTable( pWin );
+            }
         }
 	}
 	else
@@ -269,7 +272,8 @@ ModulWindow* BasicIDEShell::CreateBasWin
 		}
 		DBG_ASSERT( nKey, "CreateBasWin: Kein Key- Fenster nicht gefunden!" );
 	}
-	pTabBar->InsertPage( (USHORT)nKey, aModName );
+    if( nKey )
+	    pTabBar->InsertPage( (USHORT)nKey, aModName );
 	pTabBar->Sort();
 	pWin->GrabScrollBars( &aHScrollBar, &aVScrollBar );
 	if ( !pCurWin )
