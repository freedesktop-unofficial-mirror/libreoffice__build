--- /dev/null	2007-05-04 18:54:36.000000000 +0800
+++ udkapi/com/sun/star/script/ModuleInfo.idl	2007-11-30 11:46:33.000000000 +0800
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: ArrayWrapper.idl,v $
+ *
+ *  $Revision: 1.2 $
+ *
+ *  last change: $Author: rt $ $Date: 2006/05/05 10:14:46 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __com_sun_star_script_ModuleInfo_idl__
+#define __com_sun_star_script_ModuleInfo_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+//=============================================================================
+module com {  module sun {  module star { module script {
+interface XObjectProvider;
+struct ModuleInfo
+{
+	string ModuleName; 
+	string ModuleSource; 
+	XObjectProvider ModuleObjectProvider; 
+	short ModuleType; // string?
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
--- /dev/null	2007-05-04 18:54:36.000000000 +0800
+++ udkapi/com/sun/star/script/XObjectProvider.idl	2007-11-30 11:46:33.000000000 +0800
@@ -0,0 +1,52 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: XDefaultMethod.idl,v $
+ *
+ *  $Revision: 1.3 $
+ *
+ *  last change: $Author: vg $ $Date: 2006/11/02 16:34:45 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __com_sun_star_script_XObjectProvider_idl__
+#define __com_sun_star_script_XObjectProvider_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+module com { module sun { module star { module script {
+//==============================================================================
+interface XObjectProvider : ::com::sun::star::uno::XInterface
+{
+  any getObject();
+
+};
+
+};  };  };  };
+#endif
--- udkapi/com/sun/star/script/makefile.mk.bak	2007-11-30 10:24:01.000000000 +0800
+++ udkapi/com/sun/star/script/makefile.mk	2007-11-30 11:46:33.000000000 +0800
@@ -89,6 +89,8 @@ IDLFILES=\
 	XScriptEventsAttacher.idl\
 	XDefaultMethod.idl\
 	XDefaultProperty.idl\
+    ModuleInfo.idl\
+    XObjectProvider.idl\
 
 # ------------------------------------------------------------------
 
--- svx/source/msfilter/svxmsbas.cxx.bak	2007-11-30 10:24:01.000000000 +0800
+++ svx/source/msfilter/svxmsbas.cxx	2007-12-11 16:04:48.000000000 +0800
@@ -88,6 +88,7 @@ using namespace com::sun::star::awt;
 
 #include <com/sun/star/container/XNameContainer.hpp>
 #include <com/sun/star/script/XLibraryContainer.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
 using namespace com::sun::star::container;
 using namespace com::sun::star::script;
 using namespace com::sun::star::uno;
@@ -418,12 +419,37 @@ BOOL SvxImportMSVBasic::ImportCode_Impl(
 						aSource += rtl::OUString::createFromAscii("\nEnd Sub");
 				}
 				::rtl::OUString aModName( sModule );
-				if ( aSource.getLength() )
+				//if ( aSource.getLength() )
 				{
+                    Reference< script::XObjectProvider > xVBAObjectProvider;
+                    if( mType == Document )
+                    {
+                        Reference< XMultiServiceFactory> xSF(rDocSh.GetModel(), UNO_QUERY);
+                        if ( xSF.is() )
+                        {
+                            try
+                            {
+                                uno::Sequence< uno::Any > aArgs(1);
+                                aArgs[0] = uno::Any( aModName );
+                                    xVBAObjectProvider.set( xSF->createInstanceWithArguments( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "org.openoffice.vba.VBAObjectModuleObjectProvider")), aArgs), UNO_QUERY );
+                            }
+                            catch( Exception& ) { }
+                        }
+                    }
 					aSource = modeTypeComment + aSource;
 
 					Any aSourceAny;
-					aSourceAny <<= aSource;
+                    if ( xVBAObjectProvider.is() && mType == Document )
+                    {
+                        script::ModuleInfo sModuleInfo;
+                        sModuleInfo.ModuleName = aModName;
+                        sModuleInfo.ModuleSource = aSource;
+                        sModuleInfo.ModuleType == Document;
+                        sModuleInfo.ModuleObjectProvider.set( xVBAObjectProvider, UNO_QUERY );
+                        aSourceAny <<= sModuleInfo;
+                    }
+                    else
+					    aSourceAny <<= aSource;
 					if( xLib->hasByName( aModName ) )
 						xLib->replaceByName( aModName, aSourceAny );
 					else
@@ -433,6 +459,8 @@ BOOL SvxImportMSVBasic::ImportCode_Impl(
 				bRet = true;
 			}
 		}
+        if( bRet )
+            rDocSh.GetBasic()->SetVBAEnabled( true );
 		SFX_APP()->LeaveBasicCall();
 	}
 	return bRet;
--- sc/inc/servuno.hxx.bak	2007-11-30 10:24:01.000000000 +0800
+++ sc/inc/servuno.hxx	2007-11-30 11:46:33.000000000 +0800
@@ -103,7 +103,8 @@ class ScDocShell;
 #define SC_SERVICE_FORMULAPARS  38
 #define SC_SERVICE_OPCODEMAPPER 39
 
-#define SC_SERVICE_COUNT        40
+#define SC_SERVICE_VBAOBJECTPROVIDER   40
+#define SC_SERVICE_COUNT        41
 #define SC_SERVICE_INVALID		USHRT_MAX
 
 
--- sc/source/ui/unoobj/servuno.cxx.bak	2007-11-30 10:24:01.000000000 +0800
+++ sc/source/ui/unoobj/servuno.cxx	2007-11-30 11:46:33.000000000 +0800
@@ -77,8 +77,89 @@
 #include <svx/xmlgrhlp.hxx>
 #endif
 
+#include "scextopt.hxx"
+#include <com/sun/star/script/XObjectProvider.hpp>
+#include <comphelper/processfactory.hxx>
+
 using namespace ::com::sun::star;
 
+class ScVbaObjectProvider : public ::cppu::WeakImplHelper2< script::XObjectProvider, lang::XInitialization >
+{
+    ScDocShell* mpDocShell;
+    uno::Any aObj;
+    String msName;
+public:
+    ScVbaObjectProvider( const rtl::OUString& sName, ScDocShell* pDocShell ) : mpDocShell( pDocShell ), msName(sName) {}
+    ScVbaObjectProvider( ScDocShell* pDocShell ) : mpDocShell( pDocShell ) {}
+    virtual void SAL_CALL initialize( const uno::Sequence< uno::Any >& aArguments ) throw (uno::Exception, uno::RuntimeException)
+    {
+        OSL_TRACE("ScVbaObjectProvider::initialize ");
+        if(aArguments.getLength() != 1)
+        {
+            throw lang::IllegalArgumentException(rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("give a string instanciating this component!") ), static_cast< script::XObjectProvider * >(this), 0 );
+        }
+        rtl::OUString sName;
+        aArguments[0] >>= sName;
+        msName = sName;
+    }
+    virtual uno::Any SAL_CALL getObject() throw (uno::RuntimeException)
+    {
+        if ( !aObj.hasValue() )
+        {
+            uno::Reference<lang::XMultiServiceFactory> xSF(comphelper::getProcessServiceFactory());
+            uno::Reference<beans::XPropertySet> xProps(xSF, uno::UNO_QUERY);
+            if( xProps.is() )
+            {
+                ScDocument* pDoc = mpDocShell->GetDocument();
+                if ( !pDoc )
+                    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("")), uno::Reference< uno::XInterface >() );
+                String sGlobCodeName = pDoc->GetCodeName();
+                uno::Reference< uno::XInterface > xIf;
+
+                uno::Sequence< uno::Any > aArgs(2);
+                aArgs[0] = uno::Any( uno::Reference< uno::XInterface >() );
+                aArgs[1] = uno::Any( mpDocShell->GetModel() );
+                uno::Reference< uno::XInterface > xWorkbook( xSF->createInstanceWithArguments(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.excel.Workbook") ), aArgs ), uno::UNO_QUERY );
+                if( sGlobCodeName == msName )
+                {
+                    xIf.set( xWorkbook, uno::UNO_QUERY );
+                }
+                 else
+                 {
+                    String sCodeName;
+                    SCTAB nCount = pDoc->GetTableCount();
+                    for( SCTAB i = 0; i < nCount; i++ )
+                    {
+                        pDoc->GetCodeName( i, sCodeName );
+                        if( sCodeName == msName )
+                        {
+                            String sSheetName;
+                            if( pDoc->GetName( i, sSheetName ) )
+                            {
+                            uno::Reference< frame::XModel > xModel( mpDocShell->GetModel() );
+                            uno::Reference <sheet::XSpreadsheetDocument> xSpreadDoc( xModel, uno::UNO_QUERY_THROW );
+                            uno::Reference<sheet::XSpreadsheets > xSheets( xSpreadDoc->getSheets(), uno::UNO_QUERY_THROW );
+                            uno::Reference< container::XIndexAccess > xIndexAccess( xSheets, uno::UNO_QUERY_THROW );
+                            uno::Reference< sheet::XSpreadsheet > xSheet( xIndexAccess->getByIndex( i ), uno::UNO_QUERY_THROW );
+                            uno::Sequence< uno::Any > aArgs(3);
+                            aArgs[0] = uno::Any( xWorkbook );
+                            aArgs[1] = uno::Any( xModel );
+                            aArgs[2] = uno::Any( rtl::OUString( sSheetName ) );
+                            xIf.set( xSF->createInstanceWithArguments(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.excel.Worksheet") ), aArgs ), uno::UNO_QUERY );
+                            break;
+                            }
+                        }
+                    }
+                 }
+                 if( xIf.is() )
+                 {
+                    aObj <<= xIf;
+                 }
+            }
+        }
+        return aObj;
+    }
+};
 
 //------------------------------------------------------------------------
 
@@ -128,7 +209,8 @@ static const sal_Char* __FAR_DATA aProvN
 
         SC_SERVICENAME_CHDATAPROV,                  // SC_SERVICE_CHDATAPROV
         SC_SERVICENAME_FORMULAPARS,                 // SC_SERVICE_FORMULAPARS
-        SC_SERVICENAME_OPCODEMAPPER                 // SC_SERVICE_OPCODEMAPPER
+        SC_SERVICENAME_OPCODEMAPPER,                 // SC_SERVICE_OPCODEMAPPER
+        "org.openoffice.vba.VBAObjectModuleObjectProvider",// SC_SERVICE_VBAOBJECTPROVIDER
 	};
 
 //
@@ -180,6 +262,7 @@ static const sal_Char* __FAR_DATA aOldNa
         "",                                         // SC_SERVICE_SHEETDOCSET
         "",                                         // SC_SERVICE_CHDATAPROV
         "",                                         // SC_SERVICE_FORMULAPARS
+        "",                                         // SC_SERVICE_VBAOBJECTPROVIDER
         ""                                          // SC_SERVICE_OPCODEMAPPER
 	};
 
@@ -373,6 +456,8 @@ uno::Reference<uno::XInterface> ScServic
         case SC_SERVICE_OPCODEMAPPER:
             xRet.set(static_cast<sheet::XFormulaOpCodeMapper*>(new ScFormulaOpCodeMapperObj));
             break;
+        case SC_SERVICE_VBAOBJECTPROVIDER:
+            xRet.set(static_cast<script::XObjectProvider*>(new ScVbaObjectProvider( pDocShell )));
 	}
 	return xRet;
 }
--- sc/source/ui/unoobj/makefile.mk.bak	2007-11-30 10:24:01.000000000 +0800
+++ sc/source/ui/unoobj/makefile.mk	2007-11-30 11:46:33.000000000 +0800
@@ -54,6 +54,7 @@ AUTOSEG=true
 .INCLUDE :  sc.mk
 .INCLUDE :  $(PRJ)$/util$/makefile.pmk
 
+INCPRE=$(INCCOM)$/vbaobj
 # --- Files --------------------------------------------------------
 SLO1FILES =  \
         $(SLO)$/docuno.obj \
--- basctl/source/basicide/scriptdocument.cxx.bak	2007-11-30 10:24:02.000000000 +0800
+++ basctl/source/basicide/scriptdocument.cxx	2007-12-17 12:02:46.000000000 +0800
@@ -61,6 +61,7 @@
 #include <com/sun/star/frame/XModel2.hpp>
 #include <com/sun/star/awt/XWindow2.hpp>
 #include <com/sun/star/document/XEmbeddedScripts.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
 /** === end UNO includes === **/
 
 #include <sfx2/objsh.hxx>
@@ -146,6 +147,7 @@ namespace basctl
     using ::com::sun::star::uno::RuntimeException;
     using ::com::sun::star::document::XEventBroadcaster;
     using ::com::sun::star::document::XEmbeddedScripts;
+    using ::com::sun::star::script::ModuleInfo;
     /** === end UNO using === **/
     namespace MacroExecMode = ::com::sun::star::document::MacroExecMode;
     namespace FrameSearchFlag = ::com::sun::star::frame::FrameSearchFlag;
@@ -678,6 +680,15 @@ namespace basctl
             }
 
 		    // insert element by new name in container
+            if ( _eType == E_SCRIPTS )
+            {
+                ModuleInfo sModuleInfo;
+                if ( aElement >>= sModuleInfo )
+                {
+                    sModuleInfo.ModuleName = _rNewName;
+                    aElement <<= sModuleInfo;
+                }
+            }
 		    xLib->insertByName( _rNewName, aElement );
             return true;
         }
@@ -1433,7 +1444,18 @@ namespace basctl
         Any aCode;
         if ( !m_pImpl->getModuleOrDialog( E_SCRIPTS, _rLibName, _rModName, aCode ) )
             return false;
-        OSL_VERIFY( aCode >>= _out_rModuleSource );
+        ModuleInfo sModuleInfo;
+        rtl::OUString sMod;
+        if ( aCode >>= sModuleInfo )
+        {
+            sMod = sModuleInfo.ModuleSource;
+        }
+        else
+        {
+            aCode >>= sMod;
+        }
+        Any aMod(sMod);
+        OSL_VERIFY( aMod >>= _out_rModuleSource );
         return true;
     }
 
--- /dev/null	2007-05-04 18:54:36.000000000 +0800
+++ basic/inc/basic/sbobjmod.hxx	2007-11-30 11:46:33.000000000 +0800
@@ -0,0 +1,67 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: sbobjmod.hxx,v $
+ *
+ *  $Revision: 1.4 $
+ *
+ *  last change: $Author:  $ $Date: 2007/08/27 16:31:39 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef _SB_OBJMOD_HXX
+#define _SB_OBJMOD_HXX
+
+#include <basic/sbmod.hxx>
+#include <basic/sbstar.hxx>
+#include <com/sun/star/script/ModuleInfo.hpp>
+
+// Basic-Module for excel object.
+
+class SbObjModule : public SbModule
+{
+    com::sun::star::script::ModuleInfo m_mInfo;
+    SbxObjectRef pDocObject; // a excel object.
+protected:
+	//virtual ~SbObjModule();
+    void InitObject( const XubString& rName );
+public:
+    TYPEINFO();
+	SBX_DECL_PERSIST_NODATA(SBXCR_SBX,SBXID_DOCUMENTMOD,2);
+    SbObjModule( const rtl::OUString& rName, const com::sun::star::script::ModuleInfo& mInfo );
+    virtual SbxVariable* Find( const XubString& rName, SbxClassType t );
+    virtual SbxVariable* GetObject();
+    virtual void SetCodeName( const XubString& rName );
+};
+#ifndef __SB_SBOBJMODULEREF_HXX
+#define __SB_SBOBJMODULEREF_HXX
+
+SV_DECL_IMPL_REF(SbObjModule);
+
+#endif
+#endif
+
--- basic/prj/d.lst.bak	2007-11-30 10:24:02.000000000 +0800
+++ basic/prj/d.lst	2007-11-30 11:46:33.000000000 +0800
@@ -27,6 +27,7 @@ mkdir: %_DEST%\inc%_EXT%\basic
 
 ..\inc\basic\sbdef.hxx %_DEST%\inc%_EXT%\basic\sbdef.hxx
 ..\inc\basic\sbmod.hxx %_DEST%\inc%_EXT%\basic\sbmod.hxx
+..\inc\basic\sbobjmod.hxx %_DEST%\inc%_EXT%\basic\sbobjmod.hxx
 ..\inc\basic\sbjsmod.hxx %_DEST%\inc%_EXT%\basic\sbjsmod.hxx
 ..\inc\basic\sbmeth.hxx %_DEST%\inc%_EXT%\basic\sbmeth.hxx
 ..\inc\basic\sbprop.hxx %_DEST%\inc%_EXT%\basic\sbprop.hxx
--- basic/source/classes/sbxmod.cxx.bak	2007-11-30 10:24:02.000000000 +0800
+++ basic/source/classes/sbxmod.cxx	2007-11-30 11:46:33.000000000 +0800
@@ -62,6 +62,8 @@
 #include "sbunoobj.hxx"
 #include <basic/hilight.hxx>
 #include <basic/basrdll.hxx>
+#include <basic/sbobjmod.hxx>
+#include <com/sun/star/script/XObjectProvider.hpp>
 
 #ifndef _VOS_MUTEX_HXX_
 #include <vos/mutex.hxx>
@@ -88,6 +90,7 @@ TYPEINIT1(SbProperty,SbxProperty)
 TYPEINIT1(SbProcedureProperty,SbxProperty)
 TYPEINIT1(SbJScriptModule,SbModule)
 TYPEINIT1(SbJScriptMethod,SbMethod)
+TYPEINIT1(SbObjModule,SbModule)
 
 SV_DECL_VARARR(SbiBreakpoints,USHORT,4,4)
 SV_IMPL_VARARR(SbiBreakpoints,USHORT)
@@ -1903,6 +1906,64 @@ void SyntaxHighlighter::getHighlightPort
 	m_pSimpleTokenizer->getHighlightPortions( nLine, rLine, portions );
 }
 
+/////////////////////////////////////////////////////////////////////////
+SbObjModule::SbObjModule( const rtl::OUString& rName, const com::sun::star::script::ModuleInfo& mInfo )
+    :SbModule( rName ), pDocObject( NULL )
+{
+    m_mInfo = mInfo;
+    SetSource32( mInfo.ModuleSource );
+}
+SbxVariable*
+SbObjModule::GetObject()
+{
+    if( !pDocObject )
+        InitObject( GetName() );
+    return pDocObject;
+}
+SbxVariable*
+SbObjModule::Find( const XubString& rName, SbxClassType t )
+{
+    OSL_TRACE("SbObjectModule find for %s", rtl::OUStringToOString(  rName, RTL_TEXTENCODING_UTF8 ).getStr() );
+    if ( !pDocObject )
+        InitObject( GetName() );
+    OSL_TRACE("!!!!try to find in derived module " );
+    SbxVariable* pVar = NULL;
+    if ( !pVar && pDocObject)
+    {
+        pVar = pDocObject->Find( rName, t );
+        if ( pVar )
+        {
+           OSL_TRACE("found in uno (psuedo-base) object" );
+        }
+        else
+           OSL_TRACE("NOT found in uno (psuedo-base) object" );
+    }
+    if ( !pVar )
+    {
+        pVar = SbModule::Find( rName, t );
+        if ( pVar )
+           OSL_TRACE("! found in (normal) module " );
+    }
+
+    return pVar;
+}
+void
+SbObjModule::InitObject( const XubString& rName )
+{
+    OSL_TRACE("Initialize pDocObject");
+    try
+    {
+        com::sun::star::uno::Reference< com::sun::star::script::XObjectProvider > xObjectProvider( m_mInfo.ModuleObjectProvider, com::sun::star::uno::UNO_QUERY_THROW );
+        pDocObject = new SbUnoObject( rName, xObjectProvider->getObject() );
+    }catch( com::sun::star::uno::RuntimeException e )
+    {
+        OSL_TRACE("Object is not exist." );
+    }
+}
+void
+SbObjModule::SetCodeName( const XubString& rName )
+{
+}
 
 /////////////////////////////////////////////////////////////////////////
 // Implementation SbJScriptModule (Basic-Modul fuer JavaScript-Sourcen)
--- basic/source/classes/sb.cxx.bak	2007-11-30 10:24:02.000000000 +0800
+++ basic/source/classes/sb.cxx	2007-12-14 18:30:15.000000000 +0800
@@ -70,6 +70,7 @@
 #include "disas.hxx"
 #include "runtime.hxx"
 #include <basic/sbuno.hxx>
+#include <basic/sbobjmod.hxx>
 #include "stdobj.hxx"
 #include "filefmt.hxx"
 #include "sb.hrc"
@@ -667,6 +668,7 @@ StarBASIC::StarBASIC( StarBASIC* p, BOOL
 	SetParent( p );
 	pLibInfo = NULL;
 	bNoRtl = bBreak = FALSE;
+    bVBAEnabled = FALSE;
 	pModules = new SbxArray;
 
 	if( !GetSbData()->nInst++ )
@@ -769,13 +771,21 @@ SbModule* StarBASIC::MakeModule( const S
 
 SbModule* StarBASIC::MakeModule32( const String& rName, const ::rtl::OUString& rSrc )
 {
-	SbModule* p = new SbModule( rName );
+    SbModule* p = new SbModule( rName );
 	p->SetSource32( rSrc );
 	p->SetParent( this );
 	pModules->Insert( p, pModules->Count() );
 	SetModified( TRUE );
 	return p;
 }
+SbModule* StarBASIC::MakeObjModule( const String& rName, const com::sun::star::script::ModuleInfo& mInfo )
+{
+    SbObjModule* p = new SbObjModule( rName, mInfo );
+	p->SetParent( this );
+	pModules->Insert( p, pModules->Count() );
+	SetModified( TRUE );
+    return p;
+}
 
 void StarBASIC::Insert( SbxVariable* pVar )
 {
@@ -948,6 +958,8 @@ SbxVariable* StarBASIC::Find( const Stri
 				}
 				pNamed = p;
 			}
+            if ( p->GetSbxId() == SBXID_DOCUMENTMOD )
+                 continue;
 			// Sonst testen, ob das Element vorhanden ist
 			// GBLSEARCH-Flag rausnehmen (wg. Rekursion)
 			USHORT nGblFlag = p->GetFlags() & SBX_GBLSEARCH;
--- basic/source/runtime/methods1.cxx.bak	2007-11-30 10:24:02.000000000 +0800
+++ basic/source/runtime/methods1.cxx	2007-11-30 11:46:33.000000000 +0800
@@ -60,6 +60,9 @@
 #ifndef _SBX_HXX
 #include <basic/sbx.hxx>
 #endif
+#ifndef _SBSTAR_HXX
+#include <basic/sbstar.hxx>
+#endif
 #ifndef _ZFORLIST_HXX //autogen
 #include <svtools/zforlist.hxx>
 #endif
@@ -86,6 +89,7 @@
 #endif
 
 #include <vcl/jobset.hxx>
+#include <basic/sbobjmod.hxx>
 
 #include "sbintern.hxx"
 #include "runtime.hxx"
@@ -2613,7 +2617,14 @@ RTLFUNC(Me)
 	SbClassModuleObject* pClassModuleObject = PTR_CAST(SbClassModuleObject,pActiveModule);
 	if( pClassModuleObject == NULL )
 	{
-		StarBASIC::Error( SbERR_INVALID_USAGE_OBJECT );
+        SbObjModule* pMod = PTR_CAST(SbObjModule,pActiveModule);
+        if ( pMod == NULL )
+		    StarBASIC::Error( SbERR_INVALID_USAGE_OBJECT );
+        else
+        {
+            SbxVariableRef refVar = rPar.Get(0);
+            refVar->PutObject( pMod );
+        }
 	}
 	else
 	{
--- basic/source/basmgr/basmgr.cxx.bak	2007-11-30 10:24:02.000000000 +0800
+++ basic/source/basmgr/basmgr.cxx	2007-12-12 14:09:22.000000000 +0800
@@ -102,6 +102,7 @@
 #include <com/sun/star/script/XStarBasicDialogInfo.hpp>
 #include <com/sun/star/script/XStarBasicLibraryInfo.hpp>
 #include <com/sun/star/script/XLibraryContainerPassword.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
 
 #include <cppuhelper/implbase1.hxx>
 
@@ -145,6 +146,7 @@ static const char* szScriptLanguage = "S
 static const String BasicStreamName( String::CreateFromAscii(szBasicStorage) );
 static const String ManagerStreamName( String::CreateFromAscii(szManagerStream) );
 
+enum ModuleType { Unknown = 0, Normal, Class, Form, Document };
 
 #define	DEFINE_CONST_UNICODE(CONSTASCII)    UniString(RTL_CONSTASCII_USTRINGPARAM(CONSTASCII))
 
@@ -280,9 +282,22 @@ void BasMgrContainerListenerImpl::addLib
 		{
 			OUString aModuleName = pNames[ j ];
 			Any aElement = xLibNameAccess->getByName( aModuleName );
+            ModuleInfo mInfo;
 			OUString aMod;
-			aElement >>= aMod;
-			pLib->MakeModule32( aModuleName, aMod );
+            sal_Int16 mType;
+            if ( aElement >>= mInfo )
+            {
+                aMod = mInfo.ModuleSource;
+                mType = mInfo.ModuleType;
+                OSL_TRACE("#1 - aMod");
+                //pLib->MakeModule32( aModuleName, aMod, SBXID_DOCUMENTMOD );
+                pLib->MakeObjModule( aModuleName, mInfo );
+            }
+            else
+            {
+			    aElement >>= aMod;
+			    pLib->MakeModule32( aModuleName, aMod );
+            }
 		}
 	}
 
@@ -319,8 +334,16 @@ void SAL_CALL BasMgrContainerListenerImp
 	}
 	else
 	{
+        ModuleInfo mInfo;
 		OUString aMod;
-		Event.Element >>= aMod;
+        sal_Int16 mType;
+        if( Event.Element >>= mInfo )
+        {
+            aMod = mInfo.ModuleSource;
+            mType = mInfo.ModuleType;
+        }
+        else
+		    Event.Element >>= aMod;
 
 		StarBASIC* pLib = mpMgr->GetLib( maLibName );
 		DBG_ASSERT( pLib, "BasMgrContainerListenerImpl::elementInserted: Unknown lib!");
@@ -329,7 +352,15 @@ void SAL_CALL BasMgrContainerListenerImp
     		SbModule* pMod = pLib->FindModule( aName );
             if( !pMod )
             {
-			    pLib->MakeModule32( aName, aMod );
+                if ( mType == Document )
+                {
+                    //pLib->MakeModule32( aName, aMod, SBXID_DOCUMENTMOD );
+                    pLib->MakeObjModule( aName, mInfo );
+                }
+                else
+                {
+			        pLib->MakeModule32( aName, aMod );
+                }
 			    pLib->SetModified( FALSE );
             }
 		}
@@ -356,12 +387,27 @@ void SAL_CALL BasMgrContainerListenerImp
 	if( pLib )
 	{
 		SbModule* pMod = pLib->FindModule( aName );
+        ModuleInfo mInfo;
 		OUString aMod;
+        sal_Int16 mType;
 		Event.Element >>= aMod;
 		if( pMod )
 			pMod->SetSource32( aMod );
 		else
-			pLib->MakeModule32( aName, aMod );
+        {
+            if( Event.Element >>= mInfo )
+            {
+                aMod = mInfo.ModuleSource;
+                mType = mInfo.ModuleType;
+                //pLib->MakeModule32( aName, aMod, SBXID_DOCUMENTMOD );
+                pLib->MakeObjModule( aName, mInfo );
+            }
+            else
+            {
+                Event.Element >>= aMod;
+			    pLib->MakeModule32( aName, aMod );
+            }
+        }
 
 		pLib->SetModified( FALSE );
 	}
--- basic/inc/basic/sbstar.hxx.bak	2007-11-30 10:24:02.000000000 +0800
+++ basic/inc/basic/sbstar.hxx	2007-12-11 15:46:48.000000000 +0800
@@ -51,6 +51,7 @@
 
 #include <basic/sbdef.hxx>
 #include <basic/sberrors.hxx>
+#include <com/sun/star/script/ModuleInfo.hpp>
 
 class SbModule;                     // fertiges Modul
 class SbiInstance;                  // Laufzeit-Instanz
@@ -82,6 +83,7 @@ class StarBASIC : public SbxObject
 	BOOL			bNoRtl;				// TRUE: RTL nicht durchsuchen
 	BOOL			bBreak;				// TRUE: Break, sonst Step
 	BOOL			bDocBasic;
+    BOOL            bVBAEnabled;
 	BasicLibInfo*	pLibInfo;			// Infoblock fuer Basic-Manager
 	SbLanguageMode	eLanguageMode;		// LanguageMode des Basic-Objekts
 protected:
@@ -124,7 +126,8 @@ public:
 
 	// Compiler-Interface
 	SbModule*   	MakeModule( const String& rName, const String& rSrc );
-    SbModule*   	MakeModule32( const String& rName, const ::rtl::OUString& rSrc );
+    SbModule*       MakeModule32( const String& rName, const ::rtl::OUString& rSrc );
+    SbModule*       MakeObjModule( const String& rName, const com::sun::star::script::ModuleInfo& mInfo );
 	BOOL			Compile( SbModule* );
 	BOOL 			Disassemble( SbModule*, String& rText );
 	static void 	Stop();
@@ -196,6 +199,8 @@ public:
 					( const String& rName, USHORT& rStatus );
 	static SbMethod* GetActiveMethod( USHORT nLevel = 0 );
 	static SbModule* GetActiveModule();
+    void SetVBAEnabled( BOOL bEnabled );
+    BOOL isVBAEnabled();
 
 	// #60175 TRUE: SFX-Resource wird bei Basic-Fehlern nicht angezogen
 	static void StaticSuppressSfxResource( BOOL bSuppress );
--- basic/inc/basic/sbdef.hxx.bak	2007-11-30 10:24:02.000000000 +0800
+++ basic/inc/basic/sbdef.hxx	2007-11-30 11:46:33.000000000 +0800
@@ -100,6 +100,7 @@ void setBasicWatchMode( bool bOn );
 
 #define SBXID_BASIC			0x6273			// sb: StarBASIC
 #define	SBXID_BASICMOD		0x6d62			// bm: StarBASIC-Modul
+#define SBXID_DOCUMENTMOD   0x6d63          // Special document Module
 #define SBXID_BASICPROP		0x7262			// pr: StarBASIC-Property
 #define	SBXID_BASICMETHOD	0x6d65          // me: StarBASIC-Methode
 #define	SBXID_JSCRIPTMOD	0x6a62			// jm: JavaScript-Modul
--- basic/source/uno/namecont.cxx.bak	2007-11-30 10:24:02.000000000 +0800
+++ basic/source/uno/namecont.cxx	2007-12-14 18:14:04.000000000 +0800
@@ -139,6 +139,9 @@
 #endif
 #include <basic/sbmod.hxx>
 
+#ifndef _COM_SUN_STAR_SCRIPT_MODULEINFO_HPP_
+#include <com/sun/star/script/ModuleInfo.hpp>
+#endif
 
 namespace basic
 {
@@ -217,7 +220,7 @@ void NameContainer::replaceByName( const
 	throw(IllegalArgumentException, NoSuchElementException, WrappedTargetException, RuntimeException)
 {
 	Type aAnyType = aElement.getValueType();
-	if( mType != aAnyType )
+    if( mType != aAnyType && aAnyType != getCppuType( static_cast< ModuleInfo* >( NULL ) ) )
 		throw IllegalArgumentException();
 
 	NameContainerNameMap::iterator aIt = mHashMap.find( aName );
@@ -259,7 +262,7 @@ void NameContainer::insertByName( const 
 	throw(IllegalArgumentException, ElementExistException, WrappedTargetException, RuntimeException)
 {
 	Type aAnyType = aElement.getValueType();
-	if( mType != aAnyType )
+    if( mType != aAnyType && aAnyType != getCppuType( static_cast< ModuleInfo* >( NULL ) ) )
 		throw IllegalArgumentException();
 
 	NameContainerNameMap::iterator aIt = mHashMap.find( aName );
--- sfx2/source/doc/objmisc.cxx.bak	2007-11-30 10:24:02.000000000 +0800
+++ sfx2/source/doc/objmisc.cxx	2007-11-30 11:46:33.000000000 +0800
@@ -98,6 +98,9 @@
 #ifndef _COM_SUN_STAR_UTIL_XMODIFIABLE_HPP_
 #include <com/sun/star/util/XModifiable.hpp>
 #endif
+#ifndef _COM_SUN_STAR_SCRIPT_MODULEINFO_HPP_
+#include <com/sun/star/script/ModuleInfo.hpp>
+#endif
 
 #include <com/sun/star/script/provider/XScript.hpp>
 #include <com/sun/star/script/provider/XScriptProvider.hpp>
@@ -2213,6 +2216,39 @@ BOOL SfxObjectShell::HasMacrosLib_Impl()
 						aAny >>= xLib;
 						if ( xLib.is() )
 							bHasMacros = xLib->hasElements();
+                        // VBA will introduce some empty Object Module
+                        // If all module only include 
+                        // "Rem Attribute VBA_ModuleType=VBADocumentModule\nOption VBASupport"
+                        // it should be set bHasMacros as false
+                        uno::Sequence< ::rtl::OUString > sNames = xLib->getElementNames();
+                        uno::Reference < container::XNameContainer > xNameContainer( xContainer->getByName( aStdLibName ), uno::UNO_QUERY_THROW );
+                        sal_Int32 nCount = sNames.getLength();
+                        sal_Bool bVbaOption = sal_True;
+                        ::rtl::OUString sName;
+                        Any aCode;
+                        ModuleInfo sModuleInfo;
+                        ::rtl::OUString sMod;
+                        ::rtl::OUString sVbaOptiona( RTL_CONSTASCII_USTRINGPARAM( "Rem Attribute VBA_ModuleType=VBADocumentModule\nOption VBASupport 1\n" ));
+                        ::rtl::OUString sVbaOptionb( RTL_CONSTASCII_USTRINGPARAM( "\r\n" ));
+                        sVbaOptionb = sVbaOptiona + sVbaOptionb;
+                        for ( sal_Int32 nMod = 0; nMod < nCount; nMod++ )
+                        {
+                            sName = sNames[nMod];
+                            if ( xNameContainer->hasByName( sName ) )
+                                aCode = xNameContainer->getByName( sName );
+                            if ( aCode >>= sModuleInfo )
+                            {
+                                sMod = sModuleInfo.ModuleSource;
+                            }
+                            else
+                            {
+                                aCode >>= sMod;
+                            }
+                            if ( sMod.getLength() && !( sMod.equals( sVbaOptiona ) || sMod.equals( sVbaOptionb ) ) )
+                                bVbaOption = sal_False;
+                        }
+                        if ( bVbaOption )
+                            bHasMacros = sal_False;
 					}
 				}
 			}
--- sc/inc/document.hxx.bak	2007-12-04 15:36:21.000000000 +0800
+++ sc/inc/document.hxx	2007-12-11 13:41:05.000000000 +0800
@@ -306,6 +306,7 @@ private:
 
 	com::sun::star::uno::Sequence<sal_Int8>	aProtectPass;
 	String              aDocName;                       // opt: Dokumentname
+	String              aDocCodeName;                       // opt: Dokumentname
 	ScRangePairListRef	xColNameRanges;
 	ScRangePairListRef	xRowNameRanges;
 
@@ -448,6 +449,8 @@ public:
 
 	const String& 	GetName() const { return aDocName; }
 	void			SetName( const String& r ) { aDocName = r; }
+	const String& 	GetCodeName() const { return aDocCodeName; }
+	void			SetCodeName( const String& r ) { aDocCodeName = r; }
 
 	void			GetDocStat( ScDocStat& rDocStat );
 
@@ -535,6 +538,8 @@ SC_DLLPUBLIC	ScDBCollection*	GetDBCollec
 
 	BOOL			HasTable( SCTAB nTab ) const;
 	SC_DLLPUBLIC BOOL			GetName( SCTAB nTab, String& rName ) const;
+	SC_DLLPUBLIC BOOL			GetCodeName( SCTAB nTab, String& rName ) const;
+	SC_DLLPUBLIC BOOL			SetCodeName( SCTAB nTab, String& rName );
 	BOOL			GetTable( const String& rName, SCTAB& rTab ) const;
 	inline SCTAB	GetTableCount() const { return nMaxTableNumber; }
 	SvNumberFormatterIndexTable* GetFormatExchangeList() const { return pFormatExchangeList; }
--- sc/inc/table.hxx.bak	2007-12-04 15:36:21.000000000 +0800
+++ sc/inc/table.hxx	2007-12-04 15:36:27.000000000 +0800
@@ -102,6 +102,7 @@ private:
 	ScColumn		aCol[MAXCOLCOUNT];
 
 	String			aName;
+	String			aCodeName;
 	String			aComment;
 	BOOL			bScenario;
 	BOOL			bLayoutRTL;
@@ -232,6 +233,9 @@ public:
 	void		GetName( String& rName ) const;
 	void		SetName( const String& rNewName );
 
+	void		GetCodeName( String& rName ) const {  rName = aCodeName; }
+	void		SetCodeName( const String& rNewName ) { aCodeName = rNewName; }
+
     const String&   GetUpperName() const;
 
 	const String&	GetPageStyle() const					{ return aPageStyle; }
--- sc/source/core/data/document.cxx.bak	2007-12-04 15:36:21.000000000 +0800
+++ sc/source/core/data/document.cxx	2007-12-14 12:03:46.000000000 +0800
@@ -107,6 +107,7 @@
 #include "bcaslot.hxx"
 #include "scextopt.hxx"
 
+
 struct ScDefaultAttr
 {
 	const ScPatternAttr*	pAttr;
@@ -161,6 +162,32 @@ BOOL ScDocument::GetName( SCTAB nTab, St
 	return FALSE;
 }
 
+BOOL ScDocument::SetCodeName( SCTAB nTab, String& rName ) 
+{
+	if (VALIDTAB(nTab))
+	{
+		if (pTab[nTab])
+		{
+			pTab[nTab]->SetCodeName( rName );
+			return TRUE;
+		}
+	}
+	OSL_TRACE( "**** can't set code name %s", rtl::OUStringToOString( rName, RTL_TEXTENCODING_UTF8 ).getStr() );
+	return FALSE;
+}
+
+BOOL ScDocument::GetCodeName( SCTAB nTab, String& rName ) const
+{
+	if (VALIDTAB(nTab))
+		if (pTab[nTab])
+		{
+			pTab[nTab]->GetCodeName( rName );
+			return TRUE;
+		}
+	rName.Erase();
+	return FALSE;
+}
+
 
 BOOL ScDocument::GetTable( const String& rName, SCTAB& rTab ) const
 {
@@ -286,7 +313,6 @@ void ScDocument::CreateValidTabName(Stri
 	}
 }
 
-
 BOOL ScDocument::InsertTab( SCTAB nPos, const String& rName,
 			BOOL bExternalDocument )
 {
@@ -302,10 +328,11 @@ BOOL ScDocument::InsertTab( SCTAB nPos, 
 			pTab[nTabCount] = new ScTable(this, nTabCount, rName);
 			// if we are mapping codenames then a new tab always has has
 			// codename = sheetname
-			if ( pExtOptions && ( pExtOptions->GetCodeNameCount() > 0 ) )
+			/*if ( pExtOptions && ( pExtOptions->GetCodeNameCount() > 0 ) )
 			{
 					pExtOptions->SetCodeName( rName, nTabCount );
-			}
+			}*/
+            pTab[nTabCount]->SetCodeName( rName );
 			++nMaxTableNumber;
 			if ( bExternalDocument )
 				pTab[nTabCount]->SetVisible( FALSE );
@@ -340,7 +367,7 @@ BOOL ScDocument::InsertTab( SCTAB nPos, 
 				for (i = nTabCount; i > nPos; i--)
 				{
 					pTab[i] = pTab[i - 1];
-					if ( pTab[i] && pExtOptions && ( pExtOptions->GetCodeNameCount() > 0 ) )
+					/*if ( pTab[i] && pExtOptions && ( pExtOptions->GetCodeNameCount() > 0 ) )
 					{
 						String sCodeName = pExtOptions->GetCodeName( i - 1 );
 						if ( sCodeName.Len() )
@@ -348,16 +375,17 @@ BOOL ScDocument::InsertTab( SCTAB nPos, 
 							OSL_TRACE("Associating codeName %s with tab %d", rtl::OUStringToOString( sCodeName, RTL_TEXTENCODING_UTF8 ).getStr(), i );
 							pExtOptions->SetCodeName( sCodeName, i );
 						}
-					}
+					}*/
 				}
 
-				if ( pExtOptions && ( pExtOptions->GetCodeNameCount() > 0 ) )
+				/*if ( pExtOptions && ( pExtOptions->GetCodeNameCount() > 0 ) )
 				{
 						OSL_TRACE("Inserting codeName %s with tab %d", rtl::OUStringToOString( rName, RTL_TEXTENCODING_UTF8 ).getStr(),nPos );
 						pExtOptions->SetCodeName( rName, nPos );
-				}
+				}*/
 
 				pTab[nPos] = new ScTable(this, nPos, rName);
+                pTab[nPos]->SetCodeName( rName );
 				++nMaxTableNumber;
 
 				for (i = 0; i <= MAXTAB; i++)
@@ -447,7 +475,7 @@ BOOL ScDocument::DeleteTab( SCTAB nTab, 
 				delete pTab[nTab];
 				for (i=nTab + 1; i < nTabCount; i++)
 				{
-					if ( pTab[i - 1 ] && pExtOptions && ( pExtOptions->GetCodeNameCount() > 0 ) )
+					/*if ( pTab[i - 1 ] && pExtOptions && ( pExtOptions->GetCodeNameCount() > 0 ) )
 					{
 						String sCodeName = pExtOptions->GetCodeName( i );
 						if ( sCodeName.Len() )
@@ -455,15 +483,15 @@ BOOL ScDocument::DeleteTab( SCTAB nTab, 
 							OSL_TRACE("Associating codeName %s with tab %d", rtl::OUStringToOString( sCodeName, RTL_TEXTENCODING_UTF8 ).getStr(), i - 1 );
 							pExtOptions->SetCodeName( sCodeName, i - 1 );
 						}
-					}
+					}*/
 					pTab[i - 1] = pTab[i];
 
 				}
-				if ( pTab[i - 1 ] && pExtOptions && ( pExtOptions->GetCodeNameCount() > 0 ) )
+				/*if ( pTab[i - 1 ] && pExtOptions && ( pExtOptions->GetCodeNameCount() > 0 ) )
 				{
 					OSL_TRACE("Deleting codename %s as %d", rtl::OUStringToOString(  pExtOptions->GetCodeName( nTabCount-1 ), RTL_TEXTENCODING_UTF8 ).getStr(),  nTabCount - 1 ) ;
 					pExtOptions->DeleteCodeName( nTabCount - 1 );
-				}
+				}*/
 
 				pTab[nTabCount - 1] = NULL;
 				--nMaxTableNumber;
--- sc/source/core/data/table1.cxx.bak	2007-12-04 15:36:21.000000000 +0800
+++ sc/source/core/data/table1.cxx	2007-12-04 15:36:27.000000000 +0800
@@ -129,6 +129,7 @@ extern BOOL bIsOlk, bOderSo;
 ScTable::ScTable( ScDocument* pDoc, SCTAB nNewTab, const String& rNewName,
 					BOOL bColInfo, BOOL bRowInfo ) :
 	aName( rNewName ),
+	aCodeName( rNewName ),
 	bScenario( FALSE ),
 	bLayoutRTL( FALSE ),
     bLoadingRTL( FALSE ),
--- sc/source/filter/excel/excdoc.cxx.bak	2007-12-04 15:36:21.000000000 +0800
+++ sc/source/filter/excel/excdoc.cxx	2007-12-04 15:36:27.000000000 +0800
@@ -168,7 +168,7 @@ void ExcTable::FillAsHeader( ExcBoundshe
 	String	aTmpString;
     SCTAB  nScTabCount     = rTabInfo.GetScTabCount();
     UINT16  nExcTabCount    = rTabInfo.GetXclTabCount();
-    UINT16  nCodenames      = static_cast< UINT16 >( GetExtDocOptions().GetCodeNameCount() );
+    UINT16  nCodenames      = nScTabCount;
 
 	rR.pObjRecs = NULL;				// per sheet
 
@@ -182,7 +182,8 @@ void ExcTable::FillAsHeader( ExcBoundshe
         if( HasVbaStorage() )
 		{
 			Add( new XclObproj );
-            const String& rCodeName = GetExtDocOptions().GetDocSettings().maGlobCodeName;
+            //const String& rCodeName = GetExtDocOptions().GetDocSettings().maGlobCodeName;
+            const String rCodeName = GetDoc().GetCodeName();
             if( rCodeName.Len() )
                 Add( new XclCodename( rCodeName ) );
 		}
@@ -403,8 +404,12 @@ void ExcTable::FillAsTable( size_t nCode
         Add( new XclExpCondFormatBuffer( GetRoot() ) );
 
         if( HasVbaStorage() )
-            if( nCodeNameIdx < GetExtDocOptions().GetCodeNameCount() )
-                Add( new XclCodename( GetExtDocOptions().GetCodeName( nCodeNameIdx ) ) );
+            if( nCodeNameIdx < GetTabInfo().GetScTabCount() )
+            {
+                String sCodeName;
+                rDoc.GetCodeName( nCodeNameIdx, sCodeName );
+                Add( new XclCodename( sCodeName ) );
+            }
 	}
 
     // list of HLINK records, generated by the cell table
@@ -429,7 +434,7 @@ void ExcTable::FillAsEmptyTable( size_t 
 {
     InitializeTable( mnScTab );
 
-    if( HasVbaStorage() && (nCodeNameIdx < GetExtDocOptions().GetCodeNameCount()) )
+    if( HasVbaStorage() && (nCodeNameIdx < GetTabInfo().GetScTabCount()) )
     {
         if( GetBiff() <= EXC_BIFF5 )
         {
@@ -438,7 +443,9 @@ void ExcTable::FillAsEmptyTable( size_t 
         else
         {
             Add( new ExcBof8 );
-            Add( new XclCodename( GetExtDocOptions().GetCodeName( nCodeNameIdx ) ) );
+            String sCodeName;
+            GetDoc().GetCodeName( nCodeNameIdx, sCodeName );
+            Add( new XclCodename( sCodeName  ) );
         }
         // sheet view settings: WINDOW2, SCL, PANE, SELECTION
         aRecList.AppendNewRecord( new XclExpTabViewSettings( GetRoot(), mnScTab ) );
@@ -480,7 +487,7 @@ void ExcDocument::ReadDoc( void )
     aHeader.FillAsHeader( maBoundsheetList );
 
     SCTAB nScTab = 0, nScTabCount = GetTabInfo().GetScTabCount();
-    size_t nCodeNameIdx = 0, nCodeNameCount = GetExtDocOptions().GetCodeNameCount();
+    size_t nCodeNameIdx = 0, nCodeNameCount = nScTabCount;
 
     for( ; nScTab < nScTabCount; ++nScTab )
     {
--- sc/source/filter/excel/xelink.cxx.bak	2007-12-04 15:36:21.000000000 +0800
+++ sc/source/filter/excel/xelink.cxx	2007-12-04 15:36:27.000000000 +0800
@@ -1296,7 +1296,6 @@ XclExpSupbookBuffer::XclExpSupbookBuffer
 {
     XclExpTabInfo& rTabInfo = GetTabInfo();
     sal_uInt16 nXclCnt = rTabInfo.GetXclTabCount();
-    sal_uInt16 nCodeCnt = static_cast< sal_uInt16 >( GetExtDocOptions().GetCodeNameCount() );
     size_t nCount = nXclCnt + rTabInfo.GetXclExtTabCount();
 
     DBG_ASSERT( nCount > 0, "XclExpSupbookBuffer::XclExpSupbookBuffer - no sheets to export" );
@@ -1305,7 +1304,7 @@ XclExpSupbookBuffer::XclExpSupbookBuffer
         maSBIndexVec.resize( nCount );
 
         // self-ref SUPBOOK first of list
-        XclExpSupbookRef xSupbook( new XclExpSupbook( GetRoot(), ::std::max( nXclCnt, nCodeCnt ) ) );
+        XclExpSupbookRef xSupbook( new XclExpSupbook( GetRoot(), nXclCnt ) );
         mnOwnDocSB = Append( xSupbook );
         for( sal_uInt16 nXclTab = 0; nXclTab < nXclCnt; ++nXclTab )
             maSBIndexVec[ nXclTab ].Set( mnOwnDocSB, nXclTab );
--- sc/source/filter/excel/xlocx.cxx.bak	2007-12-04 15:36:21.000000000 +0800
+++ sc/source/filter/excel/xlocx.cxx	2007-12-04 15:36:27.000000000 +0800
@@ -88,7 +88,7 @@
 #include <cppuhelper/bootstrap.hxx>
 #endif
 #include <sfx2/objsh.hxx>
-
+#include "document.hxx"
 using org::openoffice::vba::XVBAToOOEventDescGen;
 using com::sun::star::uno::XComponentContext;
 using com::sun::star::awt::XControl;
@@ -372,7 +372,9 @@ void XclImpOcxConverter::RegisterOleMacr
             if( StarBASIC* pBasic = pDocShell->GetBasic() )
             {
                 // Seach in the CodeName ( Module ) associated with this sheet
-                if( SbModule* pModule = dynamic_cast< SbModule* >( pBasic->Find( GetExtDocOptions().GetCodeName(rOcxCtrlObj.GetScTab() ), SbxCLASS_OBJECT ) ) )
+		String sCodeName;
+		GetDoc().GetCodeName( rOcxCtrlObj.GetScTab(), sCodeName );
+                if( SbModule* pModule = dynamic_cast< SbModule* >( pBasic->Find( sCodeName , SbxCLASS_OBJECT ) ) )
                 {
                     Reference<XComponentContext > xContext( ::cppu::defaultBootstrap_InitialComponentContext(), UNO_QUERY_THROW ); // Fatal error anyway
                     if ( SbxArray* pMethods = pModule->GetMethods() )
--- sc/source/filter/inc/excimp8.hxx.bak	2007-12-04 15:36:21.000000000 +0800
+++ sc/source/filter/inc/excimp8.hxx	2007-12-11 11:29:24.000000000 +0800
@@ -69,6 +69,7 @@ class XclImpStream;
 
 class ImportExcel8 : public ImportExcel
 {
+        SCTAB mnTab;
 	protected:
         ExcScenarioList         aScenList;
 
--- sc/source/ui/docshell/docsh.cxx.bak	2007-12-04 15:36:21.000000000 +0800
+++ sc/source/ui/docshell/docsh.cxx	2007-12-04 15:36:27.000000000 +0800
@@ -207,11 +207,8 @@ const static rtl::OUString sUrlPart2 = r
 	rtl::OUString sCodeName = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ThisWorkbook") );
 	if ( pShell )
 	{
-		if ( ScExtDocOptions* pExtDocOpts = pShell->GetDocument()->GetExtDocOptions() )
-		{
-			if ( pExtDocOpts->GetDocSettings().maGlobCodeName.Len() > 0 ) 
-				sCodeName = pExtDocOpts->GetDocSettings().maGlobCodeName;
-		}
+		if ( ScDocument* pDoc  = pShell->GetDocument() )
+			sCodeName = pDoc->GetCodeName();
 	}
 	return sCodeName;
 }	
--- sc/source/ui/view/tabview5.cxx.bak	2007-12-04 15:36:21.000000000 +0800
+++ sc/source/ui/view/tabview5.cxx	2007-12-04 15:36:27.000000000 +0800
@@ -347,10 +347,15 @@ void ScTabView::TabChanged()
 	aViewData.GetDocument()->BroadcastUno( SfxSimpleHint( SC_HINT_TABLECHANGED ) );
 	ScExtDocOptions* pExtOptions = aViewData.GetDocument()->GetExtDocOptions();
 	String sSheetModuleName;
-	aViewData.GetDocument()->GetName( aViewData.GetTabNo(), sSheetModuleName);
+	aViewData.GetDocument()->GetCodeName( aViewData.GetTabNo(), sSheetModuleName);
+	if ( !sSheetModuleName.Len() > 0 )
+		aViewData.GetDocument()->GetName( aViewData.GetTabNo(), sSheetModuleName);
+
+/*
 	// Use code name if that exists
 	if ( pExtOptions )
 		sSheetModuleName = pExtOptions->GetCodeName( aViewData. GetTabNo() );
+*/
 	static String sUrl( RTL_CONSTASCII_USTRINGPARAM("vnd.sun.star.script:Standard") );
 	static String sUrl2( RTL_CONSTASCII_USTRINGPARAM("?language=Basic&location=document") );
 	static String sSheetActivateScript( RTL_CONSTASCII_USTRINGPARAM("Worksheet_Activate") );
--- sc/source/filter/excel/excimp8.cxx.bak	2007-12-04 15:36:21.000000000 +0800
+++ sc/source/filter/excel/excimp8.cxx	2007-12-11 13:24:53.000000000 +0800
@@ -148,7 +148,7 @@ using namespace com::sun::star;
 
 
 ImportExcel8::ImportExcel8( XclImpRootData& rImpData, SvStream& rStrm ) :
-    ImportExcel( rImpData, rStrm )
+    ImportExcel( rImpData, rStrm ), mnTab(0)
 {
 	delete pFormConv;
 
@@ -294,9 +294,15 @@ void ImportExcel8::Codename( BOOL bWorkb
         if( aName.Len() )
         {
             if( bWorkbookGlobals )
-                GetExtDocOptions().GetDocSettings().maGlobCodeName = aName;
+            {
+                //GetExtDocOptions().GetDocSettings().maGlobCodeName = aName;
+                GetDoc().SetCodeName( aName );
+            }
             else
-                GetExtDocOptions().AppendCodeName( aName );
+            {
+                //GetExtDocOptions().AppendCodeName( aName );
+                GetDoc().SetCodeName( mnTab++, aName );
+            }
         }
 	}
 }
--- basic/source/runtime/runtime.cxx.bak	2007-12-17 14:28:09.000000000 +0800
+++ basic/source/runtime/runtime.cxx	2007-12-11 16:08:06.000000000 +0800
@@ -82,6 +82,17 @@ void StarBASIC::StaticEnableReschedule( 
 {
     bStaticGlobalEnableReschedule = bReschedule;
 }
+void StarBASIC::SetVBAEnabled( BOOL bEnabled )
+{
+    bVBAEnabled = bEnabled;
+}
+
+BOOL StarBASIC::isVBAEnabled()
+{
+    if( SbiRuntime::isVBAEnabled() )
+        return TRUE;
+    return bVBAEnabled;
+}
 
 
 struct SbiArgvStack {					// Argv stack:
--- sc/source/ui/docshell/docfunc.cxx.bak	2007-12-17 14:29:02.000000000 +0800
+++ sc/source/ui/docshell/docfunc.cxx	2007-12-14 16:09:31.000000000 +0800
@@ -58,6 +58,11 @@
 #include <svtools/PasswordHelper.hxx>
 #endif
 
+#include <basic/sbstar.hxx>
+#include <com/sun/star/container/XNameContainer.hpp>
+#include <com/sun/star/script/XLibraryContainer.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
+
 #include <list>
 
 #include "docfunc.hxx"
@@ -101,6 +106,7 @@
 #include "scui_def.hxx" //CHINA001
 using namespace com::sun::star;
 
+
 // STATIC DATA -----------------------------------------------------------
 
 //========================================================================
@@ -2022,6 +2028,94 @@ BOOL ScDocFunc::MoveBlock( const ScRange
 }
 
 //------------------------------------------------------------------------
+enum ModuleType { Unknown = 0, Normal, Class, Form, Document };
+script::ModuleInfo lcl_InitModuleInfo( ScDocShell& rDocSh, String& sModule )
+{
+    ::rtl::OUString aModName( sModule );
+    uno::Reference< lang::XMultiServiceFactory> xSF(rDocSh.GetModel(), uno::UNO_QUERY);
+    uno::Reference< script::XObjectProvider > xVBAObjectProvider;
+    if ( xSF.is() )
+    {
+        uno::Sequence< uno::Any > aArgs(1);
+        aArgs[0] = uno::Any( aModName );
+        xVBAObjectProvider.set( xSF->createInstanceWithArguments( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "org.openoffice.vba.VBAObjectModuleObjectProvider")), aArgs), uno::UNO_QUERY );    
+    }
+    script::ModuleInfo sModuleInfo;
+    ::rtl::OUString sVbaOption( RTL_CONSTASCII_USTRINGPARAM( "Rem Attribute VBA_ModuleType=VBADocumentModule\nOption VBASupport 1\n" ));
+    sModuleInfo.ModuleName = aModName;
+    sModuleInfo.ModuleSource = sVbaOption;
+    sModuleInfo.ModuleType = Document;
+    sModuleInfo.ModuleObjectProvider.set( xVBAObjectProvider, uno::UNO_QUERY );
+    return sModuleInfo;
+}
+
+void lcl_InsertModule( ScDocShell& rDocSh, SCTAB nTab, script::ModuleInfo sModuleInfo )
+{
+    SFX_APP()->EnterBasicCall();
+    uno::Reference< script::XLibraryContainer > xLibContainer = rDocSh.GetBasicContainer();
+    DBG_ASSERT( xLibContainer.is(), "No BasicContainer!" );
+
+    uno::Reference< container::XNameContainer > xLib;
+    if( xLibContainer.is() )
+    {
+        String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+        uno::Any aLibAny = xLibContainer->getByName( aLibName );
+        aLibAny >>= xLib;
+    }
+    if( xLib.is() )
+    {
+        // test Module has exist
+        // if the Module is exist. changed to another name
+        // and at this time the sting like "SheetX"
+        rtl::OUString sModuleName( sModuleInfo.ModuleName );
+        while( xLib->hasByName( sModuleName ) )
+        {
+            sal_Int32 nCount = sModuleName.getLength();
+            rtl::OUString sNum = sModuleName.copy( nCount - 1 );
+            sal_Int32 nNum = sNum.toInt32();
+            nNum += 1;
+            sModuleName = rtl::OUString::createFromAscii( "Sheet" ) + rtl::OUString::valueOf( nNum );
+        }
+        sModuleInfo.ModuleName = sModuleName;
+        uno::Any aSourceAny;
+        aSourceAny <<= sModuleInfo;
+        xLib->insertByName( sModuleName, aSourceAny );
+        ScDocument* pDoc = rDocSh.GetDocument();
+        String sCodeName( sModuleName );
+        pDoc->SetCodeName( nTab, sCodeName );
+    }
+    SFX_APP()->LeaveBasicCall();
+}
+
+void lcl_CreateModule( ScDocShell& rDocSh, SCTAB nTab, String& sModuleName )
+{
+    script::ModuleInfo sModuleInfo = lcl_InitModuleInfo(  rDocSh, sModuleName );
+    lcl_InsertModule( rDocSh, nTab, sModuleInfo );
+}
+
+void lcl_DeleteModule( ScDocShell& rDocSh, String& sModuleName )
+{
+    SFX_APP()->EnterBasicCall();
+    uno::Reference< script::XLibraryContainer > xLibContainer = rDocSh.GetBasicContainer();
+    DBG_ASSERT( xLibContainer.is(), "No BasicContainer!" );
+
+    uno::Reference< container::XNameContainer > xLib;
+    if( xLibContainer.is() )
+    {
+        String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+        uno::Any aLibAny = xLibContainer->getByName( aLibName );
+        aLibAny >>= xLib;
+    }
+    if( xLib.is() )
+    {
+        if( xLib->hasByName( sModuleName ) )
+        {
+            xLib->removeByName( sModuleName );
+        }
+    }
+    SFX_APP()->LeaveBasicCall();
+}
+
 
 BOOL ScDocFunc::InsertTable( SCTAB nTab, const String& rName, BOOL bRecord, BOOL bApi )
 {
@@ -2031,8 +2125,12 @@ BOOL ScDocFunc::InsertTable( SCTAB nTab,
 	ScDocShellModificator aModificator( rDocShell );
 
 	ScDocument* pDoc = rDocShell.GetDocument();
+    StarBASIC* pStarBASIC = rDocShell.GetBasic();
+    BOOL bVbaEnabled = pStarBASIC->isVBAEnabled();
 	if (bRecord && !pDoc->IsUndoEnabled())
 		bRecord = FALSE;
+    if ( bVbaEnabled )
+        bRecord = FALSE;
 	if (bRecord)
 		pDoc->BeginDrawUndo();							//	InsertTab erzeugt ein SdrUndoNewPage
 
@@ -2047,6 +2145,12 @@ BOOL ScDocFunc::InsertTable( SCTAB nTab,
 			rDocShell.GetUndoManager()->AddUndoAction(
 						new ScUndoInsertTab( &rDocShell, nTab, bAppend, rName));
 		//	Views updaten:
+        if( bVbaEnabled )
+        {
+            String sCodeName( rName );
+            lcl_CreateModule( rDocShell, nTab, sCodeName );
+            pStarBASIC->Broadcast( SID_BASICIDE_SHOWSBX );
+        }
 		rDocShell.Broadcast( ScTablesHint( SC_TAB_INSERTED, nTab ) );
 
 		rDocShell.PostPaintExtras();
@@ -2068,8 +2172,12 @@ BOOL ScDocFunc::DeleteTable( SCTAB nTab,
 
 	BOOL bSuccess = FALSE;
 	ScDocument* pDoc = rDocShell.GetDocument();
+    StarBASIC* pStarBASIC = rDocShell.GetBasic();
+    BOOL bVbaEnabled = pStarBASIC->isVBAEnabled();
 	if (bRecord && !pDoc->IsUndoEnabled())
 		bRecord = FALSE;
+    if ( bVbaEnabled )
+        bRecord = FALSE;
 	BOOL bWasLinked = pDoc->IsLinked(nTab);
 	ScDocument* pUndoDoc = NULL;
 	ScRefUndoData* pUndoData = NULL;
@@ -2110,6 +2218,8 @@ BOOL ScDocFunc::DeleteTable( SCTAB nTab,
 		pUndoData = new ScRefUndoData( pDoc );
 	}
 
+    String sCodeName;
+    BOOL bHasCodeName = pDoc->GetCodeName( nTab, sCodeName );
 	if (pDoc->DeleteTab( nTab, pUndoDoc ))
 	{
 		if (bRecord)
@@ -2120,6 +2230,14 @@ BOOL ScDocFunc::DeleteTable( SCTAB nTab,
 						new ScUndoDeleteTab( &rDocShell, theTabs, pUndoDoc, pUndoData ));
 		}
 		//	Views updaten:
+        if( bVbaEnabled )
+        {
+            if( bHasCodeName )
+            {
+                lcl_DeleteModule( rDocShell, sCodeName );
+                pStarBASIC->Broadcast( SID_BASICIDE_SBXDELETED );
+            }
+        }
 		rDocShell.Broadcast( ScTablesHint( SC_TAB_DELETED, nTab ) );
 
 		if (bWasLinked)
--- basctl/source/basicide/basidesh.cxx.bak	2007-12-14 10:44:45.000000000 +0800
+++ basctl/source/basicide/basidesh.cxx	2007-12-14 16:41:47.000000000 +0800
@@ -599,7 +599,6 @@ void BasicIDEShell::ShowObjectDialog( BO
 }
 
 
-
 void __EXPORT BasicIDEShell::SFX_NOTIFY( SfxBroadcaster& rBC, const TypeId&,
 										const SfxHint& rHint, const TypeId& )
 {
@@ -674,12 +673,50 @@ void __EXPORT BasicIDEShell::SFX_NOTIFY(
                         pWin = aIDEWindowTable.Next();
                     }
                 }
+                else if ( ( nHintId == SID_BASICIDE_SHOWSBX ) || nHintId == SID_BASICIDE_SBXDELETED )
+                {
+                    SbxVariable* pSbxVariable = rSbxHint.GetVar();
+                    StarBASIC* pStarBASIC = PTR_CAST( StarBASIC, pSbxVariable );
+                    if( pStarBASIC )
+                    {
+                        BasicManager* pBasicManager = BasicIDE::FindBasicManager( pStarBASIC );
+                        if( pBasicManager )
+                        {
+                            ScriptDocument aScriptDocument( ScriptDocument::getDocumentForBasicManager( pBasicManager ) );
+                            if( aScriptDocument.isAlive() )
+                            {
+                                switch( nHintId )
+                                {
+                                    case SID_BASICIDE_SHOWSBX:
+                                        UpdateWindows();
+                                        break;
+                                    case SID_BASICIDE_SBXDELETED:
+                                        RemoveNoModulesWindows();
+                                        break;
+                                }
+                            } 
+                        }
+                    }
+                }
             }
         }
     }
 }
 
-
+void BasicIDEShell::RemoveNoModulesWindows()
+{
+    for ( ULONG nWin = 0; nWin < aIDEWindowTable.Count(); nWin++ )
+    {
+        IDEBaseWindow* pWin = aIDEWindowTable.GetObject( nWin );
+        if ( pWin->IsDocument( m_aCurDocument ) && ( pWin->GetLibName() == m_aCurLibName ) )
+        {
+            if ( !m_aCurDocument.hasModule( pWin->GetLibName(), pWin->GetName() ) )
+            {
+                RemoveWindow( pWin, FALSE, TRUE );
+            }
+        }
+    }
+}
 
 void BasicIDEShell::CheckWindows()
 {
--- sc/source/ui/view/viewfun2.cxx.bak	2007-12-14 12:30:27.000000000 +0800
+++ sc/source/ui/view/viewfun2.cxx	2007-12-14 14:36:22.000000000 +0800
@@ -62,6 +62,11 @@
 #include <vcl/sound.hxx>
 #include <vcl/waitobj.hxx>
 
+#include <basic/sbstar.hxx>
+#include <com/sun/star/container/XNameContainer.hpp>
+#include <com/sun/star/script/XLibraryContainer.hpp>
+using namespace com::sun::star;
+
 #include "viewfunc.hxx"
 
 #include "sc.hrc"
@@ -2085,15 +2090,42 @@ BOOL ScViewFunc::DeleteTable( SCTAB nTab
 	return bSuccess;
 }
 
+void lcl_DeleteModule( ScDocShell* rDocSh, String& sModuleName )
+{
+    SFX_APP()->EnterBasicCall();
+    uno::Reference< script::XLibraryContainer > xLibContainer = rDocSh->GetBasicContainer();
+    DBG_ASSERT( xLibContainer.is(), "No BasicContainer!" );
+
+    uno::Reference< container::XNameContainer > xLib;
+    if( xLibContainer.is() )
+    {
+        String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+        uno::Any aLibAny = xLibContainer->getByName( aLibName );
+        aLibAny >>= xLib;
+    }
+    if( xLib.is() )
+    {
+        if( xLib->hasByName( sModuleName ) )
+        {
+            xLib->removeByName( sModuleName );
+        }
+    }
+    SFX_APP()->LeaveBasicCall();
+}
+
 BOOL ScViewFunc::DeleteTables(const SvShorts &TheTabs, BOOL bRecord )
 {
 	ScDocShell* pDocSh	= GetViewData()->GetDocShell();
 	ScDocument* pDoc 	= pDocSh->GetDocument();
+    StarBASIC* pStarBASIC = pDocSh->GetBasic();
+    BOOL bVbaEnabled = pStarBASIC->isVBAEnabled();
 	SCTAB		nNewTab = TheTabs[0];
 	int			i;
 	WaitObject aWait( GetFrameWin() );
 	if (bRecord && !pDoc->IsUndoEnabled())
 		bRecord = FALSE;
+    if ( bVbaEnabled )
+        bRecord = FALSE;
 
 	while ( nNewTab > 0 && !pDoc->IsVisible( nNewTab ) )
 		--nNewTab;
@@ -2160,9 +2192,19 @@ BOOL ScViewFunc::DeleteTables(const SvSh
 
 	for(i=TheTabs.Count()-1;i>=0;i--)
 	{
+        String sCodeName;
+        BOOL bHasCodeName = pDoc->GetCodeName( TheTabs[sal::static_int_cast<USHORT>(i)], sCodeName );
         if (pDoc->DeleteTab( TheTabs[sal::static_int_cast<USHORT>(i)], pUndoDoc ))
 		{
 			bDelDone = TRUE;
+            if( bVbaEnabled )
+            {
+                if( bHasCodeName )
+                {
+                    lcl_DeleteModule( pDocSh, sCodeName );
+                    pStarBASIC->Broadcast( SID_BASICIDE_SBXDELETED );
+                }
+            }
             pDocSh->Broadcast( ScTablesHint( SC_TAB_DELETED, TheTabs[sal::static_int_cast<USHORT>(i)] ) );
 		}
 	}
@@ -2190,6 +2232,7 @@ BOOL ScViewFunc::DeleteTables(const SvSh
 		pDocSh->PostPaintExtras();
 		pDocSh->SetDocumentModified();
 
+
         SfxApplication* pSfxApp = SFX_APP();                                // Navigator
         pSfxApp->Broadcast( SfxSimpleHint( SC_HINT_TABLES_CHANGED ) );
         pSfxApp->Broadcast( SfxSimpleHint( SC_HINT_DBAREAS_CHANGED ) );
--- basctl/source/inc/basidesh.hxx.bak	2007-12-14 15:35:04.000000000 +0800
+++ basctl/source/inc/basidesh.hxx	2007-12-14 15:38:12.000000000 +0800
@@ -124,6 +124,7 @@ friend class BasicIDE;
 	void				CheckWindows();
 	void				RemoveWindows( const ScriptDocument& rDocument, const String& rLibName, BOOL bDestroy );
 	void				UpdateWindows();
+	void				RemoveNoModulesWindows();
 	void				ShowObjectDialog( BOOL bShow, BOOL bCreateOrDestroy );
 	void				InvalidateBasicIDESlots();
 	void				StoreAllWindowData( BOOL bPersistent = TRUE );
