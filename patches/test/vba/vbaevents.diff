--- /dev/null	2007-05-04 18:54:36.000000000 +0800
+++ oovbaapi/org/openoffice/vba/VBAWorkbookEvent.idl	2008-05-15 14:43:15.000000000 +0800
@@ -0,0 +1,78 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __org_openoffice_vba_VBAWorkbookEvent_idl__
+#define __org_openoffice_vba_VBAWorkbookEvent_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+//=============================================================================
+
+module org {  module openoffice {  module vba { 
+//=============================================================================
+
+published constants VBAWorkbookEvent
+{
+    const long SC_VBAEVENT_SHEET_START                  = 10000;
+    // Worksheet
+    const long SC_VBAEVENT_SHEET_ACTIVATE               = 10001;
+    const long SC_VBAEVENT_SHEET_BEFOREDOUBLECLICK      = 10002;
+    const long SC_VBAEVENT_SHEET_BEFORERIGHTCLICK       = 10003;
+    const long SC_VBAEVENT_SHEET_CALCULATE              = 10004;
+    const long SC_VBAEVENT_SHEET_CHANGE                 = 10005;
+    const long SC_VBAEVENT_SHEET_DEACTIVATE             = 10006;
+    const long SC_VBAEVENT_SHEET_FOLLOWHYPERLINK        = 10007;
+    const long SC_VBAEVENT_SHEET_PIVOTTABLEUPDATE       = 10008;
+    const long SC_VBAEVENT_SHEET_SELECTIONCHANGE        = 10009;
+    // Workbook
+    const long SC_VBAEVENT_WORKBOOK_ACTIVATE            = 10020;
+    const long SC_VBAEVENT_WORKBOOK_DEACTIVATE          = 10021;
+    const long SC_VBAEVENT_WORKBOOK_OPEN                = 10022;
+    const long SC_VBAEVENT_WORKBOOK_AUTOOPEN            = 10023;
+    const long SC_VBAEVENT_WORKBOOK_BEFORECLOSE         = 10024;
+    const long SC_VBAEVENT_WORKBOOK_BEFOREPRINT         = 10025;
+    const long SC_VBAEVENT_WORKBOOK_BEFORESAVE          = 10026;
+    const long SC_VBAEVENT_WORKBOOK_NEWSHEET            = 10027;
+    const long SC_VBAEVENT_WORKBOOK_WINDOWACTIVATE      = 10028;
+    const long SC_VBAEVENT_WORKBOOK_WINDOWDEACTIVATE    = 10029;
+    const long SC_VBAEVENT_WORKBOOK_WINDOWRESIZE        = 10030;
+    const long SC_VBAEVENT_WORKBOOK_WINDOWCOLSE         = 10031;
+    const long SC_VBAEVENT_WORKBOOK_CLOSE               = 10032;
+};
+
+}; }; };
+
+#endif
--- oovbaapi/org/openoffice/vba/makefile.mk.orig	2008-05-19 16:54:01.000000000 +0800
+++ oovbaapi/org/openoffice/vba/makefile.mk	2008-05-19 16:53:52.000000000 +0800
@@ -52,6 +52,9 @@ IDLFILES=\
 	XCommandBarControls.idl\
 	XCommandBar.idl\
 	XCommandBars.idl\
+	VBAWorkbookEvent.idl\
+	XVBAWorkbookEventsHelper.idl\
+    VBAWorkbookEventsHelper.idl\
 	Globals.idl\
 
 # ------------------------------------------------------------------
--- /dev/null	2007-05-04 18:54:36.000000000 +0800
+++ offapi/com/sun/star/document/XVbaEventHelper.idl	2008-05-16 16:16:16.000000000 +0800
@@ -0,0 +1,48 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XVbaEventHelper.idl,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_document_XVbaEventHelper_idl__
+#define __com_sun_star_document_XVbaEventHelper_idl__
+
+//=============================================================================
+
+module com {   module sun {   module star {   module document {
+
+//=============================================================================
+interface XVbaEventHelper
+{
+	//-------------------------------------------------------------------------
+    boolean processVbaEvent( [in] short nStatus, [in] short nEventId );
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
--- offapi/com/sun/star/document/makefile.mk.bak	2008-05-08 17:24:51.000000000 +0800
+++ offapi/com/sun/star/document/makefile.mk	2008-05-08 17:33:09.000000000 +0800
@@ -109,6 +109,7 @@ IDLFILES=\
     DocumentRevisionListPersistence.idl \
     XDocumentLanguages.idl \
     XCodeNameQuery.idl \
+    XVbaEventHelper.idl \
 
 
 # ------------------------------------------------------------------
--- /dev/null	2007-05-04 18:54:36.000000000 +0800
+++ sc/source/ui/vba/vbaeventshelper.hxx	2008-05-19 12:42:35.000000000 +0800
@@ -0,0 +1,105 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: vbaeventshelper.hxx,v $
+ *
+ *  $Revision: 1.0 $
+ *
+ *  last change: $Author: vg $ $Date: 2007/12/07 10:42:26 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef SC_VBAEVENTS_HXX
+#define SC_VBAEVENTS_HXX
+
+#include "document.hxx"
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/container/XNameReplace.hpp>
+#include <com/sun/star/awt/XEnhancedMouseClickHandler.hpp>
+#include <org/openoffice/vba/VBAWorkbookEvent.hpp>
+#include <org/openoffice/vba/XVBAWorkbookEventsHelper.hpp>
+#include "vbahelper.hxx"
+
+using namespace com::sun::star;
+
+typedef ::cppu::WeakImplHelper1< org::openoffice::vba::XVBAWorkbookEventsHelper > VBAWorkbookEvent_BASE;
+
+//class ScTablesHint;
+class VbaWindowListener;
+class SfxEventHint;
+class ScVbaEventsHelper : public VBAWorkbookEvent_BASE
+{
+private:
+	ScDocument* pDoc;
+    css::uno::Reference< css::uno::XComponentContext > m_xContext;
+    VbaWindowListener* mpWindowListener;
+    sal_Bool mbOpened;
+
+	String getWorkbookModuleName();
+	String getSheetModuleName( SCTAB nTab );
+	sal_Bool addOpenDocEvent( const uno::Reference< container::XNameReplace >& xEvts, const String& sOpenMacro );
+	String docMacroExists( SfxObjectShell* pShell, const String& sMod, const String& sMacro );
+
+	uno::Any createWorkSheet( SfxObjectShell* pShell, SCTAB nTab );
+	uno::Any createRange( const uno::Any& aRange );
+	uno::Any createHyperlink( const uno::Any& rCell );
+	void getSheetEventName( USHORT nEvent, String& rSheetScript, String& rWorkbookScript );
+	sal_Bool executeWorkBookMacro( SfxObjectShell* pShell, const String& sMacroName, uno::Sequence< uno::Any >& aArgs, uno::Any& aRet );
+	sal_Bool processDocOpenMacro( SfxObjectShell* pShell );
+	sal_Bool processDocActivateMacro( SfxObjectShell* pShell );
+	sal_Bool processDocDeactivateMacro( SfxObjectShell* pShell );
+	void processDocNewSheetMacro( SfxObjectShell* pShell, uno::Any aElement );
+	void processDocNewSheet( SCTAB nTab );
+	uno::Any getVbaWindow( SfxObjectShell* pShell );
+	sal_Bool addDocEvent( SfxObjectShell* pShell, const String& sEvt, const String& sOpenMacro );
+	void processDocDeactivateMacroRun( SfxObjectShell* pShell );
+	sal_Bool processDocBeforeCloseMacro();
+	sal_Bool processDocBeforePrintMacro();
+	sal_Bool processDocMacro();
+	sal_Bool processDocBeforeSaveMacro( sal_Bool bSaveAsUI );
+    void processWorkbookMacro_noreturn( const rtl::OUString sMacroName );
+    void WorkbookAutoOpen();
+    void WorkbookOpen();
+    void WorkbookActivate();
+    void WorkbookDeactivate();
+    void WorkbookWindowMacro( const sal_Int32 nHint );
+
+public:
+	ScVbaEventsHelper( ScDocument* pDocument ):pDoc( pDocument ), mpWindowListener( NULL ), mbOpened( sal_False ){};
+    ScVbaEventsHelper( css::uno::Sequence< css::uno::Any > const& aArgs, css::uno::Reference< css::uno::XComponentContext > const& xContext );
+    ~ScVbaEventsHelper();
+	ScDocument* getDocument() { return pDoc; };
+	sal_Bool executeSheetMacro( USHORT nEvent, SCTAB nTab, uno::Sequence< uno::Any >& rArgs );
+	//void processScTablesHint( USHORT nId, SCTAB nTab );
+	//void processSfxEventHint( const SfxEventHint& rHint );
+	void processWindowMacro( String sFuncName );
+    // XVBAWorkbookEventHelper
+    virtual sal_Bool SAL_CALL ProcessWorkbookEvent( sal_Int32 VbaEvent, sal_Int32 nTab, uno::Sequence< uno::Any >& aArgs ) throw (uno::RuntimeException);
+};
+
+#endif
+
--- /dev/null	2007-05-04 18:54:36.000000000 +0800
+++ sc/source/ui/vba/vbaeventshelper.cxx	2008-05-19 14:00:44.000000000 +0800
@@ -0,0 +1,1163 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: vbaeventshelper.cxx,v $
+ *
+ *  $Revision: 1.0 $
+ *
+ *  last change: $Author: vg $ $Date: 2007/12/07 10:42:26 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbaeventshelper.hxx"
+#include "helperdecl.hxx"
+#include <sfx2/objsh.hxx> 
+#include <basic/basmgr.hxx>
+#include <basic/sbmod.hxx>
+#include <basic/sbmeth.hxx>
+#include <basic/sbx.hxx>
+#include "scextopt.hxx"
+#include <sfx2/evntconf.hxx>
+#include <sfx2/event.hxx>
+#include <sfx2/sfx.hrc>
+#include <toolkit/unohlp.hxx>
+#include <comphelper/processfactory.hxx>
+#include <cppuhelper/implbase1.hxx>
+#ifndef _COM_SUN_STAR_SHEET_XSHEETCELLRANGECONTAINER_HPP_
+#include <com/sun/star/sheet/XSheetCellRangeContainer.hpp>
+#endif
+#include <com/sun/star/document/XEventsSupplier.hpp>
+#ifndef _COM_SUN_STAR_SHEET_XCELLRANGEREFERRER_HPP_
+#include <com/sun/star/sheet/XCellRangeReferrer.hpp>
+#endif
+#include <com/sun/star/table/XCell.hpp> 
+#include <com/sun/star/sheet/XSpreadsheetDocument.hpp>
+#include <com/sun/star/sheet/XSpreadsheet.hpp>
+#include <com/sun/star/container/XNamed.hpp>
+#include <com/sun/star/awt/XWindowListener.hpp>
+#include <com/sun/star/awt/WindowEvent.hpp>
+#include <com/sun/star/lang/EventObject.hpp>
+#include <com/sun/star/awt/MouseButton.hpp> 
+#include "cellsuno.hxx" 
+using namespace com::sun::star;
+using namespace org::openoffice;
+using namespace org::openoffice::vba::VBAWorkbookEvent;
+
+const static String sLibrary( RTL_CONSTASCII_USTRINGPARAM("Standard"));
+const static String sModule( RTL_CONSTASCII_USTRINGPARAM("ThisWorkbook"));
+
+const static rtl::OUString sUrlPart0 = rtl::OUString::createFromAscii( "vnd.sun.star.script:");
+const static rtl::OUString sUrlPart1 = rtl::OUString::createFromAscii( "vnd.sun.star.script:Standard.");
+const static rtl::OUString sUrlPart2 = rtl::OUString::createFromAscii( "?language=Basic&location=document"); 
+
+typedef ::cppu::WeakImplHelper1< awt::XWindowListener > WindowListener_BASE;
+class VbaWindowListener : public WindowListener_BASE
+{
+    ScVbaEventsHelper* pVbaEventsHelper;
+    uno::Reference< frame::XModel > m_xModel;
+    sal_Bool m_bPrepare;
+protected :
+    uno::Reference< awt::XWindow > GetContainerWindow();
+    sal_Bool IsMouseReleased();
+    DECL_LINK( fireResizeMacro, Timer* );
+    void processWindowResizeMacro();
+public :
+    VbaWindowListener( ScVbaEventsHelper* pHelper );
+    void startWindowLinstener();
+    void stopWindowLinstener();
+    // XWindowListener
+    virtual void SAL_CALL windowResized( const awt::WindowEvent& aEvent ) throw ( uno::RuntimeException );
+    virtual void SAL_CALL windowMoved( const awt::WindowEvent& aEvent ) throw ( uno::RuntimeException );
+    virtual void SAL_CALL windowShown( const lang::EventObject& aEvent ) throw ( uno::RuntimeException );
+    virtual void SAL_CALL windowHidden( const lang::EventObject& aEvent ) throw ( uno::RuntimeException );
+    virtual void SAL_CALL disposing( const lang::EventObject& aEvent ) throw ( uno::RuntimeException );
+};
+VbaWindowListener::VbaWindowListener( ScVbaEventsHelper* pHelper ) : pVbaEventsHelper( pHelper )
+{
+    m_xModel.set( pVbaEventsHelper->getDocument()->GetDocumentShell()->GetModel(), uno::UNO_QUERY );
+    m_bPrepare = sal_False;
+    //m_pTimer = 0;
+}
+uno::Reference< awt::XWindow > 
+VbaWindowListener::GetContainerWindow() 
+{
+    try
+    {
+        if( pVbaEventsHelper )
+        {
+            uno::Reference< frame::XModel > xModel( m_xModel, uno::UNO_QUERY );
+            if( xModel.is() )
+            {
+                uno::Reference< frame::XController > xController( xModel->getCurrentController(), uno::UNO_QUERY );
+                if( xController.is() )
+                {
+                    uno::Reference< frame::XFrame > xFrame( xController->getFrame(), uno::UNO_QUERY );
+                    if( xFrame.is() )
+                    {
+                        uno::Reference< awt::XWindow > xWindow( xFrame->getContainerWindow(), uno::UNO_QUERY );
+                        if( xWindow.is() )
+                            return xWindow;
+                    }
+                }
+            }
+        }
+    }
+	catch( uno::Exception& e )
+    {
+    }
+    return uno::Reference< awt::XWindow >();
+}
+sal_Bool
+VbaWindowListener::IsMouseReleased()
+{
+    Window* pWindow = (VCLUnoHelper::GetWindow(  GetContainerWindow() ) );
+    if( pWindow )
+    {
+        Window::PointerState aPointerState = pWindow->GetPointerState();
+        if( !aPointerState.mnState & ( MOUSE_LEFT | MOUSE_MIDDLE | MOUSE_RIGHT ) )
+            return sal_True; 
+    }
+    return sal_False;
+}
+void
+VbaWindowListener::startWindowLinstener()
+{
+    OSL_TRACE( "VbaWindowListener::startWindowLinstener" );
+    uno::Reference< awt::XWindow > xWindow( GetContainerWindow(), uno::UNO_QUERY );
+    if( xWindow.is() )
+        xWindow->addWindowListener( this );
+}
+void
+VbaWindowListener::stopWindowLinstener()
+{
+    OSL_TRACE( "VbaWindowListener::stopWindowLinstener" );
+    uno::Reference< awt::XWindow > xWindow( GetContainerWindow(), uno::UNO_QUERY );
+    if( xWindow.is() )
+    {
+        xWindow->removeWindowListener( this );
+        pVbaEventsHelper = NULL;
+    }
+}
+void
+VbaWindowListener::processWindowResizeMacro()
+{
+    const static String sWindowResize( RTL_CONSTASCII_USTRINGPARAM("Workbook_WindowResize") );
+    if( pVbaEventsHelper )
+        pVbaEventsHelper->processWindowMacro( sWindowResize );
+}
+IMPL_LINK( VbaWindowListener, fireResizeMacro, Timer*, pTimer )
+{
+    if( pVbaEventsHelper && m_bPrepare && pTimer )
+    {
+        if( IsMouseReleased() )
+        {
+            pTimer->Stop();
+            delete pTimer;
+            pTimer = 0;
+            m_bPrepare = sal_False;
+            OSL_TRACE("\tfiredMacroAtHere");
+            processWindowResizeMacro();
+        }
+    }
+    return 0;
+}
+void SAL_CALL
+VbaWindowListener::windowResized(  const awt::WindowEvent& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+    Window* pWindow = (VCLUnoHelper::GetWindow(  GetContainerWindow() ) );
+    if( pWindow && !m_bPrepare )
+    {
+        m_bPrepare = sal_True;
+        AutoTimer* pTimer = new AutoTimer();
+        pTimer->SetTimeoutHdl( LINK( this, VbaWindowListener, fireResizeMacro ) );
+        pTimer->Start();
+        OSL_TRACE("\tVbaWindowListener::windowResized");
+    }
+}
+void SAL_CALL
+VbaWindowListener::windowMoved(  const awt::WindowEvent& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+    // not interest this time
+    OSL_TRACE("\tVbaWindowListener::windowMoved");
+}
+void SAL_CALL
+VbaWindowListener::windowShown(  const lang::EventObject& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+    // not interest this time
+    OSL_TRACE("\tVbaWindowListener::windowShown");
+}
+void SAL_CALL
+VbaWindowListener::windowHidden(  const lang::EventObject& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+    // not interest this time
+    OSL_TRACE("\tVbaWindowListener::windowHidden");
+}
+void SAL_CALL
+VbaWindowListener::disposing(  const lang::EventObject& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+    OSL_TRACE("\tVbaWindowListener::disposing");
+    stopWindowLinstener();
+    //m_xModel->dispose();
+    pVbaEventsHelper = NULL;
+}
+
+ScVbaEventsHelper::ScVbaEventsHelper( uno::Sequence< css::uno::Any > const& aArgs, uno::Reference< uno::XComponentContext > const& xContext )
+    : m_xContext( xContext ), mpWindowListener( NULL ), mbOpened( sal_False )
+{
+    OSL_TRACE( "ScVbaEventsHelper::ScVbaEventsHelper" );
+    uno::Reference< frame::XModel > xModel ( getXSomethingFromArgs< frame::XModel >( aArgs, 0 ), uno::UNO_QUERY );
+    ScDocShell* pDocShell = getDocShell( xModel );
+    pDoc = pDocShell->GetDocument();
+}
+
+ScVbaEventsHelper::~ScVbaEventsHelper()
+{
+    OSL_TRACE("ScVbaEventsHelper::~ScVbaEventsHelper");
+    if( mpWindowListener )
+    {
+        mpWindowListener->stopWindowLinstener();
+        mpWindowListener = NULL;
+    }
+}
+
+String ScVbaEventsHelper::getWorkbookModuleName()
+{
+	String sCodeName( RTL_CONSTASCII_USTRINGPARAM("ThisWorkbook") );
+	if ( ScExtDocOptions* pExtDocOpts = pDoc->GetExtDocOptions() )
+	{
+		if ( pExtDocOpts->GetDocSettings().maGlobCodeName.Len() > 0 ) 
+			sCodeName = pExtDocOpts->GetDocSettings().maGlobCodeName;
+	}
+	return sCodeName;
+}
+
+// Treat the args as possible inouts ( convertion at bottom of method )
+sal_Bool ScVbaEventsHelper::executeWorkBookMacro( SfxObjectShell* pShell, const String& sMacroName, uno::Sequence< uno::Any >& aArgs, uno::Any& aRet )
+{
+	// until ObjectModules ( and persisting of codenames ) is supported, if this is a
+	// document saved from XL then we won't be able to determine the codename for the Workbook
+	// Module, so... we have no choice but to search all modules for the moment, thus the macro
+	// passed in should be the fully specified name. 	
+	//rtl::OUString sCodeName = getWorkbookModuleName( pShell );
+	//rtl::OUString sUrl = sUrlPart1.concat( sCodeName ).concat( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".") ) ).concat( sMacroName ).concat( sUrlPart2 );
+	rtl::OUString sUrl = sUrlPart0.concat( sMacroName ).concat( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".") ) ).concat( sUrlPart2 ) ;
+	uno::Sequence< sal_Int16 > aOutArgsIndex;
+	uno::Sequence< uno::Any > aOutArgs;
+	ErrCode nErr = pShell->CallXScript( sUrl,  aArgs, aRet,
+			aOutArgsIndex, aOutArgs, sal_False );
+
+	// Script Executed?
+	if ( nErr != ERRCODE_NONE )
+		return sal_False;
+
+	sal_Int32 nLen = aOutArgs.getLength();
+	// convert any out params to seem like they were inouts
+	if ( nLen )
+	{
+		for ( sal_Int32 index=0; index < nLen; ++index )
+		{
+			sal_Int32 nOutIndex = aOutArgsIndex[ index ];
+			aArgs[ nOutIndex ] = aOutArgs[ index ];
+		}
+
+	}
+	return sal_True;
+}
+String ScVbaEventsHelper::docMacroExists( SfxObjectShell* pShell, const String& sMod, const String& sMacro )
+{
+	String sFullName;	
+	// would use the script provider to see if the macro exists but
+	// called at this stage tdoc content handler stuff is not set up
+	// so it fails
+
+	BasicManager* pBasicMgr = pShell-> GetBasicManager();
+	if ( pBasicMgr )
+	{
+		StarBASIC* pBasic = pBasicMgr->GetLib( sLibrary );
+		if ( !pBasic )
+		{
+			USHORT nId = pBasicMgr->GetLibId( sLibrary );
+			pBasicMgr->LoadLib( nId );
+			pBasic = pBasicMgr->GetLib( sLibrary );
+		}
+		if ( pBasic )
+		{
+			if ( sMod.Len() ) // we wish to find the macro is a specific module
+			{
+				SbModule* pModule = pBasic->FindModule( sMod );
+				if ( pModule )
+				{
+					SbxArray* pMethods = pModule->GetMethods();
+					if ( pMethods )
+					{
+						SbMethod* pMethod = static_cast< SbMethod* >( pMethods->Find( sMacro, SbxCLASS_METHOD ) );
+						if ( pMethod )
+						{
+							sFullName = sMacro;
+							sFullName.Insert( '.', 0 ).Insert( sMod, 0 ).Insert( '.', 0 ).Insert( sLibrary, 0 );
+						}
+					}
+				}
+			}
+			else if( SbMethod* pMethod = dynamic_cast< SbMethod* >( pBasic->Find( sMacro, SbxCLASS_METHOD ) ) )
+			{
+					if( SbModule* pModule = pMethod->GetModule() )
+					{
+						sFullName = sMacro;
+						sFullName.Insert( '.', 0 ).Insert( pModule->GetName(), 0).Insert( '.', 0 ).Insert( sLibrary, 0 );
+					}
+			}		
+				
+		}
+	}
+	return sFullName;
+}
+
+sal_Bool ScVbaEventsHelper::processDocBeforeCloseMacro()
+{
+	sal_Bool bCancel = sal_False;
+	SfxObjectShell* pShell = pDoc->GetDocumentShell();
+	if( pShell )
+	{
+    	uno::Any aRet;
+    	uno::Sequence< uno::Any > aArgs( 1 );
+    	aArgs[ 0 ] <<= bCancel;
+    	const static String sBeforeClose( RTL_CONSTASCII_USTRINGPARAM("Workbook_BeforeClose") );
+    	String sFullClose = docMacroExists( pShell, String(), sBeforeClose );
+    	if ( sFullClose.Len() > 0 )
+    	{ 
+    		if ( !executeWorkBookMacro( pShell, sFullClose, aArgs, aRet ) )
+    			return sal_False;
+    	}
+    	aArgs[ 0 ] >>= bCancel;
+	}
+	return bCancel;
+}
+
+sal_Bool ScVbaEventsHelper::addOpenDocEvent( const uno::Reference< container::XNameReplace >& xEvts, const String& sOpenMacro )
+{
+	sal_Bool result = sal_False;
+	const rtl::OUString sUrl = sUrlPart0.concat( sOpenMacro ).concat( sUrlPart2 );
+	const static rtl::OUString sEvtType( RTL_CONSTASCII_USTRINGPARAM("EventType") );
+	const static rtl::OUString sScript( RTL_CONSTASCII_USTRINGPARAM("Script") );
+	const static rtl::OUString sEvt( RTL_CONSTASCII_USTRINGPARAM("OnLoad") );
+	if ( xEvts.is() )
+	{
+		uno::Sequence< beans::PropertyValue > aEvents;
+		xEvts->getByName( sEvt ) >>= aEvents;
+		uno::Sequence< beans::PropertyValue > aOpenEvt( 2 );
+		aOpenEvt[ 0 ].Name = sEvtType;
+		aOpenEvt[ 0 ].Value = uno::makeAny(sScript);
+		aOpenEvt[ 1 ].Name = sScript;
+		aOpenEvt[ 1 ].Value = uno::makeAny(sUrl);
+		sal_Int32 nPos = aEvents.getLength();
+
+		sal_Int32 nNewSize = aEvents.getLength() + aOpenEvt.getLength();
+		if ( nNewSize > aEvents.getLength() )
+			aEvents.realloc( nNewSize );
+
+		for ( sal_Int32 nIndex = nPos, nCpyIndex = 0; nIndex<nNewSize; nIndex++, nCpyIndex++ )
+			aEvents[ nIndex ] = aOpenEvt[ nCpyIndex ];	
+			
+		uno::Any aParam = uno::makeAny( aEvents );
+
+		xEvts->replaceByName( sEvt, aParam ); 
+		result = sal_True;
+	}
+	return result;
+}
+
+uno::Any ScVbaEventsHelper::createWorkSheet( SfxObjectShell* pShell, SCTAB nTab )
+{
+	uno::Any aRet;
+	try
+	{
+		uno::Reference< lang::XMultiComponentFactory > xSMgr( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+		uno::Reference< beans::XPropertySet > xProps( xSMgr, uno::UNO_QUERY_THROW );
+		uno::Reference<uno::XComponentContext > xCtx( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), uno::UNO_QUERY_THROW );
+		// Eventually we will be able to pull the Workbook/Worksheet objects
+		// directly from basic and register them as listeners
+
+		// create Workbook
+		uno::Sequence< uno::Any > aArgs(2);
+		aArgs[0] = uno::Any( uno::Reference< uno::XInterface >() );
+		aArgs[1] = uno::Any( pShell->GetModel() );
+		uno::Reference< uno::XInterface > xWorkbook( xSMgr->createInstanceWithArgumentsAndContext(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.excel.Workbook") ), aArgs, xCtx ), uno::UNO_QUERY );
+
+		// create WorkSheet
+		String sSheetName;
+		pDoc->GetName( nTab, sSheetName );
+		aArgs = uno::Sequence< uno::Any >(3);
+		aArgs[ 0 ] <<= xWorkbook;
+		aArgs[ 1 ] <<= pShell->GetModel();
+		aArgs[ 2 ] = uno::makeAny( rtl::OUString( sSheetName ) );
+		aRet <<= xSMgr->createInstanceWithArgumentsAndContext(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.excel.Worksheet") ), aArgs, xCtx );
+	}
+	catch( uno::Exception& e )
+	{
+	}
+	return aRet;
+}
+
+uno::Any ScVbaEventsHelper::createRange( const uno::Any& aRange )
+{
+	uno::Any aRet;
+	try
+	{
+		uno::Reference< sheet::XSheetCellRangeContainer > xRanges( 	aRange, uno::UNO_QUERY );
+		uno::Reference< table::XCellRange > xRange( aRange, uno::UNO_QUERY );
+		uno::Reference< lang::XMultiComponentFactory > xSMgr( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+		uno::Reference< beans::XPropertySet > xProps( xSMgr, uno::UNO_QUERY_THROW );
+		if (  xRanges.is() || xRange.is() )
+		{
+			uno::Reference<uno::XComponentContext > xCtx( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), uno::UNO_QUERY_THROW );
+			uno::Sequence< uno::Any > aArgs(2);
+			aArgs[0] = uno::Any( uno::Reference< uno::XInterface >() ); // dummy parent
+			if ( xRanges.is() )
+			{
+				aArgs[1] <<= xRanges;
+			}
+			else if ( xRange.is() )
+			{
+				aArgs[1] <<= xRange;
+			}
+			else
+			{
+				throw uno::RuntimeException(); // 
+			}
+			aRet <<= xSMgr->createInstanceWithArgumentsAndContext( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.excel.Range") ), aArgs, xCtx  );	
+		}
+	}
+	catch( uno::Exception& e ) 
+	{
+	}
+	return aRet;
+}
+
+uno::Any ScVbaEventsHelper::createHyperlink( const uno::Any& rCell )
+{
+	uno::Any aRet;
+	try
+	{
+		uno::Reference< lang::XMultiComponentFactory > xSMgr( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+		uno::Reference< beans::XPropertySet > xProps( xSMgr, uno::UNO_QUERY_THROW ); 
+		uno::Reference< table::XCell > xCell( rCell, uno::UNO_QUERY );
+		if( xCell.is() )
+		{
+			uno::Reference<uno::XComponentContext > xCtx( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), uno::UNO_QUERY_THROW );
+			uno::Sequence< uno::Any > aArgs(2);
+			aArgs[0] = uno::Any( uno::Reference< uno::XInterface >() ); // dummy parent
+			aArgs[1] <<= rCell;
+			//aArgs[1] <<= uno::makeAny( rtl::OUString( aItem ) );
+			
+			aRet <<= xSMgr->createInstanceWithArgumentsAndContext( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.excel.Hyperlink") ), aArgs, xCtx  );	
+		}
+		else
+		{
+			throw uno::RuntimeException(); // 
+		}
+	}
+	catch( uno::Exception& e ) 
+	{
+	}
+	return aRet;
+}
+
+void ScVbaEventsHelper::getSheetEventName( USHORT nEvent, String& rSheetScript, String& rWorkbookScript )
+{
+	switch( nEvent )
+	{
+		case SC_VBAEVENT_SHEET_ACTIVATE:
+		{
+			rSheetScript = String( RTL_CONSTASCII_USTRINGPARAM("Worksheet_Activate") );
+			rWorkbookScript = String( RTL_CONSTASCII_USTRINGPARAM("Workbook_SheetActivate") );
+			break;
+		}
+		case SC_VBAEVENT_SHEET_BEFOREDOUBLECLICK:
+		{
+			rSheetScript = String( RTL_CONSTASCII_USTRINGPARAM("Worksheet_BeforeDoubleClick") );
+			rWorkbookScript = String( RTL_CONSTASCII_USTRINGPARAM("Workbook_SheetBeforeDoubleClick") );
+			break;
+		}
+		case SC_VBAEVENT_SHEET_BEFORERIGHTCLICK:
+		{
+			rSheetScript = String( RTL_CONSTASCII_USTRINGPARAM("Worksheet_BeforeRightClick") );
+			rWorkbookScript = String( RTL_CONSTASCII_USTRINGPARAM("Workbook_SheetBeforeRightClick") );
+			break;
+		}
+		case SC_VBAEVENT_SHEET_CALCULATE:
+		{
+			rSheetScript = String( RTL_CONSTASCII_USTRINGPARAM("Worksheet_Calculate") );
+			rWorkbookScript = String( RTL_CONSTASCII_USTRINGPARAM("Workbook_SheetCalculate") );
+			break;
+		}
+		case SC_VBAEVENT_SHEET_CHANGE:
+		{
+			rSheetScript = String( RTL_CONSTASCII_USTRINGPARAM("Worksheet_Change") );
+			rWorkbookScript = String( RTL_CONSTASCII_USTRINGPARAM("Workbook_SheetChange") );
+			break;
+		}
+		case SC_VBAEVENT_SHEET_DEACTIVATE:
+		{
+			rSheetScript = String( RTL_CONSTASCII_USTRINGPARAM("Worksheet_Deactivate") );
+			rWorkbookScript = String( RTL_CONSTASCII_USTRINGPARAM("Workbook_SheetDeactivate") );
+			break;
+		}
+		case SC_VBAEVENT_SHEET_FOLLOWHYPERLINK:
+		{
+			rSheetScript = String( RTL_CONSTASCII_USTRINGPARAM("Worksheet_FollowHyperlink") );
+			rWorkbookScript = String( RTL_CONSTASCII_USTRINGPARAM("Workbook_SheetFollowHyperlink") );
+			break;
+		}
+		case SC_VBAEVENT_SHEET_PIVOTTABLEUPDATE:
+		{
+			rSheetScript = String( RTL_CONSTASCII_USTRINGPARAM("Worksheet_PivotTableUpdate") );
+			rWorkbookScript = String( RTL_CONSTASCII_USTRINGPARAM("Workbook_SheetPivotTableUpdate") );
+			break;
+		}
+		case SC_VBAEVENT_SHEET_SELECTIONCHANGE:
+		{
+			rSheetScript = String( RTL_CONSTASCII_USTRINGPARAM("Worksheet_SelectionChange") );
+			rWorkbookScript = String( RTL_CONSTASCII_USTRINGPARAM("Workbook_SheetSelectionChange") );
+			break;
+		}
+		default:
+			break;
+	}
+	
+	return;
+}
+
+String ScVbaEventsHelper::getSheetModuleName( SCTAB nTab )
+{
+	ScExtDocOptions* pExtOptions = pDoc->GetExtDocOptions();
+	String aCodeName;
+	pDoc->GetName( nTab, aCodeName);
+	// Use code name if that exists
+	if ( pExtOptions )
+		aCodeName = pExtOptions->GetCodeName( nTab );
+	return aCodeName;	
+}
+
+sal_Bool ScVbaEventsHelper::executeSheetMacro( USHORT nEvent, SCTAB nTab, uno::Sequence< uno::Any >& rArgs )
+{
+	SfxObjectShell* pShell = pDoc->GetDocumentShell();
+	if( !pShell )
+		return sal_False;
+
+	sal_Bool result = sal_False;
+	uno::Sequence< uno::Any > aArgs;
+	uno::Any aRet;
+	
+	String aSheetScript;
+	String aWorkbookScript;
+
+	getSheetEventName( nEvent, aSheetScript, aWorkbookScript );
+
+	String aSheetModuleName = getSheetModuleName( nTab );
+	String aSheetMacro = docMacroExists( pShell, aSheetModuleName, aSheetScript );
+	String aWorkbookMacro = docMacroExists( pShell, String(), aWorkbookScript );
+	if( aSheetMacro.Len() > 0 || aWorkbookMacro.Len() > 0 )
+	{
+		switch( nEvent )
+		{
+			case SC_VBAEVENT_SHEET_ACTIVATE:
+			case SC_VBAEVENT_SHEET_CALCULATE:
+			case SC_VBAEVENT_SHEET_DEACTIVATE:
+			{
+				// no arguments
+				if( aSheetMacro.Len() > 0 )
+					result = executeWorkBookMacro( pShell, aSheetMacro, aArgs, aRet );
+				
+				if( aWorkbookMacro.Len() > 0 )
+				{
+					aArgs = uno::Sequence< uno::Any >(1);
+					aArgs[0] = createWorkSheet( pShell, nTab ); 
+					result = executeWorkBookMacro( pShell, aWorkbookMacro, aArgs, aRet );
+				}
+					
+				break;
+			}
+			case SC_VBAEVENT_SHEET_CHANGE:
+			case SC_VBAEVENT_SHEET_SELECTIONCHANGE:
+			{
+				// one argument: range
+				uno::Any aRange = createRange( rArgs[0] );
+				if( aSheetMacro.Len() > 0 )
+				{
+					aArgs = uno::Sequence< uno::Any >(1);
+					aArgs[0] = aRange;
+					result = executeWorkBookMacro( pShell, aSheetMacro, aArgs, aRet );
+				}
+
+				if( aWorkbookMacro.Len() > 0 )
+				{
+					aArgs = uno::Sequence< uno::Any >(2);
+					aArgs[0] = createWorkSheet( pShell, nTab );
+					aArgs[1] = aRange;
+					result = executeWorkBookMacro( pShell, aWorkbookMacro, aArgs, aRet );
+				}
+				break;
+			}
+			case SC_VBAEVENT_SHEET_BEFOREDOUBLECLICK:
+			case SC_VBAEVENT_SHEET_BEFORERIGHTCLICK:
+			{
+				// two aruments: range and cancel
+				uno::Any aRange = createRange( rArgs[0] );
+				if( aSheetMacro.Len() > 0 )
+				{
+					aArgs = uno::Sequence< uno::Any >(2);
+					aArgs[0] = aRange;
+					aArgs[1] = rArgs[1];
+					result = executeWorkBookMacro( pShell, aSheetMacro, aArgs, aRet );
+					// return the cancel value
+					rArgs[1] = aArgs[1];
+				}
+
+				if( aWorkbookMacro.Len() > 0 )
+				{
+					aArgs = uno::Sequence< uno::Any >(3);
+					aArgs[0] = createWorkSheet( pShell, nTab );
+					aArgs[1] = aRange;
+					aArgs[2] = aArgs[1];
+					result = executeWorkBookMacro( pShell, aWorkbookMacro, aArgs, aRet );
+					rArgs[2] = aArgs[2];
+				}
+				break;
+			}
+			case SC_VBAEVENT_SHEET_FOLLOWHYPERLINK:
+			{
+				// one argument: hyperlink
+				uno::Any aHyperlink = createHyperlink( rArgs[0] );
+				if( aSheetMacro.Len() > 0 )
+				{
+					aArgs = uno::Sequence< uno::Any >(1);
+					aArgs[0] = aHyperlink;
+					result = executeWorkBookMacro( pShell, aSheetMacro, aArgs, aRet );
+				}
+
+				if( aWorkbookMacro.Len() > 0 )
+				{
+					aArgs = uno::Sequence< uno::Any >(2);
+					aArgs[0] = createWorkSheet( pShell, nTab );
+					aArgs[1] = aHyperlink;
+					result = executeWorkBookMacro( pShell, aWorkbookMacro, aArgs, aRet );
+				}
+				break;
+			}
+			case SC_VBAEVENT_SHEET_PIVOTTABLEUPDATE:
+			{
+				// one argument: pivottable
+				break;
+			}
+		}
+	}
+
+	return result;
+}
+
+sal_Bool ScVbaEventsHelper::processDocBeforePrintMacro( )
+{
+	SfxObjectShell* pShell = pDoc->GetDocumentShell();
+	if( !pShell )
+		return sal_False;
+	
+	uno::Any aRet;
+	uno::Sequence< uno::Any > aArgs( 1 );
+	sal_Bool bCancel = sal_False;
+	aArgs[ 0 ] <<= bCancel;
+	const static String sBeforeClose( RTL_CONSTASCII_USTRINGPARAM("Workbook_BeforePrint") );
+	String sFullClose = docMacroExists( pShell, String(), sBeforeClose );
+	if ( sFullClose.Len() > 0 )
+	{ 
+		if ( !executeWorkBookMacro( pShell, sFullClose, aArgs, aRet ) )
+			return sal_False;
+	}
+	aArgs[ 0 ] >>= bCancel;
+	return bCancel;
+}
+
+void ScVbaEventsHelper::processDocNewSheetMacro( SfxObjectShell* pShell, uno::Any aElement )
+{
+    uno::Any aRet;
+    if( aElement.hasValue() )
+    {
+        uno::Sequence< uno::Any > aArgs(1);
+        aArgs[0] = aElement;
+        const static String sNewSheet( RTL_CONSTASCII_USTRINGPARAM("Workbook_NewSheet") );
+        String sFullClose = docMacroExists( pShell, String(), sNewSheet );
+        if ( sFullClose.Len() > 0 )
+        {
+            executeWorkBookMacro( pShell, sFullClose, aArgs, aRet );
+        }
+    }
+}
+/*
+#define SC_TAB_INSERTED         1
+void ScVbaEventsHelper::processScTablesHint( USHORT nId, SCTAB nTab )
+{
+	SfxObjectShell* pShell = pDoc->GetDocumentShell();
+    if( pShell )
+    {
+//        USHORT nId = rHint.GetId();
+//       SCTAB  nTab = rHint.GetTab1();
+        if( nId == SC_TAB_INSERTED )
+        {
+            processDocNewSheetMacro( pShell, createWorkSheet( pShell, nTab ) );
+        }
+    }
+}
+*/
+void ScVbaEventsHelper::processDocNewSheet( SCTAB nTab )
+{
+    SfxObjectShell* pShell = pDoc->GetDocumentShell();
+    if( pShell )
+        processDocNewSheetMacro( pShell, createWorkSheet( pShell, nTab ) );
+}
+
+void ScVbaEventsHelper::processWindowMacro( String sFuncName )
+{
+	SfxObjectShell* pShell = pDoc->GetDocumentShell();
+	if( !pShell )
+		return;
+	uno::Any aElement = getVbaWindow( pShell );
+
+    uno::Any aRet;
+    if( aElement.hasValue() && ( sFuncName.Len() > 0 ) )
+    {
+        uno::Sequence< uno::Any > aArgs(1);
+        aArgs[0] = aElement;
+        String sMacro = docMacroExists( pShell, String(), sFuncName );
+        if ( sMacro.Len() > 0 )
+        {
+            executeWorkBookMacro( pShell, sMacro, aArgs, aRet );
+        }
+    }
+}
+uno::Any ScVbaEventsHelper::getVbaWindow( SfxObjectShell* pShell )
+{
+    try
+    {
+        uno::Reference< lang::XMultiServiceFactory > xSF( comphelper::getProcessServiceFactory(), uno::UNO_QUERY );
+        uno::Reference< frame::XModel > xModel( pShell->GetModel(), uno::UNO_QUERY );
+        uno::Sequence< uno::Any > aWindowArgs(2);
+        aWindowArgs[0] = uno::Any( uno::Reference< uno::XInterface > () );
+        aWindowArgs[1] = uno::Any( xModel );
+        uno::Reference< uno::XInterface > xWindow( xSF->createInstanceWithArguments( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.excel.Window" ) ), aWindowArgs ), uno::UNO_QUERY );
+        if( xWindow.is() )
+            return uno::makeAny( xWindow );
+    }
+	catch( uno::Exception& e )
+	{
+	}
+    return uno::Any();
+}
+
+sal_Bool ScVbaEventsHelper::addDocEvent( SfxObjectShell* pShell, const String& sEvt, const String& sOpenMacro )
+{
+	sal_Bool result = sal_False;
+	const rtl::OUString sUrl = sUrlPart0.concat( sOpenMacro ).concat( sUrlPart2 );
+	const static rtl::OUString sEvtType( RTL_CONSTASCII_USTRINGPARAM("EventType") );
+	const static rtl::OUString sScript( RTL_CONSTASCII_USTRINGPARAM("Script") );
+	uno::Reference< document::XEventsSupplier > xEvtSupplier( pShell->GetModel(), uno::UNO_QUERY );
+
+	if ( xEvtSupplier.is() )
+    {
+		uno::Reference< container::XNameReplace > xEvts( xEvtSupplier->getEvents(), uno::UNO_QUERY );
+	    if ( xEvts.is() )
+	    {
+            if( xEvts->hasByName( sEvt ) )
+            {
+                if( !xEvts->getByName( sEvt ).hasValue() )
+                {
+                    uno::Sequence< beans::PropertyValue > aEvt( 2 );
+                    aEvt[ 0 ].Name = sEvtType;
+                    aEvt[ 0 ].Value = uno::makeAny(sScript);
+                    aEvt[ 1 ].Name = sScript;
+                    aEvt[ 1 ].Value = uno::makeAny(sUrl);
+
+		            uno::Any aParam = uno::makeAny( aEvt );
+                    xEvts->replaceByName( sEvt, aParam );
+		            result = sal_True;
+                }
+            }
+	    }
+    }
+	return result;
+}
+
+
+sal_Bool ScVbaEventsHelper::processDocActivateMacro( SfxObjectShell* pShell )
+{
+    sal_Bool result = sal_True;
+    const static rtl::OUString sAtctivateMacro( RTL_CONSTASCII_USTRINGPARAM("Workbook_Activate") );
+    const static rtl::OUString sOnFocusEvt( RTL_CONSTASCII_USTRINGPARAM("OnFocus") );
+    rtl::OUString sWorkbookModule;
+    String sFullOnFocus = docMacroExists( pShell, sWorkbookModule, sAtctivateMacro );
+    if( sFullOnFocus.Len() > 0 )
+    {
+        if( !addDocEvent( pShell, sOnFocusEvt, sFullOnFocus ) )
+            return sal_False;
+    }
+    return result;
+}
+
+sal_Bool ScVbaEventsHelper::processDocDeactivateMacro( SfxObjectShell* pShell )
+{
+    sal_Bool result = sal_True;
+    const static rtl::OUString sDeatctivateMacro( RTL_CONSTASCII_USTRINGPARAM("Workbook_Deactivate") );
+    const static rtl::OUString sOnFocusEvt( RTL_CONSTASCII_USTRINGPARAM("OnUnfocus") );
+    rtl::OUString sWorkbookModule;
+    String sFullUnOnfocus = docMacroExists( pShell, sWorkbookModule, sDeatctivateMacro );
+    if( sFullUnOnfocus.Len() > 0 )
+    {
+        if( !addDocEvent( pShell, sOnFocusEvt, sFullUnOnfocus ) )
+            return sal_False;
+    }
+    return result;
+}
+
+void ScVbaEventsHelper::processDocDeactivateMacroRun( SfxObjectShell* pShell )
+{
+    uno::Any aRet;
+    uno::Sequence< uno::Any > aArgs;
+    const static String sDeactivate( RTL_CONSTASCII_USTRINGPARAM("Workbook_Deactivate") );
+    String sDeactivateMacro = docMacroExists( pShell, String(), sDeactivate );
+    if ( sDeactivateMacro.Len() > 0 )
+    {
+        executeWorkBookMacro( pShell, sDeactivateMacro, aArgs, aRet );
+    }
+}
+
+void ScVbaEventsHelper::processWorkbookMacro_noreturn( const rtl::OUString sMacroName )
+{
+    uno::Any aRet;
+    uno::Sequence< uno::Any > aArgs;
+	SfxObjectShell* pShell = pDoc->GetDocumentShell();
+    String sOpenMacro = docMacroExists( pShell, String(), sMacroName );
+    if( pShell )
+    {
+        if ( sOpenMacro.Len() > 0 && pShell )
+        {
+            executeWorkBookMacro( pShell, sOpenMacro, aArgs, aRet );
+        }
+    }
+}
+
+void ScVbaEventsHelper::WorkbookAutoOpen()
+{
+	const static rtl::OUString sAuto_OpenMacro( RTL_CONSTASCII_USTRINGPARAM("auto_open") );
+    processWorkbookMacro_noreturn( sAuto_OpenMacro );
+}
+
+void ScVbaEventsHelper::WorkbookOpen()
+{
+	const static rtl::OUString sOpenMacro( RTL_CONSTASCII_USTRINGPARAM("Workbook_Open") );
+    processWorkbookMacro_noreturn( sOpenMacro );
+}
+
+void ScVbaEventsHelper::WorkbookActivate()
+{
+    const static rtl::OUString sAtctivateMacro( RTL_CONSTASCII_USTRINGPARAM("Workbook_Activate") );
+    processWorkbookMacro_noreturn( sAtctivateMacro );
+}
+
+void ScVbaEventsHelper::WorkbookDeactivate()
+{
+    const static rtl::OUString sDeatctivateMacro( RTL_CONSTASCII_USTRINGPARAM("Workbook_Deactivate") );
+    processWorkbookMacro_noreturn( sDeatctivateMacro );
+}
+
+/*
+void ScVbaEventsHelper::processSfxEventHint( const SfxEventHint& rHint )
+{
+	SfxObjectShell* pShell = pDoc->GetDocumentShell();
+	if( !pShell )
+		return;
+    ULONG nEventId = rHint.GetEventId();
+    const static String sWindowActivate( RTL_CONSTASCII_USTRINGPARAM("Workbook_WindowActivate") );
+    const static String sWindowDeactivate( RTL_CONSTASCII_USTRINGPARAM("Workbook_WindowDeactivate") );
+    switch( nEventId )
+    {
+        case SFX_EVENT_ACTIVATEDOC :
+            processWindowMacro( sWindowActivate );
+            break;
+        case SFX_EVENT_DEACTIVATEDOC :
+            // it will be called when close the doc. but will not launch the macro.
+            processWindowMacro( sWindowDeactivate );
+            break;
+        case SFX_EVENT_CLOSEDOC :
+            // the macro will not be called at this time, because of the doc has died.
+            //processDocDeactivateMacroRun( pShell );
+            break;
+        case SFX_EVENT_CLOSEVIEW :
+            processWindowMacro( sWindowDeactivate );
+            // does Doc be closed surely?
+            processDocDeactivateMacroRun( pShell );
+            break;
+        case SFX_EVENT_OPENDOC :
+        {
+            VbaWindowListener* pListener = new VbaWindowListener( this );
+            pListener->startWindowLinstener();
+            break;
+        }
+        default:
+            break;
+    }
+}
+*/
+
+void ScVbaEventsHelper::WorkbookWindowMacro( const sal_Int32 nHint )
+{
+	SfxObjectShell* pShell = pDoc->GetDocumentShell();
+	if( !pShell )
+		return;
+    const static String sWindowActivate( RTL_CONSTASCII_USTRINGPARAM("Workbook_WindowActivate") );
+    const static String sWindowDeactivate( RTL_CONSTASCII_USTRINGPARAM("Workbook_WindowDeactivate") );
+    switch( nHint )
+    {
+        case SC_VBAEVENT_WORKBOOK_WINDOWACTIVATE:
+            processWindowMacro( sWindowActivate );
+            break;
+        case SC_VBAEVENT_WORKBOOK_WINDOWDEACTIVATE:
+            // it will be called when close the doc. but will not launch the macro.
+            processWindowMacro( sWindowDeactivate );
+            break;
+        case SC_VBAEVENT_WORKBOOK_WINDOWCOLSE:
+            processWindowMacro( sWindowDeactivate );
+            // does Doc be closed surely?
+            processDocDeactivateMacroRun( pShell );
+            break;
+        default:
+            break;
+    }
+}
+
+sal_Bool ScVbaEventsHelper::processDocBeforeSaveMacro( sal_Bool bSaveAsUI )
+{
+	SfxObjectShell* pShell = pDoc->GetDocumentShell();
+	if( !pShell )
+		return sal_False;
+	
+	uno::Any aRet;
+	uno::Sequence< uno::Any > aArgs( 2 );
+	sal_Bool bCancel = sal_False;
+    aArgs[ 0 ] <<= bSaveAsUI;
+	aArgs[ 1 ] <<= bCancel;
+	const static String sBeforeClose( RTL_CONSTASCII_USTRINGPARAM("Workbook_BeforeSave") );
+	String sFullClose = docMacroExists( pShell, String(), sBeforeClose );
+	if ( sFullClose.Len() > 0 )
+	{ 
+		if ( !executeWorkBookMacro( pShell, sFullClose, aArgs, aRet ) )
+			return sal_False;
+	}
+	aArgs[ 1 ] >>= bCancel;
+	return bCancel;
+}
+
+sal_Bool ScVbaEventsHelper::processDocOpenMacro( SfxObjectShell* pShell )
+{
+	sal_Bool result = sal_True;
+	// no point adding a handler for unless it exists
+	// probably worth just doing this on import of xl document
+	
+		
+	// Urk due to async nature, re-enterency and other horrors of the load
+	// process, its seems the most sensible thing is to hook into the 
+	// document event broadcaster
+	const static rtl::OUString sOpenMacro( RTL_CONSTASCII_USTRINGPARAM("Workbook_Open") );
+	const static rtl::OUString sAuto_OpenMacro( RTL_CONSTASCII_USTRINGPARAM("auto_open") );
+    const static rtl::OUString sOnLoadEvt( RTL_CONSTASCII_USTRINGPARAM("OnLoad") );
+
+	// until ObjectModules ( and persisting of codename )  are supported if this is a
+	// document saved from XL then we won't be able to determine the codename for the Workbook
+	// Module, so... we have no choice but to search all modules for the moment 	
+	//rtl::OUString workbookModule = getWorkbookModuleName( pShell );
+	rtl::OUString workbookModule; // no name means all modules will be searched
+	String sFullOpen = docMacroExists( pShell, workbookModule, sOpenMacro );
+	if ( sFullOpen.Len() > 0 )
+	{
+			if ( !addDocEvent( pShell, sOnLoadEvt, sFullOpen ) )
+				return sal_False;
+	}
+	// deep sigh, you can only specify one event binding not multiple ones, thats crap
+/*
+		String sFullAuto = docMacroExists( pShell, workbookModule, sAuto_OpenMacro );
+		if ( sFullAuto.Len() > 0 )
+		{
+				if ( !addOpenDocEvent( xEvts, sFullAuto ) )
+					return sal_False;
+		}
+*/
+
+	return result;
+}
+sal_Bool ScVbaEventsHelper::processDocMacro()
+{
+	SfxObjectShell* pShell = pDoc->GetDocumentShell();
+	if( !pShell )
+		return sal_False;
+    sal_Bool result = sal_True;
+    if ( !processDocOpenMacro( pShell ) )
+        result = sal_False;
+    if( !processDocActivateMacro( pShell ) )
+        result = sal_False;
+    if( !processDocDeactivateMacro( pShell ) )
+        result = sal_False;
+
+    return result;
+}
+sal_Bool SAL_CALL 
+ScVbaEventsHelper::ProcessWorkbookEvent( sal_Int32 VbaEvent, sal_Int32 nTab, uno::Sequence< uno::Any >& aArgs ) throw (uno::RuntimeException)
+{
+    switch( VbaEvent )
+    {
+        // Worksheet
+		case SC_VBAEVENT_SHEET_ACTIVATE               :
+            executeSheetMacro( (USHORT)VbaEvent, (SCTAB)nTab, aArgs );
+        break;
+		case SC_VBAEVENT_SHEET_BEFOREDOUBLECLICK      :
+            executeSheetMacro( (USHORT)VbaEvent, (SCTAB)nTab, aArgs );
+        break;
+		case SC_VBAEVENT_SHEET_BEFORERIGHTCLICK       :
+            executeSheetMacro( (USHORT)VbaEvent, (SCTAB)nTab, aArgs );
+        break;
+		case SC_VBAEVENT_SHEET_CALCULATE              :
+            executeSheetMacro( (USHORT)VbaEvent, (SCTAB)nTab, aArgs );
+        break;
+		case SC_VBAEVENT_SHEET_CHANGE                 :
+            executeSheetMacro( (USHORT)VbaEvent, (SCTAB)nTab, aArgs );
+        break;
+		case SC_VBAEVENT_SHEET_DEACTIVATE             :
+            executeSheetMacro( (USHORT)VbaEvent, (SCTAB)nTab, aArgs );
+        break;
+		case SC_VBAEVENT_SHEET_FOLLOWHYPERLINK        :
+            executeSheetMacro( (USHORT)VbaEvent, (SCTAB)nTab, aArgs );
+        break;
+		case SC_VBAEVENT_SHEET_PIVOTTABLEUPDATE       :
+            executeSheetMacro( (USHORT)VbaEvent, (SCTAB)nTab, aArgs );
+        break;
+		case SC_VBAEVENT_SHEET_SELECTIONCHANGE        :
+            executeSheetMacro( (USHORT)VbaEvent, (SCTAB)nTab, aArgs );
+        break;
+		// Workbook
+		case SC_VBAEVENT_WORKBOOK_ACTIVATE            :
+        {
+            // if workbook open event do not be fired. fired it before 
+            // workbook activate event to compatible with MSO.
+            if( !mbOpened )
+            {
+                WorkbookOpen();
+                mbOpened = sal_True;
+            }
+            WorkbookActivate();
+            // workbook window activate event same as this one
+            WorkbookWindowMacro( SC_VBAEVENT_WORKBOOK_WINDOWACTIVATE );
+        }
+        break;
+		case SC_VBAEVENT_WORKBOOK_DEACTIVATE          :
+        {
+            WorkbookDeactivate();
+            // same as workbook window deactivate
+            WorkbookWindowMacro( SC_VBAEVENT_WORKBOOK_WINDOWDEACTIVATE );
+        }
+        break;
+		case SC_VBAEVENT_WORKBOOK_OPEN                :
+        {
+            //processDocMacro();
+            // process workbook open macro
+            // does auto open work here?
+            //WorkbookAutoOpen();
+            if( !mbOpened )
+            {
+                WorkbookOpen();
+                mbOpened = sal_True;
+            }
+            // register the window listener.
+            //VbaWindowListener* pListener = new VbaWindowListener( this );
+            if( !mpWindowListener )
+            {
+                mpWindowListener = new VbaWindowListener( this );
+                mpWindowListener->startWindowLinstener();
+            }
+        }
+        break;
+		case SC_VBAEVENT_WORKBOOK_AUTOOPEN            :
+        break;
+		case SC_VBAEVENT_WORKBOOK_BEFORECLOSE         :
+        {
+            sal_Bool bCancel = processDocBeforeCloseMacro();
+            if( mpWindowListener && !bCancel )
+            {
+                mpWindowListener->stopWindowLinstener();
+                mpWindowListener = NULL;
+            }
+            return bCancel;
+        }
+        break;
+		case SC_VBAEVENT_WORKBOOK_BEFOREPRINT         :
+        {
+            sal_Bool bCancel = processDocBeforePrintMacro();
+            return bCancel;
+        }
+        break;
+		case SC_VBAEVENT_WORKBOOK_BEFORESAVE          :
+        {
+            sal_Bool bUISave = sal_Bool();
+            if( aArgs[0] >>= bUISave )
+                return processDocBeforeSaveMacro( bUISave );
+        }
+        break;
+		case SC_VBAEVENT_WORKBOOK_NEWSHEET            :
+            processDocNewSheet( nTab ); 
+        break;
+		case SC_VBAEVENT_WORKBOOK_WINDOWACTIVATE      :
+        break;
+		case SC_VBAEVENT_WORKBOOK_WINDOWDEACTIVATE    :
+        break;
+		case SC_VBAEVENT_WORKBOOK_WINDOWRESIZE        :
+        break;
+		case SC_VBAEVENT_WORKBOOK_WINDOWCOLSE        :
+            WorkbookWindowMacro( VbaEvent );
+        break;
+		case SC_VBAEVENT_WORKBOOK_CLOSE               :
+        break;
+        default:
+            OSL_TRACE( "Invalid Event" );
+    }
+
+    return sal_True;
+}
+
+namespace vbaeventshelper
+{
+namespace sdecl = comphelper::service_decl;
+sdecl::class_<ScVbaEventsHelper, sdecl::with_args<true> > serviceImpl;
+extern sdecl::ServiceDecl const serviceDecl(
+    serviceImpl,
+    "ScVbaEventsHelper",
+    "org.openoffice.vba.VbaWorkbookEventsHelper" );
+}
--- sc/source/ui/vba/service.cxx.orig	2008-05-13 16:48:00.000000000 +0800
+++ sc/source/ui/vba/service.cxx	2008-05-13 22:54:36.000000000 +0800
@@ -69,6 +69,10 @@ namespace hyperlink 
 {
 extern sdecl::ServiceDecl const serviceDecl;
 }
+namespace vbaeventshelper
+{
+extern sdecl::ServiceDecl const serviceDecl;
+}
 
 
 extern "C"
@@ -87,7 +91,7 @@ extern "C"
 
 	// Component registration
         if ( component_writeInfoHelper( pServiceManager, pRegistryKey, 
-		range::serviceDecl, workbook::serviceDecl, worksheet::serviceDecl, globals::serviceDecl, userform::serviceDecl, window::serviceDecl, hyperlink::serviceDecl ) )
+		range::serviceDecl, workbook::serviceDecl, worksheet::serviceDecl, globals::serviceDecl, userform::serviceDecl, window::serviceDecl, hyperlink::serviceDecl ) && component_writeInfoHelper( pServiceManager, pRegistryKey, vbaeventshelper::serviceDecl ) )
 		{
 			// Singleton registration
 			try
@@ -116,6 +120,8 @@ extern "C"
 		OSL_TRACE("In component_getFactory for %s", pImplName );
 	void* pRet =  component_getFactoryHelper(
         	pImplName, pServiceManager, pRegistryKey, range::serviceDecl, workbook::serviceDecl, worksheet::serviceDecl, globals::serviceDecl, userform::serviceDecl, window::serviceDecl, hyperlink::serviceDecl );
+    if( !pRet )
+        pRet = component_getFactoryHelper( pImplName, pServiceManager, pRegistryKey, vbaeventshelper::serviceDecl );
 	OSL_TRACE("Ret is 0x%x", pRet);
 	return pRet;
     }
--- sc/inc/document.hxx.orig	2008-05-07 12:06:10.000000000 +0800
+++ sc/inc/document.hxx	2008-05-14 12:06:34.000000000 +0800
@@ -42,6 +42,7 @@
 #include "brdcst.hxx"
 #include "tabopparams.hxx"
 #include "grammar.hxx"
+//#include <org/openoffice/vba/XVBAWorkbookEventHelper.hpp>
 
 #include <memory>
 #include <map>
@@ -132,6 +133,7 @@ class ScAutoNameCache;
 class ScTemporaryChartLock;
 class ScLookupCache;
 struct ScLookupCacheMapImpl;
+//class ScVbaEventsHelper;
 
 namespace com { namespace sun { namespace star {
     namespace lang {
@@ -149,6 +151,9 @@ namespace com { namespace sun { namespac
     }
 } } }
 
+namespace org { namespace openoffice { namespace vba {
+    class XVBAWorkbookEventsHelper;
+} } }
 #include <svtools/zforlist.hxx>
 /*
 #ifdef _ZFORLIST_DECLARE_TABLE
@@ -307,6 +312,9 @@ private:
 
 	Timer				aTrackTimer;
 
+	//ScVbaEventsHelper*	pVbaEventsHelper;
+    com::sun::star::uno::Reference< org::openoffice::vba::XVBAWorkbookEventsHelper > rVbaEventsHelper;
+
 public:
     ScTabOpList         aTableOpList;		            // list of ScInterpreterTableOpParams currently in use
     ScInterpreterTableOpParams  aLastTableOpParams;     // remember last params
@@ -1717,6 +1725,9 @@ public:
 	void GetSortParam( ScSortParam& rParam, SCTAB nTab );
 	void SetSortParam( ScSortParam& rParam, SCTAB nTab );
 
+ 	//ScVbaEventsHelper* GetVbaEventsHelper();
+    com::sun::star::uno::Reference< org::openoffice::vba::XVBAWorkbookEventsHelper > GetVbaEventsHelper();
+
     /** Should only be GRAM_PODF or GRAM_ODFF. */
     void                SetStorageGrammar( ScGrammar::Grammar eGrammar );
     ScGrammar::Grammar  GetStorageGrammar() const
--- sc/source/core/data/documen2.cxx.orig	2008-05-07 12:09:09.000000000 +0800
+++ sc/source/core/data/documen2.cxx	2008-05-15 15:29:26.000000000 +0800
@@ -93,6 +93,8 @@
 #include "listenercalls.hxx"
 #include "recursionhelper.hxx"
 #include "lookupcache.hxx"
+//#include "vbaeventshelper.hxx"
+#include <org/openoffice/vba/XVBAWorkbookEventsHelper.hpp>
 
 // pImpl because including lookupcache.hxx in document.hxx isn't wanted, and
 // dtor is convenient.
@@ -146,6 +148,7 @@ ScDocument::ScDocument( ScDocumentMode	e
         pRecursionHelper( NULL ),
         pAutoNameCache( NULL ),
         pLookupCacheMapImpl( NULL ),
+		//rVbaEventsHelper( NULL ),
         nUnoObjectId( 0 ),
         nRangeOverflowType( 0 ),
 		aCurTextWidthCalcPos(MAXCOL,0,0),
@@ -434,6 +437,12 @@ ScDocument::~ScDocument()
 	delete pOtherObjects;
     delete pRecursionHelper;
 
+	/*if( rVbaEventsHelper )
+	{
+		delete pVbaEventsHelper;
+		pVbaEventsHelper = NULL;
+	}*/
+
     DBG_ASSERT( !pAutoNameCache, "AutoNameCache still set in dtor" );
 }
 
@@ -1857,3 +1866,27 @@ void ScDocument::RemoveLookupCache( ScLo
         EndListeningArea( pCache->getRange(), &rCache);
     }
 }
+
+using namespace com::sun::star;
+uno::Reference< org::openoffice::vba::XVBAWorkbookEventsHelper > 
+ScDocument::GetVbaEventsHelper()
+{
+	if( !rVbaEventsHelper.is() )
+	{
+        try
+        {
+            uno::Reference< lang::XMultiServiceFactory > xSF( comphelper::getProcessServiceFactory(), uno::UNO_QUERY );
+            uno::Reference< frame::XModel > xModel( pShell->GetModel(), uno::UNO_QUERY );
+            uno::Sequence< uno::Any > aArgs(1);
+            aArgs[0] = uno::Any( xModel );
+            uno::Reference< org::openoffice::vba::XVBAWorkbookEventsHelper > xVBAWorkbookEventsHelper( xSF->createInstanceWithArguments( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.vba.VbaWorkbookEventsHelper" ) ), aArgs ), uno::UNO_QUERY );
+            // helper will always be created successfully.
+            // if( xVBAWorkbookEventsHelper.is() )
+            rVbaEventsHelper.set( xVBAWorkbookEventsHelper, uno::UNO_QUERY );
+        }
+        catch( uno::Exception& e )
+        {
+        }
+	}
+	return rVbaEventsHelper;
+}
--- sc/source/core/data/documen7.cxx.orig	2008-05-07 12:09:09.000000000 +0800
+++ sc/source/core/data/documen7.cxx	2008-05-14 12:31:56.000000000 +0800
@@ -59,7 +59,16 @@
 
 
 #include "globstr.hrc"
+//#include "vbaeventshelper.hxx"
+#include <algorithm>
+#include <vector>
 
+
+#include <org/openoffice/vba/XVBAWorkbookEventsHelper.hpp>
+#include <org/openoffice/vba/VBAWorkbookEvent.hpp>
+using namespace com::sun::star;
+using namespace org::openoffice;
+using namespace org::openoffice::vba::VBAWorkbookEvent;
 extern const ScFormulaCell* pLastFormulaTreeTop;	// cellform.cxx Err527 WorkAround
 
 // STATIC DATA -----------------------------------------------------------
@@ -449,6 +458,7 @@ void ScDocument::TrackFormulas( ULONG nH
 		ScFormulaCell* pTrack;
 		ScFormulaCell* pNext;
 		pTrack = pFormulaTrack;
+		::std::vector<SCTAB> aTabs; 
 		do
 		{
 			ScHint aHint( nHintId, pTrack->aPos, pTrack );
@@ -458,6 +468,12 @@ void ScDocument::TrackFormulas( ULONG nH
 			//	Repaint fuer bedingte Formate mit relativen Referenzen:
 			if ( pCondFormList )
 				pCondFormList->SourceChanged( pTrack->aPos );
+			::std::vector<SCTAB>::iterator result;
+			result = ::std::find( aTabs.begin(), aTabs.end(), pTrack->aPos.Tab() );
+			if( result == aTabs.end() )
+			{
+				aTabs.push_back( pTrack->aPos.Tab() );
+			}
 			pTrack = pTrack->GetNextTrack();
 		} while ( pTrack );
 		pTrack = pFormulaTrack;
@@ -480,6 +496,14 @@ void ScDocument::TrackFormulas( ULONG nH
 			else
 				SetForcedFormulaPending( TRUE );
 		}
+
+		::std::vector<SCTAB>::iterator iter;
+		for( iter = aTabs.begin(); iter != aTabs.end(); iter++ )
+		{
+			SCTAB nTab = *iter;
+			uno::Sequence< uno::Any > aArgs;
+			GetVbaEventsHelper()->ProcessWorkbookEvent( SC_VBAEVENT_SHEET_CALCULATE, nTab, aArgs );
+		}
 	}
 	DBG_ASSERT( nFormulaTrackCount==0, "TrackFormulas: nFormulaTrackCount!=0" );
 }
--- sc/source/core/tool/makefile.mk.orig	2008-05-07 12:09:09.000000000 +0800
+++ sc/source/core/tool/makefile.mk	2008-05-13 13:47:37.000000000 +0800
@@ -158,3 +158,11 @@ $(INCCOM)$/osversiondef.hxx :
 
 $(SLO)$/interpr5.obj : $(INCCOM)$/osversiondef.hxx
 
+ALLTAR : \
+        $(MISC)$/$(TARGET).don \
+
+$(SLOFILES) : $(MISC)$/$(TARGET).don
+
+$(MISC)$/$(TARGET).don : $(SOLARBINDIR)$/oovbaapi.rdb
+        +$(CPPUMAKER) -O$(INCCOM)$/$(TARGET) -BUCR $(SOLARBINDIR)$/oovbaapi.rdb -X$(SOLARBINDIR)$/types.rdb && echo > $@
+        echo $@
--- sc/source/ui/docshell/docsh.cxx.orig	2008-05-07 12:09:09.000000000 +0800
+++ sc/source/ui/docshell/docsh.cxx	2008-05-19 17:05:08.000000000 +0800
@@ -131,6 +131,13 @@
 #include <rtl/logfile.hxx>
 
 #include <comphelper/processfactory.hxx>
+#include "uiitems.hxx"
+//#include "vbaeventshelper.hxx"
+#include "cellsuno.hxx"
+#include <org/openoffice/vba/XVBAWorkbookEventsHelper.hpp>
+#include <org/openoffice/vba/VBAWorkbookEvent.hpp>
+using namespace org::openoffice;
+using namespace org::openoffice::vba::VBAWorkbookEvent;
 
 using namespace com::sun::star;
 
@@ -754,6 +761,17 @@ void __EXPORT ScDocShell::Notify( SfxBro
 			pAutoStyleList = new ScAutoStyleList(this);
 		pAutoStyleList->AddInitial( aRange, aName1, nTimeout, aName2 );
 	}
+    else if (rHint.ISA(ScTablesHint) )
+    {
+		USHORT nId = ((ScTablesHint&)rHint).GetId();	
+		SCTAB nTab = ((ScTablesHint&)rHint).GetTab1();	
+        //aDocument.GetVbaEventsHelper()->processScTablesHint( nId, nTab );
+        if( nId == SC_TAB_INSERTED )
+        {
+            uno::Sequence< uno::Any > aArgs;
+            aDocument.GetVbaEventsHelper()->ProcessWorkbookEvent( SC_VBAEVENT_WORKBOOK_NEWSHEET, nTab, aArgs );
+        }
+    }
     else if ( rHint.ISA( SfxEventHint ) )
     {
         ULONG nEventId = ((SfxEventHint&)rHint).GetEventId();
@@ -940,6 +958,38 @@ void __EXPORT ScDocShell::Notify( SfxBro
                     }
                 }
                 break;
+            case SFX_EVENT_ACTIVATEDOC:
+            {
+                uno::Sequence< uno::Any > aArgs;
+                aDocument.GetVbaEventsHelper()->ProcessWorkbookEvent( SC_VBAEVENT_WORKBOOK_ACTIVATE, (sal_Int32)-1, aArgs );
+            }
+                break;
+            case SFX_EVENT_DEACTIVATEDOC:
+            {
+                uno::Sequence< uno::Any > aArgs;
+                aDocument.GetVbaEventsHelper()->ProcessWorkbookEvent( SC_VBAEVENT_WORKBOOK_DEACTIVATE, (sal_Int32)-1, aArgs );
+            }
+                break;
+            case SFX_EVENT_CLOSEDOC :
+            {
+                uno::Sequence< uno::Any > aArgs;
+                aDocument.GetVbaEventsHelper()->ProcessWorkbookEvent( SC_VBAEVENT_WORKBOOK_CLOSE, (sal_Int32)-1, aArgs );
+            }
+                break;
+            case SFX_EVENT_CLOSEVIEW :
+            {
+                uno::Sequence< uno::Any > aArgs;
+                aDocument.GetVbaEventsHelper()->ProcessWorkbookEvent( SC_VBAEVENT_WORKBOOK_WINDOWCOLSE, (sal_Int32)-1, aArgs );
+            }
+                break;
+            case SFX_EVENT_OPENDOC:
+            {
+                //aDocument.GetVbaEventsHelper()->processSfxEventHint( (SfxEventHint&)rHint );
+                // some later than workbook activate.
+                uno::Sequence< uno::Any > aArgs;
+                aDocument.GetVbaEventsHelper()->ProcessWorkbookEvent( SC_VBAEVENT_WORKBOOK_OPEN, (sal_Int32)-1, aArgs );
+            }
+                break;
             default:
                 {
                 }
@@ -2246,6 +2296,12 @@ USHORT __EXPORT ScDocShell::PrepareClose
 
 	DoEnterHandler();
 
+	// start handler for possible veto from DocBefore_Close
+    uno::Sequence< uno::Any > aArgs;
+	if ( !IsInPrepareClose() && aDocument.GetVbaEventsHelper()->ProcessWorkbookEvent( SC_VBAEVENT_WORKBOOK_BEFORECLOSE, (sal_Int32)-1, aArgs ) )
+		return sal_False;
+	// end handler code
+
 	USHORT nRet = SfxObjectShell::PrepareClose( bUI, bForBrowsing );
 	if (nRet == TRUE)						// TRUE = schliessen
 		aDocument.DisableIdle(TRUE);		// nicht mehr drin rumpfuschen !!!
@@ -2455,6 +2511,43 @@ void ScDocShell::SetModified( BOOL bModi
 	}
 }
 
+void ScDocShell::PostContentChanged( const ScRange& rRange )
+{
+//  OSL_TRACE("ScDocShell::PostContentChanged. Changed Range Address: nTab1 = %d, nCol1 = %d, nRow1 = %d; nTab2 = %d, nCol2 = %d, nRow2 = %d;", rRange.aStart.Tab(), rRange.aStart.Col(), rRange.aStart.Row(), rRange.aEnd.Tab(), rRange.aEnd.Col(), rRange.aEnd.Row() );
+
+    ScRangeList aList;
+    aList.Append(rRange);
+    PostContentChanged(aList);
+}
+
+void ScDocShell::PostContentChanged( const ScRangeList& rList )
+{
+#if 0		
+    String aStr;
+    rList.Format(aStr, SCR_ABS, &aDocument, ScAddress::CONV_XL_A1);
+    fprintf(stdout, "ScDocShell::PostContentChanged:   range = '%s'\n",
+            rtl::OUStringToOString(aStr, RTL_TEXTENCODING_UTF8).getStr());
+#endif
+
+    ScCellRangesBase* pObj = NULL;
+	const ScRange& rRange = *(rList.GetObject(0));	
+	if( rList.Count() == 1 )
+	{
+    	if (rRange.aStart == rRange.aEnd)
+    	    pObj = new ScCellObj( this, rRange.aStart );
+	   	else
+	       	pObj = new ScCellRangeObj( this, rRange );
+	}
+	else
+		pObj = new ScCellRangesObj( this, rList );	
+
+    uno::Sequence< uno::Any > aArgs(1);
+    aArgs[0] = uno::makeAny(uno::Reference<uno::XInterface>(static_cast<cppu::OWeakObject*>(pObj)));
+
+    SCTAB nTab = rRange.aStart.Tab();
+    //aDocument.GetVbaEventsHelper()->executeSheetMacro( SC_VBAEVENT_SHEET_CHANGE, nTab, aArgs );
+    aDocument.GetVbaEventsHelper()->ProcessWorkbookEvent( SC_VBAEVENT_SHEET_CHANGE, nTab, aArgs );
+}
 
 void ScDocShell::SetDocumentModified( BOOL bIsModified /* = TRUE */ )
 {
--- sc/source/ui/inc/docsh.hxx.orig	2008-05-07 12:09:09.000000000 +0800
+++ sc/source/ui/inc/docsh.hxx	2008-05-19 15:39:24.000000000 +0800
@@ -47,6 +47,7 @@
 #include "refreshtimer.hxx"
 
 #include <hash_map>
+#include <cppuhelper/implbase1.hxx>
 
 class ScEditEngineDefaulter;
 class FontList;
@@ -326,6 +327,8 @@ public:
 	void            PostPaintExtras();
 
 	void            PostDataChanged();
+	void			PostContentChanged( const ScRange& rRange ); // for worsheet/workbook changed event
+    void            PostContentChanged( const ScRangeList& rList );
 
 	void			UpdatePaintExt( USHORT& rExtFlags, SCCOL nStartCol, SCROW nStartRow, SCTAB nStartTab,
 													   SCCOL nEndCol, SCROW nEndRow, SCTAB nEndTab );
--- sc/source/ui/undo/undoblk3.cxx.orig	2008-05-07 12:09:09.000000000 +0800
+++ sc/source/ui/undo/undoblk3.cxx	2008-05-07 12:09:21.000000000 +0800
@@ -112,6 +112,15 @@ ScUndoDeleteContents::ScUndoDeleteConten
 	if ( !(aMarkData.IsMarked() || aMarkData.IsMultiMarked()) )		// keine Zelle markiert:
 		aMarkData.SetMarkArea( aRange );							// Zelle unter Cursor markieren
 
+    if (aMarkData.IsMarked() || aMarkData.IsMultiMarked())
+    {
+        ScRangeList aList;
+        aMarkData.FillRangeListWithMarks(&aList, false);
+        pDocShell->PostContentChanged(aList);
+    }
+    else
+        pDocShell->PostContentChanged( aRange );
+
 	SetChangeTrack();
 }
 
@@ -202,6 +211,15 @@ void ScUndoDeleteContents::DoChange( con
 	if (pViewShell)
 		pViewShell->CellContentChanged();
 
+    if (aMarkData.IsMarked() || aMarkData.IsMultiMarked())
+    {
+        ScRangeList aList;
+        aMarkData.FillRangeListWithMarks(&aList, false);
+        pDocShell->PostContentChanged(aList);
+    }
+    else
+        pDocShell->PostContentChanged( aRange );
+
 	ShowTable( aRange );
 }
 
--- sc/source/ui/undo/undoblk.cxx.orig	2008-05-07 12:09:09.000000000 +0800
+++ sc/source/ui/undo/undoblk.cxx	2008-05-07 12:09:21.000000000 +0800
@@ -124,6 +124,7 @@ ScUndoInsertCells::ScUndoInsertCells( Sc
 		aEffRange.aEnd.SetRow(MAXROW);
 	}
 
+	pDocShell->PostContentChanged( aEffRange );
 	SetChangeTrack();
 }
 
@@ -259,6 +260,7 @@ void ScUndoInsertCells::DoChange( const 
 	if (pViewShell)
 		pViewShell->CellContentChanged();
 
+	pDocShell->PostContentChanged( aEffRange );
 	ShowTable( aEffRange.aStart.Tab() );
 }
 
@@ -332,6 +334,8 @@ ScUndoDeleteCells::ScUndoDeleteCells( Sc
 		aEffRange.aEnd.SetRow(MAXROW);
 	}
 
+	pDocShell->PostContentChanged( aEffRange );
+
 	SetChangeTrack();
 }
 
@@ -464,6 +468,7 @@ void ScUndoDeleteCells::DoChange( const 
 
 	pDocShell->PostDataChanged();
 	//	CellContentChanged kommt mit der Markierung
+	pDocShell->PostContentChanged( aWorkRange );
 
 	ShowTable( aEffRange.aStart.Tab() );
 }
@@ -713,6 +718,7 @@ ScUndoCut::ScUndoCut( ScDocShell* pNewDo
 	pUndoDoc( pNewUndoDoc ),
 	aExtendedRange( aRange )
 {
+	pDocShell->PostContentChanged( aExtendedRange );
 	SetChangeTrack();
 }
 
@@ -771,6 +777,7 @@ void ScUndoCut::DoChange( const BOOL bUn
 	pDocShell->PostDataChanged();
 	if (pViewShell)
 		pViewShell->CellContentChanged();
+	pDocShell->PostContentChanged( aExtendedRange );
 }
 
 void __EXPORT ScUndoCut::Undo()
@@ -837,6 +844,7 @@ ScUndoPaste::ScUndoPaste( ScDocShell* pN
 
 	if ( pOptions )
 		aPasteOptions = *pOptions;		// used only for Repeat
+	pDocShell->PostContentChanged( aBlockRange );
 
 	SetChangeTrack();
 }
@@ -1012,6 +1020,7 @@ void ScUndoPaste::DoChange( const BOOL b
 	pDocShell->PostDataChanged();
 	if (pViewShell)
 		pViewShell->CellContentChanged();
+	pDocShell->PostContentChanged( aDrawRange );
 }
 
 void __EXPORT ScUndoPaste::Undo()
--- sc/source/ui/undo/undocell.cxx.orig	2008-05-07 12:09:09.000000000 +0800
+++ sc/source/ui/undo/undocell.cxx	2008-05-07 12:09:21.000000000 +0800
@@ -213,6 +213,7 @@ ScUndoEnterData::ScUndoEnterData( ScDocS
 	nTab( nNewTab ),
 	nCount( nNewCount )
 {
+	pDocShell->PostContentChanged( ScRange( ScAddress( nCol, nRow, nTab ) ) );
 	SetChangeTrack();
 }
 
@@ -249,6 +250,7 @@ void ScUndoEnterData::DoChange() const
 		pViewShell->MoveCursorAbs( nCol, nRow, SC_FOLLOW_JUMP, FALSE, FALSE );
 	}
 
+	pDocShell->PostContentChanged( ScRange( ScAddress( nCol, nRow, nTab ) ) );
 	pDocShell->PostDataChanged();
 }
 
@@ -370,6 +372,7 @@ ScUndoEnterValue::ScUndoEnterValue( ScDo
 	nValue		( nVal ),
 	bNeedHeight	( bHeight )
 {
+	pDocShell->PostContentChanged( ScRange( aPos ) );
 	SetChangeTrack();
 }
 
@@ -420,6 +423,8 @@ void __EXPORT ScUndoEnterValue::Undo()
 
 	pDocShell->PostPaintCell( aPos.Col(), aPos.Row(), aPos.Tab() );
 
+	pDocShell->PostContentChanged( ScRange( aPos ) );
+
 	ScChangeTrack* pChangeTrack = pDoc->GetChangeTrack();
 	if ( pChangeTrack )
 		pChangeTrack->Undo( nEndChangeAction, nEndChangeAction );
@@ -435,6 +440,8 @@ void __EXPORT ScUndoEnterValue::Redo()
 	pDoc->SetValue( aPos.Col(), aPos.Row(), aPos.Tab(), nValue );
 	pDocShell->PostPaintCell( aPos.Col(), aPos.Row(), aPos.Tab() );
 
+	pDocShell->PostContentChanged( ScRange( aPos ) );
+
 	SetChangeTrack();
 
 	EndRedo();
@@ -464,6 +471,7 @@ ScUndoPutCell::ScUndoPutCell( ScDocShell
 	pEnteredCell( pRedoCell ),
 	bNeedHeight	( bHeight )
 {
+	pDocShell->PostContentChanged( ScRange( aPos ) );
 	SetChangeTrack();
 }
 
@@ -516,6 +524,8 @@ void __EXPORT ScUndoPutCell::Undo()
 
 	pDocShell->PostPaintCell( aPos.Col(), aPos.Row(), aPos.Tab() );
 
+	pDocShell->PostContentChanged( ScRange( aPos ) );
+
 	ScChangeTrack* pChangeTrack = pDoc->GetChangeTrack();
 	if ( pChangeTrack )
 		pChangeTrack->Undo( nEndChangeAction, nEndChangeAction );
@@ -546,6 +556,8 @@ void __EXPORT ScUndoPutCell::Redo()
 
 	pDocShell->PostPaintCell( aPos.Col(), aPos.Row(), aPos.Tab() );
 
+	pDocShell->PostContentChanged( ScRange( aPos ) );
+
 	SetChangeTrack();
 
 	EndRedo();
--- sc/source/ui/unoobj/viewuno.cxx.orig	2008-05-07 12:09:09.000000000 +0800
+++ sc/source/ui/unoobj/viewuno.cxx	2008-05-14 16:19:28.000000000 +0800
@@ -71,6 +71,12 @@
 #include "gridwin.hxx"
 #include <com/sun/star/view/DocumentZoomType.hpp>
 #include "AccessibilityHints.hxx"
+#include <com/sun/star/awt/MouseButton.hpp>
+//#include "vbaeventshelper.hxx"
+#include <org/openoffice/vba/XVBAWorkbookEventsHelper.hpp>
+#include <org/openoffice/vba/VBAWorkbookEvent.hpp>
+using namespace org::openoffice;
+using namespace org::openoffice::vba::VBAWorkbookEvent;
 
 using namespace com::sun::star;
 
@@ -480,7 +486,6 @@ ScTabViewObj::ScTabViewObj( ScTabViewShe
 	aActivationListeners( 0 ),
 	bDrawSelModeSet(sal_False)
 {
-	//!	Listening oder so
 }
 
 ScTabViewObj::~ScTabViewObj()
@@ -1206,36 +1211,64 @@ sal_Bool ScTabViewObj::MousePressed( con
 {
     sal_Bool bReturn(sal_False);
 
-    if (aMouseClickHandlers.Count())
+    uno::Reference< uno::XInterface > xTarget = GetClickedObject(Point(e.X, e.Y));
+
+    if (xTarget.is())
     {
-        uno::Reference< uno::XInterface > xTarget = GetClickedObject(Point(e.X, e.Y));
+		// Handle BeforeDoubleClick and BeforeRightClick events
+		uno::Reference<table::XCell> xCell( xTarget, uno::UNO_QUERY );
+		if( xCell.is() )
+		{
+			ScTabViewShell* pViewSh = GetViewShell();
+			if ( pViewSh )
+			{
+				ScViewData* pViewData = pViewSh->GetViewData();
+				if ( pViewData )
+				{
+					if( e.ClickCount == 2 || e.Buttons == ::com::sun::star::awt::MouseButton::RIGHT )
+					{
+						uno::Sequence< uno::Any > aArgs(2);
+						sal_Bool bCancel = sal_False;
+						aArgs[0] = getSelection();
+						aArgs[1] <<= bCancel;
+
+						USHORT nEvent = SC_VBAEVENT_SHEET_BEFORERIGHTCLICK;
+						if( e.ClickCount == 2 )
+							nEvent = SC_VBAEVENT_SHEET_BEFOREDOUBLECLICK;
 
-        if (xTarget.is())
-        {
-            awt::EnhancedMouseEvent aMouseEvent;
+						pViewData->GetDocument()->GetVbaEventsHelper()->ProcessWorkbookEvent( nEvent, pViewData->GetTabNo(), aArgs );
 
-            aMouseEvent.Buttons = e.Buttons;
-            aMouseEvent.X = e.X;
-            aMouseEvent.Y = e.Y;
-            aMouseEvent.ClickCount = e.ClickCount;
-            aMouseEvent.PopupTrigger = e.PopupTrigger;
-            aMouseEvent.Target = xTarget;
+						// TODO... handle the cancel argument
+						aArgs[1] >>= bCancel;
+					}
+				}
+			}
+		}
+		
+        awt::EnhancedMouseEvent aMouseEvent;
 
-	        for ( USHORT n=0; n<aMouseClickHandlers.Count(); n++ )
+        aMouseEvent.Buttons = e.Buttons;
+        aMouseEvent.X = e.X;
+        aMouseEvent.Y = e.Y;
+        aMouseEvent.ClickCount = e.ClickCount;
+        aMouseEvent.PopupTrigger = e.PopupTrigger;
+        aMouseEvent.Target = xTarget;
+
+	    for ( USHORT n=0; n<aMouseClickHandlers.Count(); n++ )
+        {
+            try
             {
-                try
-                {
-                    if (!(*aMouseClickHandlers[n])->mousePressed( aMouseEvent ))
-                        bReturn = sal_True;
-                }
-                catch ( uno::Exception& )
-                {
-                    aMouseClickHandlers.DeleteAndDestroy(n);
-                    --n; // because it will be increased again in the loop
-                }
+                if (!(*aMouseClickHandlers[n])->mousePressed( aMouseEvent ))
+                    bReturn = sal_True;
+            }
+            catch ( uno::Exception& )
+            {
+                aMouseClickHandlers.DeleteAndDestroy(n);
+                --n; // because it will be increased again in the loop
             }
         }
     }
+
     return bReturn;
 }
 
@@ -1709,6 +1742,18 @@ void SAL_CALL ScTabViewObj::removeSelect
 
 void ScTabViewObj::SelectionChanged()
 {
+	ScTabViewShell* pViewSh = GetViewShell();
+	if ( pViewSh )
+	{
+		ScViewData* pViewData = pViewSh->GetViewData();
+		if ( pViewData )
+		{
+			uno::Sequence< uno::Any > aArgs(1);
+			aArgs[0] = getSelection();
+			pViewData->GetDocument()->GetVbaEventsHelper()->ProcessWorkbookEvent( SC_VBAEVENT_SHEET_SELECTIONCHANGE, pViewData->GetTabNo(), aArgs );
+		}
+	}
+
 	lang::EventObject aEvent;
 	aEvent.Source.set(static_cast<cppu::OWeakObject*>(this));
 	for ( USHORT n=0; n<aSelectionListeners.Count(); n++ )
--- sc/source/ui/unoobj/docuno.cxx.orig	2008-05-19 10:34:38.000000000 +0800
+++ sc/source/ui/unoobj/docuno.cxx	2008-05-19 16:32:43.000000000 +0800
@@ -92,6 +92,12 @@
 #include "rangeutl.hxx"
 #include "ViewSettingsSequenceDefines.hxx"
 
+#define BEFORE 0
+#define AFTER 1
+#include <org/openoffice/vba/XVBAWorkbookEventsHelper.hpp>
+#include <org/openoffice/vba/VBAWorkbookEvent.hpp>
+using namespace org::openoffice;
+using namespace org::openoffice::vba::VBAWorkbookEvent;
 using namespace com::sun::star;
 
 //------------------------------------------------------------------------
@@ -329,6 +335,7 @@ uno::Any SAL_CALL ScModelObj::queryInter
 	SC_QUERYINTERFACE( document::XLinkTargetSupplier )
 	SC_QUERYINTERFACE( beans::XPropertySet )
 	SC_QUERYINTERFACE( document::XCodeNameQuery )
+	SC_QUERYINTERFACE( document::XVbaEventHelper)
 	SC_QUERYINTERFACE( lang::XMultiServiceFactory )
 	SC_QUERYINTERFACE( lang::XServiceInfo )
 
@@ -1730,6 +1737,48 @@ ScModelObj::getCodeNameForObject( const 
     // Probably should throw here ( if !bMatched )
      return sCodeName;
 }
+// XVbaEventHelper
+// For Vba Event
+// status, 0 before, 1 done...
+sal_Bool SAL_CALL
+ScModelObj::processVbaEvent( sal_Int16 nStatus, sal_Int16 nSlotId ) throw( ::com::sun::star::uno::RuntimeException )
+{
+    USHORT nId = nSlotId;
+    switch( nId )
+    {
+        case SID_SAVEDOC:
+        {
+            if( nStatus == BEFORE )
+            {
+                uno::Sequence< uno::Any > aArgs(1);
+                aArgs[0] <<= sal_False;
+                return GetDocument()->GetVbaEventsHelper()->ProcessWorkbookEvent( SC_VBAEVENT_WORKBOOK_BEFORESAVE, -1L, aArgs );
+            }
+            break;
+        }
+        case SID_SAVEASDOC:
+        {
+            if( nStatus == BEFORE )
+            {
+                uno::Sequence< uno::Any > aArgs(1);
+                aArgs[0] <<= sal_True;
+                return GetDocument()->GetVbaEventsHelper()->ProcessWorkbookEvent( SC_VBAEVENT_WORKBOOK_BEFORESAVE, (sal_Int32)-1, aArgs );
+            }
+            break;
+        }
+        case SID_PRINTDOC:
+        case SID_PRINTDOCDIRECT:
+        {
+            if( nStatus == BEFORE )
+            {
+                uno::Sequence< uno::Any > aArgs;
+                return GetDocument()->GetVbaEventsHelper()->ProcessWorkbookEvent( SC_VBAEVENT_WORKBOOK_BEFOREPRINT, (sal_Int32)-1, aArgs );
+            }
+            break;
+        }
+    }
+    return sal_False;
+}
 // XServiceInfo
 
 rtl::OUString SAL_CALL ScModelObj::getImplementationName() throw(uno::RuntimeException)
--- sc/inc/docuno.hxx.orig	2008-05-19 15:34:55.000000000 +0800
+++ sc/inc/docuno.hxx	2008-05-19 15:47:20.000000000 +0800
@@ -55,6 +55,7 @@
 #include <com/sun/star/sheet/XSheetAnnotations.hpp>
 #include <com/sun/star/beans/XPropertySet.hpp>
 #include <com/sun/star/sheet/XCellRangesAccess.hpp>
+#include <com/sun/star/document/XVbaEventHelper.hpp>
 #include <cppuhelper/implbase2.hxx>
 #include <cppuhelper/implbase3.hxx>
 #include <cppuhelper/implbase4.hxx>
@@ -89,6 +90,7 @@ class SC_DLLPUBLIC ScModelObj : public S
 					public com::sun::star::document::XLinkTargetSupplier,
 					public com::sun::star::beans::XPropertySet,
 					public com::sun::star::document::XCodeNameQuery,
+                    public com::sun::star::document::XVbaEventHelper,
 					public SvxFmMSFactory,	// derived from XMultiServiceFactory
                     public com::sun::star::lang::XServiceInfo
 {
@@ -303,6 +305,8 @@ public:
 								throw(::com::sun::star::uno::RuntimeException);
  	virtual rtl::OUString SAL_CALL getCodeNameForObject( const ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface >& aObj )
 								throw(::com::sun::star::uno::RuntimeException);
+                            // XVbaEventHelper
+    virtual sal_Bool SAL_CALL processVbaEvent( sal_Int16 nStatus, sal_Int16 nEventId ) throw (::com::sun::star::uno::RuntimeException);
 };
 
 
--- sc/source/ui/view/gridwin.cxx.orig	2008-05-07 12:06:10.000000000 +0800
+++ sc/source/ui/view/gridwin.cxx	2008-05-14 12:10:39.000000000 +0800
@@ -149,6 +149,13 @@
 #include <svx/sdr/overlay/overlaymanager.hxx>
 #include <vcl/svapp.hxx>
 
+//#include "vbaeventshelper.hxx"
+#include "cellsuno.hxx"
+
+#include <org/openoffice/vba/XVBAWorkbookEventsHelper.hpp>
+#include <org/openoffice/vba/VBAWorkbookEvent.hpp>
+
+using namespace org::openoffice::vba::VBAWorkbookEvent;
 using namespace com::sun::star;
 using ::com::sun::star::uno::Sequence;
 using ::com::sun::star::uno::Any;
@@ -398,6 +405,32 @@ void lcl_UnLockComment( SdrView* pView, 
 
 }
 
+sal_Bool lcl_GetHyperlinkCell(ScDocument* pDoc, SCCOL& rPosX, SCROW& rPosY, SCTAB nTab, ScBaseCell*& rpCell )
+{
+	BOOL bFound = FALSE;
+	do
+	{
+		pDoc->GetCell( rPosX, rPosY, nTab, rpCell );
+		if ( !rpCell || rpCell->GetCellType() == CELLTYPE_NOTE )
+		{
+			if ( rPosX <= 0 )
+				return FALSE;							// alles leer bis links
+			else
+				--rPosX;								// weitersuchen
+		}
+                else if ( rpCell->GetCellType() == CELLTYPE_EDIT)
+                    bFound = TRUE;
+                else if (rpCell->GetCellType() == CELLTYPE_FORMULA &&
+                  static_cast<ScFormulaCell*>(rpCell)->IsHyperLinkCell())
+                    bFound = TRUE;
+	    else
+			return FALSE;								// andere Zelle
+	}
+	while ( !bFound );
+
+	return bFound;
+}
+
 //==================================================================
 
 //	WB_DIALOGCONTROL noetig fuer UNO-Controls
@@ -1442,6 +1475,7 @@ void ScGridWindow::HandleMouseButtonDown
 	SCCOL	nOldColFBox	  = bWasFilterBox ? pFilterBox->GetCol() : 0;
 	SCROW  nOldRowFBox	  = bWasFilterBox ? pFilterBox->GetRow() : 0;
 #endif
+#include "cellsuno.hxx" 
 
 	ClickExtern();	// loescht FilterBox, wenn vorhanden
 
@@ -2122,6 +2156,24 @@ void __EXPORT ScGridWindow::MouseButtonU
 		{
 			nMouseStatus = SC_GM_NONE;				// keinen Doppelklick anfangen
 			ScGlobal::OpenURL( aUrl, aTarget );
+			
+			// fire worksheet_followhyperlink event
+			Point aPos = rMEvt.GetPosPixel();
+	        SCsCOL nPosX;
+    	    SCsROW nPosY;
+        	SCTAB nTab = pViewData->GetTabNo();
+        	pViewData->GetPosFromPixel( aPos.X(), aPos.Y(), eWhich, nPosX, nPosY );
+			ScBaseCell* pCell = NULL;
+
+			BOOL bFound = lcl_GetHyperlinkCell( pDoc, nPosX, nPosY, nTab, pCell );
+			if( bFound )
+			{
+				ScAddress aCellPos( nPosX, nPosY, nTab );
+				ScCellObj* pObj = new ScCellObj( pViewData->GetDocShell(), aCellPos );
+				uno::Sequence< uno::Any > aArgs(1);
+				aArgs[0] = uno::makeAny(uno::Reference<uno::XInterface>(static_cast<cppu::OWeakObject*>(pObj)));
+				pViewData->GetDocument()->GetVbaEventsHelper()->ProcessWorkbookEvent( SC_VBAEVENT_SHEET_FOLLOWHYPERLINK, pViewData->GetTabNo(), aArgs );
+			}
 			return;
 		}
 	}
@@ -2441,13 +2493,13 @@ long ScGridWindow::PreNotify( NotifyEven
 			        if (xController.is())
 			        {
 				        ScTabViewObj* pImp = ScTabViewObj::getImplementation( xController );
-				        if (pImp && pImp->IsMouseListening())
+				        if (pImp)
                         {
 			                ::com::sun::star::awt::MouseEvent aEvent;
 			                lcl_InitMouseEvent( aEvent, *rNEvt.GetMouseEvent() );
 	                        if ( rNEvt.GetWindow() )
 		                        aEvent.Source = rNEvt.GetWindow()->GetComponentInterface();
-                            if ( nType == EVENT_MOUSEBUTTONDOWN)
+                            if ( nType == EVENT_MOUSEBUTTONDOWN )
 					            pImp->MousePressed( aEvent );
                             else
                                 pImp->MouseReleased( aEvent );
@@ -4857,26 +4909,9 @@ BOOL ScGridWindow::GetEditUrlOrError( BO
 	ScDocument* pDoc = pDocSh->GetDocument();
 	ScBaseCell* pCell = NULL;
 
-	BOOL bFound = FALSE;
-	do
-	{
-		pDoc->GetCell( nPosX, nPosY, nTab, pCell );
-		if ( !pCell || pCell->GetCellType() == CELLTYPE_NOTE )
-		{
-			if ( nPosX <= 0 )
-				return FALSE;							// alles leer bis links
-			else
-				--nPosX;								// weitersuchen
-		}
-                else if ( pCell->GetCellType() == CELLTYPE_EDIT)
-                    bFound = TRUE;
-                else if (pCell->GetCellType() == CELLTYPE_FORMULA &&
-                  static_cast<ScFormulaCell*>(pCell)->IsHyperLinkCell())
-                    bFound = TRUE;
-	    else
-			return FALSE;								// andere Zelle
-	}
-	while ( !bFound );
+	BOOL bFound = lcl_GetHyperlinkCell( pDoc, nPosX, nPosY, nTab, pCell );
+	if( !bFound )
+		return FALSE;
 
 	ScHideTextCursor aHideCursor( pViewData, eWhich );	// before GetEditArea (MapMode is changed)
 
--- sc/source/ui/view/tabview3.cxx.orig	2008-05-07 12:09:09.000000000 +0800
+++ sc/source/ui/view/tabview3.cxx	2008-05-14 12:07:38.000000000 +0800
@@ -80,8 +80,13 @@
 #include "rangeutl.hxx"
 #include "client.hxx"
 #include "tabprotection.hxx"
+//#include "vbaeventshelper.hxx"
 
 #include <com/sun/star/chart2/data/HighlightedRange.hpp>
+#include <org/openoffice/vba/XVBAWorkbookEventsHelper.hpp>
+#include <org/openoffice/vba/VBAWorkbookEvent.hpp>
+
+using namespace org::openoffice::vba::VBAWorkbookEvent;
 
 namespace
 {
@@ -1684,6 +1689,12 @@ void ScTabView::SetTabNo( SCTAB nTab, BO
 										//	nicht InputEnterHandler wegen Referenzeingabe !
 
 		ScDocument* pDoc = aViewData.GetDocument();
+		if( !bNew )
+		{
+			uno::Sequence< uno::Any > aArgs;
+			pDoc->GetVbaEventsHelper()->ProcessWorkbookEvent( SC_VBAEVENT_SHEET_DEACTIVATE, aViewData.GetTabNo(), aArgs );
+		}
+			
 		pDoc->MakeTable( nTab );
 
 		SCTAB nTabCount = pDoc->GetTableCount();
@@ -1782,7 +1793,13 @@ void ScTabView::SetTabNo( SCTAB nTab, BO
 					if ( pGridWin[i]->IsVisible() )
 						pGridWin[i]->UpdateEditViewPos();
 		}
-
+		
+		if( !bNew )
+		{
+			uno::Sequence< uno::Any > aArgs;
+			pDoc->GetVbaEventsHelper()->ProcessWorkbookEvent( SC_VBAEVENT_SHEET_ACTIVATE, aViewData.GetTabNo(), aArgs );
+		}
+			
 		TabChanged();										// DrawView
 		aViewData.GetViewShell()->WindowChanged();			// falls das aktive Fenster anders ist
         if ( !bUnoRefDialog )
--- sc/source/ui/vba/makefile.mk.orig	2008-05-12 11:19:10.000000000 +0800
+++ sc/source/ui/vba/makefile.mk	2008-05-12 11:20:08.000000000 +0800
@@ -126,6 +126,7 @@ SLOFILES= \
                 $(SLO)$/vbacommandbar.obj \
                 $(SLO)$/vbacommandbars.obj \
         $(SLO)$/vbahyperlink.obj \
+        $(SLO)$/vbaeventshelper.obj \
 		$(SLO)$/service.obj \
  
 
--- sc/source/ui/view/makefile.mk.orig	2008-05-13 11:46:02.000000000 +0800
+++ sc/source/ui/view/makefile.mk	2008-05-13 11:47:14.000000000 +0800
@@ -165,3 +165,11 @@ EXCEPTIONSFILES= \
 
 .INCLUDE :  target.mk
 
+ALLTAR : \
+        $(MISC)$/$(TARGET).don \
+
+$(SLOFILES) : $(MISC)$/$(TARGET).don
+
+$(MISC)$/$(TARGET).don : $(SOLARBINDIR)$/oovbaapi.rdb
+        +$(CPPUMAKER) -O$(INCCOM)$/$(TARGET) -BUCR $(SOLARBINDIR)$/oovbaapi.rdb -X$(SOLARBINDIR)$/types.rdb && echo > $@
+        echo $@
--- sc/source/core/data/makefile.mk.orig	2008-05-13 13:38:43.000000000 +0800
+++ sc/source/core/data/makefile.mk	2008-05-13 13:42:43.000000000 +0800
@@ -161,3 +161,11 @@ EXCEPTIONSFILES+= \
 
 .INCLUDE :  target.mk
 
+ALLTAR : \
+        $(MISC)$/$(TARGET).don \
+
+$(SLOFILES) : $(MISC)$/$(TARGET).don
+
+$(MISC)$/$(TARGET).don : $(SOLARBINDIR)$/oovbaapi.rdb
+        +$(CPPUMAKER) -O$(INCCOM)$/$(TARGET) -BUCR $(SOLARBINDIR)$/oovbaapi.rdb -X$(SOLARBINDIR)$/types.rdb && echo > $@
+        echo $@
--- sc/source/ui/docshell/makefile.mk.orig	2008-05-14 12:52:06.000000000 +0800
+++ sc/source/ui/docshell/makefile.mk	2008-05-14 12:52:15.000000000 +0800
@@ -136,3 +136,11 @@ LIB1OBJFILES =  \
 
 .INCLUDE :  target.mk
 
+ALLTAR : \
+        $(MISC)$/$(TARGET).don \
+
+$(SLOFILES) : $(MISC)$/$(TARGET).don
+
+$(MISC)$/$(TARGET).don : $(SOLARBINDIR)$/oovbaapi.rdb
+        +$(CPPUMAKER) -O$(INCCOM)$/$(TARGET) -BUCR $(SOLARBINDIR)$/oovbaapi.rdb -X$(SOLARBINDIR)$/types.rdb && echo > $@
+        echo $@
--- sc/source/ui/unoobj/makefile.mk.orig	2008-05-14 16:15:34.000000000 +0800
+++ sc/source/ui/unoobj/makefile.mk	2008-05-14 16:16:46.000000000 +0800
@@ -113,3 +113,11 @@ NOOPTFILES= \
 
 .INCLUDE :  target.mk
 
+ALLTAR : \
+        $(MISC)$/$(TARGET).don \
+
+$(SLOFILES) : $(MISC)$/$(TARGET).don
+
+$(MISC)$/$(TARGET).don : $(SOLARBINDIR)$/oovbaapi.rdb
+        +$(CPPUMAKER) -O$(INCCOM)$/$(TARGET) -BUCR $(SOLARBINDIR)$/oovbaapi.rdb -X$(SOLARBINDIR)$/types.rdb && echo > $@
+        echo $@
--- sfx2/inc/sfx2/objsh.hxx.orig	2008-05-07 12:09:29.000000000 +0800
+++ sfx2/inc/sfx2/objsh.hxx	2008-05-16 16:04:06.000000000 +0800
@@ -267,9 +267,6 @@ public:
     sal_Bool                    Stamp_GetPrintCancelState() const;
 
     using SotObject::GetInterface;
-    // status, 0 before, 1 done...
-    virtual sal_Bool            processVbaEvents( USHORT nStatus, USHORT nSlotId )
-                                { (void)nSlotId; (void)nStatus; return sal_False; }
 
     // Document-Shell Iterator
 	static SfxObjectShell*		GetFirst( const TypeId* pType = 0,
@@ -407,7 +404,8 @@ public:
         ::com::sun::star::uno::Any& aRet,
         ::com::sun::star::uno::Sequence< sal_Int16 >& aOutParamIndex,
         ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aOutParam,
-        bool bRaiseError = true
+        bool bRaiseError = true,
+        ::com::sun::star::uno::Any* aCaller = 0
     );
 
     static ErrCode  CallXScript(
@@ -417,7 +415,8 @@ public:
         ::com::sun::star::uno::Any& aRet,
         ::com::sun::star::uno::Sequence< sal_Int16 >& aOutParamIndex,
         ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aOutParam,
-        bool bRaiseError = true
+        bool bRaiseError = true,
+        ::com::sun::star::uno::Any* aCaller = 0
     );
 
     /** adjusts the internal macro mode, according to the current security settings
--- sfx2/source/doc/objmisc.cxx.orig	2008-05-07 12:09:22.000000000 +0800
+++ sfx2/source/doc/objmisc.cxx	2008-05-07 12:09:37.000000000 +0800
@@ -1591,7 +1591,7 @@ namespace
 }
 
 ErrCode SfxObjectShell::CallXScript( const Reference< XInterface >& _rxScriptContext, const ::rtl::OUString& _rScriptURL,
-    const Sequence< Any >& aParams, Any& aRet, Sequence< sal_Int16 >& aOutParamIndex, Sequence< Any >& aOutParam, bool bRaiseError )
+    const Sequence< Any >& aParams, Any& aRet, Sequence< sal_Int16 >& aOutParamIndex, Sequence< Any >& aOutParam, bool bRaiseError, ::com::sun::star::uno::Any* pCaller )
 {
     OSL_TRACE( "in CallXScript" );
 	ErrCode nErr = ERRCODE_NONE;
@@ -1622,7 +1622,16 @@ ErrCode SfxObjectShell::CallXScript( con
 
         // obtain the script, and execute it
         Reference< provider::XScript > xScript( xScriptProvider->getScript( _rScriptURL ), UNO_QUERY_THROW );
-
+        if ( pCaller && pCaller->hasValue() )
+        {
+            Reference< beans::XPropertySet > xProps( xScript, uno::UNO_QUERY ); 
+            if ( xProps.is() )
+            {
+                Sequence< uno::Any > aArgs( 1 );
+                aArgs[ 0 ] = *pCaller;
+                xProps->setPropertyValue( rtl::OUString::createFromAscii("Caller"), uno::makeAny( aArgs ) );
+            }
+        }
         aRet = xScript->invoke( aParams, aOutParamIndex, aOutParam );
     }
     catch ( const uno::Exception& )
@@ -1656,9 +1665,9 @@ ErrCode SfxObjectShell::CallXScript( con
         ::com::sun::star::uno::Any& aRet,
         ::com::sun::star::uno::Sequence< sal_Int16 >& aOutParamIndex,
         ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >&
-            aOutParam, bool bRaiseError )
+            aOutParam, bool bRaiseError, ::com::sun::star::uno::Any* pCaller )
 {
-    return CallXScript( GetModel(), rScriptURL, aParams, aRet, aOutParamIndex, aOutParam, bRaiseError );
+    return CallXScript( GetModel(), rScriptURL, aParams, aRet, aOutParamIndex, aOutParam, bRaiseError, pCaller );
 }
 
 //-------------------------------------------------------------------------
--- sfx2/source/doc/objserv.cxx.orig	2008-05-07 12:06:10.000000000 +0800
+++ sfx2/source/doc/objserv.cxx	2008-05-19 16:22:07.000000000 +0800
@@ -28,6 +28,8 @@
  *
  ************************************************************************/
 
+#define BEFORE 0
+#define AFTER 1
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sfx2.hxx"
 
@@ -108,6 +110,7 @@
 #include <com/sun/star/document/XDocumentInfo.hpp>
 #include <com/sun/star/document/XDocumentInfoSupplier.hpp>
 #include <com/sun/star/document/XDocumentProperties.hpp>
+#include <com/sun/star/document/XVbaEventHelper.hpp>
 
 #ifndef _SFX_HELPID_HRC
 #include "helpid.hrc"
@@ -521,6 +524,18 @@ void SfxObjectShell::ExecFile_Impl(SfxRe
 		case SID_SAVEASDOC:
 		case SID_SAVEDOC:
 		{
+            if( nId == SID_SAVEDOC || nId == SID_SAVEASDOC )
+            {
+                uno::Reference< document::XVbaEventHelper > xVbaEventHelper( GetModel(), uno::UNO_QUERY );
+                if( xVbaEventHelper.is() )
+                {
+                    if( xVbaEventHelper->processVbaEvent( BEFORE, nId ) )
+                    {
+                        rReq.SetReturnValue( SfxBoolItem( 0, sal_True ) );
+                        return;
+                    }
+                }
+            }
 			//!! detaillierte Auswertung eines Fehlercodes
 			SfxObjectShellRef xLock( this );
 
--- sfx2/source/view/viewprn.cxx.orig	2008-05-07 12:06:10.000000000 +0800
+++ sfx2/source/view/viewprn.cxx	2008-05-19 16:19:58.000000000 +0800
@@ -28,10 +28,12 @@
  *
  ************************************************************************/
 
+#define BEFORE 0
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sfx2.hxx"
 
 #include <com/sun/star/document/XDocumentProperties.hpp>
+#include <com/sun/star/document/XVbaEventHelper.hpp>
 #include <com/sun/star/view/PrintableState.hpp>
 #include <svtools/itempool.hxx>
 #ifndef _MSGBOX_HXX //autogen
@@ -67,6 +69,8 @@
 #include "view.hrc"
 #include "helpid.hrc"
 
+using namespace com::sun::star;
+
 TYPEINIT1(SfxPrintingHint, SfxHint);
 
 // -----------------------------------------------------------------------
@@ -405,6 +409,22 @@ void SfxViewShell::ExecPrint_Impl( SfxRe
 		case SID_SETUPPRINTER:
 	    case SID_PRINTER_NAME :
 		{
+            if( nId == SID_PRINTDOC )
+            {
+				SfxObjectShell* pDoc = GetObjectShell();
+                if( pDoc )
+                {
+                    uno::Reference< document::XVbaEventHelper > xVbaEventHelper( pDoc->GetModel(), uno::UNO_QUERY );
+                    if( xVbaEventHelper.is() )
+                    {
+                        if( xVbaEventHelper->processVbaEvent( BEFORE, nId ) )
+                        {
+                            rReq.SetReturnValue(SfxBoolItem(0,FALSE));
+                            return;
+                        }
+                    }
+                }
+            }
 	        // quiet mode (AppEvent, API call)
 			SFX_REQUEST_ARG(rReq, pSilentItem, SfxBoolItem, SID_SILENT, FALSE);
 			bSilent = pSilentItem && pSilentItem->GetValue();
@@ -714,6 +734,15 @@ void SfxViewShell::ExecPrint_Impl( SfxRe
 	        if ( SID_PRINTDOCDIRECT == nId )
 	        {
 				SfxObjectShell* pDoc = GetObjectShell();
+                uno::Reference< document::XVbaEventHelper > xVbaEventHelper( pDoc->GetModel(), uno::UNO_QUERY );
+                if( xVbaEventHelper.is() )
+                {
+                    if( xVbaEventHelper->processVbaEvent( BEFORE, nId ) )
+                    {
+                        rReq.SetReturnValue(SfxBoolItem(0,FALSE));
+                        return;
+                    }
+                }
 				bool bDetectHidden = ( !bSilent && pDoc );
 				if ( bDetectHidden && pDoc->QueryHiddenInformation( WhenPrinting, NULL ) != RET_YES )
 					return;
