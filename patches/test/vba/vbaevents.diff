--- /dev/null	2007-05-04 18:54:36.000000000 +0800
+++ offapi/com/sun/star/document/VbaEventId.idl	2008-05-28 15:37:18.000000000 +0800
@@ -0,0 +1,83 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __org_openoffice_vba_VbaEventId_idl__
+#define __org_openoffice_vba_VbaEventId_idl__
+
+//=============================================================================
+
+module com {  module sun {  module star { module document {
+//=============================================================================
+
+constants VbaEventId
+{
+    // Worksheet
+    const long VBAEVENT_WORKSHEET_ACTIVATE                  	= 1;
+    const long VBAEVENT_WORKSHEET_BEFOREDOUBLECLICK         	= 2;
+    const long VBAEVENT_WORKSHEET_BEFORERIGHTCLICK          	= 3;
+    const long VBAEVENT_WORKSHEET_CALCULATE                 	= 4;
+    const long VBAEVENT_WORKSHEET_CHANGE                    	= 5;
+    const long VBAEVENT_WORKSHEET_DEACTIVATE                	= 6;
+    const long VBAEVENT_WORKSHEET_FOLLOWHYPERLINK           	= 7;
+    const long VBAEVENT_WORKSHEET_PIVOTTABLEUPDATE          	= 8;
+    const long VBAEVENT_WORKSHEET_SELECTIONCHANGE           	= 9;
+    // Workbook
+    const long VBAEVENT_WORKBOOK_ACTIVATE            			= 20;
+    const long VBAEVENT_WORKBOOK_DEACTIVATE          			= 21;
+    const long VBAEVENT_WORKBOOK_OPEN                			= 22;
+    const long VBAEVENT_WORKBOOK_AUTOOPEN            			= 23;
+    const long VBAEVENT_WORKBOOK_BEFORECLOSE         			= 24;
+    const long VBAEVENT_WORKBOOK_BEFOREPRINT         			= 25;
+    const long VBAEVENT_WORKBOOK_BEFORESAVE          			= 26;
+    const long VBAEVENT_WORKBOOK_NEWSHEET            			= 27;
+    const long VBAEVENT_WORKBOOK_WINDOWACTIVATE      			= 28;
+    const long VBAEVENT_WORKBOOK_WINDOWDEACTIVATE    			= 29;
+    const long VBAEVENT_WORKBOOK_WINDOWRESIZE        			= 30;
+    const long VBAEVENT_WORKBOOK_WINDOWCOLSE         			= 31;
+    const long VBAEVENT_WORKBOOK_CLOSE               			= 32;
+    // Workbook_sheet
+    const long VBAEVENT_WORKBOOK_SHEET_ACTIVATE               	= 51;
+    const long VBAEVENT_WORKBOOK_SHEET_BEFOREDOUBLECLICK      	= 52;
+    const long VBAEVENT_WORKBOOK_SHEET_BEFORERIGHTCLICK       	= 53;
+    const long VBAEVENT_WORKBOOK_SHEET_CALCULATE              	= 54;
+    const long VBAEVENT_WORKBOOK_SHEET_CHANGE                 	= 55;
+    const long VBAEVENT_WORKBOOK_SHEET_DEACTIVATE             	= 56;
+    const long VBAEVENT_WORKBOOK_SHEET_FOLLOWHYPERLINK        	= 57;
+    const long VBAEVENT_WORKBOOK_SHEET_PIVOTTABLEUPDATE       	= 58;
+    const long VBAEVENT_WORKBOOK_SHEET_SELECTIONCHANGE        	= 59;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2007-05-04 18:54:36.000000000 +0800
+++ offapi/com/sun/star/document/XVbaEventsHelper.idl	2008-05-27 17:16:25.000000000 +0800
@@ -0,0 +1,54 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __org_openoffice_vba_XVbaEventsHelper_idl__
+#define __org_openoffice_vba_XVbaEventsHelper_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+//=============================================================================
+
+module com {  module sun {  module star {  module document {
+//=============================================================================
+
+interface XVbaEventsHelper
+{
+    // nTab -1 for workbook.
+    boolean ProcessCompatibleVbaEvent( [in] long VbaEvent, [in] sequence< any > aArgs );
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2007-05-04 18:54:36.000000000 +0800
+++ offapi/com/sun/star/document/VbaEventsHelper.idl	2008-05-27 11:46:31.000000000 +0800
@@ -0,0 +1,55 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __org_openoffice_vba_VbaEventsHelper_idl__
+#define __org_openoffice_vba_VbaEventsHelper_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+#include <com/sun/star/frame/XModel.idl>
+#include <com/sun/star/document/XVbaEventsHelper.idl>
+//=============================================================================
+
+module com {  module sun {  module star { module document {
+//=============================================================================
+
+service VbaEventsHelper : XVbaEventsHelper
+{
+  	createVbaEventsHelper(  [in] ::com::sun::star::frame::XModel xModel );
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2007-05-04 18:54:36.000000000 +0800
+++ offapi/com/sun/star/document/XDocumentEventCompatibleHelper.idl	2008-05-28 16:19:12.000000000 +0800
@@ -0,0 +1,47 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XVbaEventHelper.idl,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_document_XDocumentEventCompatibleHelper_idl__
+#define __com_sun_star_document_XDocumentEventCompatibleHelper_idl__
+
+//=============================================================================
+
+module com {   module sun {   module star {   module document {
+
+//=============================================================================
+interface XDocumentEventCompatibleHelper
+{
+    boolean processCompatibleEvent( [in] short nStatus, [in] short nEventId );
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
--- offapi/com/sun/star/document/makefile.mk.bak	2008-05-08 17:24:51.000000000 +0800
+++ offapi/com/sun/star/document/makefile.mk	2008-05-27 11:44:41.000000000 +0800
@@ -109,6 +109,10 @@ IDLFILES=\
     DocumentRevisionListPersistence.idl \
     XDocumentLanguages.idl \
     XCodeNameQuery.idl \
+    XDocumentEventCompatibleHelper.idl \
+    VbaEventId.idl \
+    XVbaEventsHelper.idl \
+    VbaEventsHelper.idl \
 
 
 # ------------------------------------------------------------------
--- /dev/null	2007-05-04 18:54:36.000000000 +0800
+++ sc/source/ui/vba/vbaeventshelper.hxx	2008-05-30 17:14:57.000000000 +0800
@@ -0,0 +1,92 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: vbaeventshelper.hxx,v $
+ *
+ *  $Revision: 1.0 $
+ *
+ *  last change: $Author: vg $ $Date: 2007/12/07 10:42:26 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef SC_VBAEVENTS_HXX
+#define SC_VBAEVENTS_HXX
+
+#include "document.hxx"
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/container/XNameReplace.hpp>
+#include <com/sun/star/awt/XEnhancedMouseClickHandler.hpp>
+#include <com/sun/star/document/VbaEventId.hpp>
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
+#include "vbahelper.hxx"
+
+using namespace com::sun::star;
+
+typedef ::cppu::WeakImplHelper1< com::sun::star::document::XVbaEventsHelper > VBAWorkbookEvent_BASE;
+
+//class ScTablesHint;
+class VbaWindowListener;
+class SfxEventHint;
+class ImplVbaEventNameInfo;
+class ScVbaEventsHelper : public VBAWorkbookEvent_BASE
+{
+private:
+	ScDocument* pDoc;
+    css::uno::Reference< css::uno::XComponentContext > m_xContext;
+    VbaWindowListener* mpWindowListener;
+    sal_Bool mbOpened;
+
+	String getSheetModuleName( SCTAB nTab );
+	String docMacroExists( SfxObjectShell* pShell, const String& sMod, const String& sMacro );
+
+	uno::Any createWorkSheet( SfxObjectShell* pShell, SCTAB nTab );
+	uno::Any createRange( const uno::Any& aRange );
+	uno::Any createHyperlink( const uno::Any& rCell );
+	uno::Any createWindow( SfxObjectShell* pShell );
+	sal_Bool executeWorkBookMacro( SfxObjectShell* pShell, const String& sMacroName, uno::Sequence< uno::Any >& aArgs, uno::Any& aRet );
+    sal_Bool processVbaEventWithCancel( const sal_Int32 nEventId );
+	sal_Bool processDocBeforeSaveMacro( sal_Bool bSaveAsUI );
+    void processVbaEventMacro_noreturn( const sal_Int32 nEventId );
+    void processVbaEventMacroWithArgs( const sal_Int32 nEventId, uno::Sequence< uno::Any >& rArgs );
+    void WorkbookWindowMacro( const sal_Int32 nHint );
+    SCTAB getTabFromArgs( const uno::Sequence< uno::Any > aArgs, const sal_Int32 nPos );
+protected:
+    rtl::OUString GetEventName( const sal_Int32 nId );
+    rtl::OUString getMacroPath( const sal_Int32 nEventId, const SCTAB nTab );
+
+public:
+	ScVbaEventsHelper( ScDocument* pDocument ):pDoc( pDocument ), mpWindowListener( NULL ), mbOpened( sal_False ){};
+    ScVbaEventsHelper( css::uno::Sequence< css::uno::Any > const& aArgs, css::uno::Reference< css::uno::XComponentContext > const& xContext );
+    ~ScVbaEventsHelper();
+	ScDocument* getDocument() { return pDoc; };
+	sal_Bool executeSheetMacro( USHORT nEvent, SCTAB nTab, uno::Sequence< uno::Any >& rArgs );
+    // XVBAWorkbookEventHelper
+    virtual sal_Bool SAL_CALL ProcessCompatibleVbaEvent( sal_Int32 VbaEvent, const uno::Sequence< uno::Any >& aArgs ) throw (uno::RuntimeException);
+};
+
+#endif
+
--- /dev/null	2007-05-04 18:54:36.000000000 +0800
+++ sc/source/ui/vba/vbaeventshelper.cxx	2008-05-30 19:07:54.000000000 +0800
@@ -0,0 +1,1066 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: vbaeventshelper.cxx,v $
+ *
+ *  $Revision: 1.0 $
+ *
+ *  last change: $Author: vg $ $Date: 2007/12/07 10:42:26 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbaeventshelper.hxx"
+#include "helperdecl.hxx"
+#include <sfx2/objsh.hxx> 
+#include <basic/basmgr.hxx>
+#include <basic/sbmod.hxx>
+#include <basic/sbmeth.hxx>
+#include <basic/sbx.hxx>
+#include "scextopt.hxx"
+#include <sfx2/evntconf.hxx>
+#include <sfx2/event.hxx>
+#include <sfx2/sfx.hrc>
+#include <toolkit/unohlp.hxx>
+#include <comphelper/processfactory.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <cppuhelper/implbase2.hxx>
+#include <com/sun/star/sheet/XSheetCellRangeContainer.hpp>
+#include <com/sun/star/document/XEventsSupplier.hpp>
+#include <com/sun/star/sheet/XCellRangeReferrer.hpp>
+#include <com/sun/star/table/XCell.hpp> 
+#include <com/sun/star/sheet/XSpreadsheetDocument.hpp>
+#include <com/sun/star/sheet/XSpreadsheet.hpp>
+#include <com/sun/star/container/XNamed.hpp>
+#include <com/sun/star/awt/XWindowListener.hpp>
+#include <com/sun/star/awt/WindowEvent.hpp>
+#include <com/sun/star/awt/XMouseListener.hpp>
+#include <com/sun/star/awt/MouseEvent.hpp>
+#include <com/sun/star/lang/EventObject.hpp>
+#include <com/sun/star/awt/MouseButton.hpp> 
+#include "cellsuno.hxx" 
+
+#include <map>
+
+using namespace std;
+using namespace com::sun::star;
+using namespace org::openoffice;
+using namespace com::sun::star::document::VbaEventId;
+
+const static String sLibrary( RTL_CONSTASCII_USTRINGPARAM("Standard"));
+const static String sModule( RTL_CONSTASCII_USTRINGPARAM("ThisWorkbook"));
+
+const static rtl::OUString sUrlPart0 = rtl::OUString::createFromAscii( "vnd.sun.star.script:");
+const static rtl::OUString sUrlPart1 = rtl::OUString::createFromAscii( "vnd.sun.star.script:Standard.");
+const static rtl::OUString sUrlPart2 = rtl::OUString::createFromAscii( "?language=Basic&location=document"); 
+
+//typedef ::cppu::WeakImplHelper2< awt::XWindowListener, awt::XMouseListener > WindowListener_BASE;
+typedef ::cppu::WeakImplHelper1< awt::XWindowListener > WindowListener_BASE;
+
+class VbaWindowListener : public WindowListener_BASE
+{
+    ScVbaEventsHelper* pVbaEventsHelper;
+    uno::Reference< frame::XModel > m_xModel;
+    sal_Bool m_bPrepare;
+protected :
+    uno::Reference< awt::XWindow > GetContainerWindow();
+    sal_Bool IsMouseReleased();
+    DECL_LINK( fireResizeMacro, Timer* );
+    void processWindowResizeMacro();
+public :
+    VbaWindowListener( ScVbaEventsHelper* pHelper );
+    void startWindowLinstener();
+    void stopWindowLinstener();
+    // XWindowListener
+    virtual void SAL_CALL windowResized( const awt::WindowEvent& aEvent ) throw ( uno::RuntimeException );
+    virtual void SAL_CALL windowMoved( const awt::WindowEvent& aEvent ) throw ( uno::RuntimeException );
+    virtual void SAL_CALL windowShown( const lang::EventObject& aEvent ) throw ( uno::RuntimeException );
+    virtual void SAL_CALL windowHidden( const lang::EventObject& aEvent ) throw ( uno::RuntimeException );
+    virtual void SAL_CALL disposing( const lang::EventObject& aEvent ) throw ( uno::RuntimeException );
+};
+VbaWindowListener::VbaWindowListener( ScVbaEventsHelper* pHelper ) : pVbaEventsHelper( pHelper )
+{
+    m_xModel.set( pVbaEventsHelper->getDocument()->GetDocumentShell()->GetModel(), uno::UNO_QUERY );
+    m_bPrepare = sal_False;
+    //m_pTimer = 0;
+}
+uno::Reference< awt::XWindow > 
+VbaWindowListener::GetContainerWindow() 
+{
+    try
+    {
+        if( pVbaEventsHelper )
+        {
+            uno::Reference< frame::XModel > xModel( m_xModel, uno::UNO_QUERY );
+            if( xModel.is() )
+            {
+                uno::Reference< frame::XController > xController( xModel->getCurrentController(), uno::UNO_QUERY );
+                if( xController.is() )
+                {
+                    uno::Reference< frame::XFrame > xFrame( xController->getFrame(), uno::UNO_QUERY );
+                    if( xFrame.is() )
+                    {
+                        uno::Reference< awt::XWindow > xWindow( xFrame->getContainerWindow(), uno::UNO_QUERY );
+                        if( xWindow.is() )
+                            return xWindow;
+                    }
+                }
+            }
+        }
+    }
+	catch( uno::Exception& e )
+    {
+    }
+    return uno::Reference< awt::XWindow >();
+}
+sal_Bool
+VbaWindowListener::IsMouseReleased()
+{
+    Window* pWindow = (VCLUnoHelper::GetWindow(  GetContainerWindow() ) );
+    if( pWindow )
+    {
+        Window::PointerState aPointerState = pWindow->GetPointerState();
+        if( !aPointerState.mnState & ( MOUSE_LEFT | MOUSE_MIDDLE | MOUSE_RIGHT ) )
+            return sal_True; 
+    }
+    return sal_False;
+}
+void
+VbaWindowListener::startWindowLinstener()
+{
+    OSL_TRACE( "VbaWindowListener::startWindowLinstener" );
+    uno::Reference< awt::XWindow > xWindow( GetContainerWindow(), uno::UNO_QUERY );
+    if( xWindow.is() )
+        xWindow->addWindowListener( this );
+}
+void
+VbaWindowListener::stopWindowLinstener()
+{
+    OSL_TRACE( "VbaWindowListener::stopWindowLinstener" );
+    uno::Reference< awt::XWindow > xWindow( GetContainerWindow(), uno::UNO_QUERY );
+    if( xWindow.is() )
+    {
+        xWindow->removeWindowListener( this );
+        pVbaEventsHelper = NULL;
+    }
+}
+void
+VbaWindowListener::processWindowResizeMacro()
+{
+    const static String sWindowResize( RTL_CONSTASCII_USTRINGPARAM("Workbook_WindowResize") );
+    if( pVbaEventsHelper )
+        pVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_WINDOWRESIZE, uno::Sequence< uno::Any >() );
+}
+IMPL_LINK( VbaWindowListener, fireResizeMacro, Timer*, pTimer )
+{
+    if( pVbaEventsHelper && m_bPrepare && pTimer )
+    {
+        if( IsMouseReleased() )
+        {
+            pTimer->Stop();
+            delete pTimer;
+            pTimer = 0;
+            m_bPrepare = sal_False;
+            OSL_TRACE("\tfiredMacroAtHere");
+            processWindowResizeMacro();
+        }
+    }
+    return 0;
+}
+void SAL_CALL
+VbaWindowListener::windowResized(  const awt::WindowEvent& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+    Window* pWindow = (VCLUnoHelper::GetWindow(  GetContainerWindow() ) );
+    if( pWindow && !m_bPrepare )
+    {
+        m_bPrepare = sal_True;
+        AutoTimer* pTimer = new AutoTimer();
+        pTimer->SetTimeoutHdl( LINK( this, VbaWindowListener, fireResizeMacro ) );
+        pTimer->Start();
+        OSL_TRACE("\tVbaWindowListener::windowResized");
+    }
+}
+void SAL_CALL
+VbaWindowListener::windowMoved(  const awt::WindowEvent& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+    // not interest this time
+    OSL_TRACE("\tVbaWindowListener::windowMoved");
+}
+void SAL_CALL
+VbaWindowListener::windowShown(  const lang::EventObject& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+    // not interest this time
+    OSL_TRACE("\tVbaWindowListener::windowShown");
+}
+void SAL_CALL
+VbaWindowListener::windowHidden(  const lang::EventObject& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+    // not interest this time
+    OSL_TRACE("\tVbaWindowListener::windowHidden");
+}
+void SAL_CALL
+VbaWindowListener::disposing(  const lang::EventObject& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+    OSL_TRACE("\tVbaWindowListener::disposing");
+    pVbaEventsHelper = NULL;
+}
+
+class ImplVbaEventNameInfo
+{
+private:
+    map< sal_Int32, rtl::OUString > m_aEventNameMap;
+
+protected:
+    static ImplVbaEventNameInfo* pImplVbaEventNameInfo;
+    ImplVbaEventNameInfo() { InitImplVbaEventNameInfo(); }
+private:
+    void insert( const sal_Int32 nId, const rtl::OUString sEventName )
+    {
+        m_aEventNameMap.insert( make_pair( nId, sEventName ) );
+    }
+    void InitImplVbaEventNameInfo();
+public:
+    virtual ~ImplVbaEventNameInfo();
+    rtl::OUString getEventName( const sal_Int32 nId )
+    {
+        map< sal_Int32, rtl::OUString >::iterator iter = m_aEventNameMap.find( nId );
+        if( iter != m_aEventNameMap.end() )
+            return iter->second;
+        return rtl::OUString();
+    }
+    static ImplVbaEventNameInfo* GetImplVbaEventNameInfo();
+};
+ImplVbaEventNameInfo* ImplVbaEventNameInfo::pImplVbaEventNameInfo = NULL;
+
+ImplVbaEventNameInfo::~ImplVbaEventNameInfo()
+{
+    if( pImplVbaEventNameInfo )
+        delete pImplVbaEventNameInfo;
+}
+
+ImplVbaEventNameInfo* 
+ImplVbaEventNameInfo::GetImplVbaEventNameInfo()
+{
+    if( !pImplVbaEventNameInfo )
+    {
+        pImplVbaEventNameInfo = new ImplVbaEventNameInfo;
+    }
+    return pImplVbaEventNameInfo;
+}
+
+#define CREATEOUSTRING(asciistr) rtl::OUString::createFromAscii(asciistr)
+
+#define INSERT_EVENT_INFO( Object, Event, ObjectName, EventName ) \
+        insert( VBAEVENT_##Object##_##Event, ObjectName + CREATEOUSTRING( EventName ) )
+
+#define INSERT_WORKSHEET_EVENT_INFO( Event, EventName ) \
+        INSERT_EVENT_INFO( WORKSHEET, Event,CREATEOUSTRING("Worksheet_"), EventName ); \
+        INSERT_EVENT_INFO( WORKBOOK_SHEET, Event, CREATEOUSTRING("Workbook_Sheet"), EventName )
+
+#define INSERT_WORKBOOK_EVENT_INFO( Event, EventName ) \
+        INSERT_EVENT_INFO(  WORKBOOK, Event, CREATEOUSTRING("Workbook_"), EventName )
+
+void ImplVbaEventNameInfo::InitImplVbaEventNameInfo()
+{
+    INSERT_WORKSHEET_EVENT_INFO( ACTIVATE, "Activate");
+    INSERT_WORKSHEET_EVENT_INFO( BEFOREDOUBLECLICK, "BeforeDoubleClick" );
+    INSERT_WORKSHEET_EVENT_INFO( BEFORERIGHTCLICK, "BeforeRightClick" );
+    INSERT_WORKSHEET_EVENT_INFO( CALCULATE, "Calculate" );
+    INSERT_WORKSHEET_EVENT_INFO( CHANGE, "Change" );
+    INSERT_WORKSHEET_EVENT_INFO( DEACTIVATE, "Deactivate" );
+    INSERT_WORKSHEET_EVENT_INFO( FOLLOWHYPERLINK, "FollowHyperlink" );
+    INSERT_WORKSHEET_EVENT_INFO( PIVOTTABLEUPDATE, "PivotTableUpdate" );
+    INSERT_WORKSHEET_EVENT_INFO( SELECTIONCHANGE, "SelectionChange" );
+
+    // Workbook
+    INSERT_WORKBOOK_EVENT_INFO( ACTIVATE, "Activate" );
+    INSERT_WORKBOOK_EVENT_INFO( DEACTIVATE, "Deactivate" );
+    INSERT_WORKBOOK_EVENT_INFO( OPEN, "Open" );
+    // AUTOOPEN doesn't be used. TODO, this should be "auto_open"
+    INSERT_WORKBOOK_EVENT_INFO( BEFORECLOSE, "BeforeClose" );
+    INSERT_WORKBOOK_EVENT_INFO( BEFOREPRINT, "BeforePrint" );
+    INSERT_WORKBOOK_EVENT_INFO( BEFORESAVE, "BeforeSave" );
+    INSERT_WORKBOOK_EVENT_INFO( NEWSHEET, "NewSheet" );
+    INSERT_WORKBOOK_EVENT_INFO( WINDOWACTIVATE, "WindowActivate" );
+    INSERT_WORKBOOK_EVENT_INFO( WINDOWDEACTIVATE, "WindowDeactivate" );
+    INSERT_WORKBOOK_EVENT_INFO( WINDOWRESIZE, "WindowResize" );
+    // VBAEVENT_WORKBOOK_WINDOWCOLSE and VBAEVENT_WORKBOOK_CLOSE doesn't be used
+}
+
+ScVbaEventsHelper::ScVbaEventsHelper( uno::Sequence< css::uno::Any > const& aArgs, uno::Reference< uno::XComponentContext > const& xContext )
+    : m_xContext( xContext ), mpWindowListener( NULL ), mbOpened( sal_False )
+{
+    OSL_TRACE( "ScVbaEventsHelper::ScVbaEventsHelper" );
+    uno::Reference< frame::XModel > xModel ( getXSomethingFromArgs< frame::XModel >( aArgs, 0 ), uno::UNO_QUERY );
+    ScDocShell* pDocShell = getDocShell( xModel );
+    pDoc = pDocShell->GetDocument();
+}
+
+ScVbaEventsHelper::~ScVbaEventsHelper()
+{
+    OSL_TRACE("ScVbaEventsHelper::~ScVbaEventsHelper");
+    if( mpWindowListener )
+    {
+        mpWindowListener->stopWindowLinstener();
+        mpWindowListener = NULL;
+    }
+}
+
+rtl::OUString
+ScVbaEventsHelper::GetEventName( const sal_Int32 nId )
+{
+    rtl::OUString sEventName;
+    ImplVbaEventNameInfo* pEventInfo = ImplVbaEventNameInfo::GetImplVbaEventNameInfo();
+    if( pEventInfo )
+        sEventName = pEventInfo->getEventName( nId );
+    return sEventName;
+}
+
+// Treat the args as possible inouts ( convertion at bottom of method )
+sal_Bool ScVbaEventsHelper::executeWorkBookMacro( SfxObjectShell* pShell, const String& sMacroName, uno::Sequence< uno::Any >& aArgs, uno::Any& aRet )
+{
+	// until ObjectModules ( and persisting of codenames ) is supported, if this is a
+	// document saved from XL then we won't be able to determine the codename for the Workbook
+	// Module, so... we have no choice but to search all modules for the moment, thus the macro
+	// passed in should be the fully specified name. 	
+	rtl::OUString sUrl = sUrlPart0.concat( sMacroName ).concat( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".") ) ).concat( sUrlPart2 ) ;
+	uno::Sequence< sal_Int16 > aOutArgsIndex;
+	uno::Sequence< uno::Any > aOutArgs;
+	ErrCode nErr = pShell->CallXScript( sUrl,  aArgs, aRet,
+			aOutArgsIndex, aOutArgs, sal_False );
+
+	// Script Executed?
+	if ( nErr != ERRCODE_NONE )
+		return sal_False;
+
+	sal_Int32 nLen = aOutArgs.getLength();
+	// convert any out params to seem like they were inouts
+	if ( nLen )
+	{
+		for ( sal_Int32 index=0; index < nLen; ++index )
+		{
+			sal_Int32 nOutIndex = aOutArgsIndex[ index ];
+			aArgs[ nOutIndex ] = aOutArgs[ index ];
+		}
+
+	}
+	return sal_True;
+}
+String ScVbaEventsHelper::docMacroExists( SfxObjectShell* pShell, const String& sMod, const String& sMacro )
+{
+	String sFullName;	
+	// would use the script provider to see if the macro exists but
+	// called at this stage tdoc content handler stuff is not set up
+	// so it fails
+
+	BasicManager* pBasicMgr = pShell-> GetBasicManager();
+	if ( pBasicMgr )
+	{
+		StarBASIC* pBasic = pBasicMgr->GetLib( sLibrary );
+		if ( !pBasic )
+		{
+			USHORT nId = pBasicMgr->GetLibId( sLibrary );
+			pBasicMgr->LoadLib( nId );
+			pBasic = pBasicMgr->GetLib( sLibrary );
+		}
+		if ( pBasic )
+		{
+			if ( sMod.Len() ) // we wish to find the macro is a specific module
+			{
+				SbModule* pModule = pBasic->FindModule( sMod );
+				if ( pModule )
+				{
+					SbxArray* pMethods = pModule->GetMethods();
+					if ( pMethods )
+					{
+						SbMethod* pMethod = static_cast< SbMethod* >( pMethods->Find( sMacro, SbxCLASS_METHOD ) );
+						if ( pMethod )
+						{
+							sFullName = sMacro;
+							sFullName.Insert( '.', 0 ).Insert( sMod, 0 ).Insert( '.', 0 ).Insert( sLibrary, 0 );
+						}
+					}
+				}
+			}
+			else if( SbMethod* pMethod = dynamic_cast< SbMethod* >( pBasic->Find( sMacro, SbxCLASS_METHOD ) ) )
+			{
+					if( SbModule* pModule = pMethod->GetModule() )
+					{
+						sFullName = sMacro;
+						sFullName.Insert( '.', 0 ).Insert( pModule->GetName(), 0).Insert( '.', 0 ).Insert( sLibrary, 0 );
+					}
+			}		
+				
+		}
+	}
+	return sFullName;
+}
+
+sal_Bool ScVbaEventsHelper::processVbaEventWithCancel( const sal_Int32 nEventId )
+{
+	uno::Sequence< uno::Any > aArgs( 1 );
+	sal_Bool bCancel = sal_False;
+	aArgs[ 0 ] <<= bCancel;
+    processVbaEventMacroWithArgs( nEventId, aArgs );
+	aArgs[ 0 ] >>= bCancel;
+	return bCancel;
+}
+
+uno::Any ScVbaEventsHelper::createWorkSheet( SfxObjectShell* pShell, SCTAB nTab )
+{
+	uno::Any aRet;
+	try
+	{
+		uno::Reference< lang::XMultiComponentFactory > xSMgr( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+		uno::Reference< beans::XPropertySet > xProps( xSMgr, uno::UNO_QUERY_THROW );
+		uno::Reference<uno::XComponentContext > xCtx( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), uno::UNO_QUERY_THROW );
+		// Eventually we will be able to pull the Workbook/Worksheet objects
+		// directly from basic and register them as listeners
+
+		// create Workbook
+		uno::Sequence< uno::Any > aArgs(2);
+		aArgs[0] = uno::Any( uno::Reference< uno::XInterface >() );
+		aArgs[1] = uno::Any( pShell->GetModel() );
+		uno::Reference< uno::XInterface > xWorkbook( xSMgr->createInstanceWithArgumentsAndContext(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.excel.Workbook") ), aArgs, xCtx ), uno::UNO_QUERY );
+
+		// create WorkSheet
+		String sSheetName;
+		pDoc->GetName( nTab, sSheetName );
+		aArgs = uno::Sequence< uno::Any >(3);
+		aArgs[ 0 ] <<= xWorkbook;
+		aArgs[ 1 ] <<= pShell->GetModel();
+		aArgs[ 2 ] = uno::makeAny( rtl::OUString( sSheetName ) );
+		aRet <<= xSMgr->createInstanceWithArgumentsAndContext(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.excel.Worksheet") ), aArgs, xCtx );
+	}
+	catch( uno::Exception& e )
+	{
+	}
+	return aRet;
+}
+
+uno::Any ScVbaEventsHelper::createRange( const uno::Any& aRange )
+{
+	uno::Any aRet;
+	try
+	{
+		uno::Reference< sheet::XSheetCellRangeContainer > xRanges( 	aRange, uno::UNO_QUERY );
+		uno::Reference< table::XCellRange > xRange( aRange, uno::UNO_QUERY );
+		uno::Reference< lang::XMultiComponentFactory > xSMgr( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+		uno::Reference< beans::XPropertySet > xProps( xSMgr, uno::UNO_QUERY_THROW );
+		if (  xRanges.is() || xRange.is() )
+		{
+			uno::Reference<uno::XComponentContext > xCtx( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), uno::UNO_QUERY_THROW );
+			uno::Sequence< uno::Any > aArgs(2);
+			aArgs[0] = uno::Any( uno::Reference< uno::XInterface >() ); // dummy parent
+			if ( xRanges.is() )
+			{
+				aArgs[1] <<= xRanges;
+			}
+			else if ( xRange.is() )
+			{
+				aArgs[1] <<= xRange;
+			}
+			else
+			{
+				throw uno::RuntimeException(); // 
+			}
+			aRet <<= xSMgr->createInstanceWithArgumentsAndContext( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.excel.Range") ), aArgs, xCtx  );	
+		}
+	}
+	catch( uno::Exception& e ) 
+	{
+	}
+	return aRet;
+}
+
+uno::Any ScVbaEventsHelper::createHyperlink( const uno::Any& rCell )
+{
+	uno::Any aRet;
+	try
+	{
+		uno::Reference< lang::XMultiComponentFactory > xSMgr( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+		uno::Reference< beans::XPropertySet > xProps( xSMgr, uno::UNO_QUERY_THROW ); 
+		uno::Reference< table::XCell > xCell( rCell, uno::UNO_QUERY );
+		if( xCell.is() )
+		{
+			uno::Reference<uno::XComponentContext > xCtx( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), uno::UNO_QUERY_THROW );
+			uno::Sequence< uno::Any > aArgs(2);
+			aArgs[0] = uno::Any( uno::Reference< uno::XInterface >() ); // dummy parent
+			aArgs[1] <<= rCell;
+			
+			aRet <<= xSMgr->createInstanceWithArgumentsAndContext( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.excel.Hyperlink") ), aArgs, xCtx  );	
+		}
+		else
+		{
+			throw uno::RuntimeException(); // 
+		}
+	}
+	catch( uno::Exception& e ) 
+	{
+	}
+	return aRet;
+}
+
+String ScVbaEventsHelper::getSheetModuleName( SCTAB nTab )
+{
+	ScExtDocOptions* pExtOptions = pDoc->GetExtDocOptions();
+	String aCodeName;
+	pDoc->GetName( nTab, aCodeName);
+	// Use code name if that exists
+	if ( pExtOptions )
+		aCodeName = pExtOptions->GetCodeName( nTab );
+	return aCodeName;	
+}
+
+rtl::OUString
+ScVbaEventsHelper::getMacroPath( const sal_Int32 nEventId, const SCTAB nTab )
+{
+	SfxObjectShell* pShell = pDoc->GetDocumentShell();
+    rtl::OUString sMacroPath;
+    rtl::OUString sMacroName = GetEventName( nEventId );
+    switch( nEventId )
+    {
+        // Worksheet
+    	case VBAEVENT_WORKSHEET_ACTIVATE                      :
+    	case VBAEVENT_WORKSHEET_BEFOREDOUBLECLICK             :
+    	case VBAEVENT_WORKSHEET_BEFORERIGHTCLICK              :
+    	case VBAEVENT_WORKSHEET_CALCULATE                     :
+    	case VBAEVENT_WORKSHEET_CHANGE                        :
+    	case VBAEVENT_WORKSHEET_DEACTIVATE                    :
+    	case VBAEVENT_WORKSHEET_FOLLOWHYPERLINK               :
+    	case VBAEVENT_WORKSHEET_PIVOTTABLEUPDATE              :
+    	case VBAEVENT_WORKSHEET_SELECTIONCHANGE               :
+        {
+            rtl::OUString  aSheetModuleName = getSheetModuleName( nTab );
+            sMacroPath = docMacroExists( pShell, aSheetModuleName, sMacroName );
+            break;
+        }
+        // Workbook
+    	case VBAEVENT_WORKBOOK_ACTIVATE                       :
+    	case VBAEVENT_WORKBOOK_DEACTIVATE                     :
+    	case VBAEVENT_WORKBOOK_OPEN                           :
+    	case VBAEVENT_WORKBOOK_AUTOOPEN                       :
+    	case VBAEVENT_WORKBOOK_BEFORECLOSE                    :
+    	case VBAEVENT_WORKBOOK_BEFOREPRINT                    :
+    	case VBAEVENT_WORKBOOK_BEFORESAVE                     :
+    	case VBAEVENT_WORKBOOK_NEWSHEET                       :
+    	case VBAEVENT_WORKBOOK_WINDOWACTIVATE                 :
+    	case VBAEVENT_WORKBOOK_WINDOWDEACTIVATE               :
+    	case VBAEVENT_WORKBOOK_WINDOWRESIZE                   :
+    	case VBAEVENT_WORKBOOK_WINDOWCOLSE                    :
+    	case VBAEVENT_WORKBOOK_CLOSE                          :
+        // Workbook_sheet
+    	case VBAEVENT_WORKBOOK_SHEET_ACTIVATE                 :
+    	case VBAEVENT_WORKBOOK_SHEET_BEFOREDOUBLECLICK        :
+    	case VBAEVENT_WORKBOOK_SHEET_BEFORERIGHTCLICK         :
+    	case VBAEVENT_WORKBOOK_SHEET_CALCULATE                :
+    	case VBAEVENT_WORKBOOK_SHEET_CHANGE                   :
+    	case VBAEVENT_WORKBOOK_SHEET_DEACTIVATE               :
+    	case VBAEVENT_WORKBOOK_SHEET_FOLLOWHYPERLINK          :
+    	case VBAEVENT_WORKBOOK_SHEET_PIVOTTABLEUPDATE         :
+    	case VBAEVENT_WORKBOOK_SHEET_SELECTIONCHANGE          :
+        {
+	        ScExtDocOptions* pExtOptions = pDoc->GetExtDocOptions();
+            if( pExtOptions )
+            {
+                ScExtDocSettings aExtDocSettings = pExtOptions->GetDocSettings();
+                String sWorkbookModuleName = aExtDocSettings.maGlobCodeName;
+                sMacroPath = docMacroExists( pShell, sWorkbookModuleName, sMacroName );
+            }
+            else
+            {
+                // TODO need this?
+                sMacroPath = docMacroExists( pShell, rtl::OUString(), sMacroName );
+            }
+            break;
+        }
+        default:
+            break;
+    }
+    return sMacroPath;
+}
+
+sal_Bool ScVbaEventsHelper::executeSheetMacro( USHORT nEvent, SCTAB nTab, uno::Sequence< uno::Any >& rArgs )
+{
+	SfxObjectShell* pShell = pDoc->GetDocumentShell();
+
+	sal_Bool result = sal_False;
+	uno::Sequence< uno::Any > aArgs;
+	uno::Any aRet;
+	
+    rtl::OUString sMacroPath = getMacroPath( nEvent, nTab );
+	if( sMacroPath.getLength() )
+	{
+		switch( nEvent )
+		{
+			case VBAEVENT_WORKSHEET_ACTIVATE:
+			case VBAEVENT_WORKSHEET_CALCULATE:
+			case VBAEVENT_WORKSHEET_DEACTIVATE:
+			{
+				// no arguments
+				result = executeWorkBookMacro( pShell, sMacroPath, aArgs, aRet );
+				break;
+			}
+    	    case VBAEVENT_WORKBOOK_SHEET_DEACTIVATE        :
+    	    case VBAEVENT_WORKBOOK_SHEET_CALCULATE         :
+    	    case VBAEVENT_WORKBOOK_SHEET_ACTIVATE          :
+            {
+				aArgs = uno::Sequence< uno::Any >(1);
+				aArgs[0] = createWorkSheet( pShell, nTab ); 
+				result = executeWorkBookMacro( pShell, sMacroPath, aArgs, aRet );
+				break;
+            }
+			case VBAEVENT_WORKSHEET_CHANGE:
+			case VBAEVENT_WORKSHEET_SELECTIONCHANGE:
+			{
+				// one argument: range
+				uno::Any aRange = createRange( rArgs[0] );
+				aArgs = uno::Sequence< uno::Any >(1);
+				aArgs[0] = aRange;
+				result = executeWorkBookMacro( pShell, sMacroPath, aArgs, aRet );
+				break;
+			}
+    	    case VBAEVENT_WORKBOOK_SHEET_CHANGE            :
+    	    case VBAEVENT_WORKBOOK_SHEET_SELECTIONCHANGE   :
+            {
+				uno::Any aRange = createRange( rArgs[0] );
+				aArgs = uno::Sequence< uno::Any >(2);
+				aArgs[0] = createWorkSheet( pShell, nTab );
+				aArgs[1] = aRange;
+				result = executeWorkBookMacro( pShell, sMacroPath, aArgs, aRet );
+				break;
+            }
+			case VBAEVENT_WORKSHEET_BEFOREDOUBLECLICK:
+			case VBAEVENT_WORKSHEET_BEFORERIGHTCLICK:
+			{
+				// two aruments: range and cancel
+				uno::Any aRange = createRange( rArgs[0] );
+				aArgs = uno::Sequence< uno::Any >(2);
+				aArgs[0] = aRange;
+				aArgs[1] = rArgs[1];
+				result = executeWorkBookMacro( pShell, sMacroPath, aArgs, aRet );
+				// return the cancel value
+				rArgs[1] = aArgs[1];
+				break;
+			}
+    	    case VBAEVENT_WORKBOOK_SHEET_BEFOREDOUBLECLICK :
+    	    case VBAEVENT_WORKBOOK_SHEET_BEFORERIGHTCLICK  :
+            {
+				uno::Any aRange = createRange( rArgs[0] );
+				aArgs = uno::Sequence< uno::Any >(3);
+				aArgs[0] = createWorkSheet( pShell, nTab );
+				aArgs[1] = aRange;
+				aArgs[2] = aArgs[1];
+				result = executeWorkBookMacro( pShell, sMacroPath, aArgs, aRet );
+				rArgs[2] = aArgs[2];
+				break;
+            }
+			case VBAEVENT_WORKSHEET_FOLLOWHYPERLINK:
+			{
+				// one argument: hyperlink
+				uno::Any aHyperlink = createHyperlink( rArgs[0] );
+				aArgs = uno::Sequence< uno::Any >(1);
+				aArgs[0] = aHyperlink;
+				result = executeWorkBookMacro( pShell, sMacroPath, aArgs, aRet );
+				break;
+			}
+    	    case VBAEVENT_WORKBOOK_SHEET_FOLLOWHYPERLINK   :
+            {
+				uno::Any aHyperlink = createHyperlink( rArgs[0] );
+				aArgs = uno::Sequence< uno::Any >(2);
+				aArgs[0] = createWorkSheet( pShell, nTab );
+				aArgs[1] = aHyperlink;
+				result = executeWorkBookMacro( pShell, sMacroPath, aArgs, aRet );
+				break;
+            }
+			case VBAEVENT_WORKSHEET_PIVOTTABLEUPDATE:
+    	    case VBAEVENT_WORKBOOK_SHEET_PIVOTTABLEUPDATE  :
+			{
+				// one argument: pivottable
+				break;
+			}
+		}
+	}
+
+	return result;
+}
+
+uno::Any ScVbaEventsHelper::createWindow( SfxObjectShell* pShell )
+{
+    try
+    {
+        uno::Reference< lang::XMultiServiceFactory > xSF( comphelper::getProcessServiceFactory(), uno::UNO_QUERY );
+        uno::Reference< frame::XModel > xModel( pShell->GetModel(), uno::UNO_QUERY );
+        uno::Sequence< uno::Any > aWindowArgs(2);
+        aWindowArgs[0] = uno::Any( uno::Reference< uno::XInterface > () );
+        aWindowArgs[1] = uno::Any( xModel );
+        uno::Reference< uno::XInterface > xWindow( xSF->createInstanceWithArguments( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.excel.Window" ) ), aWindowArgs ), uno::UNO_QUERY );
+        if( xWindow.is() )
+            return uno::makeAny( xWindow );
+    }
+	catch( uno::Exception& e )
+	{
+	}
+    return uno::Any();
+}
+
+void ScVbaEventsHelper::processVbaEventMacro_noreturn( const sal_Int32 nEventId )
+{
+    uno::Sequence< uno::Any > aArgs;
+    processVbaEventMacroWithArgs( nEventId, aArgs );
+}
+
+void ScVbaEventsHelper::processVbaEventMacroWithArgs( const sal_Int32 nEventId, uno::Sequence< uno::Any >& rArgs )
+{
+	SfxObjectShell* pShell = pDoc->GetDocumentShell();
+	if( !pShell )
+		return;
+
+    String sMacroName = GetEventName( nEventId );
+    if( sMacroName.Len() > 0 )
+    {
+        uno::Any aRet;
+        String sMacro = docMacroExists( pShell, String(), sMacroName );
+        if ( sMacro.Len() > 0 )
+        {
+            executeWorkBookMacro( pShell, sMacro, rArgs, aRet );
+        }
+    }
+}
+
+void ScVbaEventsHelper::WorkbookWindowMacro( const sal_Int32 nHint )
+{
+	SfxObjectShell* pShell = pDoc->GetDocumentShell();
+	if( !pShell )
+		return;
+    uno::Sequence< uno::Any > aArgs(1);
+	uno::Any aElement = createWindow( pShell );
+    aArgs[0] = aElement;
+    switch( nHint )
+    {
+        case VBAEVENT_WORKBOOK_WINDOWACTIVATE:
+        case VBAEVENT_WORKBOOK_WINDOWDEACTIVATE:
+        case VBAEVENT_WORKBOOK_WINDOWRESIZE:
+            // it will be called when close the doc. but should not launch the macro.
+            processVbaEventMacroWithArgs( nHint, aArgs );
+            break;
+        case VBAEVENT_WORKBOOK_WINDOWCOLSE:
+            // ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_WINDOWDEACTIVATE, uno::Sequence< uno::Any >() );
+            // does Doc be closed surely? if yes. should frie the workbook deactivate event.
+            ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_DEACTIVATE, uno::Sequence< uno::Any >() );
+            break;
+         default:
+            break;
+    }
+}
+
+sal_Bool ScVbaEventsHelper::processDocBeforeSaveMacro( sal_Bool bSaveAsUI )
+{
+	uno::Sequence< uno::Any > aArgs( 2 );
+	sal_Bool bCancel = sal_False;
+    aArgs[ 0 ] <<= bSaveAsUI;
+	aArgs[ 1 ] <<= bCancel;
+    processVbaEventMacroWithArgs( VBAEVENT_WORKBOOK_BEFORESAVE, aArgs );
+	aArgs[ 1 ] >>= bCancel;
+	return bCancel;
+}
+
+SCTAB
+ScVbaEventsHelper::getTabFromArgs( const uno::Sequence< uno::Any > aArgs, const sal_Int32 nPos )
+{
+    SCTAB nTab = -1;
+    uno::Reference< sheet::XCellRangeAddressable > xCellRangeAddressable( getXSomethingFromArgs< sheet::XCellRangeAddressable >( aArgs, nPos ), uno::UNO_QUERY );
+    if( xCellRangeAddressable.is() )
+    {
+        table::CellRangeAddress aAddress = xCellRangeAddressable->getRangeAddress();
+        nTab = aAddress.Sheet;
+    }
+    return nTab;
+}
+
+#define INVALID_TAB -1
+
+sal_Bool SAL_CALL 
+ScVbaEventsHelper::ProcessCompatibleVbaEvent( sal_Int32 VbaEvent, const uno::Sequence< uno::Any >& aArgs ) throw (uno::RuntimeException)
+{
+	SfxObjectShell* pShell = pDoc->GetDocumentShell();
+	if( !pShell )
+		return sal_False;
+    
+    sal_Int32 nTab = INVALID_TAB;
+    uno::Sequence< uno::Any > aTmpArgs( aArgs );
+    switch( VbaEvent )
+    {
+        // Worksheet
+		case VBAEVENT_WORKSHEET_ACTIVATE               :
+        {
+            if( aArgs[0] >>= nTab )
+            {
+                executeSheetMacro( (USHORT)VbaEvent, (SCTAB)nTab, aTmpArgs );
+                // recursive call related workbook sheet event.
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_SHEET_ACTIVATE, aArgs );
+            }
+            break;
+        }
+		case VBAEVENT_WORKSHEET_BEFOREDOUBLECLICK      :
+        {
+            nTab = getTabFromArgs( aTmpArgs, 0 );
+            if( nTab > INVALID_TAB )
+            {
+                executeSheetMacro( (USHORT)VbaEvent, (SCTAB)nTab, aTmpArgs );
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_SHEET_BEFOREDOUBLECLICK, aArgs );
+            }
+            break;
+        }
+		case VBAEVENT_WORKSHEET_BEFORERIGHTCLICK       :
+        {
+            nTab = getTabFromArgs( aTmpArgs, 0 );
+            if( nTab > INVALID_TAB )
+            {
+                executeSheetMacro( (USHORT)VbaEvent, (SCTAB)nTab, aTmpArgs );
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_SHEET_BEFORERIGHTCLICK, aArgs );
+            }
+            break;
+        }
+		case VBAEVENT_WORKSHEET_CALCULATE              :
+        {
+            if( aArgs[0] >>= nTab )
+            {
+                executeSheetMacro( (USHORT)VbaEvent, (SCTAB)nTab, aTmpArgs );
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_SHEET_CALCULATE, aArgs );
+            }
+            break;
+        }
+		case VBAEVENT_WORKSHEET_CHANGE                 :
+        {
+            nTab = getTabFromArgs( aTmpArgs, 0 );
+            if( nTab > INVALID_TAB )
+            {
+                executeSheetMacro( (USHORT)VbaEvent, (SCTAB)nTab, aTmpArgs );
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_SHEET_CHANGE, aArgs );
+            }
+            break;
+        }
+		case VBAEVENT_WORKSHEET_DEACTIVATE             :
+        {
+            if( aArgs[0] >>= nTab )
+            {
+                executeSheetMacro( (USHORT)VbaEvent, (SCTAB)nTab, aTmpArgs );
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_SHEET_DEACTIVATE, aArgs );
+            }
+            break;
+        }
+		case VBAEVENT_WORKSHEET_FOLLOWHYPERLINK        :
+        {
+            nTab = getTabFromArgs( aTmpArgs, 0 );
+            if( nTab > INVALID_TAB )
+            {
+                executeSheetMacro( (USHORT)VbaEvent, (SCTAB)nTab, aTmpArgs );
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_SHEET_FOLLOWHYPERLINK, aArgs );
+            }
+            break;
+        }
+		case VBAEVENT_WORKSHEET_PIVOTTABLEUPDATE       :
+            // TODO
+            break;
+		case VBAEVENT_WORKSHEET_SELECTIONCHANGE        :
+        {
+            nTab = getTabFromArgs( aTmpArgs, 0 );
+            if( nTab > INVALID_TAB )
+            {
+                executeSheetMacro( (USHORT)VbaEvent, (SCTAB)nTab, aTmpArgs );
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_SHEET_SELECTIONCHANGE, aArgs );
+            }
+            break;
+        }
+        // Workbook_sheet
+    	case VBAEVENT_WORKBOOK_SHEET_ACTIVATE          :
+        {
+            if( aArgs[0] >>= nTab )
+            {
+                executeSheetMacro( (USHORT)VbaEvent, (SCTAB)nTab, aTmpArgs );
+            }
+            break;
+        }
+    	case VBAEVENT_WORKBOOK_SHEET_BEFOREDOUBLECLICK :
+        {
+            nTab = getTabFromArgs( aTmpArgs, 0 );
+            if( nTab > INVALID_TAB )
+            {
+                executeSheetMacro( (USHORT)VbaEvent, (SCTAB)nTab, aTmpArgs );
+            }
+            break;
+        }
+    	case VBAEVENT_WORKBOOK_SHEET_BEFORERIGHTCLICK  :
+        {
+            nTab = getTabFromArgs( aTmpArgs, 0 );
+            if( nTab > INVALID_TAB )
+            {
+                executeSheetMacro( (USHORT)VbaEvent, (SCTAB)nTab, aTmpArgs );
+            }
+            break;
+        }
+    	case VBAEVENT_WORKBOOK_SHEET_CALCULATE         :
+        {
+            if( aArgs[0] >>= nTab )
+            {
+                executeSheetMacro( (USHORT)VbaEvent, (SCTAB)nTab, aTmpArgs );
+            }
+            break;
+        }
+    	case VBAEVENT_WORKBOOK_SHEET_CHANGE            :
+        {
+            nTab = getTabFromArgs( aTmpArgs, 0 );
+            if( nTab > INVALID_TAB )
+            {
+                executeSheetMacro( (USHORT)VbaEvent, (SCTAB)nTab, aTmpArgs );
+            }
+            break;
+        }
+    	case VBAEVENT_WORKBOOK_SHEET_DEACTIVATE        :
+        {
+            if( aArgs[0] >>= nTab )
+            {
+                executeSheetMacro( (USHORT)VbaEvent, (SCTAB)nTab, aTmpArgs );
+            }
+            break;
+        }
+    	case VBAEVENT_WORKBOOK_SHEET_FOLLOWHYPERLINK   :
+        {
+            nTab = getTabFromArgs( aTmpArgs, 0 );
+            if( nTab > INVALID_TAB )
+            {
+                executeSheetMacro( (USHORT)VbaEvent, (SCTAB)nTab, aTmpArgs );
+            }
+            break;
+        }
+    	case VBAEVENT_WORKBOOK_SHEET_PIVOTTABLEUPDATE  :
+        // TODO
+            break;
+    	case VBAEVENT_WORKBOOK_SHEET_SELECTIONCHANGE   :
+        {
+            nTab = getTabFromArgs( aTmpArgs, 0 );
+            if( nTab > INVALID_TAB )
+            {
+                executeSheetMacro( (USHORT)VbaEvent, (SCTAB)nTab, aTmpArgs );
+            }
+            break;
+        }
+		// Workbook
+		case VBAEVENT_WORKBOOK_ACTIVATE            :
+        {
+            // if workbook open event do not be fired. fired it before 
+            // workbook activate event to compatible with MSO.
+            if( !mbOpened )
+            {
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_OPEN, aArgs );
+            }
+            processVbaEventMacro_noreturn( VBAEVENT_WORKBOOK_ACTIVATE );
+            // workbook window activate event same as this one
+            ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_WINDOWACTIVATE, aArgs );
+            break;
+        }
+		case VBAEVENT_WORKBOOK_DEACTIVATE          :
+        {
+            processVbaEventMacro_noreturn( VBAEVENT_WORKBOOK_DEACTIVATE );
+            // same as workbook window deactivate
+            ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_WINDOWDEACTIVATE, aArgs );
+            break;
+        }
+		case VBAEVENT_WORKBOOK_OPEN                :
+        {
+            // process workbook open macro
+            // does auto open work here?
+            //WorkbookAutoOpen();
+            if( !mbOpened )
+            {
+                processVbaEventMacro_noreturn( VBAEVENT_WORKBOOK_OPEN );
+                mbOpened = sal_True;
+            }
+            // register the window listener.
+            if( !mpWindowListener )
+            {
+                mpWindowListener = new VbaWindowListener( this );
+                mpWindowListener->startWindowLinstener();
+            }
+            break;
+        }
+		case VBAEVENT_WORKBOOK_AUTOOPEN            :
+            break;
+		case VBAEVENT_WORKBOOK_BEFORECLOSE         :
+        {
+            sal_Bool bCancel = processVbaEventWithCancel( VbaEvent );
+            if( mpWindowListener && !bCancel )
+            {
+                mpWindowListener->stopWindowLinstener();
+                mpWindowListener = NULL;
+            }
+            return bCancel;
+        }
+		case VBAEVENT_WORKBOOK_BEFOREPRINT         :
+        {
+            return processVbaEventWithCancel( VbaEvent );
+        }
+		case VBAEVENT_WORKBOOK_BEFORESAVE          :
+        {
+            sal_Bool bUISave = sal_Bool();
+            if( aArgs.getLength() && ( aArgs[0] >>= bUISave ) )
+                return processDocBeforeSaveMacro( bUISave );
+        }
+		case VBAEVENT_WORKBOOK_NEWSHEET            :
+        {
+            SCTAB nTabNum;
+            if( aArgs.getLength() && ( aArgs[0] >>= nTabNum ) )
+            {
+                uno::Sequence< uno::Any > rArgs(1);
+                rArgs[0] = createWorkSheet( pShell, nTabNum );
+                processVbaEventMacroWithArgs( VBAEVENT_WORKBOOK_NEWSHEET, rArgs );
+            }
+            break;
+        }
+		case VBAEVENT_WORKBOOK_WINDOWACTIVATE      :
+		case VBAEVENT_WORKBOOK_WINDOWDEACTIVATE    :
+		case VBAEVENT_WORKBOOK_WINDOWRESIZE        :
+		case VBAEVENT_WORKBOOK_WINDOWCOLSE        :
+            WorkbookWindowMacro( VbaEvent );
+            break;
+		case VBAEVENT_WORKBOOK_CLOSE               :
+            break;
+        default:
+            OSL_TRACE( "Invalid Event" );
+    }
+
+    return sal_True;
+}
+
+namespace vbaeventshelper
+{
+namespace sdecl = comphelper::service_decl;
+sdecl::class_<ScVbaEventsHelper, sdecl::with_args<true> > serviceImpl;
+extern sdecl::ServiceDecl const serviceDecl(
+    serviceImpl,
+    "ScVbaEventsHelper",
+    "com.sun.star.document.VbaEventsHelper" );
+}
--- sc/source/ui/vba/service.cxx.orig	2008-05-13 16:48:00.000000000 +0800
+++ sc/source/ui/vba/service.cxx	2008-05-13 22:54:36.000000000 +0800
@@ -69,6 +69,10 @@ namespace hyperlink 
 {
 extern sdecl::ServiceDecl const serviceDecl;
 }
+namespace vbaeventshelper
+{
+extern sdecl::ServiceDecl const serviceDecl;
+}
 
 
 extern "C"
@@ -87,7 +91,7 @@ extern "C"
 
 	// Component registration
         if ( component_writeInfoHelper( pServiceManager, pRegistryKey, 
-		range::serviceDecl, workbook::serviceDecl, worksheet::serviceDecl, globals::serviceDecl, userform::serviceDecl, window::serviceDecl, hyperlink::serviceDecl ) )
+		range::serviceDecl, workbook::serviceDecl, worksheet::serviceDecl, globals::serviceDecl, userform::serviceDecl, window::serviceDecl, hyperlink::serviceDecl ) && component_writeInfoHelper( pServiceManager, pRegistryKey, vbaeventshelper::serviceDecl ) )
 		{
 			// Singleton registration
 			try
@@ -116,6 +120,8 @@ extern "C"
 		OSL_TRACE("In component_getFactory for %s", pImplName );
 	void* pRet =  component_getFactoryHelper(
         	pImplName, pServiceManager, pRegistryKey, range::serviceDecl, workbook::serviceDecl, worksheet::serviceDecl, globals::serviceDecl, userform::serviceDecl, window::serviceDecl, hyperlink::serviceDecl );
+    if( !pRet )
+        pRet = component_getFactoryHelper( pImplName, pServiceManager, pRegistryKey, vbaeventshelper::serviceDecl );
 	OSL_TRACE("Ret is 0x%x", pRet);
 	return pRet;
     }
--- sc/inc/document.hxx.orig	2008-05-07 12:06:10.000000000 +0800
+++ sc/inc/document.hxx	2008-05-27 12:15:49.000000000 +0800
@@ -42,6 +42,7 @@
 #include "brdcst.hxx"
 #include "tabopparams.hxx"
 #include "grammar.hxx"
+//#include <org/openoffice/vba/XVBAWorkbookEventHelper.hpp>
 
 #include <memory>
 #include <map>
@@ -132,6 +133,7 @@ class ScAutoNameCache;
 class ScTemporaryChartLock;
 class ScLookupCache;
 struct ScLookupCacheMapImpl;
+//class ScVbaEventsHelper;
 
 namespace com { namespace sun { namespace star {
     namespace lang {
@@ -149,6 +151,9 @@ namespace com { namespace sun { namespac
     }
 } } }
 
+namespace com { namespace sun { namespace star { namespace document {
+    class XVbaEventsHelper;
+} } } }
 #include <svtools/zforlist.hxx>
 /*
 #ifdef _ZFORLIST_DECLARE_TABLE
@@ -307,6 +312,9 @@ private:
 
 	Timer				aTrackTimer;
 
+	//ScVbaEventsHelper*	pVbaEventsHelper;
+    com::sun::star::uno::Reference< com::sun::star::document::XVbaEventsHelper > rVbaEventsHelper;
+
 public:
     ScTabOpList         aTableOpList;		            // list of ScInterpreterTableOpParams currently in use
     ScInterpreterTableOpParams  aLastTableOpParams;     // remember last params
@@ -1717,6 +1725,8 @@ public:
 	void GetSortParam( ScSortParam& rParam, SCTAB nTab );
 	void SetSortParam( ScSortParam& rParam, SCTAB nTab );
 
+    com::sun::star::uno::Reference< com::sun::star::document::XVbaEventsHelper > GetVbaEventsHelper();
+
     /** Should only be GRAM_PODF or GRAM_ODFF. */
     void                SetStorageGrammar( ScGrammar::Grammar eGrammar );
     ScGrammar::Grammar  GetStorageGrammar() const
--- sc/source/core/data/documen2.cxx.orig	2008-05-07 12:09:09.000000000 +0800
+++ sc/source/core/data/documen2.cxx	2008-05-27 12:40:39.000000000 +0800
@@ -93,6 +93,8 @@
 #include "listenercalls.hxx"
 #include "recursionhelper.hxx"
 #include "lookupcache.hxx"
+//#include "vbaeventshelper.hxx"
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
 
 // pImpl because including lookupcache.hxx in document.hxx isn't wanted, and
 // dtor is convenient.
@@ -146,6 +148,7 @@ ScDocument::ScDocument( ScDocumentMode	e
         pRecursionHelper( NULL ),
         pAutoNameCache( NULL ),
         pLookupCacheMapImpl( NULL ),
+		//rVbaEventsHelper( NULL ),
         nUnoObjectId( 0 ),
         nRangeOverflowType( 0 ),
 		aCurTextWidthCalcPos(MAXCOL,0,0),
@@ -434,6 +437,12 @@ ScDocument::~ScDocument()
 	delete pOtherObjects;
     delete pRecursionHelper;
 
+	/*if( rVbaEventsHelper )
+	{
+		delete pVbaEventsHelper;
+		pVbaEventsHelper = NULL;
+	}*/
+
     DBG_ASSERT( !pAutoNameCache, "AutoNameCache still set in dtor" );
 }
 
@@ -1857,3 +1866,26 @@ void ScDocument::RemoveLookupCache( ScLo
         EndListeningArea( pCache->getRange(), &rCache);
     }
 }
+
+using namespace com::sun::star;
+uno::Reference< document::XVbaEventsHelper > 
+ScDocument::GetVbaEventsHelper()
+{
+	if( !rVbaEventsHelper.is() )
+	{
+        try
+        {
+            uno::Reference< lang::XMultiServiceFactory > xSF( comphelper::getProcessServiceFactory(), uno::UNO_QUERY );
+            uno::Reference< frame::XModel > xModel( pShell->GetModel(), uno::UNO_QUERY );
+            uno::Sequence< uno::Any > aArgs(1);
+            aArgs[0] = uno::Any( xModel );
+            uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper( xSF->createInstanceWithArguments( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.document.VbaEventsHelper" ) ), aArgs ), uno::UNO_QUERY );
+            // helper will always be created successfully.
+            rVbaEventsHelper.set( xVbaEventsHelper, uno::UNO_QUERY );
+        }
+        catch( uno::Exception& e )
+        {
+        }
+	}
+	return rVbaEventsHelper;
+}
--- sc/source/core/data/documen7.cxx.orig	2008-05-07 12:09:09.000000000 +0800
+++ sc/source/core/data/documen7.cxx	2008-05-30 12:26:31.000000000 +0800
@@ -59,7 +59,16 @@
 
 
 #include "globstr.hrc"
+//#include "vbaeventshelper.hxx"
+#include <algorithm>
+#include <vector>
 
+
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
+#include <com/sun/star/document/VbaEventId.hpp>
+
+using namespace com::sun::star;
+using namespace com::sun::star::document::VbaEventId;
 extern const ScFormulaCell* pLastFormulaTreeTop;	// cellform.cxx Err527 WorkAround
 
 // STATIC DATA -----------------------------------------------------------
@@ -449,6 +458,7 @@ void ScDocument::TrackFormulas( ULONG nH
 		ScFormulaCell* pTrack;
 		ScFormulaCell* pNext;
 		pTrack = pFormulaTrack;
+		::std::vector<SCTAB> aTabs; 
 		do
 		{
 			ScHint aHint( nHintId, pTrack->aPos, pTrack );
@@ -458,6 +468,12 @@ void ScDocument::TrackFormulas( ULONG nH
 			//	Repaint fuer bedingte Formate mit relativen Referenzen:
 			if ( pCondFormList )
 				pCondFormList->SourceChanged( pTrack->aPos );
+			::std::vector<SCTAB>::iterator result;
+			result = ::std::find( aTabs.begin(), aTabs.end(), pTrack->aPos.Tab() );
+			if( result == aTabs.end() )
+			{
+				aTabs.push_back( pTrack->aPos.Tab() );
+			}
 			pTrack = pTrack->GetNextTrack();
 		} while ( pTrack );
 		pTrack = pFormulaTrack;
@@ -480,6 +496,18 @@ void ScDocument::TrackFormulas( ULONG nH
 			else
 				SetForcedFormulaPending( TRUE );
 		}
+
+		::std::vector<SCTAB>::iterator iter;
+		for( iter = aTabs.begin(); iter != aTabs.end(); iter++ )
+		{
+            uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper ( GetVbaEventsHelper(), uno::UNO_QUERY );
+            if( xVbaEventsHelper.is() )
+            {
+			    uno::Sequence< uno::Any > aArgs(1);
+                aArgs[0] <<= *iter;
+			    xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKSHEET_CALCULATE, aArgs );
+            }
+		}
 	}
 	DBG_ASSERT( nFormulaTrackCount==0, "TrackFormulas: nFormulaTrackCount!=0" );
 }
--- sc/source/core/tool/makefile.mk.orig	2008-05-07 12:09:09.000000000 +0800
+++ sc/source/core/tool/makefile.mk	2008-05-13 13:47:37.000000000 +0800
@@ -158,3 +158,11 @@ $(INCCOM)$/osversiondef.hxx :
 
 $(SLO)$/interpr5.obj : $(INCCOM)$/osversiondef.hxx
 
+ALLTAR : \
+        $(MISC)$/$(TARGET).don \
+
+$(SLOFILES) : $(MISC)$/$(TARGET).don
+
+$(MISC)$/$(TARGET).don : $(SOLARBINDIR)$/oovbaapi.rdb
+        +$(CPPUMAKER) -O$(INCCOM)$/$(TARGET) -BUCR $(SOLARBINDIR)$/oovbaapi.rdb -X$(SOLARBINDIR)$/types.rdb && echo > $@
+        echo $@
--- sc/source/ui/docshell/docsh.cxx.orig	2008-05-07 12:09:09.000000000 +0800
+++ sc/source/ui/docshell/docsh.cxx	2008-05-30 15:56:49.000000000 +0800
@@ -131,6 +131,14 @@
 #include <rtl/logfile.hxx>
 
 #include <comphelper/processfactory.hxx>
+#include "uiitems.hxx"
+//#include "vbaeventshelper.hxx"
+#include "cellsuno.hxx"
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
+#include <com/sun/star/document/VbaEventId.hpp>
+
+using namespace com::sun::star;
+using namespace com::sun::star::document::VbaEventId;
 
 using namespace com::sun::star;
 
@@ -719,9 +727,70 @@ BOOL __EXPORT ScDocShell::Load( SfxMediu
 	return bRet;
 }
 
+void lcl_processCompatibleSfxHint( uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper, const SfxHint& rHint )
+{
+    if (rHint.ISA(ScTablesHint) )
+    {
+		USHORT nId = ((ScTablesHint&)rHint).GetId();	
+		SCTAB nTab = ((ScTablesHint&)rHint).GetTab1();	
+        if( nId == SC_TAB_INSERTED )
+        {
+            uno::Sequence< uno::Any > aArgs(1);
+            aArgs[0] <<= nTab;
+            xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_NEWSHEET, aArgs );
+        }
+    }
+    else if ( rHint.ISA( SfxEventHint ) )
+    {
+        ULONG nEventId = ((SfxEventHint&)rHint).GetEventId();
+        switch ( nEventId )
+        {
+            case SFX_EVENT_ACTIVATEDOC:
+            {
+                uno::Sequence< uno::Any > aArgs;
+                xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_ACTIVATE, aArgs );
+            }
+                break;
+            case SFX_EVENT_DEACTIVATEDOC:
+            {
+                uno::Sequence< uno::Any > aArgs;
+                xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_DEACTIVATE, aArgs );
+            }
+                break;
+            case SFX_EVENT_CLOSEDOC :
+            {
+                uno::Sequence< uno::Any > aArgs;
+                xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_CLOSE, aArgs );
+            }
+                break;
+            case SFX_EVENT_CLOSEVIEW :
+            {
+                uno::Sequence< uno::Any > aArgs;
+                xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_WINDOWCOLSE, aArgs );
+            }
+                break;
+            case SFX_EVENT_OPENDOC:
+            {
+                // some later than workbook activate.
+                uno::Sequence< uno::Any > aArgs;
+                xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_OPEN, aArgs );
+            }
+                break;
+            default:
+                {
+                }
+                break;
+        }
+    }
+}
 
 void __EXPORT ScDocShell::Notify( SfxBroadcaster&, const SfxHint& rHint )
 {
+    uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper ( aDocument.GetVbaEventsHelper(), uno::UNO_QUERY );
+    if ( xVbaEventsHelper.is() )
+    {
+        lcl_processCompatibleSfxHint( xVbaEventsHelper, rHint );
+    }
 	if (rHint.ISA(SfxSimpleHint))								// ohne Parameter
 	{
 		ULONG nSlot = ((const SfxSimpleHint&)rHint).GetId();
@@ -2246,6 +2315,16 @@ USHORT __EXPORT ScDocShell::PrepareClose
 
 	DoEnterHandler();
 
+	// start handler for possible veto from DocBefore_Close
+    uno::Sequence< uno::Any > aArgs;
+    uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper ( aDocument.GetVbaEventsHelper(), uno::UNO_QUERY );
+    if ( xVbaEventsHelper.is() )
+    {
+	    if ( !IsInPrepareClose() && xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_BEFORECLOSE, aArgs ) )
+		    return sal_False;
+    }
+	// end handler code
+
 	USHORT nRet = SfxObjectShell::PrepareClose( bUI, bForBrowsing );
 	if (nRet == TRUE)						// TRUE = schliessen
 		aDocument.DisableIdle(TRUE);		// nicht mehr drin rumpfuschen !!!
@@ -2455,6 +2534,43 @@ void ScDocShell::SetModified( BOOL bModi
 	}
 }
 
+void ScDocShell::PostContentChanged( const ScRange& rRange )
+{
+//  OSL_TRACE("ScDocShell::PostContentChanged. Changed Range Address: nTab1 = %d, nCol1 = %d, nRow1 = %d; nTab2 = %d, nCol2 = %d, nRow2 = %d;", rRange.aStart.Tab(), rRange.aStart.Col(), rRange.aStart.Row(), rRange.aEnd.Tab(), rRange.aEnd.Col(), rRange.aEnd.Row() );
+
+    ScRangeList aList;
+    aList.Append(rRange);
+    PostContentChanged(aList);
+}
+
+void ScDocShell::PostContentChanged( const ScRangeList& rList )
+{
+#if 0		
+    String aStr;
+    rList.Format(aStr, SCR_ABS, &aDocument, ScAddress::CONV_XL_A1);
+    fprintf(stdout, "ScDocShell::PostContentChanged:   range = '%s'\n",
+            rtl::OUStringToOString(aStr, RTL_TEXTENCODING_UTF8).getStr());
+#endif
+
+    ScCellRangesBase* pObj = NULL;
+	const ScRange& rRange = *(rList.GetObject(0));	
+	if( rList.Count() == 1 )
+	{
+    	if (rRange.aStart == rRange.aEnd)
+    	    pObj = new ScCellObj( this, rRange.aStart );
+	   	else
+	       	pObj = new ScCellRangeObj( this, rRange );
+	}
+	else
+		pObj = new ScCellRangesObj( this, rList );	
+
+    uno::Sequence< uno::Any > aArgs(1);
+    aArgs[0] = uno::makeAny(uno::Reference<uno::XInterface>(static_cast<cppu::OWeakObject*>(pObj)));
+
+    uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper( aDocument.GetVbaEventsHelper(), uno::UNO_QUERY );
+    if ( xVbaEventsHelper.is() )
+        xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKSHEET_CHANGE, aArgs );
+}
 
 void ScDocShell::SetDocumentModified( BOOL bIsModified /* = TRUE */ )
 {
--- sc/source/ui/inc/docsh.hxx.orig	2008-05-07 12:09:09.000000000 +0800
+++ sc/source/ui/inc/docsh.hxx	2008-05-19 15:39:24.000000000 +0800
@@ -47,6 +47,7 @@
 #include "refreshtimer.hxx"
 
 #include <hash_map>
+#include <cppuhelper/implbase1.hxx>
 
 class ScEditEngineDefaulter;
 class FontList;
@@ -326,6 +327,8 @@ public:
 	void            PostPaintExtras();
 
 	void            PostDataChanged();
+	void			PostContentChanged( const ScRange& rRange ); // for worsheet/workbook changed event
+    void            PostContentChanged( const ScRangeList& rList );
 
 	void			UpdatePaintExt( USHORT& rExtFlags, SCCOL nStartCol, SCROW nStartRow, SCTAB nStartTab,
 													   SCCOL nEndCol, SCROW nEndRow, SCTAB nEndTab );
--- sc/source/ui/undo/undoblk3.cxx.orig	2008-05-30 17:56:31.000000000 +0800
+++ sc/source/ui/undo/undoblk3.cxx	2008-05-30 17:57:03.000000000 +0800
@@ -79,7 +79,17 @@ TYPEINIT1(ScUndoInsertAreaLink,		SfxUndo
 TYPEINIT1(ScUndoRemoveAreaLink,		SfxUndoAction);
 TYPEINIT1(ScUndoUpdateAreaLink,		SfxUndoAction);
 
-
+void lcl_PostContentChanged( ScDocShell* pDocShell, const ScMarkData& rMark, const ScRange& rRange )
+{
+    if (rMark.IsMarked() || rMark.IsMultiMarked())
+    {
+        ScRangeList aList;
+        rMark.FillRangeListWithMarks(&aList, false);
+        pDocShell->PostContentChanged(aList);
+    }
+    else
+        pDocShell->PostContentChanged( rRange );
+}
 // To Do:
 /*A*/	// SetOptimalHeight auf Dokument, wenn keine View
 
@@ -113,6 +123,8 @@ ScUndoDeleteContents::ScUndoDeleteConten
 		aMarkData.SetMarkArea( aRange );							// Zelle unter Cursor markieren
 
 	SetChangeTrack();
+
+	lcl_PostContentChanged( pDocShell, aMarkData, aRange );
 }
 
 
@@ -213,6 +225,7 @@ void __EXPORT ScUndoDeleteContents::Undo
 	BeginUndo();
 	DoChange( TRUE );
 	EndUndo();
+	lcl_PostContentChanged( pDocShell, aMarkData, aRange );
 }
 
 
@@ -223,6 +236,7 @@ void __EXPORT ScUndoDeleteContents::Redo
 	BeginRedo();
 	DoChange( FALSE );
 	EndRedo();
+	lcl_PostContentChanged( pDocShell, aMarkData, aRange );
 }
 
 
--- sc/source/ui/undo/undoblk.cxx.orig	2008-05-30 17:56:23.000000000 +0800
+++ sc/source/ui/undo/undoblk.cxx	2008-05-30 17:57:03.000000000 +0800
@@ -125,6 +125,7 @@ ScUndoInsertCells::ScUndoInsertCells( Sc
 	}
 
 	SetChangeTrack();
+	pDocShell->PostContentChanged( aEffRange );
 }
 
 __EXPORT ScUndoInsertCells::~ScUndoInsertCells()
@@ -271,6 +272,7 @@ void __EXPORT ScUndoInsertCells::Undo()
 	BeginUndo();
 	DoChange( TRUE );
 	EndUndo();
+	pDocShell->PostContentChanged( aEffRange );
 }
 
 void __EXPORT ScUndoInsertCells::Redo()
@@ -279,6 +281,7 @@ void __EXPORT ScUndoInsertCells::Redo()
 	BeginRedo();
 	DoChange( FALSE );
 	EndRedo();
+	pDocShell->PostContentChanged( aEffRange );
 
 	if ( pPasteUndo )
 		pPasteUndo->Redo();		// redo paste last
@@ -333,6 +336,7 @@ ScUndoDeleteCells::ScUndoDeleteCells( Sc
 	}
 
 	SetChangeTrack();
+	pDocShell->PostContentChanged( aEffRange );
 }
 
 __EXPORT ScUndoDeleteCells::~ScUndoDeleteCells()
@@ -474,6 +478,7 @@ void __EXPORT ScUndoDeleteCells::Undo()
 	BeginUndo();
 	DoChange( TRUE );
 	EndUndo();
+	pDocShell->PostContentChanged( aEffRange );
     SFX_APP()->Broadcast( SfxSimpleHint( SC_HINT_AREALINKS_CHANGED ) );
 
 	// Markierung erst nach EndUndo
@@ -488,6 +493,7 @@ void __EXPORT ScUndoDeleteCells::Redo()
 	BeginRedo();
 	DoChange( FALSE);
 	EndRedo();
+	pDocShell->PostContentChanged( aEffRange );
     SFX_APP()->Broadcast( SfxSimpleHint( SC_HINT_AREALINKS_CHANGED ) );
 
 	ScTabViewShell* pViewShell = ScTabViewShell::GetActiveViewShell();
@@ -714,6 +720,7 @@ ScUndoCut::ScUndoCut( ScDocShell* pNewDo
 	aExtendedRange( aRange )
 {
 	SetChangeTrack();
+	pDocShell->PostContentChanged( aExtendedRange );
 }
 
 __EXPORT ScUndoCut::~ScUndoCut()
@@ -778,6 +785,7 @@ void __EXPORT ScUndoCut::Undo()
 	BeginUndo();
 	DoChange( TRUE );
 	EndUndo();
+	pDocShell->PostContentChanged( aExtendedRange );
 }
 
 void __EXPORT ScUndoCut::Redo()
@@ -788,6 +796,7 @@ void __EXPORT ScUndoCut::Redo()
 	DoChange( FALSE );
 	EnableDrawAdjust( pDoc, TRUE );					//! include in ScBlockUndo?
 	EndRedo();
+	pDocShell->PostContentChanged( aExtendedRange );
 }
 
 void __EXPORT ScUndoCut::Repeat(SfxRepeatTarget& rTarget)
@@ -839,6 +848,7 @@ ScUndoPaste::ScUndoPaste( ScDocShell* pN
 		aPasteOptions = *pOptions;		// used only for Repeat
 
 	SetChangeTrack();
+	pDocShell->PostContentChanged( aBlockRange );
 }
 
 __EXPORT ScUndoPaste::~ScUndoPaste()
@@ -1020,6 +1030,7 @@ void __EXPORT ScUndoPaste::Undo()
 	DoChange( TRUE );
 	ShowTable( aBlockRange );
 	EndUndo();
+	pDocShell->PostContentChanged( aBlockRange );
     SFX_APP()->Broadcast( SfxSimpleHint( SC_HINT_AREALINKS_CHANGED ) );
 }
 
@@ -1031,6 +1042,7 @@ void __EXPORT ScUndoPaste::Redo()
 	DoChange( FALSE );
 	EnableDrawAdjust( pDoc, TRUE );					//! include in ScBlockUndo?
 	EndRedo();
+	pDocShell->PostContentChanged( aBlockRange );
     SFX_APP()->Broadcast( SfxSimpleHint( SC_HINT_AREALINKS_CHANGED ) );
 }
 
--- sc/source/ui/undo/undocell.cxx.orig	2008-05-30 17:56:08.000000000 +0800
+++ sc/source/ui/undo/undocell.cxx	2008-05-30 17:57:03.000000000 +0800
@@ -214,6 +214,7 @@ ScUndoEnterData::ScUndoEnterData( ScDocS
 	nCount( nNewCount )
 {
 	SetChangeTrack();
+	pDocShell->PostContentChanged( ScRange( ScAddress( nCol, nRow, nTab ) ) );
 }
 
 __EXPORT ScUndoEnterData::~ScUndoEnterData()
@@ -319,6 +320,7 @@ void __EXPORT ScUndoEnterData::Undo()
 
 	DoChange();
 	EndUndo();
+	pDocShell->PostContentChanged( ScRange( ScAddress( nCol, nRow, nTab ) ) );
 }
 
 void __EXPORT ScUndoEnterData::Redo()
@@ -340,6 +342,7 @@ void __EXPORT ScUndoEnterData::Redo()
 
 	DoChange();
 	EndRedo();
+	pDocShell->PostContentChanged( ScRange( ScAddress( nCol, nRow, nTab ) ) );
 }
 
 void __EXPORT ScUndoEnterData::Repeat(SfxRepeatTarget& rTarget)
@@ -371,6 +374,7 @@ ScUndoEnterValue::ScUndoEnterValue( ScDo
 	bNeedHeight	( bHeight )
 {
 	SetChangeTrack();
+	pDocShell->PostContentChanged( ScRange( aPos ) );
 }
 
 __EXPORT ScUndoEnterValue::~ScUndoEnterValue()
@@ -425,6 +429,7 @@ void __EXPORT ScUndoEnterValue::Undo()
 		pChangeTrack->Undo( nEndChangeAction, nEndChangeAction );
 
 	EndUndo();
+	pDocShell->PostContentChanged( ScRange( aPos ) );
 }
 
 void __EXPORT ScUndoEnterValue::Redo()
@@ -438,6 +443,7 @@ void __EXPORT ScUndoEnterValue::Redo()
 	SetChangeTrack();
 
 	EndRedo();
+	pDocShell->PostContentChanged( ScRange( aPos ) );
 }
 
 void __EXPORT ScUndoEnterValue::Repeat(SfxRepeatTarget& /* rTarget */)
@@ -465,6 +471,7 @@ ScUndoPutCell::ScUndoPutCell( ScDocShell
 	bNeedHeight	( bHeight )
 {
 	SetChangeTrack();
+	pDocShell->PostContentChanged( ScRange( aPos ) );
 }
 
 __EXPORT ScUndoPutCell::~ScUndoPutCell()
@@ -521,6 +528,7 @@ void __EXPORT ScUndoPutCell::Undo()
 		pChangeTrack->Undo( nEndChangeAction, nEndChangeAction );
 
 	EndUndo();
+	pDocShell->PostContentChanged( ScRange( aPos ) );
 }
 
 void __EXPORT ScUndoPutCell::Redo()
@@ -549,6 +557,7 @@ void __EXPORT ScUndoPutCell::Redo()
 	SetChangeTrack();
 
 	EndRedo();
+	pDocShell->PostContentChanged( ScRange( aPos ) );
 }
 
 void __EXPORT ScUndoPutCell::Repeat(SfxRepeatTarget& /* rTarget */)
--- sc/source/ui/unoobj/viewuno.cxx.orig	2008-05-07 12:09:09.000000000 +0800
+++ sc/source/ui/unoobj/viewuno.cxx	2008-05-30 16:07:06.000000000 +0800
@@ -71,8 +71,12 @@
 #include "gridwin.hxx"
 #include <com/sun/star/view/DocumentZoomType.hpp>
 #include "AccessibilityHints.hxx"
+#include <com/sun/star/awt/MouseButton.hpp>
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
+#include <com/sun/star/document/VbaEventId.hpp>
 
 using namespace com::sun::star;
+using namespace com::sun::star::document::VbaEventId;
 
 //------------------------------------------------------------------------
 
@@ -480,7 +484,6 @@ ScTabViewObj::ScTabViewObj( ScTabViewShe
 	aActivationListeners( 0 ),
 	bDrawSelModeSet(sal_False)
 {
-	//!	Listening oder so
 }
 
 ScTabViewObj::~ScTabViewObj()
@@ -1206,36 +1209,67 @@ sal_Bool ScTabViewObj::MousePressed( con
 {
     sal_Bool bReturn(sal_False);
 
-    if (aMouseClickHandlers.Count())
-    {
-        uno::Reference< uno::XInterface > xTarget = GetClickedObject(Point(e.X, e.Y));
+    uno::Reference< uno::XInterface > xTarget = GetClickedObject(Point(e.X, e.Y));
 
-        if (xTarget.is())
-        {
-            awt::EnhancedMouseEvent aMouseEvent;
+    if (xTarget.is())
+    {
+		// Handle BeforeDoubleClick and BeforeRightClick events
+		uno::Reference<table::XCell> xCell( xTarget, uno::UNO_QUERY );
+		if( xCell.is() )
+		{
+			ScTabViewShell* pViewSh = GetViewShell();
+			if ( pViewSh )
+			{
+				ScViewData* pViewData = pViewSh->GetViewData();
+				if ( pViewData )
+				{
+					if( e.ClickCount == 2 || e.Buttons == ::com::sun::star::awt::MouseButton::RIGHT )
+					{
+                        uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper( pViewData->GetDocument()->GetVbaEventsHelper(), uno::UNO_QUERY );
+                        if( xVbaEventsHelper.is() )
+                        {
+						    uno::Sequence< uno::Any > aArgs(2);
+						    sal_Bool bCancel = sal_False;
+						    aArgs[0] = getSelection();
+						    aArgs[1] <<= bCancel;
+
+						    USHORT nEvent = VBAEVENT_WORKSHEET_BEFORERIGHTCLICK;
+						    if( e.ClickCount == 2 )
+							    nEvent = VBAEVENT_WORKSHEET_BEFOREDOUBLECLICK;
+						    xVbaEventsHelper->ProcessCompatibleVbaEvent( nEvent, aArgs );
+
+						    // TODO... handle the cancel argument
+						    aArgs[1] >>= bCancel;
+                        }
+					}
+				}
+			}
+		}
+		
+        awt::EnhancedMouseEvent aMouseEvent;
 
-            aMouseEvent.Buttons = e.Buttons;
-            aMouseEvent.X = e.X;
-            aMouseEvent.Y = e.Y;
-            aMouseEvent.ClickCount = e.ClickCount;
-            aMouseEvent.PopupTrigger = e.PopupTrigger;
-            aMouseEvent.Target = xTarget;
+        aMouseEvent.Buttons = e.Buttons;
+        aMouseEvent.X = e.X;
+        aMouseEvent.Y = e.Y;
+        aMouseEvent.ClickCount = e.ClickCount;
+        aMouseEvent.PopupTrigger = e.PopupTrigger;
+        aMouseEvent.Target = xTarget;
 
-	        for ( USHORT n=0; n<aMouseClickHandlers.Count(); n++ )
+	    for ( USHORT n=0; n<aMouseClickHandlers.Count(); n++ )
+        {
+            try
             {
-                try
-                {
-                    if (!(*aMouseClickHandlers[n])->mousePressed( aMouseEvent ))
-                        bReturn = sal_True;
-                }
-                catch ( uno::Exception& )
-                {
-                    aMouseClickHandlers.DeleteAndDestroy(n);
-                    --n; // because it will be increased again in the loop
-                }
+                if (!(*aMouseClickHandlers[n])->mousePressed( aMouseEvent ))
+                    bReturn = sal_True;
+            }
+            catch ( uno::Exception& )
+            {
+                aMouseClickHandlers.DeleteAndDestroy(n);
+                --n; // because it will be increased again in the loop
             }
         }
     }
+
     return bReturn;
 }
 
@@ -1709,6 +1743,22 @@ void SAL_CALL ScTabViewObj::removeSelect
 
 void ScTabViewObj::SelectionChanged()
 {
+	ScTabViewShell* pViewSh = GetViewShell();
+	if ( pViewSh )
+	{
+		ScViewData* pViewData = pViewSh->GetViewData();
+		if ( pViewData )
+		{
+            uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper( pViewData->GetDocument()->GetVbaEventsHelper(), uno::UNO_QUERY );
+            if( xVbaEventsHelper.is() )
+            { 
+			    uno::Sequence< uno::Any > aArgs(1);
+			    aArgs[0] = getSelection();
+			    xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKSHEET_SELECTIONCHANGE, aArgs );
+            }
+		}
+	}
+
 	lang::EventObject aEvent;
 	aEvent.Source.set(static_cast<cppu::OWeakObject*>(this));
 	for ( USHORT n=0; n<aSelectionListeners.Count(); n++ )
--- sc/source/ui/unoobj/docuno.cxx.orig	2008-05-19 10:34:38.000000000 +0800
+++ sc/source/ui/unoobj/docuno.cxx	2008-05-27 21:57:27.000000000 +0800
@@ -92,7 +92,12 @@
 #include "rangeutl.hxx"
 #include "ViewSettingsSequenceDefines.hxx"
 
+#define BEFORE 0
+#define AFTER 1
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
+#include <com/sun/star/document/VbaEventId.hpp>
 using namespace com::sun::star;
+using namespace com::sun::star::document::VbaEventId;
 
 //------------------------------------------------------------------------
 
@@ -329,6 +334,7 @@ uno::Any SAL_CALL ScModelObj::queryInter
 	SC_QUERYINTERFACE( document::XLinkTargetSupplier )
 	SC_QUERYINTERFACE( beans::XPropertySet )
 	SC_QUERYINTERFACE( document::XCodeNameQuery )
+	SC_QUERYINTERFACE( document::XDocumentEventCompatibleHelper)
 	SC_QUERYINTERFACE( lang::XMultiServiceFactory )
 	SC_QUERYINTERFACE( lang::XServiceInfo )
 
@@ -1730,6 +1736,52 @@ ScModelObj::getCodeNameForObject( const 
     // Probably should throw here ( if !bMatched )
      return sCodeName;
 }
+// XVbaEventHelper
+// For Vba Event
+// status, 0 before, 1 done...
+sal_Bool SAL_CALL
+ScModelObj::processCompatibleEvent( sal_Int16 nStatus, sal_Int16 nSlotId ) throw( ::com::sun::star::uno::RuntimeException )
+{
+    USHORT nId = nSlotId;
+    uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper( GetDocument()->GetVbaEventsHelper(), uno::UNO_QUERY );
+    if( xVbaEventsHelper.is() )
+    {
+        switch( nId )
+        {
+            case SID_SAVEDOC:
+            {
+                if( nStatus == BEFORE )
+                {
+                    uno::Sequence< uno::Any > aArgs(1);
+                    aArgs[0] <<= sal_False;
+                    return xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_BEFORESAVE, aArgs );
+                }
+                break;
+            }
+            case SID_SAVEASDOC:
+            {
+                if( nStatus == BEFORE )
+                {
+                    uno::Sequence< uno::Any > aArgs(1);
+                    aArgs[0] <<= sal_True;
+                    return xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_BEFORESAVE, aArgs );
+                }
+                break;
+            }
+            case SID_PRINTDOC:
+            case SID_PRINTDOCDIRECT:
+            {
+                if( nStatus == BEFORE )
+                {
+                    uno::Sequence< uno::Any > aArgs;
+                    return xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_BEFOREPRINT, aArgs );
+                }
+                break;
+            }
+        }
+        return sal_False;
+    }
+}
 // XServiceInfo
 
 rtl::OUString SAL_CALL ScModelObj::getImplementationName() throw(uno::RuntimeException)
--- sc/inc/docuno.hxx.orig	2008-05-19 15:34:55.000000000 +0800
+++ sc/inc/docuno.hxx	2008-05-27 15:29:50.000000000 +0800
@@ -55,6 +55,7 @@
 #include <com/sun/star/sheet/XSheetAnnotations.hpp>
 #include <com/sun/star/beans/XPropertySet.hpp>
 #include <com/sun/star/sheet/XCellRangesAccess.hpp>
+#include <com/sun/star/document/XDocumentEventCompatibleHelper.hpp>
 #include <cppuhelper/implbase2.hxx>
 #include <cppuhelper/implbase3.hxx>
 #include <cppuhelper/implbase4.hxx>
@@ -89,6 +90,7 @@ class SC_DLLPUBLIC ScModelObj : public S
 					public com::sun::star::document::XLinkTargetSupplier,
 					public com::sun::star::beans::XPropertySet,
 					public com::sun::star::document::XCodeNameQuery,
+                    public com::sun::star::document::XDocumentEventCompatibleHelper,
 					public SvxFmMSFactory,	// derived from XMultiServiceFactory
                     public com::sun::star::lang::XServiceInfo
 {
@@ -303,6 +305,8 @@ public:
 								throw(::com::sun::star::uno::RuntimeException);
  	virtual rtl::OUString SAL_CALL getCodeNameForObject( const ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface >& aObj )
 								throw(::com::sun::star::uno::RuntimeException);
+                            // XVbaEventHelper
+    virtual sal_Bool SAL_CALL processCompatibleEvent( sal_Int16 nStatus, sal_Int16 nEventId ) throw (::com::sun::star::uno::RuntimeException);
 };
 
 
--- sc/source/ui/view/gridwin.cxx.orig	2008-05-07 12:06:10.000000000 +0800
+++ sc/source/ui/view/gridwin.cxx	2008-05-30 16:11:00.000000000 +0800
@@ -149,7 +149,14 @@
 #include <svx/sdr/overlay/overlaymanager.hxx>
 #include <vcl/svapp.hxx>
 
+//#include "vbaeventshelper.hxx"
+#include "cellsuno.hxx"
+
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
+#include <com/sun/star/document/VbaEventId.hpp>
+
 using namespace com::sun::star;
+using namespace com::sun::star::document::VbaEventId;
 using ::com::sun::star::uno::Sequence;
 using ::com::sun::star::uno::Any;
 
@@ -398,6 +405,32 @@ void lcl_UnLockComment( SdrView* pView, 
 
 }
 
+sal_Bool lcl_GetHyperlinkCell(ScDocument* pDoc, SCCOL& rPosX, SCROW& rPosY, SCTAB nTab, ScBaseCell*& rpCell )
+{
+	BOOL bFound = FALSE;
+	do
+	{
+		pDoc->GetCell( rPosX, rPosY, nTab, rpCell );
+		if ( !rpCell || rpCell->GetCellType() == CELLTYPE_NOTE )
+		{
+			if ( rPosX <= 0 )
+				return FALSE;							// alles leer bis links
+			else
+				--rPosX;								// weitersuchen
+		}
+                else if ( rpCell->GetCellType() == CELLTYPE_EDIT)
+                    bFound = TRUE;
+                else if (rpCell->GetCellType() == CELLTYPE_FORMULA &&
+                  static_cast<ScFormulaCell*>(rpCell)->IsHyperLinkCell())
+                    bFound = TRUE;
+	    else
+			return FALSE;								// andere Zelle
+	}
+	while ( !bFound );
+
+	return bFound;
+}
+
 //==================================================================
 
 //	WB_DIALOGCONTROL noetig fuer UNO-Controls
@@ -1442,6 +1475,7 @@ void ScGridWindow::HandleMouseButtonDown
 	SCCOL	nOldColFBox	  = bWasFilterBox ? pFilterBox->GetCol() : 0;
 	SCROW  nOldRowFBox	  = bWasFilterBox ? pFilterBox->GetRow() : 0;
 #endif
+#include "cellsuno.hxx" 
 
 	ClickExtern();	// loescht FilterBox, wenn vorhanden
 
@@ -2122,6 +2156,26 @@ void __EXPORT ScGridWindow::MouseButtonU
 		{
 			nMouseStatus = SC_GM_NONE;				// keinen Doppelklick anfangen
 			ScGlobal::OpenURL( aUrl, aTarget );
+			
+			// fire worksheet_followhyperlink event
+			Point aPos = rMEvt.GetPosPixel();
+	        SCsCOL nPosX;
+    	    SCsROW nPosY;
+        	SCTAB nTab = pViewData->GetTabNo();
+        	pViewData->GetPosFromPixel( aPos.X(), aPos.Y(), eWhich, nPosX, nPosY );
+			ScBaseCell* pCell = NULL;
+
+			BOOL bFound = lcl_GetHyperlinkCell( pDoc, nPosX, nPosY, nTab, pCell );
+			if( bFound )
+			{
+				ScAddress aCellPos( nPosX, nPosY, nTab );
+				ScCellObj* pObj = new ScCellObj( pViewData->GetDocShell(), aCellPos );
+				uno::Sequence< uno::Any > aArgs(1);
+				aArgs[0] = uno::makeAny(uno::Reference<uno::XInterface>(static_cast<cppu::OWeakObject*>(pObj)));
+                uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper ( pViewData->GetDocument()->GetVbaEventsHelper(), uno::UNO_QUERY );
+                if( xVbaEventsHelper.is() )
+			        xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKSHEET_FOLLOWHYPERLINK, aArgs );
+			}
 			return;
 		}
 	}
@@ -2441,13 +2495,13 @@ long ScGridWindow::PreNotify( NotifyEven
 			        if (xController.is())
 			        {
 				        ScTabViewObj* pImp = ScTabViewObj::getImplementation( xController );
-				        if (pImp && pImp->IsMouseListening())
+				        if (pImp)
                         {
 			                ::com::sun::star::awt::MouseEvent aEvent;
 			                lcl_InitMouseEvent( aEvent, *rNEvt.GetMouseEvent() );
 	                        if ( rNEvt.GetWindow() )
 		                        aEvent.Source = rNEvt.GetWindow()->GetComponentInterface();
-                            if ( nType == EVENT_MOUSEBUTTONDOWN)
+                            if ( nType == EVENT_MOUSEBUTTONDOWN )
 					            pImp->MousePressed( aEvent );
                             else
                                 pImp->MouseReleased( aEvent );
@@ -4857,26 +4911,9 @@ BOOL ScGridWindow::GetEditUrlOrError( BO
 	ScDocument* pDoc = pDocSh->GetDocument();
 	ScBaseCell* pCell = NULL;
 
-	BOOL bFound = FALSE;
-	do
-	{
-		pDoc->GetCell( nPosX, nPosY, nTab, pCell );
-		if ( !pCell || pCell->GetCellType() == CELLTYPE_NOTE )
-		{
-			if ( nPosX <= 0 )
-				return FALSE;							// alles leer bis links
-			else
-				--nPosX;								// weitersuchen
-		}
-                else if ( pCell->GetCellType() == CELLTYPE_EDIT)
-                    bFound = TRUE;
-                else if (pCell->GetCellType() == CELLTYPE_FORMULA &&
-                  static_cast<ScFormulaCell*>(pCell)->IsHyperLinkCell())
-                    bFound = TRUE;
-	    else
-			return FALSE;								// andere Zelle
-	}
-	while ( !bFound );
+	BOOL bFound = lcl_GetHyperlinkCell( pDoc, nPosX, nPosY, nTab, pCell );
+	if( !bFound )
+		return FALSE;
 
 	ScHideTextCursor aHideCursor( pViewData, eWhich );	// before GetEditArea (MapMode is changed)
 
--- sc/source/ui/view/tabview3.cxx.orig	2008-05-07 12:09:09.000000000 +0800
+++ sc/source/ui/view/tabview3.cxx	2008-05-28 16:32:00.000000000 +0800
@@ -80,8 +80,13 @@
 #include "rangeutl.hxx"
 #include "client.hxx"
 #include "tabprotection.hxx"
+//#include "vbaeventshelper.hxx"
 
 #include <com/sun/star/chart2/data/HighlightedRange.hpp>
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
+#include <com/sun/star/document/VbaEventId.hpp>
+
+using namespace com::sun::star::document::VbaEventId;
 
 namespace
 {
@@ -1684,6 +1689,17 @@ void ScTabView::SetTabNo( SCTAB nTab, BO
 										//	nicht InputEnterHandler wegen Referenzeingabe !
 
 		ScDocument* pDoc = aViewData.GetDocument();
+		if( !bNew )
+		{
+            uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper ( pDoc->GetVbaEventsHelper(), uno::UNO_QUERY );
+            if( xVbaEventsHelper.is() )
+            {
+                uno::Sequence< uno::Any > aArgs(1);
+                aArgs[0] <<= aViewData.GetTabNo();
+			    xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKSHEET_DEACTIVATE, aArgs );
+            }
+		}
+			
 		pDoc->MakeTable( nTab );
 
 		SCTAB nTabCount = pDoc->GetTableCount();
@@ -1782,7 +1798,18 @@ void ScTabView::SetTabNo( SCTAB nTab, BO
 					if ( pGridWin[i]->IsVisible() )
 						pGridWin[i]->UpdateEditViewPos();
 		}
-
+		
+		if( !bNew )
+		{
+            uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper ( pDoc->GetVbaEventsHelper(), uno::UNO_QUERY );
+            if( xVbaEventsHelper.is() )
+            {
+                uno::Sequence< uno::Any > aArgs(1);
+                aArgs[0] <<= aViewData.GetTabNo();
+			    xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKSHEET_ACTIVATE,  aArgs );
+            }
+		}
+			
 		TabChanged();										// DrawView
 		aViewData.GetViewShell()->WindowChanged();			// falls das aktive Fenster anders ist
         if ( !bUnoRefDialog )
--- sc/source/ui/vba/makefile.mk.orig	2008-05-12 11:19:10.000000000 +0800
+++ sc/source/ui/vba/makefile.mk	2008-05-12 11:20:08.000000000 +0800
@@ -126,6 +126,7 @@ SLOFILES= \
                 $(SLO)$/vbacommandbar.obj \
                 $(SLO)$/vbacommandbars.obj \
         $(SLO)$/vbahyperlink.obj \
+        $(SLO)$/vbaeventshelper.obj \
 		$(SLO)$/service.obj \
  
 
--- sfx2/inc/sfx2/objsh.hxx.orig	2008-05-07 12:09:29.000000000 +0800
+++ sfx2/inc/sfx2/objsh.hxx	2008-05-16 16:04:06.000000000 +0800
@@ -267,9 +267,6 @@ public:
     sal_Bool                    Stamp_GetPrintCancelState() const;
 
     using SotObject::GetInterface;
-    // status, 0 before, 1 done...
-    virtual sal_Bool            processVbaEvents( USHORT nStatus, USHORT nSlotId )
-                                { (void)nSlotId; (void)nStatus; return sal_False; }
 
     // Document-Shell Iterator
 	static SfxObjectShell*		GetFirst( const TypeId* pType = 0,
@@ -407,7 +404,8 @@ public:
         ::com::sun::star::uno::Any& aRet,
         ::com::sun::star::uno::Sequence< sal_Int16 >& aOutParamIndex,
         ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aOutParam,
-        bool bRaiseError = true
+        bool bRaiseError = true,
+        ::com::sun::star::uno::Any* aCaller = 0
     );
 
     static ErrCode  CallXScript(
@@ -417,7 +415,8 @@ public:
         ::com::sun::star::uno::Any& aRet,
         ::com::sun::star::uno::Sequence< sal_Int16 >& aOutParamIndex,
         ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aOutParam,
-        bool bRaiseError = true
+        bool bRaiseError = true,
+        ::com::sun::star::uno::Any* aCaller = 0
     );
 
     /** adjusts the internal macro mode, according to the current security settings
--- sfx2/source/doc/objmisc.cxx.orig	2008-05-07 12:09:22.000000000 +0800
+++ sfx2/source/doc/objmisc.cxx	2008-05-07 12:09:37.000000000 +0800
@@ -1591,7 +1591,7 @@ namespace
 }
 
 ErrCode SfxObjectShell::CallXScript( const Reference< XInterface >& _rxScriptContext, const ::rtl::OUString& _rScriptURL,
-    const Sequence< Any >& aParams, Any& aRet, Sequence< sal_Int16 >& aOutParamIndex, Sequence< Any >& aOutParam, bool bRaiseError )
+    const Sequence< Any >& aParams, Any& aRet, Sequence< sal_Int16 >& aOutParamIndex, Sequence< Any >& aOutParam, bool bRaiseError, ::com::sun::star::uno::Any* pCaller )
 {
     OSL_TRACE( "in CallXScript" );
 	ErrCode nErr = ERRCODE_NONE;
@@ -1622,7 +1622,16 @@ ErrCode SfxObjectShell::CallXScript( con
 
         // obtain the script, and execute it
         Reference< provider::XScript > xScript( xScriptProvider->getScript( _rScriptURL ), UNO_QUERY_THROW );
-
+        if ( pCaller && pCaller->hasValue() )
+        {
+            Reference< beans::XPropertySet > xProps( xScript, uno::UNO_QUERY ); 
+            if ( xProps.is() )
+            {
+                Sequence< uno::Any > aArgs( 1 );
+                aArgs[ 0 ] = *pCaller;
+                xProps->setPropertyValue( rtl::OUString::createFromAscii("Caller"), uno::makeAny( aArgs ) );
+            }
+        }
         aRet = xScript->invoke( aParams, aOutParamIndex, aOutParam );
     }
     catch ( const uno::Exception& )
@@ -1656,9 +1665,9 @@ ErrCode SfxObjectShell::CallXScript( con
         ::com::sun::star::uno::Any& aRet,
         ::com::sun::star::uno::Sequence< sal_Int16 >& aOutParamIndex,
         ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >&
-            aOutParam, bool bRaiseError )
+            aOutParam, bool bRaiseError, ::com::sun::star::uno::Any* pCaller )
 {
-    return CallXScript( GetModel(), rScriptURL, aParams, aRet, aOutParamIndex, aOutParam, bRaiseError );
+    return CallXScript( GetModel(), rScriptURL, aParams, aRet, aOutParamIndex, aOutParam, bRaiseError, pCaller );
 }
 
 //-------------------------------------------------------------------------
--- sfx2/source/doc/objserv.cxx.orig	2008-05-07 12:06:10.000000000 +0800
+++ sfx2/source/doc/objserv.cxx	2008-05-29 20:02:09.000000000 +0800
@@ -28,6 +28,8 @@
  *
  ************************************************************************/
 
+#define BEFORE 0
+#define AFTER 1
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sfx2.hxx"
 
@@ -108,6 +110,7 @@
 #include <com/sun/star/document/XDocumentInfo.hpp>
 #include <com/sun/star/document/XDocumentInfoSupplier.hpp>
 #include <com/sun/star/document/XDocumentProperties.hpp>
+#include <com/sun/star/document/XDocumentEventCompatibleHelper.hpp>
 
 #ifndef _SFX_HELPID_HRC
 #include "helpid.hrc"
@@ -521,6 +524,18 @@ void SfxObjectShell::ExecFile_Impl(SfxRe
 		case SID_SAVEASDOC:
 		case SID_SAVEDOC:
 		{
+            if( nId == SID_SAVEDOC || nId == SID_SAVEASDOC )
+            {
+                uno::Reference< document::XDocumentEventCompatibleHelper > xVbaEventHelper( GetModel(), uno::UNO_QUERY );
+                if( xVbaEventHelper.is() )
+                {
+                    if( xVbaEventHelper->processCompatibleEvent( BEFORE, nId ) )
+                    {
+                        rReq.SetReturnValue( SfxBoolItem( 0, sal_True ) );
+                        return;
+                    }
+                }
+            }
 			//!! detaillierte Auswertung eines Fehlercodes
 			SfxObjectShellRef xLock( this );
 
--- sfx2/source/view/viewprn.cxx.orig	2008-05-07 12:06:10.000000000 +0800
+++ sfx2/source/view/viewprn.cxx	2008-05-27 15:31:06.000000000 +0800
@@ -28,10 +28,12 @@
  *
  ************************************************************************/
 
+#define BEFORE 0
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sfx2.hxx"
 
 #include <com/sun/star/document/XDocumentProperties.hpp>
+#include <com/sun/star/document/XDocumentEventCompatibleHelper.hpp>
 #include <com/sun/star/view/PrintableState.hpp>
 #include <svtools/itempool.hxx>
 #ifndef _MSGBOX_HXX //autogen
@@ -67,6 +69,8 @@
 #include "view.hrc"
 #include "helpid.hrc"
 
+using namespace com::sun::star;
+
 TYPEINIT1(SfxPrintingHint, SfxHint);
 
 // -----------------------------------------------------------------------
@@ -405,6 +409,22 @@ void SfxViewShell::ExecPrint_Impl( SfxRe
 		case SID_SETUPPRINTER:
 	    case SID_PRINTER_NAME :
 		{
+            if( nId == SID_PRINTDOC )
+            {
+				SfxObjectShell* pDoc = GetObjectShell();
+                if( pDoc )
+                {
+                    uno::Reference< document::XDocumentEventCompatibleHelper > xVbaEventHelper( pDoc->GetModel(), uno::UNO_QUERY );
+                    if( xVbaEventHelper.is() )
+                    {
+                        if( xVbaEventHelper->processCompatibleEvent( BEFORE, nId ) )
+                        {
+                            rReq.SetReturnValue(SfxBoolItem(0,FALSE));
+                            return;
+                        }
+                    }
+                }
+            }
 	        // quiet mode (AppEvent, API call)
 			SFX_REQUEST_ARG(rReq, pSilentItem, SfxBoolItem, SID_SILENT, FALSE);
 			bSilent = pSilentItem && pSilentItem->GetValue();
@@ -714,6 +734,15 @@ void SfxViewShell::ExecPrint_Impl( SfxRe
 	        if ( SID_PRINTDOCDIRECT == nId )
 	        {
 				SfxObjectShell* pDoc = GetObjectShell();
+                uno::Reference< document::XDocumentEventCompatibleHelper > xVbaEventHelper( pDoc->GetModel(), uno::UNO_QUERY );
+                if( xVbaEventHelper.is() )
+                {
+                    if( xVbaEventHelper->processCompatibleEvent( BEFORE, nId ) )
+                    {
+                        rReq.SetReturnValue(SfxBoolItem(0,FALSE));
+                        return;
+                    }
+                }
 				bool bDetectHidden = ( !bSilent && pDoc );
 				if ( bDetectHidden && pDoc->QueryHiddenInformation( WhenPrinting, NULL ) != RET_YES )
 					return;
