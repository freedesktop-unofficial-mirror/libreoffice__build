diff --git basic/inc/basic/basmgr.hxx basic/inc/basic/basmgr.hxx
index 2674c59..3c4f364 100644
--- basic/inc/basic/basmgr.hxx
+++ basic/inc/basic/basmgr.hxx
@@ -113,9 +113,10 @@ struct LibraryContainerInfo
     ::com::sun::star::uno::Reference< com::sun::star::script::XPersistentLibraryContainer > mxScriptCont;
     ::com::sun::star::uno::Reference< com::sun::star::script::XPersistentLibraryContainer > mxDialogCont;
     OldBasicPassword* mpOldBasicPassword;
+    bool mbVBACompatOn;
 
     LibraryContainerInfo()
-        :mpOldBasicPassword( NULL )
+        :mpOldBasicPassword( NULL ), mbVBACompatOn( false )
     {
     }
 
@@ -127,7 +128,7 @@ struct LibraryContainerInfo
     )
         : mxScriptCont( xScriptCont )
         , mxDialogCont( xDialogCont )
-        , mpOldBasicPassword( pOldBasicPassword )
+        , mpOldBasicPassword( pOldBasicPassword ), mbVBACompatOn( false )
 	{}
 };
 
diff --git basic/inc/basic/sbobjmod.hxx basic/inc/basic/sbobjmod.hxx
index bdc23d9..15f6352 100644
--- basic/inc/basic/sbobjmod.hxx
+++ basic/inc/basic/sbobjmod.hxx
@@ -56,6 +56,7 @@ public:
     SbObjModule( const com::sun::star::script::ModuleInfo& mInfo, bool bIsVbaCompatible );
     virtual SbxVariable* Find( const XubString& rName, SbxClassType t );
     SbxVariable* GetObject();
+    void SetUnoObject( const com::sun::star::uno::Any& aObj )throw ( com::sun::star::uno::RuntimeException ) ;
 };
 
 class SbUserFormModule : public SbObjModule
diff --git basic/source/basmgr/basmgr.cxx basic/source/basmgr/basmgr.cxx
index b5394ae..f12312e 100644
--- basic/source/basmgr/basmgr.cxx
+++ basic/source/basmgr/basmgr.cxx
@@ -44,6 +44,7 @@
 #include <tools/debug.hxx>
 #include <tools/diagnose_ex.h>
 #include <basic/sbmod.hxx>
+#include <basic/sbobjmod.hxx>
 
 #include <basic/sbuno.hxx>
 #include <basic/basmgr.hxx>
@@ -60,6 +61,7 @@
 
 // Library API, implemented for XML import/export
 
+#include <com/sun/star/script/XVBACompat.hpp>
 #include <com/sun/star/container/XNameContainer.hpp>
 #include <com/sun/star/container/XContainer.hpp>
 #include <com/sun/star/script/XStarBasicAccess.hpp>
@@ -208,10 +210,11 @@ void BasMgrContainerListenerImpl::insert
 	if( !pMgr->GetLib( aLibName ) )
 	{
         BasicManager* pBasMgr = static_cast< BasicManager* >( pMgr );
-#ifdef DBG_UTIL
 		StarBASIC* pLib = 
-#endif
 		pBasMgr->CreateLibForLibContainer( aLibName, xScriptCont );
+		if ( pLib )
+			pLib->SetVBAEnabled( pMgr->mpImpl->maContainerInfo.mbVBACompatOn );
+        
 		DBG_ASSERT( pLib, "XML Import: Basic library could not be created");
 	}
 
@@ -292,6 +295,12 @@ void SAL_CALL BasMgrContainerListenerImp
 	{
         Reference< XLibraryContainer > xScriptCont( Event.Source, UNO_QUERY );
 		insertLibraryImpl( xScriptCont, mpMgr, Event.Element, aName );
+                Reference<  XVBACompat > xCompat( xScriptCont, UNO_QUERY );
+                if ( xCompat.is() )
+                {
+		    StarBASIC* pLib = mpMgr->GetLib( aName );
+                    pLib->SetVBAEnabled( xCompat->getVBACompatModeOn() );
+                }
 	}
 	else
 	{
@@ -337,25 +346,35 @@ void SAL_CALL BasMgrContainerListenerImp
     DBG_ASSERT( !bLibContainer, "library container fired elementReplaced()");
 
 	StarBASIC* pLib = mpMgr->GetLib( maLibName );
+    
 	if( pLib )
 	{
-         ModuleInfo mInfo;
+	    SbModule* pMod = pLib->FindModule( aName );
+		OUString aMod;
+        ModuleInfo mInfo;
         if( Event.Element >>= mInfo )
-        {
-            OSL_TRACE("#elementReplaced Mod");
-            pLib->MakeModule32( mInfo );
-        }
-        else
-        {
-		    SbModule* pMod = pLib->FindModule( aName );
-
-		    OUString aMod;
+			aMod = mInfo.ModuleSource;
+        else 
             Event.Element >>= aMod;
-		    if( pMod )
-		   	    pMod->SetSource32( aMod );
-            else
-			    pLib->MakeModule32( aName, aMod );
-        }
+		if( pMod )
+		{
+			pMod->SetSource32( aMod );
+			if ( mInfo.ModuleType == ModuleType::Document )
+			{
+				SbObjModule* pObjModule = dynamic_cast< SbObjModule* >( pMod );
+				if ( pObjModule )	
+					pObjModule->SetUnoObject( makeAny( mInfo.ModuleObject ) );
+			}
+		}
+        else
+			// Probably we should have an assert for
+			// unknow module type, e.g. either we are using
+			// the ModuleInfo structure ( vba ) for *all* modules
+			// or not ( normal )
+			if ( mInfo.ModuleType == ModuleType::Unknown )
+				pLib->MakeModule32( aName, aMod );
+			else
+				pLib->MakeModule32( mInfo );
 
 		pLib->SetModified( FALSE );
 	}
@@ -822,6 +841,12 @@ void BasicManager::SetLibraryContainerIn
 
 	Reference< XLibraryContainer > xScriptCont( mpImpl->maContainerInfo.mxScriptCont.get() );
 	StarBASIC* pStdLib = GetStdLib();
+        Reference< XVBACompat > xCompat( GetScriptLibraryContainer(), UNO_QUERY );
+        if ( xCompat.is() )
+                mpImpl->maContainerInfo.mbVBACompatOn = xCompat->getVBACompatModeOn();    
+	// Std is created regardless of any persisted Libraries, so.. we need
+	// to make sure we set its compat mode here
+	pStdLib->SetVBAEnabled( mpImpl->maContainerInfo.mbVBACompatOn );
 	String aLibName = pStdLib->GetName();
 	if( xScriptCont.is() )
 	{
diff --git basic/source/classes/sbxmod.cxx basic/source/classes/sbxmod.cxx
index 3f9e76c..8083eaa 100644
--- basic/source/classes/sbxmod.cxx
+++ basic/source/classes/sbxmod.cxx
@@ -2250,25 +2250,26 @@ SbObjModule::SbObjModule( const com::sun
     if ( mInfo.ModuleType == script::ModuleType::Form )
     {
         SetClassName( rtl::OUString::createFromAscii( "Form" ) );
-        return;
     }
-    try
+    else if ( mInfo.ModuleObject.is() )
+        SetUnoObject( uno::makeAny( mInfo.ModuleObject ) );   
+}
+void
+SbObjModule::SetUnoObject( const uno::Any& aObj ) throw ( uno::RuntimeException )
+{
+    SbUnoObject* pUnoObj = PTR_CAST(SbUnoObject,(SbxVariable*)pDocObject);
+    if ( pUnoObj && pUnoObj->getUnoAny() == aObj ) // object is equal, nothing to do
+        return;
+    pDocObject = new SbUnoObject( GetName(), uno::makeAny( aObj ) );
+            
+    com::sun::star::uno::Reference< com::sun::star::lang::XServiceInfo > xServiceInfo( aObj, com::sun::star::uno::UNO_QUERY_THROW );
+    if( xServiceInfo->supportsService( rtl::OUString::createFromAscii( "org.openoffice.excel.Worksheet" ) ) )
     {
-        com::sun::star::uno::Any aObject( mInfo.ModuleObject );
-        pDocObject = new SbUnoObject( GetName(), aObject );
-        com::sun::star::uno::Reference< com::sun::star::lang::XServiceInfo > xServiceInfo( aObject, com::sun::star::uno::UNO_QUERY_THROW );
-        if( xServiceInfo->supportsService( rtl::OUString::createFromAscii( "org.openoffice.excel.Worksheet" ) ) )
-        {
-            SetClassName( rtl::OUString::createFromAscii( "Worksheet" ) );
-        }
-        else if( xServiceInfo->supportsService( rtl::OUString::createFromAscii( "org.openoffice.excel.Workbook" ) ) )
-        {
-            SetClassName( rtl::OUString::createFromAscii( "Workbook" ) );
-        }
+        SetClassName( rtl::OUString::createFromAscii( "Worksheet" ) );
     }
-    catch( com::sun::star::uno::RuntimeException e )
+    else if( xServiceInfo->supportsService( rtl::OUString::createFromAscii( "org.openoffice.excel.Workbook" ) ) )
     {
-        OSL_TRACE("***** Failed to initialise API Object." );
+        SetClassName( rtl::OUString::createFromAscii( "Workbook" ) );
     }
 }
 
@@ -2301,7 +2302,7 @@ class FormObjEventListenerImpl : public 
 public:
     FormObjEventListenerImpl( SbUserFormModule* pUserForm, const uno::Reference< lang::XComponent >& xComponent ) : mpUserForm( pUserForm ), mxComponent( xComponent) , mbDisposed( false )
     {
-        if ( mxComponent.is() );
+        if ( mxComponent.is() )
         {
 	    uno::Reference< awt::XTopWindow > xList( mxComponent, uno::UNO_QUERY_THROW );;
             //uno::Reference< awt::XWindow > xList( mxComponent, uno::UNO_QUERY_THROW );;
diff --git basic/source/inc/namecont.hxx basic/source/inc/namecont.hxx
index e5b3d76..4f1d26a 100644
--- basic/source/inc/namecont.hxx
+++ basic/source/inc/namecont.hxx
@@ -62,20 +62,23 @@
 #include <cppuhelper/implbase2.hxx>
 #include <cppuhelper/compbase6.hxx>
 #include <cppuhelper/compbase7.hxx>
+#include <cppuhelper/compbase8.hxx>
 #include <cppuhelper/interfacecontainer.hxx>
+#include <com/sun/star/script/XVBACompat.hpp>
 
 class BasicManager;
 
 namespace basic
 {
 
-typedef ::cppu::WeakComponentImplHelper7< 
+typedef ::cppu::WeakComponentImplHelper8< 
     ::com::sun::star::lang::XInitialization,
     ::com::sun::star::script::XStorageBasedLibraryContainer,
     ::com::sun::star::script::XLibraryContainerPassword,
     ::com::sun::star::script::XLibraryContainerExport,
     ::com::sun::star::container::XContainer,
     ::com::sun::star::script::XLibraryQueryExecutable,
+    ::com::sun::star::script::XVBACompat,
     ::com::sun::star::lang::XServiceInfo > LibraryContainerHelper;
 
 typedef ::cppu::WeakImplHelper2< ::com::sun::star::container::XNameContainer,
@@ -248,7 +251,7 @@ protected:
 	sal_Bool        mbOwnBasMgr;
 
     InitMode meInitMode;
-
+    bool mbVBACompatModeOn;
 	void implStoreLibrary( SfxLibrary* pLib,
 							const ::rtl::OUString& aName,
 							const ::com::sun::star::uno::Reference< ::com::sun::star::embed::XStorage >& xStorage );
@@ -497,6 +500,8 @@ public:
         throw (::com::sun::star::uno::RuntimeException);
     virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames( )
         throw (::com::sun::star::uno::RuntimeException) = 0;
+    virtual ::sal_Bool SAL_CALL getVBACompatModeOn() throw (::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL setVBACompatModeOn( ::sal_Bool _vbacompatmodeon ) throw (::com::sun::star::uno::RuntimeException);
 };
 
 class LibraryContainerMethodGuard
@@ -556,7 +561,7 @@ private:
 	::rtl::OUString maPassword;
 
 	sal_Bool mbSharedIndexFile;
-
+    ::xmlscript::ObjectModuleDescHash mhCodeNameToObjDesc;
 	// Additional functionality for localisation
 	// Provide modify state including resources
 	virtual sal_Bool isModified( void ) = 0;
diff --git basic/source/uno/namecont.cxx basic/source/uno/namecont.cxx
index e5f37c7..a062c0d 100644
--- basic/source/uno/namecont.cxx
+++ basic/source/uno/namecont.cxx
@@ -325,6 +325,17 @@ void ModifiableHelper::setModified( sal_
 // Implementation class SfxLibraryContainer
 DBG_NAME( SfxLibraryContainer )
 
+::sal_Bool SAL_CALL 
+SfxLibraryContainer::getVBACompatModeOn() throw (RuntimeException)
+{
+    return mbVBACompatModeOn;
+}
+void SAL_CALL 
+SfxLibraryContainer::setVBACompatModeOn( ::sal_Bool _vbacompatmodeon ) throw (RuntimeException)
+{
+    // will need to trigger event so that basicmanager can get it	
+    mbVBACompatModeOn =  ( _vbacompatmodeon == sal_True );
+}
 // Ctor
 SfxLibraryContainer::SfxLibraryContainer( void )
 	: LibraryContainerHelper( maMutex )
@@ -334,6 +345,7 @@ SfxLibraryContainer::SfxLibraryContainer
     , mbOasis2OOoFormat( sal_False )
     , mpBasMgr( NULL )
     , mbOwnBasMgr( sal_False )
+    , mbVBACompatModeOn( sal_False )
 {
     DBG_CTOR( SfxLibraryContainer, NULL );
 
@@ -790,7 +802,7 @@ sal_Bool SfxLibraryContainer::init_Impl(
                 OSL_ENSURE( 0, OUStringToOString( e.Message, RTL_TEXTENCODING_ASCII_US ).getStr() );
                 return sal_False;
             }
-
+            mbVBACompatModeOn = pLibArray->mbVBAMode; 
 		    sal_Int32 nLibCount = pLibArray->mnLibCount;
 		    for( sal_Int32 i = 0 ; i < nLibCount ; i++ )
 		    {
@@ -1620,16 +1632,33 @@ void SfxLibraryContainer::implImportLibD
 	    sal_Int32 nElementCount = rLib.aElementNames.getLength();
 	    const OUString* pElementNames = rLib.aElementNames.getConstArray();
 	    Any aDummyElement = createEmptyLibraryElement();
+            ::xmlscript::ObjectModuleDescHash::iterator it_end = rLib.hCodeNameToObjDesc.end();
 	    for( sal_Int32 i = 0 ; i < nElementCount ; i++ )
 	    {
+                    ::xmlscript::ObjectModuleDescHash::iterator it = rLib.hCodeNameToObjDesc.find( pElementNames[i] );
+                    
+                    if ( it != it_end )
+                    {
+                        // for all other types set up the ModuleInfo structure
+                        com::sun::star::script::ModuleInfo mInfo;
+                        mInfo.ModuleName = pElementNames[i];
+                        mInfo.ModuleType = it->second.mnModuleType;
+                        // hack for userform, needs to know about the document
+                        // well really it needs the dialog library
+                        if (  mInfo.ModuleType == ModuleType::Form )
+                            mInfo.ModuleObject = mxOwnerDocument;
+                        aDummyElement <<= mInfo;
+                    }
 		    pLib->maNameContainer.insertByName( pElementNames[i], aDummyElement );
-	    }
+        }
         pLib->mbPasswordProtected = rLib.bPasswordProtected;
         pLib->mbReadOnly = rLib.bReadOnly;
 		pLib->mbPreload  = rLib.bPreload;
         pLib->implSetModified( sal_False );
 
         pLib->mbInitialised = sal_True;
+        pLib->mhCodeNameToObjDesc = rLib.hCodeNameToObjDesc;
+
     }
 }
 
@@ -2177,10 +2206,26 @@ void SAL_CALL SfxLibraryContainer::loadL
 			}
 
 			Any aAny = importLibraryElement( aFile, xInStream );
+            // perhaps the ModuleInfo stuff might be better done in scriptcont 
+            // ( via importLibraryElement, probably would need to pass pImplLib though, which
+            // defeats the purpose of the pImpl  )
+            ::xmlscript::ObjectModuleDescHash::iterator it = pImplLib->mhCodeNameToObjDesc.find( aElementName );
+            if ( it !=  pImplLib->mhCodeNameToObjDesc.end() )
+            {
+                // Replace the aAny with one containing ModuleInfo
+                com::sun::star::script::ModuleInfo mInfo;
+                mInfo.ModuleName = aElementName;
+                mInfo.ModuleType = it->second.mnModuleType;
+                mInfo.ModuleObject = mxOwnerDocument;
+                aAny >>= mInfo.ModuleSource; 
+                aAny <<= mInfo;
+            }
 			if( pImplLib->hasByName( aElementName ) )
             {
                 if( aAny.hasValue() )
+                {
 				    pImplLib->maNameContainer.replaceByName( aElementName, aAny );
+                }
             }
 			else
             {
diff --git basic/source/uno/sbservices.cxx basic/source/uno/sbservices.cxx
index a2a4ded..aa076ea 100644
--- basic/source/uno/sbservices.cxx
+++ basic/source/uno/sbservices.cxx
@@ -43,6 +43,7 @@ namespace basic
     //--------------------------------------------------------------------
     extern void createRegistryInfo_SfxDialogLibraryContainer();
     extern void createRegistryInfo_SfxScriptLibraryContainer();
+    extern void createRegistryInfo_PersistedReadOnlyCodeNames();
 
     static void initializeModule()
     {
@@ -54,6 +55,7 @@ namespace basic
             {
                 createRegistryInfo_SfxDialogLibraryContainer();
                 createRegistryInfo_SfxScriptLibraryContainer();
+                createRegistryInfo_PersistedReadOnlyCodeNames();
             }
         }
     }
diff --git basic/source/uno/scriptcont.cxx basic/source/uno/scriptcont.cxx
index 7480f7c..6d72850 100644
--- basic/source/uno/scriptcont.cxx
+++ basic/source/uno/scriptcont.cxx
@@ -1056,6 +1056,11 @@ SfxScriptLibraryContainer:: HasExecutabl
 
 //============================================================================
 // Service
+class PersistedReadOnlyCodeNames;
+void createRegistryInfo_PersistedReadOnlyCodeNames()
+{
+    static OAutoRegistration< PersistedReadOnlyCodeNames > aAutoRegistration;
+}
 void createRegistryInfo_SfxScriptLibraryContainer()
 {
     static OAutoRegistration< SfxScriptLibraryContainer > aAutoRegistration;
@@ -1160,6 +1165,124 @@ void SfxScriptLibrary::storeResourcesToS
 	// No resources
 	(void)xStorage;
 }
+typedef ::cppu::WeakImplHelper3< container::XNameAccess, lang::XInitialization, lang::XServiceInfo > ReadOnlyCodeNames_BASE;
+
+// XNameAccess, codename to/from objectnames
+class PersistedReadOnlyCodeNames : ReadOnlyCodeNames_BASE
+{
+    ::xmlscript::CodeNameHash mCodeNameToObjectNames;
+public:
+    PersistedReadOnlyCodeNames()
+    {
+    }
+    // Methods - XInitialise
+    virtual void SAL_CALL initialize( const uno::Sequence< uno::Any >& aArguments ) throw (uno::Exception, uno::RuntimeException)
+    {
+        if ( !aArguments.getLength() )
+            throw RuntimeException();
+        Reference< document::XStorageBasedDocument > xDocument( aArguments[ 0 ], uno::UNO_QUERY_THROW ); 
+        Reference< embed::XStorage > xDocStorage; 
+        try
+        {
+            Reference< XMultiServiceFactory > xMSF = comphelper::getProcessServiceFactory();
+            Reference< XServiceInfo > xSI( xDocument, UNO_QUERY_THROW );
+            if ( xSI->supportsService( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.document.OfficeDocument" ) ) ) )
+                xDocStorage.set( xDocument->getDocumentStorage(), UNO_QUERY_THROW );
+            if ( xDocStorage.is() ) // not a 'real' document
+            {
+                rtl::OUString codeNameDir( RTL_CONSTASCII_USTRINGPARAM("Basic") );
+                rtl::OUString codeNameFile( RTL_CONSTASCII_USTRINGPARAM("script-lc.xml") );
+    
+                uno::Reference< embed::XStorage > xLibrariesStor( xDocStorage->openStorageElement( codeNameDir, embed::ElementModes::READ ), UNO_QUERY_THROW );
+                uno::Reference< io::XStream > xStream( xLibrariesStor->openStreamElement( codeNameFile, embed::ElementModes::READ ), UNO_QUERY_THROW );
+                uno::Reference< io::XInputStream > xInput( xStream->getInputStream(), UNO_QUERY_THROW );
+                ::xmlscript::LibDescriptorArray* pLibArray = new ::xmlscript::LibDescriptorArray();
+                InputSource source;
+                source.aInputStream = xInput;
+
+                Reference< XParser > xParser( xMSF->createInstance( OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.xml.sax.Parser") ) ), UNO_QUERY_THROW );
+                xParser->setDocumentHandler(  ::xmlscript::importLibraryCodeNames( pLibArray ) );
+                xParser->parseStream( source );
+                mCodeNameToObjectNames = pLibArray->mCodeNames;
+            }
+        }
+        catch ( Exception& e )
+        {
+            OSL_TRACE("Urk, should never get here, help!!");
+        }
+    }
+    // Methods - XNameAccess
+    virtual uno::Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+    {
+        ::xmlscript::CodeNameHash::iterator it = mCodeNameToObjectNames.find( aName );
+        if ( it == mCodeNameToObjectNames.end() )
+            throw container::NoSuchElementException();
+        return uno::makeAny( it->second );
+    }
+    virtual uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (uno::RuntimeException)
+    {
+        uno::Sequence< ::rtl::OUString > sNames( mCodeNameToObjectNames.size() );
+        ::rtl::OUString* pStr = sNames.getArray();
+        ::xmlscript::CodeNameHash::iterator it = mCodeNameToObjectNames.begin();
+        ::xmlscript::CodeNameHash::iterator it_end = mCodeNameToObjectNames.end();
+        for ( ; it != it_end ; ++it, ++pStr )
+            *pStr = it->first;    
+        return sNames;
+    }
+    virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (uno::RuntimeException)
+    {
+        return ( mCodeNameToObjectNames.find( aName ) != mCodeNameToObjectNames.end() );
+    }
+    // Methods - XElementAccess
+    virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException)
+    {
+        return ::getCppuType( (const rtl::OUString *)0 );
+    }
+    virtual ::sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException)
+    {
+        return ( mCodeNameToObjectNames.size() > 0 );
+    }
+    // Methods XServiceInfo
+    virtual ::rtl::OUString SAL_CALL getImplementationName( ) throw (::com::sun::star::uno::RuntimeException)
+    {
+        return getImplementationName_static(); 
+    }
+    virtual ::sal_Bool SAL_CALL supportsService( const ::rtl::OUString& ServiceName ) throw (::com::sun::star::uno::RuntimeException)
+    {
+        uno::Sequence< rtl::OUString > sNames( getSupportedServiceNames() );
+        rtl::OUString* pStr = sNames.getArray(); 
+        rtl::OUString* pEnd = ( sNames.getArray() + sNames.getLength() ); 
+        for ( ; pStr != pEnd ; ++pStr )
+        {
+            if ( (*pStr).equals( ServiceName ) )
+                return sal_True; 
+        } 
+        return sal_False;
+    }
+    virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames( ) throw (::com::sun::star::uno::RuntimeException)
+    {
+        return getSupportedServiceNames_static();
+    }
+    // Service
+    static ::com::sun::star::uno::Sequence< ::rtl::OUString > getSupportedServiceNames_static()
+    {
+        uno::Sequence< rtl::OUString > sServiceNames(1);
+        sServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.vba.PersistedCodeNames"));
+        return sServiceNames;
+    }
+    static ::rtl::OUString getImplementationName_static()
+    {
+         static OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("PersistedReadOnlyCodeNames") );
+         return sImplName;
+    }
+
+    static Reference< XInterface > SAL_CALL Create ( const Reference< XComponentContext >& xServiceManager ) throw( Exception )
+    {
+        Reference< XInterface > xRet =
+        static_cast< XInterface* >( static_cast< OWeakObject* >( new PersistedReadOnlyCodeNames() ));
+        return xRet;
+    }
+};
 
 //============================================================================
 
diff --git offapi/com/sun/star/document/XVbaEventsHelper.idl offapi/com/sun/star/document/XVbaEventsHelper.idl
index 718e68d..fd0e2db 100644
--- offapi/com/sun/star/document/XVbaEventsHelper.idl
+++ offapi/com/sun/star/document/XVbaEventsHelper.idl
@@ -45,6 +45,7 @@ module com {  module sun {  module star 
 
 interface XVbaEventsHelper
 {
+    [attribute ] boolean IgnoreEvents; 
     // nTab -1 for workbook.
     boolean ProcessCompatibleVbaEvent( [in] long VbaEvent, [in] sequence< any > aArgs );
 };
diff --git offapi/com/sun/star/script/XCodeNameBinder.idl offapi/com/sun/star/script/XCodeNameBinder.idl
new file mode 100644
index 0000000..58e3606
--- /dev/null
+++ offapi/com/sun/star/script/XCodeNameBinder.idl
@@ -0,0 +1,49 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XLibraryContainer.idl,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_script_XCodeNameBinder_idl__ 
+#define __com_sun_star_script_XCodeNameBinder_idl__ 
+ 
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+ 
+//============================================================================= 
+ 
+module com {  module sun {  module star {  module script {  
+ 
+interface XCodeNameBinder: com::sun::star::uno::XInterface
+{ 
+
+    void bindCodeName( [in] string codename, [in] string objectname );
+//============================================================================= 
+ 
+}; }; }; };  
+}; 
+#endif 
diff --git offapi/com/sun/star/script/XVBACompat.idl offapi/com/sun/star/script/XVBACompat.idl
new file mode 100644
index 0000000..e1b2d28
--- /dev/null
+++ offapi/com/sun/star/script/XVBACompat.idl
@@ -0,0 +1,49 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XLibraryContainer.idl,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_script_XVBACompat_idl__ 
+#define __com_sun_star_script_XVBACompat_idl__ 
+ 
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+ 
+//============================================================================= 
+ 
+module com {  module sun {  module star {  module script {  
+ 
+interface XVBACompat: com::sun::star::uno::XInterface
+{ 
+
+//============================================================================= 
+    [attribute ] boolean VBACompatModeOn;
+ 
+}; }; }; };  
+}; 
+#endif 
diff --git offapi/com/sun/star/script/makefile.mk offapi/com/sun/star/script/makefile.mk
index 113d4c9..f9e3208 100644
--- offapi/com/sun/star/script/makefile.mk
+++ offapi/com/sun/star/script/makefile.mk
@@ -51,6 +51,8 @@ IDLFILES=\
 	XPersistentLibraryContainer.idl\
 	XStorageBasedLibraryContainer.idl\
 	XLibraryQueryExecutable.idl \
+	XVBACompat.idl\
+	XCodeNameBinder.idl\
 	ModuleSizeExceededRequest.idl\
 
 # ------------------------------------------------------------------
diff --git sc/inc/document.hxx sc/inc/document.hxx
index d32e28c..e23cbfd 100644
--- sc/inc/document.hxx
+++ sc/inc/document.hxx
@@ -34,6 +34,7 @@
 
 #include <vcl/prntypes.hxx>
 #include <vcl/timer.hxx>
+#include <com/sun/star/container/XNameAccess.hpp>
 #include <com/sun/star/uno/Reference.hxx>
 #include <vos/ref.hxx>
 #include "scdllapi.h"
@@ -316,7 +317,7 @@ private:
 
 	//ScVbaEventsHelper*	pVbaEventsHelper;
     com::sun::star::uno::Reference< com::sun::star::document::XVbaEventsHelper > rVbaEventsHelper;
-
+        com::sun::star::uno::Reference< com::sun::star::container::XNameAccess > mxCodeNames;
 public:
     ScTabOpList         aTableOpList;		            // list of ScInterpreterTableOpParams currently in use
     ScInterpreterTableOpParams  aLastTableOpParams;     // remember last params
@@ -434,6 +435,7 @@ public:
 								SfxObjectShell* pDocShell = NULL );
 					~ScDocument();
 
+    com::sun::star::uno::Reference< com::sun::star::container::XNameAccess > GetPersistedCodeNames() throw( com::sun::star::uno::RuntimeException );
 	inline ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory >
 					GetServiceManager() const { return xServiceManager; }
 
diff --git sc/source/core/data/documen2.cxx sc/source/core/data/documen2.cxx
index e506a03..feb8746 100644
--- sc/source/core/data/documen2.cxx
+++ sc/source/core/data/documen2.cxx
@@ -248,6 +248,7 @@ ScDocument::ScDocument( ScDocumentMode	e
 
 	aTrackTimer.SetTimeoutHdl( LINK( this, ScDocument, TrackTimeHdl ) );
 	aTrackTimer.SetTimeout( 100 );
+	aDocCodeName = String( RTL_CONSTASCII_USTRINGPARAM("ThisWorkbook") );
 }
 
 
diff --git sc/source/core/data/document.cxx sc/source/core/data/document.cxx
index b123ad7..7ee3b4a 100644
--- sc/source/core/data/document.cxx
+++ sc/source/core/data/document.cxx
@@ -91,6 +91,9 @@
 #include "bcaslot.hxx"
 #include "postit.hxx"
 #include "tabprotection.hxx"
+#include <comphelper/processfactory.hxx>
+
+using namespace ::com::sun::star;
 
 struct ScDefaultAttr
 {
@@ -4830,5 +4833,30 @@ BOOL ScDocument::NeedPageResetAfterTab( 
 	return FALSE;		// sonst nicht
 }
 
+uno::Reference< container::XNameAccess > 
+ScDocument::GetPersistedCodeNames() throw( uno::RuntimeException )
+{
+    SfxObjectShell* pObjShell = GetDocumentShell();
+    if ( pShell && !mxCodeNames.is() )
+    {
+        uno::Sequence< uno::Any > aArgs( 1 );
+        aArgs[ 0 ] = uno::makeAny( pObjShell->GetModel() );
+        mxCodeNames.set( ::comphelper::getProcessServiceFactory()->createInstanceWithArguments(rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("org.openoffice.vba.PersistedCodeNames")), aArgs),  uno::UNO_QUERY );
+        if ( mxCodeNames.is() )
+        {
+            rtl::OUString sWorkbook( RTL_CONSTASCII_USTRINGPARAM("ThisWorkbook") );
+            if ( mxCodeNames->hasByName( sWorkbook ) )
+            {
+		
+                rtl::OUString sCodeName;
+                mxCodeNames->getByName( sWorkbook ) >>= sCodeName;
+                SetCodeName( sCodeName );
+            }
+        }
+    }
+    return mxCodeNames;
+}
+
+
 
 
diff --git sc/source/filter/excel/excimp8.cxx sc/source/filter/excel/excimp8.cxx
index efd372d..8ec6e31 100644
--- sc/source/filter/excel/excimp8.cxx
+++ sc/source/filter/excel/excimp8.cxx
@@ -105,6 +105,7 @@
 
 #include <com/sun/star/document/XDocumentProperties.hpp>
 #include <com/sun/star/document/XDocumentPropertiesSupplier.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
 
 
 using namespace com::sun::star;
@@ -112,8 +113,8 @@ using namespace com::sun::star;
 
 #define	INVALID_POS		0xFFFFFFFF
 
-
-
+// defined in docfunc.cxx ( really this needs a new name )
+script::ModuleInfo lcl_InitModuleInfo( SfxObjectShell& rDocSh, String& sModule );
 
 ImportExcel8::ImportExcel8( XclImpRootData& rImpData, SvStream& rStrm ) :
     ImportExcel( rImpData, rStrm ), mnTab(0)
@@ -291,6 +292,44 @@ void ImportExcel8::ReadBasic( void )
             SvxImportMSVBasic aBasicImport( *pShell, *xRootStrg, bLoadCode, bLoadStrg );
 			bool bAsComment = !bLoadExecutable || !lcl_hasVBAEnabled();
             aBasicImport.Import( EXC_STORAGE_VBA_PROJECT, EXC_STORAGE_VBA, bAsComment );
+            // for each document module get the associated object for the codename and do a replacebyname
+            ScDocument& aDoc = GetDoc();
+            uno::Reference< script::XLibraryContainer > xLibContainer = GetDocShell()->GetBasicContainer();
+            uno::Reference< container::XNameContainer > xLib;
+            if( xLibContainer.is() )
+            {
+                String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+                uno::Any aLibAny = xLibContainer->getByName( aLibName );
+                aLibAny >>= xLib;
+            }
+            if ( xLib.is() )
+            {
+                rtl::OUString sOUCodeName( aDoc.GetCodeName() );
+                if ( xLib->hasByName( sOUCodeName ) )
+                {
+                    script::ModuleInfo mInfo;
+                    xLib->getByName( sOUCodeName ) >>= mInfo; 
+                    String sTmp = sOUCodeName;
+                    mInfo.ModuleObject = lcl_InitModuleInfo( *GetDocShell(), sTmp ).ModuleObject;
+                    xLib->replaceByName( sOUCodeName, uno::makeAny( mInfo ) );
+			
+                }
+                SCTAB nCount = aDoc.GetTableCount();
+    
+                for( SCTAB i = 0; i < nCount; ++i )
+                {
+                    String sName;
+                    aDoc.GetCodeName( i, sName );
+                    sOUCodeName = sName;
+                    if ( xLib->hasByName( sOUCodeName ) )
+                    {
+                        script::ModuleInfo mInfo;
+                        xLib->getByName( sOUCodeName ) >>= mInfo; 
+                        mInfo.ModuleObject = lcl_InitModuleInfo( *GetDocShell(), sName ).ModuleObject;
+                        xLib->replaceByName( sOUCodeName, uno::makeAny( mInfo ) );
+                    }
+                }
+            }
         }
     }
 }
diff --git sc/source/ui/docshell/docfunc.cxx sc/source/ui/docshell/docfunc.cxx
index 105f743..91ff9f7 100644
--- sc/source/ui/docshell/docfunc.cxx
+++ sc/source/ui/docshell/docfunc.cxx
@@ -2028,23 +2028,29 @@ BOOL ScDocFunc::MoveBlock( const ScRange
 }
 
 //------------------------------------------------------------------------
-script::ModuleInfo lcl_InitModuleInfo( ScDocShell& rDocSh, String& sModule )
+uno::Reference< uno::XInterface > GetDocModuleObject( SfxObjectShell& rDocSh, String& sCodeName )
 {
-    ::rtl::OUString aModName( sModule );
     uno::Reference< lang::XMultiServiceFactory> xSF(rDocSh.GetModel(), uno::UNO_QUERY);
+    uno::Reference< container::XNameAccess > xVBACodeNamedObjectAccess;
+    uno::Reference< uno::XInterface > xDocModuleApiObject;
+    if ( xSF.is() )
+    {
+        xVBACodeNamedObjectAccess.set( xSF->createInstance( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "org.openoffice.vba.VBAObjectModuleObjectProvider"))), uno::UNO_QUERY );    
+        xDocModuleApiObject.set( xVBACodeNamedObjectAccess->getByName( sCodeName ), uno::UNO_QUERY );    
+    }
+    return xDocModuleApiObject;
+
+}
+
+script::ModuleInfo lcl_InitModuleInfo( SfxObjectShell& rDocSh, String& sModule )
+{
+    ::rtl::OUString aModName( sModule );
     ::rtl::OUString sVbaOption( RTL_CONSTASCII_USTRINGPARAM( "Rem Attribute VBA_ModuleType=VBADocumentModule\nOption VBASupport 1\n" ));
     script::ModuleInfo sModuleInfo;
     sModuleInfo.ModuleName = aModName;
     sModuleInfo.ModuleSource = sVbaOption;
     sModuleInfo.ModuleType = script::ModuleType::Document;
-    uno::Reference< container::XNameAccess > xVBACodeNamedObjectAccess;
-    if ( xSF.is() )
-    {
-        uno::Sequence< uno::Any > aArgs(1);
-        aArgs[0] = uno::Any( aModName );
-        xVBACodeNamedObjectAccess.set( xSF->createInstanceWithArguments( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "org.openoffice.vba.VBAObjectModuleObjectProvider")), aArgs), uno::UNO_QUERY );    
-        sModuleInfo.ModuleObject.set( xVBACodeNamedObjectAccess->getByName( aModName ), uno::UNO_QUERY );    
-    }
+    sModuleInfo.ModuleObject = GetDocModuleObject( rDocSh, sModule );
     return sModuleInfo;
 }
 
@@ -2064,21 +2070,19 @@ void lcl_InsertModule( ScDocShell& rDocS
     }
     if( xLib.is() )
     {
-        // test Module has exist
-        // if the Module is exist. changed to another name
-        // and at this time the string like "SheetX"
+        // if the Module with codename exists then find a new name
         sal_Int32 nNum = 1;
+        sModuleInfo.ModuleName = sModuleName;
         while( xLib->hasByName( sModuleInfo.ModuleName  ) )
         {
-            sModuleName = rtl::OUString::createFromAscii( "Sheet" ) + rtl::OUString::valueOf( nNum );
+            sModuleInfo.ModuleName = rtl::OUString::createFromAscii( "Sheet" ) + rtl::OUString::valueOf( nNum );
             nNum += 1;
         }
-        sModuleInfo.ModuleName = sModuleName;
         uno::Any aSourceAny;
         aSourceAny <<= sModuleInfo;
-        xLib->insertByName( sModuleName, aSourceAny );
+        xLib->insertByName( sModuleInfo.ModuleName, aSourceAny );
         ScDocument* pDoc = rDocSh.GetDocument();
-        String sCodeName( sModuleName );
+        String sCodeName( sModuleInfo.ModuleName );
         pDoc->SetCodeName( nTab, sCodeName );
     }
     SFX_APP()->LeaveBasicCall();
@@ -2116,8 +2120,10 @@ BOOL ScDocFunc::InsertTable( SCTAB nTab,
 	ScDocShellModificator aModificator( rDocShell );
 
 	ScDocument* pDoc = rDocShell.GetDocument();
-    StarBASIC* pStarBASIC = rDocShell.GetBasic();
-    BOOL bVbaEnabled = pStarBASIC->isVBAEnabled();
+    // Strange loop, also basic is loaded too early ( InsertTable )
+    // is called via the xml import for sheets in described in odf 
+    StarBASIC* pStarBASIC = rDocShell.GetBasic(); 
+    BOOL bVbaEnabled = pStarBASIC ? pStarBASIC->isVBAEnabled() : false;
 	if (bRecord && !pDoc->IsUndoEnabled())
 		bRecord = FALSE;
     if ( bVbaEnabled )
@@ -2132,13 +2138,16 @@ BOOL ScDocFunc::InsertTable( SCTAB nTab,
 
 	if (pDoc->InsertTab( nTab, rName ))
 	{
+		String sCodeName;
 		if (bRecord)
 			rDocShell.GetUndoManager()->AddUndoAction(
 						new ScUndoInsertTab( &rDocShell, nTab, bAppend, rName));
 		//	Views updaten:
-        if( bVbaEnabled )
+        // Only insert vba modules if vba mode ( and not currently importing XML )
+        if( bVbaEnabled && !rDocShell.GetDocument()->IsImportingXML() )
         {
-            String sCodeName( rName );
+            if ( sCodeName.Len() == 0 )
+		sCodeName = rName;
             lcl_InsertModule( rDocShell, nTab, sCodeName );
         }
 		rDocShell.Broadcast( ScTablesHint( SC_TAB_INSERTED, nTab ) );
diff --git sc/source/ui/docshell/docsh.cxx sc/source/ui/docshell/docsh.cxx
index da54daa..6e57e1e 100644
--- sc/source/ui/docshell/docsh.cxx
+++ sc/source/ui/docshell/docsh.cxx
@@ -130,6 +130,7 @@
 #include "cellsuno.hxx"
 #include <com/sun/star/document/XVbaEventsHelper.hpp>
 #include <com/sun/star/document/VbaEventId.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
 
 using namespace com::sun::star;
 using namespace com::sun::star::document::VbaEventId;
@@ -516,7 +517,11 @@ sal_uInt16 ScDocShell::GetHiddenInformat
 void ScDocShell::BeforeXMLLoading()
 {
     aDocument.DisableIdle( TRUE );
-
+    // suppress VBA events when loading the xml
+    uno::Reference< document::XVbaEventsHelper > xEvt( aDocument.GetVbaEventsHelper() );
+    if ( xEvt.is() )
+       xEvt->setIgnoreEvents( sal_True );
+    
     // prevent unnecessary broadcasts and updates
     DBG_ASSERT(pModificator == NULL, "The Modificator should not exist");
 	pModificator = new ScDocShellModificator( *this );
@@ -530,6 +535,45 @@ void ScDocShell::BeforeXMLLoading()
 		ScColumn::bDoubleAlloc = sal_True;
 }
 
+// defined in docfunc.cxx ( really this needs a new name )
+uno::Reference< uno::XInterface > GetDocModuleObject( SfxObjectShell& rDocSh, String& sCodeName );
+
+rtl::OUString GetCodeName( ScDocument& aDocument, String& sObjectName )
+{
+    uno::Reference< container::XNameAccess > xCodeNames( aDocument.GetPersistedCodeNames() );
+    rtl::OUString sOUSCodeName;
+    xCodeNames->getByName( sObjectName ) >>= sOUSCodeName;
+    return sOUSCodeName;
+}
+
+void SetDocModuleForCodeName( ScDocument& aDocument, String& sCodeName )
+{
+    uno::Reference< script::XLibraryContainer > xLibContainer = aDocument.GetDocumentShell()->GetBasicContainer();
+    uno::Reference< container::XNameContainer > xLib;
+
+    if( xLibContainer.is() )
+    {
+        String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+        uno::Any aLibAny = xLibContainer->getByName( aLibName );
+        aLibAny >>= xLib;
+    }
+
+    if ( xLib.is() )
+    {
+        rtl::OUString sOUCodeName( sCodeName );
+        script::ModuleInfo mInfo;
+        if ( xLib->getByName( sOUCodeName ) >>= mInfo )
+        {
+            mInfo.ModuleObject = GetDocModuleObject( *aDocument.GetDocumentShell(), sCodeName );
+            xLib->replaceByName( sOUCodeName, uno::makeAny( mInfo ) );         
+        }
+        else
+        {
+            // Insert a big fat assertion etc
+        }
+    }
+}
+
 void ScDocShell::AfterXMLLoading(sal_Bool bRet)
 {
 	if (GetCreateMode() != SFX_CREATE_MODE_ORGANIZER)
@@ -600,8 +644,36 @@ void ScDocShell::AfterXMLLoading(sal_Boo
     }
     else
 		aDocument.SetInsertingFromOtherDoc( FALSE );
-
+        // suppress VBA events when loading the xml
+        uno::Reference< document::XVbaEventsHelper > xEvt( aDocument.GetVbaEventsHelper() );
+        if ( xEvt.is() )
+            xEvt->setIgnoreEvents( sal_False );
+        // SetCodenames for each tab  ( and set up the vba DOC Modules ) 
+        SCTAB nTabCount = aDocument.GetTableCount();
+        for (SCTAB i = 0; i < nTabCount; ++i)
+        {
+            String sObjectName;
+            String sCodeName;
+            try
+            {
+                if ( i == 0 )
+                {
+                    sObjectName = String( RTL_CONSTASCII_USTRINGPARAM("ThisWorkbook") );
+                    sCodeName = GetCodeName( aDocument, sObjectName );
+                    SetDocModuleForCodeName( aDocument, sCodeName );
+                }
+                aDocument.GetName( i, sObjectName );
+                sCodeName = GetCodeName( aDocument, sObjectName );
+                aDocument.SetCodeName( i, sCodeName );
+                SetDocModuleForCodeName( aDocument, sCodeName );
+            } 
+            catch( uno::Exception& )
+            {
+            }
+        }
+            
 	aDocument.SetImportingXML( FALSE );
+    
     aDocument.EnableUndo( TRUE );
     bIsEmpty = FALSE;
 
diff --git sc/source/ui/unoobj/docuno.cxx sc/source/ui/unoobj/docuno.cxx
index 1dcc337..55e67bd 100644
--- sc/source/ui/unoobj/docuno.cxx
+++ sc/source/ui/unoobj/docuno.cxx
@@ -1693,6 +1693,7 @@ uno::Sequence<rtl::OUString> SAL_CALL Sc
 
 	return concatServiceNames( aMyServices, aDrawServices );
 }
+
 // XCodeNameQuery
 rtl::OUString SAL_CALL 
 ScModelObj::getCodeNameForObject( const uno::Reference< uno::XInterface >& xIf ) throw( uno::RuntimeException )
@@ -1700,7 +1701,6 @@ ScModelObj::getCodeNameForObject( const 
     rtl::OUString sCodeName;
     if ( pDocShell )
     {
-        OSL_TRACE( "*** In ScModelObj::getCodeNameForObject");
         // need to find the page ( and index )  for this control
         uno::Reference< drawing::XDrawPagesSupplier > xSupplier( pDocShell->GetModel(), uno::UNO_QUERY_THROW );
         uno::Reference< container::XIndexAccess > xIndex( xSupplier->getDrawPages(), uno::UNO_QUERY_THROW );
diff --git sc/source/ui/unoobj/servuno.cxx sc/source/ui/unoobj/servuno.cxx
index b1a8a85..270c61a 100644
--- sc/source/ui/unoobj/servuno.cxx
+++ sc/source/ui/unoobj/servuno.cxx
@@ -63,7 +63,6 @@
 #include <svx/xmlgrhlp.hxx>
 
 #include <comphelper/processfactory.hxx>
-
 using namespace ::com::sun::star;
 
 class ScVbaObjectForCodeNameProvider : public ::cppu::WeakImplHelper1< container::XNameAccess >
diff --git sc/source/ui/vba/vbaeventshelper.cxx sc/source/ui/vba/vbaeventshelper.cxx
index 6c11c73..31664d0 100644
--- sc/source/ui/vba/vbaeventshelper.cxx
+++ sc/source/ui/vba/vbaeventshelper.cxx
@@ -307,7 +307,7 @@ void ImplVbaEventNameInfo::InitImplVbaEv
 }
 
 ScVbaEventsHelper::ScVbaEventsHelper( uno::Sequence< css::uno::Any > const& aArgs, uno::Reference< uno::XComponentContext > const& xContext )
-    : m_xContext( xContext ), mpWindowListener( NULL ), mbOpened( sal_False )
+    : m_xContext( xContext ), mpWindowListener( NULL ), mbOpened( sal_False ), mbIgnoreEvents( sal_False )
 {
     OSL_TRACE( "ScVbaEventsHelper::ScVbaEventsHelper" );
     uno::Reference< frame::XModel > xModel ( getXSomethingFromArgs< frame::XModel >( aArgs, 0 ), uno::UNO_QUERY );
@@ -524,7 +524,7 @@ String ScVbaEventsHelper::getSheetModule
 {
 	ScExtDocOptions* pExtOptions = pDoc->GetExtDocOptions();
 	String aCodeName;
-	pDoc->GetName( nTab, aCodeName);
+	pDoc->GetCodeName( nTab, aCodeName);
 	// Use code name if that exists
 	if ( pExtOptions )
 		aCodeName = pExtOptions->GetCodeName( nTab );
@@ -580,17 +580,14 @@ ScVbaEventsHelper::getMacroPath( const s
     	case VBAEVENT_WORKBOOK_SHEET_SELECTIONCHANGE          :
         {
 	        ScExtDocOptions* pExtOptions = pDoc->GetExtDocOptions();
+            String sWorkbookModuleName = pDoc->GetCodeName();
             if( pExtOptions )
             {
                 ScExtDocSettings aExtDocSettings = pExtOptions->GetDocSettings();
                 String sWorkbookModuleName = aExtDocSettings.maGlobCodeName;
-                sMacroPath = workbookMacroExists( pShell, sWorkbookModuleName, sMacroName );
-            }
-            else
-            {
-                // TODO need this?
-                sMacroPath = workbookMacroExists( pShell, rtl::OUString(), sMacroName );
             }
+           
+            sMacroPath = workbookMacroExists( pShell, sWorkbookModuleName, sMacroName );
             break;
         }
         default:
@@ -793,11 +790,28 @@ ScVbaEventsHelper::getTabFromArgs( const
     return nTab;
 }
 
+::sal_Bool SAL_CALL 
+ScVbaEventsHelper::getIgnoreEvents() throw (uno::RuntimeException)
+{
+    return mbIgnoreEvents;
+}
+
+void SAL_CALL 
+ScVbaEventsHelper::setIgnoreEvents( ::sal_Bool _ignoreevents ) throw (uno::RuntimeException)
+{
+    mbIgnoreEvents = _ignoreevents;
+}
+
 #define INVALID_TAB -1
 
 sal_Bool SAL_CALL 
 ScVbaEventsHelper::ProcessCompatibleVbaEvent( sal_Int32 VbaEvent, const uno::Sequence< uno::Any >& aArgs ) throw (uno::RuntimeException)
 {
+    if ( mbIgnoreEvents ) 
+    {
+    	OSL_TRACE("** Ignoring event %s [%d]", rtl::OUStringToOString( GetEventName( VbaEvent ), RTL_TEXTENCODING_UTF8 ).getStr(), VbaEvent );
+        return sal_False; // return True or False, to me returning False sorta makes sense but...
+    }
 	SfxObjectShell* pShell = pDoc->GetDocumentShell();
 	if( !pShell )
 		return sal_False;
@@ -966,13 +980,12 @@ ScVbaEventsHelper::ProcessCompatibleVbaE
         {
             // if workbook open event do not be fired. fired it before 
             // workbook activate event to compatible with MSO.
-            if( !mbOpened )
+            if( mbOpened )
             {
-                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_OPEN, aArgs );
+                 processVbaEventMacro_noreturn( VBAEVENT_WORKBOOK_ACTIVATE );
+                 // workbook window activate event same as this one
+                 ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_WINDOWACTIVATE, aArgs );
             }
-            processVbaEventMacro_noreturn( VBAEVENT_WORKBOOK_ACTIVATE );
-            // workbook window activate event same as this one
-            ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_WINDOWACTIVATE, aArgs );
             break;
         }
 		case VBAEVENT_WORKBOOK_DEACTIVATE          :
@@ -991,6 +1004,7 @@ ScVbaEventsHelper::ProcessCompatibleVbaE
             {
                 processVbaEventMacro_noreturn( VBAEVENT_WORKBOOK_OPEN );
                 mbOpened = sal_True;
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_ACTIVATE, aArgs );
             }
             // register the window listener.
             if( !mpWindowListener )
diff --git sc/source/ui/vba/vbaeventshelper.hxx sc/source/ui/vba/vbaeventshelper.hxx
index fe556be..4ac8b76 100644
--- sc/source/ui/vba/vbaeventshelper.hxx
+++ sc/source/ui/vba/vbaeventshelper.hxx
@@ -44,7 +44,6 @@
 #include <com/sun/star/document/XVbaEventsHelper.hpp>
 #include "vbahelper.hxx"
 
-using namespace com::sun::star;
 
 typedef ::cppu::WeakImplHelper1< com::sun::star::document::XVbaEventsHelper > VBAWorkbookEvent_BASE;
 
@@ -59,21 +58,21 @@ private:
     css::uno::Reference< css::uno::XComponentContext > m_xContext;
     VbaWindowListener* mpWindowListener;
     sal_Bool mbOpened;
-
+    sal_Bool mbIgnoreEvents;
 	String getSheetModuleName( SCTAB nTab );
 	String workbookMacroExists( SfxObjectShell* pShell, const String& sMod, const String& sMacro );
 
-	uno::Any createWorkSheet( SfxObjectShell* pShell, SCTAB nTab );
-	uno::Any createRange( const uno::Any& aRange );
-	uno::Any createHyperlink( const uno::Any& rCell );
-	uno::Any createWindow( SfxObjectShell* pShell );
-	sal_Bool executeWorkBookMacro( SfxObjectShell* pShell, const String& sMacroName, uno::Sequence< uno::Any >& aArgs, uno::Any& aRet );
+	css::uno::Any createWorkSheet( SfxObjectShell* pShell, SCTAB nTab );
+	css::uno::Any createRange( const css::uno::Any& aRange );
+	css::uno::Any createHyperlink( const css::uno::Any& rCell );
+	css::uno::Any createWindow( SfxObjectShell* pShell );
+	sal_Bool executeWorkBookMacro( SfxObjectShell* pShell, const String& sMacroName, css::uno::Sequence< css::uno::Any >& aArgs, css::uno::Any& aRet );
     sal_Bool processVbaEventWithCancel( const sal_Int32 nEventId );
 	sal_Bool processDocBeforeSaveMacro( sal_Bool bSaveAsUI );
     void processVbaEventMacro_noreturn( const sal_Int32 nEventId );
-    void processVbaEventMacroWithArgs( const sal_Int32 nEventId, uno::Sequence< uno::Any >& rArgs );
+    void processVbaEventMacroWithArgs( const sal_Int32 nEventId, css::uno::Sequence< css::uno::Any >& rArgs );
     void WorkbookWindowMacro( const sal_Int32 nHint );
-    SCTAB getTabFromArgs( const uno::Sequence< uno::Any > aArgs, const sal_Int32 nPos );
+    SCTAB getTabFromArgs( const css::uno::Sequence< css::uno::Any > aArgs, const sal_Int32 nPos );
 protected:
     rtl::OUString GetEventName( const sal_Int32 nId );
     rtl::OUString getMacroPath( const sal_Int32 nEventId, const SCTAB nTab );
@@ -83,9 +82,11 @@ public:
     ScVbaEventsHelper( css::uno::Sequence< css::uno::Any > const& aArgs, css::uno::Reference< css::uno::XComponentContext > const& xContext );
     ~ScVbaEventsHelper();
 	ScDocument* getDocument() { return pDoc; };
-	sal_Bool executeSheetMacro( USHORT nEvent, SCTAB nTab, uno::Sequence< uno::Any >& rArgs );
+	sal_Bool executeSheetMacro( USHORT nEvent, SCTAB nTab, css::uno::Sequence< css::uno::Any >& rArgs );
     // XVBAWorkbookEventHelper
-    virtual sal_Bool SAL_CALL ProcessCompatibleVbaEvent( sal_Int32 VbaEvent, const uno::Sequence< uno::Any >& aArgs ) throw (uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getIgnoreEvents() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setIgnoreEvents( ::sal_Bool _ignoreevents ) throw (css::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL ProcessCompatibleVbaEvent( sal_Int32 VbaEvent, const css::uno::Sequence< css::uno::Any >& aArgs ) throw (css::uno::RuntimeException);
 };
 
 #endif
diff --git svx/source/msfilter/svxmsbas.cxx svx/source/msfilter/svxmsbas.cxx
index e647cf8..d78c1e4 100644
--- svx/source/msfilter/svxmsbas.cxx
+++ svx/source/msfilter/svxmsbas.cxx
@@ -403,20 +403,23 @@ BOOL SvxImportMSVBasic::ImportCode_Impl(
 
 					Any aSourceAny;
                     OSL_TRACE("erm %d", mType );
-                    if (  xVBAObjectForCodeName.is() && ( mType == ModuleType::Document || mType == ModuleType::Class || mType == ModuleType::Form ) )
+                    if ( /*xVBAObjectForCodeName.is() && */ ( mType == ModuleType::Document || mType == ModuleType::Class || mType == ModuleType::Form ) )
                     {
                         OSL_TRACE("vba processing  %d", mType );
                         script::ModuleInfo sModuleInfo;
                         sModuleInfo.ModuleName = aModName;
                         sModuleInfo.ModuleSource = aSource;
                         sModuleInfo.ModuleType = mType;
-                        if ( mType == ModuleType::Form )
+// ok, try always passing the model to basic, should fit
+//                        if ( mType == ModuleType::Form )
                             // hack, the module ( in document basic should...
                             // know the XModel... ) needs fixing in basic 
                             // somewhere
                             sModuleInfo.ModuleObject.set( rDocSh.GetModel(), UNO_QUERY );
+/*
                         else if ( mType != ModuleType::Class )
                             sModuleInfo.ModuleObject.set( xVBAObjectForCodeName->getByName( aModName ), UNO_QUERY );
+*/
                         aSourceAny <<= sModuleInfo;
                     }
                     else
diff --git xmlscript/inc/xmlscript/xmllib_imexp.hxx xmlscript/inc/xmlscript/xmllib_imexp.hxx
index 9a3048f..81d8d43 100644
--- xmlscript/inc/xmlscript/xmllib_imexp.hxx
+++ xmlscript/inc/xmlscript/xmllib_imexp.hxx
@@ -34,11 +34,21 @@
 #include <com/sun/star/uno/Sequence.hxx>
 
 #include "xmlscript/xmlns.h"
-
+#include <hash_map>
+#include <com/sun/star/script/ModuleType.hpp>
 
 namespace xmlscript
 {
+struct ObjectModuleDesc
+{
+    rtl::OUString msObjectName;
+    sal_Int32 mnModuleType;
+ObjectModuleDesc() : mnModuleType( ::com::sun::star::script::ModuleType::Normal ) {}
+};
 
+typedef  std::hash_map< rtl::OUString,
+ObjectModuleDesc, ::rtl::OUStringHash,
+::std::equal_to< ::rtl::OUString > > ObjectModuleDescHash;
 //==============================================================================
 // Library container export
 // HACK C++ struct to transport info. Later the container 
@@ -53,14 +63,19 @@ struct LibDescriptor
 	sal_Bool bPasswordProtected;
 	::com::sun::star::uno::Sequence< ::rtl::OUString > aElementNames;
 	sal_Bool bPreload;
+	ObjectModuleDescHash hCodeNameToObjDesc;
 };
 
+typedef std::hash_map< rtl::OUString, rtl::OUString, ::rtl::OUStringHash, ::std::equal_to< ::rtl::OUString > > CodeNameHash;
+
 struct LibDescriptorArray
 {
     LibDescriptor* mpLibs;
     sal_Int32 mnLibCount;
 
-    LibDescriptorArray( void ) { mpLibs = NULL; mnLibCount = 0; }
+    CodeNameHash mCodeNames;
+    bool mbVBAMode;
+    LibDescriptorArray( void ) { mpLibs = NULL; mnLibCount = 0; mbVBAMode = false; }
     LibDescriptorArray( sal_Int32 nLibCount );
 
     ~LibDescriptorArray();
@@ -79,6 +94,11 @@ SAL_CALL exportLibraryContainer(
 SAL_CALL importLibraryContainer( LibDescriptorArray* pLibArray )
 		SAL_THROW( (::com::sun::star::uno::Exception) );
 
+::com::sun::star::uno::Reference<
+    ::com::sun::star::xml::sax::XDocumentHandler >
+SAL_CALL importLibraryCodeNames( LibDescriptorArray* pLibArray )
+		SAL_THROW( (::com::sun::star::uno::Exception) );
+
 
 void
 SAL_CALL exportLibrary(
diff --git xmlscript/source/xmllib_imexp/imp_share.hxx xmlscript/source/xmllib_imexp/imp_share.hxx
index d602103..fdc0536 100644
--- xmlscript/source/xmllib_imexp/imp_share.hxx
+++ xmlscript/source/xmllib_imexp/imp_share.hxx
@@ -220,7 +220,6 @@ class LibrariesElement : public LibEleme
     
 protected:
     vector< LibDescriptor > mLibDescriptors;
-
 public:
     virtual Reference< xml::input::XElement > SAL_CALL startChildElement(
         sal_Int32 nUid, OUString const & rLocalName,
@@ -244,7 +243,7 @@ class LibraryElement : public LibElement
 {
 protected:
     vector< OUString > mElements;
-
+    ObjectModuleDescHash mObjectDescs;
 public:
 
     virtual Reference< xml::input::XElement > SAL_CALL startChildElement(
diff --git xmlscript/source/xmllib_imexp/xmllib_import.cxx xmlscript/source/xmllib_imexp/xmllib_import.cxx
index b533d37..b04fb4e 100644
--- xmlscript/source/xmllib_imexp/xmllib_import.cxx
+++ xmlscript/source/xmllib_imexp/xmllib_import.cxx
@@ -44,7 +44,20 @@ namespace xmlscript
 {
 
 //##################################################################################################
-
+sal_Int32 lcl_getModuleTypeForStringType( const rtl::OUString& rsType )
+{
+    // default to normal unknown
+    sal_Int32 nType = com::sun::star::script::ModuleType::Unknown;
+    if ( rsType.equalsIgnoreAsciiCase( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("class") ) ) )
+        nType = com::sun::star::script::ModuleType::Class;
+    else if ( rsType.equalsIgnoreAsciiCase( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("form") ) ) )
+        nType = com::sun::star::script::ModuleType::Form;
+    else if ( rsType.equalsIgnoreAsciiCase( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("document") ) ) )
+        nType = com::sun::star::script::ModuleType::Document;
+    else if ( rsType.equalsIgnoreAsciiCase( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("normal") ) ) )
+        nType = com::sun::star::script::ModuleType::Normal;
+    return nType;
+}
 //__________________________________________________________________________________________________
 Reference< xml::input::XElement > LibElementBase::getParent()
     throw (RuntimeException)
@@ -185,6 +198,13 @@ Reference< xml::input::XElement > Librar
     }
     else if (mpLibArray && rLocalName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM("libraries") ))
     {
+        rtl::OUString sVbaCompatMode;
+        sVbaCompatMode =  xAttributes->getValueByUidName(
+            XMLNS_LIBRARY_UID,
+            OUString( RTL_CONSTASCII_USTRINGPARAM("vbaenabled") ) );
+
+        if ( sVbaCompatMode.equalsIgnoreAsciiCase( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("true") ) ) )
+            mpLibArray->mbVBAMode = true;
         return new LibrariesElement( rLocalName, xAttributes, 0, this );
     }
     else if (mpLibDesc && rLocalName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM("library") ))
@@ -269,6 +289,19 @@ Reference< xml::input::XElement > Librar
         mLibDescriptors.push_back( aDesc );
         return new LibraryElement( rLocalName, xAttributes, this, _pImport );
     }
+    // CodeNames are only relevant for the container ( e.g. the document )
+    else if (rLocalName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM("codename") ))
+    {
+        rtl::OUString sCodeName =  xAttributes->getValueByUidName(
+            _pImport->XMLNS_LIBRARY_UID,
+            OUString( RTL_CONSTASCII_USTRINGPARAM("name") ) );
+        rtl::OUString sObjectName =  xAttributes->getValueByUidName(
+            _pImport->XMLNS_LIBRARY_UID,
+            OUString( RTL_CONSTASCII_USTRINGPARAM("objectname") ) );
+        if ( ( sCodeName.getLength() > 0 ) && ( sObjectName.getLength() > 0 ) )
+                _pImport->mpLibArray->mCodeNames[ sObjectName ] = sCodeName;
+        return new LibElementBase( rLocalName, xAttributes, this, _pImport );
+    }
     else
     {
         throw xml::sax::SAXException(
@@ -311,7 +344,13 @@ Reference< xml::input::XElement > Librar
             OUString( RTL_CONSTASCII_USTRINGPARAM("name") ) ) );
         if (aValue.getLength())
             mElements.push_back( aValue );
-
+        ObjectModuleDesc aDesc;
+        aDesc.mnModuleType = lcl_getModuleTypeForStringType( 
+          xAttributes->getValueByUidName(
+            _pImport->XMLNS_LIBRARY_UID,
+            OUString( RTL_CONSTASCII_USTRINGPARAM("moduletype") ) ) );
+        if ( aValue.getLength() && aDesc.mnModuleType != ::com::sun::star::script::ModuleType::Unknown )
+             mObjectDescs[ aValue ] = aDesc;
         return new LibElementBase( rLocalName, xAttributes, this, _pImport );
     }
     else
@@ -335,6 +374,7 @@ void LibraryElement::endElement()
     if( !pLib )
         pLib = &static_cast< LibrariesElement* >( _pParent )->mLibDescriptors.back();
     pLib->aElementNames = aElementNames;
+    pLib->hCodeNameToObjDesc = mObjectDescs;
 }
 
 
@@ -348,6 +388,16 @@ SAL_CALL importLibraryContainer( LibDesc
         static_cast< xml::input::XRoot * >( new LibraryImport( pLibArray ) ) );
 }
 
+
+Reference< ::com::sun::star::xml::sax::XDocumentHandler >
+SAL_CALL importLibraryCodeNames( LibDescriptorArray* pLibArray )
+        SAL_THROW( (Exception) )
+{
+    return ::xmlscript::createDocumentHandler(
+        static_cast< xml::input::XRoot * >( new LibraryImport( pLibArray ) ) );
+}
+
+
 //##################################################################################################
 
 ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XDocumentHandler >
@@ -365,6 +415,7 @@ LibDescriptorArray::LibDescriptorArray( 
 {
     mnLibCount = nLibCount;
     mpLibs = new LibDescriptor[ mnLibCount ];
+    mbVBAMode = false;
 }
 
 LibDescriptorArray::~LibDescriptorArray()
