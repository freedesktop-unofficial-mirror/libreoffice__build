diff -rup /data4/latestBuild/ooo-build/build/oog680-m5/sc/inc/document.hxx sc/inc/document.hxx
--- /data4/latestBuild/ooo-build/build/oog680-m5/sc/inc/document.hxx	2007-12-10 12:08:57.000000000 +0000
+++ sc/inc/document.hxx	2007-12-09 15:34:24.000000000 +0000
@@ -304,6 +304,7 @@ private:
 
 	com::sun::star::uno::Sequence<sal_Int8>	aProtectPass;
 	String              aDocName;                       // opt: Dokumentname
+	String              aDocCodeName;                       // opt: Dokumentname
 	ScRangePairListRef	xColNameRanges;
 	ScRangePairListRef	xRowNameRanges;
 
@@ -443,6 +444,8 @@ public:
 
 	const String& 	GetName() const { return aDocName; }
 	void			SetName( const String& r ) { aDocName = r; }
+	const String& 	GetCodeName() const { return aDocCodeName; }
+	void			SetCodeName( const String& r ) { aDocCodeName = r; }
 
 	void			GetDocStat( ScDocStat& rDocStat );
 
@@ -530,6 +533,8 @@ SC_DLLPUBLIC	ScDBCollection*	GetDBCollec
 
 	BOOL			HasTable( SCTAB nTab ) const;
 	SC_DLLPUBLIC BOOL			GetName( SCTAB nTab, String& rName ) const;
+	SC_DLLPUBLIC BOOL			GetCodeName( SCTAB nTab, String& rName ) const;
+	SC_DLLPUBLIC BOOL			SetCodeName( SCTAB nTab, String& rName );
 	BOOL			GetTable( const String& rName, SCTAB& rTab ) const;
 	inline SCTAB	GetTableCount() const { return nMaxTableNumber; }
 	SvNumberFormatterIndexTable* GetFormatExchangeList() const { return pFormatExchangeList; }
diff -rup /data4/latestBuild/ooo-build/build/oog680-m5/sc/inc/servuno.hxx sc/inc/servuno.hxx
--- /data4/latestBuild/ooo-build/build/oog680-m5/sc/inc/servuno.hxx	2007-12-10 12:08:57.000000000 +0000
+++ sc/inc/servuno.hxx	2007-11-27 13:59:17.000000000 +0000
@@ -102,8 +102,9 @@ class ScDocShell;
 
 #define SC_SERVICE_FORMULAPARS  38
 #define SC_SERVICE_OPCODEMAPPER 39
+#define SC_SERVICE_VBACONTROL_EVENTS 40
 
-#define SC_SERVICE_COUNT        40
+#define SC_SERVICE_COUNT        41
 #define SC_SERVICE_INVALID		USHRT_MAX
 
 
diff -rup /data4/latestBuild/ooo-build/build/oog680-m5/sc/inc/table.hxx sc/inc/table.hxx
--- /data4/latestBuild/ooo-build/build/oog680-m5/sc/inc/table.hxx	2007-12-10 12:02:44.000000000 +0000
+++ sc/inc/table.hxx	2007-12-09 15:34:24.000000000 +0000
@@ -102,6 +102,7 @@ private:
 	ScColumn		aCol[MAXCOLCOUNT];
 
 	String			aName;
+	String			aCodeName;
 	String			aComment;
 	BOOL			bScenario;
 	BOOL			bLayoutRTL;
@@ -232,6 +233,9 @@ public:
 	void		GetName( String& rName ) const;
 	void		SetName( const String& rNewName );
 
+	void		GetCodeName( String& rName ) const {  rName = aCodeName; }
+	void		SetCodeName( const String& rNewName ) { aCodeName = rNewName; }
+
     const String&   GetUpperName() const;
 
 	const String&	GetPageStyle() const					{ return aPageStyle; }
diff -rup /data4/latestBuild/ooo-build/build/oog680-m5/sc/source/core/data/document.cxx sc/source/core/data/document.cxx
--- /data4/latestBuild/ooo-build/build/oog680-m5/sc/source/core/data/document.cxx	2007-12-10 12:02:49.000000000 +0000
+++ sc/source/core/data/document.cxx	2007-12-09 16:16:31.000000000 +0000
@@ -161,6 +161,32 @@ BOOL ScDocument::GetName( SCTAB nTab, St
 	return FALSE;
 }
 
+BOOL ScDocument::SetCodeName( SCTAB nTab, String& rName ) 
+{
+	if (VALIDTAB(nTab))
+	{
+		if (pTab[nTab])
+		{
+			pTab[nTab]->SetCodeName( rName );
+			return TRUE;
+		}
+	}
+	OSL_TRACE( "**** can't set code name %s", rtl::OUStringToOString( rName, RTL_TEXTENCODING_UTF8 ).getStr() );
+	return FALSE;
+}
+
+BOOL ScDocument::GetCodeName( SCTAB nTab, String& rName ) const
+{
+	if (VALIDTAB(nTab))
+		if (pTab[nTab])
+		{
+			pTab[nTab]->GetCodeName( rName );
+			return TRUE;
+		}
+	rName.Erase();
+	return FALSE;
+}
+
 
 BOOL ScDocument::GetTable( const String& rName, SCTAB& rTab ) const
 {
diff -rup /data4/latestBuild/ooo-build/build/oog680-m5/sc/source/core/data/table1.cxx sc/source/core/data/table1.cxx
--- /data4/latestBuild/ooo-build/build/oog680-m5/sc/source/core/data/table1.cxx	2007-12-10 12:08:57.000000000 +0000
+++ sc/source/core/data/table1.cxx	2007-12-09 15:34:25.000000000 +0000
@@ -129,6 +129,7 @@ extern BOOL bIsOlk, bOderSo;
 ScTable::ScTable( ScDocument* pDoc, SCTAB nNewTab, const String& rNewName,
 					BOOL bColInfo, BOOL bRowInfo ) :
 	aName( rNewName ),
+	aCodeName( rNewName ),
 	bScenario( FALSE ),
 	bLayoutRTL( FALSE ),
     bLoadingRTL( FALSE ),
diff -rup /data4/latestBuild/ooo-build/build/oog680-m5/sc/source/filter/excel/excdoc.cxx sc/source/filter/excel/excdoc.cxx
--- /data4/latestBuild/ooo-build/build/oog680-m5/sc/source/filter/excel/excdoc.cxx	2007-12-10 12:02:44.000000000 +0000
+++ sc/source/filter/excel/excdoc.cxx	2007-12-09 15:34:25.000000000 +0000
@@ -168,7 +168,7 @@ void ExcTable::FillAsHeader( ExcBoundshe
 	String	aTmpString;
     SCTAB  nScTabCount     = rTabInfo.GetScTabCount();
     UINT16  nExcTabCount    = rTabInfo.GetXclTabCount();
-    UINT16  nCodenames      = static_cast< UINT16 >( GetExtDocOptions().GetCodeNameCount() );
+    UINT16  nCodenames      = nScTabCount;
 
 	rR.pObjRecs = NULL;				// per sheet
 
@@ -182,7 +182,8 @@ void ExcTable::FillAsHeader( ExcBoundshe
         if( HasVbaStorage() )
 		{
 			Add( new XclObproj );
-            const String& rCodeName = GetExtDocOptions().GetDocSettings().maGlobCodeName;
+            //const String& rCodeName = GetExtDocOptions().GetDocSettings().maGlobCodeName;
+            const String rCodeName = GetDoc().GetCodeName();
             if( rCodeName.Len() )
                 Add( new XclCodename( rCodeName ) );
 		}
@@ -403,8 +404,12 @@ void ExcTable::FillAsTable( size_t nCode
         Add( new XclExpCondFormatBuffer( GetRoot() ) );
 
         if( HasVbaStorage() )
-            if( nCodeNameIdx < GetExtDocOptions().GetCodeNameCount() )
-                Add( new XclCodename( GetExtDocOptions().GetCodeName( nCodeNameIdx ) ) );
+            if( nCodeNameIdx < GetTabInfo().GetScTabCount() )
+            {
+                String sCodeName;
+                rDoc.GetCodeName( nCodeNameIdx, sCodeName );
+                Add( new XclCodename( sCodeName ) );
+            }
 	}
 
     // list of HLINK records, generated by the cell table
@@ -429,7 +434,7 @@ void ExcTable::FillAsEmptyTable( size_t 
 {
     InitializeTable( mnScTab );
 
-    if( HasVbaStorage() && (nCodeNameIdx < GetExtDocOptions().GetCodeNameCount()) )
+    if( HasVbaStorage() && (nCodeNameIdx < GetTabInfo().GetScTabCount()) )
     {
         if( GetBiff() <= EXC_BIFF5 )
         {
@@ -438,7 +443,9 @@ void ExcTable::FillAsEmptyTable( size_t 
         else
         {
             Add( new ExcBof8 );
-            Add( new XclCodename( GetExtDocOptions().GetCodeName( nCodeNameIdx ) ) );
+            String sCodeName;
+            GetDoc().GetCodeName( nCodeNameIdx, sCodeName );
+            Add( new XclCodename( sCodeName  ) );
         }
         // sheet view settings: WINDOW2, SCL, PANE, SELECTION
         aRecList.AppendNewRecord( new XclExpTabViewSettings( GetRoot(), mnScTab ) );
@@ -480,7 +487,7 @@ void ExcDocument::ReadDoc( void )
     aHeader.FillAsHeader( maBoundsheetList );
 
     SCTAB nScTab = 0, nScTabCount = GetTabInfo().GetScTabCount();
-    size_t nCodeNameIdx = 0, nCodeNameCount = GetExtDocOptions().GetCodeNameCount();
+    size_t nCodeNameIdx = 0, nCodeNameCount = nScTabCount;
 
     for( ; nScTab < nScTabCount; ++nScTab )
     {
diff -rup /data4/latestBuild/ooo-build/build/oog680-m5/sc/source/filter/excel/excimp8.cxx sc/source/filter/excel/excimp8.cxx
--- /data4/latestBuild/ooo-build/build/oog680-m5/sc/source/filter/excel/excimp8.cxx	2007-12-10 12:02:44.000000000 +0000
+++ sc/source/filter/excel/excimp8.cxx	2007-12-09 15:59:06.000000000 +0000
@@ -148,7 +148,7 @@ using namespace com::sun::star;
 
 
 ImportExcel8::ImportExcel8( XclImpRootData& rImpData, SvStream& rStrm ) :
-    ImportExcel( rImpData, rStrm )
+    ImportExcel( rImpData, rStrm ), mnTab(0)
 {
 	delete pFormConv;
 
@@ -293,10 +293,17 @@ void ImportExcel8::Codename( BOOL bWorkb
         String aName( aIn.ReadUniString() );
         if( aName.Len() )
         {
+            OSL_TRACE("****** C O D E N A M E     %s - tab? %d", rtl::OUStringToOString( aName, RTL_TEXTENCODING_UTF8 ).getStr(), mnTab );
             if( bWorkbookGlobals )
+            {
                 GetExtDocOptions().GetDocSettings().maGlobCodeName = aName;
+                GetDoc().SetCodeName( aName );
+            }
             else
+            {
                 GetExtDocOptions().AppendCodeName( aName );
+                GetDoc().SetCodeName( mnTab++, aName );
+            }
         }
 	}
 }
diff -rup /data4/latestBuild/ooo-build/build/oog680-m5/sc/source/filter/excel/makefile.mk sc/source/filter/excel/makefile.mk
--- /data4/latestBuild/ooo-build/build/oog680-m5/sc/source/filter/excel/makefile.mk	2007-12-10 12:08:57.000000000 +0000
+++ sc/source/filter/excel/makefile.mk	2007-11-21 15:46:09.000000000 +0000
@@ -51,6 +51,11 @@ PROJECTPCHSOURCE=..\pch\filt_pch
 .INCLUDE :  sc.mk
 .INCLUDE :  $(PRJ)$/util$/makefile.pmk
 
+.IF "$(ENABLE_VBA)"=="YES"
+        CDEFS+=-DENABLE_VBA
+        INCPRE=$(INCCOM)$/vbaobj
+.ENDIF
+
 # --- Files --------------------------------------------------------
 
 SLOFILES =	\
diff -rup /data4/latestBuild/ooo-build/build/oog680-m5/sc/source/filter/excel/xelink.cxx sc/source/filter/excel/xelink.cxx
--- /data4/latestBuild/ooo-build/build/oog680-m5/sc/source/filter/excel/xelink.cxx	2007-05-22 20:47:21.000000000 +0100
+++ sc/source/filter/excel/xelink.cxx	2007-12-09 15:34:25.000000000 +0000
@@ -1296,7 +1296,6 @@ XclExpSupbookBuffer::XclExpSupbookBuffer
 {
     XclExpTabInfo& rTabInfo = GetTabInfo();
     sal_uInt16 nXclCnt = rTabInfo.GetXclTabCount();
-    sal_uInt16 nCodeCnt = static_cast< sal_uInt16 >( GetExtDocOptions().GetCodeNameCount() );
     size_t nCount = nXclCnt + rTabInfo.GetXclExtTabCount();
 
     DBG_ASSERT( nCount > 0, "XclExpSupbookBuffer::XclExpSupbookBuffer - no sheets to export" );
@@ -1305,7 +1304,7 @@ XclExpSupbookBuffer::XclExpSupbookBuffer
         maSBIndexVec.resize( nCount );
 
         // self-ref SUPBOOK first of list
-        XclExpSupbookRef xSupbook( new XclExpSupbook( GetRoot(), ::std::max( nXclCnt, nCodeCnt ) ) );
+        XclExpSupbookRef xSupbook( new XclExpSupbook( GetRoot(), nXclCnt ) );
         mnOwnDocSB = Append( xSupbook );
         for( sal_uInt16 nXclTab = 0; nXclTab < nXclCnt; ++nXclTab )
             maSBIndexVec[ nXclTab ].Set( mnOwnDocSB, nXclTab );
diff -rup /data4/latestBuild/ooo-build/build/oog680-m5/sc/source/filter/inc/excimp8.hxx sc/source/filter/inc/excimp8.hxx
--- /data4/latestBuild/ooo-build/build/oog680-m5/sc/source/filter/inc/excimp8.hxx	2007-12-10 12:02:44.000000000 +0000
+++ sc/source/filter/inc/excimp8.hxx	2007-12-09 15:34:25.000000000 +0000
@@ -69,6 +69,7 @@ class XclImpStream;
 
 class ImportExcel8 : public ImportExcel
 {
+        SCTAB mnTab;
 	protected:
         ExcScenarioList         aScenList;
 
diff -rup /data4/latestBuild/ooo-build/build/oog680-m5/sc/source/ui/docshell/docsh.cxx sc/source/ui/docshell/docsh.cxx
--- /data4/latestBuild/ooo-build/build/oog680-m5/sc/source/ui/docshell/docsh.cxx	2007-12-10 12:08:57.000000000 +0000
+++ sc/source/ui/docshell/docsh.cxx	2007-12-09 15:34:25.000000000 +0000
@@ -208,11 +208,8 @@ const static rtl::OUString sUrlPart2 = r
 	rtl::OUString sCodeName = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ThisWorkbook") );
 	if ( pShell )
 	{
-		if ( ScExtDocOptions* pExtDocOpts = pShell->GetDocument()->GetExtDocOptions() )
-		{
-			if ( pExtDocOpts->GetDocSettings().maGlobCodeName.Len() > 0 ) 
-				sCodeName = pExtDocOpts->GetDocSettings().maGlobCodeName;
-		}
+		if ( ScDocument* pDoc  = pShell->GetDocument() )
+			sCodeName = pDoc->GetCodeName();
 	}
 	return sCodeName;
 }	
diff -rup /data4/latestBuild/ooo-build/build/oog680-m5/sc/source/ui/unoobj/makefile.mk sc/source/ui/unoobj/makefile.mk
--- /data4/latestBuild/ooo-build/build/oog680-m5/sc/source/ui/unoobj/makefile.mk	2007-12-10 12:08:57.000000000 +0000
+++ sc/source/ui/unoobj/makefile.mk	2007-11-30 17:44:44.000000000 +0000
@@ -54,6 +54,8 @@ AUTOSEG=true
 .INCLUDE :  sc.mk
 .INCLUDE :  $(PRJ)$/util$/makefile.pmk
 
+
+INCPRE=$(INCCOM)$/vbaobj
 # --- Files --------------------------------------------------------
 SLO1FILES =  \
         $(SLO)$/docuno.obj \
@@ -119,6 +121,7 @@ NOOPTFILES= \
              $(SLO)$/cellsuno.obj
 .ENDIF
 
+
 # --- Tagets -------------------------------------------------------
 
 .INCLUDE :  target.mk
diff -rup /data4/latestBuild/ooo-build/build/oog680-m5/sc/source/ui/unoobj/servuno.cxx sc/source/ui/unoobj/servuno.cxx
--- /data4/latestBuild/ooo-build/build/oog680-m5/sc/source/ui/unoobj/servuno.cxx	2007-12-10 12:08:57.000000000 +0000
+++ sc/source/ui/unoobj/servuno.cxx	2007-12-10 12:07:00.000000000 +0000
@@ -49,6 +49,8 @@
 #ifndef _COM_SUN_STAR_SHEET_XSPREADSHEETDOCUMENT_HPP_
 #include <com/sun/star/sheet/XSpreadsheetDocument.hpp>
 #endif
+#include <com/sun/star/drawing/XDrawPagesSupplier.hpp>
+#include <com/sun/star/drawing/XControlShape.hpp>
 
 #include "servuno.hxx"
 #include "unonames.hxx"
@@ -77,8 +79,80 @@
 #include <svx/xmlgrhlp.hxx>
 #endif
 
+#include <com/sun/star/script/XEventAttacherManager.hpp>
+#include <com/sun/star/form/XFormsSupplier.hpp>
+#include <org/openoffice/vba/XVBAToOOEventDescGen.hpp>
+#include <org/openoffice/vba/XFakeVBAEventDescriptorSupplier.hpp>
+#include <comphelper/processfactory.hxx>
+#include "scextopt.hxx"
+
 using namespace ::com::sun::star;
 
+typedef ::cppu::WeakImplHelper1< org::openoffice::vba::XFakeVBAEventDescriptorSupplier > Initialization_BASE;
+
+class ScFakeVBACntrlEvtSupport : public Initialization_BASE
+{
+	ScDocShell* mpDoc;
+	ScFakeVBACntrlEvtSupport(); 
+	uno::Sequence< script::ScriptEventDescriptor > getFakeEvents( const uno::Reference< uno::XInterface >& xIf, sal_Int32 pageIndex )
+	{
+		rtl::OUString sServiceName;
+		uno::Reference< beans::XPropertySet > xProps( xIf, uno::UNO_QUERY );
+		xProps->getPropertyValue( rtl::OUString::createFromAscii("DefaultControl" ) ) >>= sServiceName;
+		OSL_TRACE("Control serviceName is %s", rtl::OUStringToOString( sServiceName, RTL_TEXTENCODING_UTF8 ).getStr() );
+		xProps.set( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+		uno::Reference<uno::XComponentContext > xContext( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), uno::UNO_QUERY_THROW );
+		uno::Reference< org::openoffice::vba::XVBAToOOEventDescGen > xEvtDescGen( xContext->getServiceManager()->createInstanceWithContext( rtl::OUString::createFromAscii( "org.openoffice.vba.VBAToOOEventDesc" ), xContext ), uno::UNO_QUERY_THROW );
+		uno::Sequence< rtl::OUString > sHandlerExtns;
+		String sLibModName;
+		mpDoc->GetDocument()->GetCodeName( pageIndex, sLibModName );
+
+		if( !sLibModName.Len() )
+			mpDoc->GetDocument()->GetName( pageIndex, sLibModName );
+
+		uno::Sequence< script::ScriptEventDescriptor > aFakeEvents = xEvtDescGen->getEventDescriptions( xContext->getServiceManager()->createInstanceWithContext( sServiceName, xContext ), sLibModName, sHandlerExtns ) ;
+		return aFakeEvents;	
+	}
+public:
+	ScFakeVBACntrlEvtSupport( ScDocShell* pDoc ) : mpDoc( pDoc ) 
+	{
+		OSL_TRACE("*** In ScFakeVBACntrlEvtSupport ");
+	}
+	virtual uno::Sequence< com::sun::star::script::ScriptEventDescriptor > SAL_CALL getEventDescriptions( const uno::Reference< uno::XInterface >& xIf ) throw ( uno::RuntimeException )
+	{
+		OSL_TRACE( "*** In ScFakeVBACntrlEvtSupport::getEventDescriptions");
+		// need to find the page ( and index )  for this control
+		uno::Reference< drawing::XDrawPagesSupplier > xSupplier( mpDoc->GetModel(), uno::UNO_QUERY_THROW );
+	
+		uno::Reference< container::XIndexAccess > xIndex( xSupplier->getDrawPages(), uno::UNO_QUERY_THROW );
+
+		sal_Int32 nLen = xIndex->getCount();
+		bool bMatched = false;
+		uno::Sequence< script::ScriptEventDescriptor > aFakeEvents;
+		for ( sal_Int32 index = 0; index < nLen; ++index )
+		{
+			uno::Reference< form::XFormsSupplier >  xFormSupplier( xIndex->getByIndex( index ), uno::UNO_QUERY_THROW );
+			uno::Reference< container::XIndexAccess > xFormIndex( xFormSupplier->getForms(), uno::UNO_QUERY_THROW );
+			// get the www-standard container
+			uno::Reference< container::XIndexAccess > xFormControls( xFormIndex->getByIndex(0), uno::UNO_QUERY_THROW );
+			sal_Int32 nCntrls = xFormControls->getCount();
+			for( sal_Int32 cIndex = 0; cIndex < nCntrls; ++cIndex )
+			{
+				uno::Reference< uno::XInterface > xControl( xFormControls->getByIndex( cIndex ), uno::UNO_QUERY_THROW );	
+				bMatched = ( xControl == xIf );
+				if ( bMatched )
+				{
+					aFakeEvents = getFakeEvents( xIf, index );
+					break;
+				}
+			}
+			if ( bMatched )
+				break;
+		}
+		// Probably should throw here
+		return aFakeEvents;
+	}
+};
 
 //------------------------------------------------------------------------
 
@@ -128,7 +202,8 @@ static const sal_Char* __FAR_DATA aProvN
 
         SC_SERVICENAME_CHDATAPROV,                  // SC_SERVICE_CHDATAPROV
         SC_SERVICENAME_FORMULAPARS,                 // SC_SERVICE_FORMULAPARS
-        SC_SERVICENAME_OPCODEMAPPER                 // SC_SERVICE_OPCODEMAPPER
+        SC_SERVICENAME_OPCODEMAPPER,                // SC_SERVICE_OPCODEMAPPER
+        "org.openoffice.vba.controlevents",         // SC_SERVICE_VBACONTROL_EVENTS
 	};
 
 //
@@ -180,7 +255,8 @@ static const sal_Char* __FAR_DATA aOldNa
         "",                                         // SC_SERVICE_SHEETDOCSET
         "",                                         // SC_SERVICE_CHDATAPROV
         "",                                         // SC_SERVICE_FORMULAPARS
-        ""                                          // SC_SERVICE_OPCODEMAPPER
+        "",                                          // SC_SERVICE_OPCODEMAPPER
+        "",                                          // SC_SERVICE_VBACONTROL_EVENTS
 	};
 
 
@@ -373,6 +449,9 @@ uno::Reference<uno::XInterface> ScServic
         case SC_SERVICE_OPCODEMAPPER:
             xRet.set(static_cast<sheet::XFormulaOpCodeMapper*>(new ScFormulaOpCodeMapperObj));
             break;
+        case SC_SERVICE_VBACONTROL_EVENTS:
+            xRet.set(static_cast<org::openoffice::vba::XFakeVBAEventDescriptorSupplier*>(new ScFakeVBACntrlEvtSupport( pDocShell ) ));
+            break;
 	}
 	return xRet;
 }
diff -rup /data4/latestBuild/ooo-build/build/oog680-m5/sc/source/ui/view/tabview5.cxx sc/source/ui/view/tabview5.cxx
--- /data4/latestBuild/ooo-build/build/oog680-m5/sc/source/ui/view/tabview5.cxx	2007-12-10 12:02:49.000000000 +0000
+++ sc/source/ui/view/tabview5.cxx	2007-12-09 15:34:25.000000000 +0000
@@ -347,10 +347,15 @@ void ScTabView::TabChanged()
 	aViewData.GetDocument()->BroadcastUno( SfxSimpleHint( SC_HINT_TABLECHANGED ) );
 	ScExtDocOptions* pExtOptions = aViewData.GetDocument()->GetExtDocOptions();
 	String sSheetModuleName;
-	aViewData.GetDocument()->GetName( aViewData.GetTabNo(), sSheetModuleName);
+	aViewData.GetDocument()->GetCodeName( aViewData.GetTabNo(), sSheetModuleName);
+	if ( !sSheetModuleName.Len() > 0 )
+		aViewData.GetDocument()->GetName( aViewData.GetTabNo(), sSheetModuleName);
+
+/*
 	// Use code name if that exists
 	if ( pExtOptions )
 		sSheetModuleName = pExtOptions->GetCodeName( aViewData. GetTabNo() );
+*/
 	static String sUrl( RTL_CONSTASCII_USTRINGPARAM("vnd.sun.star.script:Standard") );
 	static String sUrl2( RTL_CONSTASCII_USTRINGPARAM("?language=Basic&location=document") );
 	static String sSheetActivateScript( RTL_CONSTASCII_USTRINGPARAM("Worksheet_Activate") );
diff -rup /data4/latestBuild/ooo-build/build/oog680-m5/forms/source/inc/InterfaceContainer.hxx forms/source/inc/InterfaceContainer.hxx
--- /data4/latestBuild/ooo-build/build/oog680-m5/forms/source/inc/InterfaceContainer.hxx	2007-01-29 15:46:36.000000000 +0000
+++ forms/source/inc/InterfaceContainer.hxx	2007-12-07 11:22:09.000000000 +0000
@@ -319,6 +319,9 @@ protected:
 	void implCheckIndex( const sal_Int32 _nIndex ) SAL_THROW( ( ::com::sun::star::lang::IndexOutOfBoundsException ) );
 
 private:
+	// hack for Vba Events
+	void fakeVbaEventsHack( sal_Int32 _nIndex );
+
 	// the runtime event format has changed from version SO5.2 to OOo
 	enum EventFormat
 	{
diff -rup /data4/latestBuild/ooo-build/build/oog680-m5/forms/source/misc/InterfaceContainer.cxx forms/source/misc/InterfaceContainer.cxx
--- /data4/latestBuild/ooo-build/build/oog680-m5/forms/source/misc/InterfaceContainer.cxx	2006-12-01 16:55:25.000000000 +0000
+++ forms/source/misc/InterfaceContainer.cxx	2007-12-07 13:08:05.000000000 +0000
@@ -105,11 +105,14 @@
 #include <rtl/logfile.hxx>
 #endif
 
+#include <com/sun/star/frame/XModel.hpp>
+#include <org/openoffice/vba/XFakeVBAEventDescriptorSupplier.hpp>
 //.........................................................................
 namespace frm
 {
 //.........................................................................
 
+using namespace ::com::sun::star::frame;
 using namespace ::com::sun::star::lang;
 using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star::beans;
@@ -127,6 +130,83 @@ namespace
 	}
 }
 
+bool
+lcl_hasVbaEvents( const Sequence< ScriptEventDescriptor >& sEvents  )
+{
+	const ScriptEventDescriptor* pDesc = sEvents.getConstArray();
+	const ScriptEventDescriptor* pEnd = ( pDesc + sEvents.getLength() );
+	for ( ; pDesc != pEnd; ++pDesc )
+	{
+		if ( pDesc->ScriptType.equals( rtl::OUString::createFromAscii( "VBAInterop" ) ) )
+			return true;
+	}
+	return false;
+}
+
+Sequence< ScriptEventDescriptor >
+lcl_stripVbaEvents( const Sequence< ScriptEventDescriptor >& sEvents )
+{
+	Sequence< ScriptEventDescriptor > sStripped( sEvents.getLength() );
+	
+	const ScriptEventDescriptor* pDesc = sEvents.getConstArray();
+	const ScriptEventDescriptor* pEnd = ( pDesc + sEvents.getLength() );
+	sal_Int32 nCopied = 0;
+	for ( ; pDesc != pEnd; ++pDesc )
+	{
+		if ( !pDesc->ScriptType.equals( rtl::OUString::createFromAscii( "VBAInterop" ) ) )
+		{
+			sStripped[ nCopied++ ] = *pDesc;
+		}
+	}
+	if ( nCopied )
+		sStripped.realloc( nCopied );
+	return sStripped;
+}
+
+void
+OInterfaceContainer::fakeVbaEventsHack(  sal_Int32 _nIndex )
+{
+	// we are dealing with form controls
+	try
+	{
+		Reference< XFormComponent > xForm( static_cast< XContainer* >(this), UNO_QUERY_THROW );
+		// grand-parent should be the model, no parent ? if not
+		// we'll ignore,  we'll get called back here  anyway )
+		Reference< XChild > xChild(  xForm->getParent(), UNO_QUERY_THROW );
+		Reference< XModel > xDocOwner( xChild->getParent(), UNO_QUERY );
+		OSL_TRACE(" Is DOC ????? %s", xDocOwner.is() ? "true" : "false" );
+		if ( xDocOwner.is() )
+		{
+			bool hasVBABindings = lcl_hasVbaEvents( m_xEventAttacher->getScriptEvents( _nIndex ) );  
+			if ( hasVBABindings )
+			{
+				OSL_TRACE("Has VBA bindings already, returning ");
+				return;
+			}
+			Reference< XMultiServiceFactory > xFac( xDocOwner, UNO_QUERY );
+			if ( xFac.is() )
+			{
+				try
+				{
+					Reference< org::openoffice::vba::XFakeVBAEventDescriptorSupplier > xDescSupplier( xFac->createInstance( rtl::OUString::createFromAscii( "org.openoffice.vba.controlevents" ) ), UNO_QUERY_THROW );
+					Reference< XInterface > xIf( getByIndex( _nIndex ) , UNO_QUERY_THROW );
+					Sequence< ScriptEventDescriptor > vbaEvents = xDescSupplier->getEventDescriptions( xIf );
+					// register the vba script events
+					if ( m_xEventAttacher.is() )
+					{
+						m_xEventAttacher->registerScriptEvents( _nIndex, vbaEvents );
+					}
+				}
+				catch( Exception& e ){ OSL_TRACE("lcl_fakevbaevents - Caught Exception trying to create control eventstuff "); }
+			}
+
+		}
+	}
+	catch( Exception& e )
+	{
+	}
+
+}
 //==================================================================
 //= ElementDescription
 //==================================================================
@@ -726,6 +806,7 @@ void OInterfaceContainer::approveNewElem
 void OInterfaceContainer::implInsert(sal_Int32 _nIndex, const Reference< XPropertySet >& _rxElement,
 	sal_Bool _bEvents, ElementDescription* _pApprovalResult, sal_Bool _bFire ) throw( IllegalArgumentException )
 {
+        OSL_TRACE("OInterfaceContainer::implInsert( %d)", _nIndex );
 	RTL_LOGFILE_CONTEXT( aLogger, "forms::OInterfaceContainer::implInsert" );
 
 	::osl::ClearableMutexGuard aGuard( m_rMutex );
@@ -775,6 +856,23 @@ void OInterfaceContainer::implInsert(sal
 	{
 		m_xEventAttacher->insertEntry(_nIndex);
 		m_xEventAttacher->attach( _nIndex, pElementMetaData->xInterface, makeAny( _rxElement ) );
+		// insert fake events?
+		Reference< XEventAttacherManager > xMgr ( pElementMetaData->xInterface, UNO_QUERY );
+		if ( xMgr.is() )
+		{ 
+			OInterfaceContainer* pIfcMgr = dynamic_cast< OInterfaceContainer* >( xMgr.get() );
+			sal_Int32 nLen = getCount();
+			for ( sal_Int32 i = 0; (i < nLen) && pIfcMgr ; ++i )
+			{	
+				// add fake events to the control at index i
+				pIfcMgr->fakeVbaEventsHack( i );
+			}	
+		}
+		else
+		{
+			// add fake events to the control at index i
+			fakeVbaEventsHack(  _nIndex );	
+		}
 	}
 
 	// notify derived classes
@@ -1054,20 +1154,29 @@ void SAL_CALL OInterfaceContainer::remov
 //------------------------------------------------------------------------
 void SAL_CALL OInterfaceContainer::registerScriptEvent( sal_Int32 nIndex, const ScriptEventDescriptor& aScriptEvent ) throw(IllegalArgumentException, RuntimeException)
 {
+    OSL_TRACE("*** registerScriptEvent %d", nIndex);
     if ( m_xEventAttacher.is() )
+    {
 	    m_xEventAttacher->registerScriptEvent( nIndex, aScriptEvent );
+            fakeVbaEventsHack( nIndex ); // add fake vba events
+    }
 }
 
 //------------------------------------------------------------------------
 void SAL_CALL OInterfaceContainer::registerScriptEvents( sal_Int32 nIndex, const Sequence< ScriptEventDescriptor >& aScriptEvents ) throw(IllegalArgumentException, RuntimeException)
 {
+    OSL_TRACE("*** registerScriptEvent(s) %d", nIndex);
     if ( m_xEventAttacher.is() )
+    {
     	m_xEventAttacher->registerScriptEvents( nIndex, aScriptEvents );
+        fakeVbaEventsHack( nIndex ); // add fake vba events
+    }
 }
 
 //------------------------------------------------------------------------
 void SAL_CALL OInterfaceContainer::revokeScriptEvent( sal_Int32 nIndex, const ::rtl::OUString& aListenerType, const ::rtl::OUString& aEventMethod, const ::rtl::OUString& aRemoveListenerParam ) throw(IllegalArgumentException, RuntimeException)
 {
+    OSL_TRACE("*** revokeScriptEvent %d listenertype %s, eventMethod %s", nIndex, rtl::OUStringToOString( aListenerType, RTL_TEXTENCODING_UTF8 ).getStr(), rtl::OUStringToOString( aEventMethod, RTL_TEXTENCODING_UTF8 ).getStr());
     if ( m_xEventAttacher.is() )
     	m_xEventAttacher->revokeScriptEvent( nIndex, aListenerType, aEventMethod, aRemoveListenerParam );
 }
@@ -1096,9 +1206,16 @@ void SAL_CALL OInterfaceContainer::remov
 //------------------------------------------------------------------------
 Sequence< ScriptEventDescriptor > SAL_CALL OInterfaceContainer::getScriptEvents( sal_Int32 nIndex ) throw(IllegalArgumentException, RuntimeException)
 {
+    OSL_TRACE("getScriptEvents");
     Sequence< ScriptEventDescriptor > aReturn;
     if ( m_xEventAttacher.is() )
+    {
 	    aReturn = m_xEventAttacher->getScriptEvents( nIndex );
+            if ( lcl_hasVbaEvents( aReturn ) )
+            {
+                aReturn = lcl_stripVbaEvents( aReturn );
+            }
+    }
     return aReturn;
 }
 
diff -rup /data4/latestBuild/ooo-build/build/oog680-m5/forms/source/misc/makefile.mk forms/source/misc/makefile.mk
--- /data4/latestBuild/ooo-build/build/oog680-m5/forms/source/misc/makefile.mk	2005-09-09 00:01:56.000000000 +0100
+++ forms/source/misc/makefile.mk	2007-12-07 11:16:14.000000000 +0000
@@ -48,6 +48,7 @@ ENABLE_EXCEPTIONS=TRUE
 # --- Types -------------------------------------
 
 INCPRE+=$(SOLARINCDIR)$/offuh
+INCPRE*=$(INCCOM)$/$(TARGET)
 
 # --- Files -------------------------------------
 
@@ -65,3 +66,12 @@ SLOFILES=	$(SLO)$/limitedformats.obj \
 
 .INCLUDE : target.mk
 
+ALLTAR : \
+        $(MISC)$/$(TARGET).don \
+
+$(SLOFILES) : $(MISC)$/$(TARGET).don
+
+$(MISC)$/$(TARGET).don : $(SOLARBINDIR)$/oovbaapi.rdb
+        +$(CPPUMAKER) -O$(INCCOM)$/$(TARGET) -BUCR $(SOLARBINDIR)$/oovbaapi.rdb -X$(SOLARBINDIR)$/types.rdb && echo > $@
+        echo $@
+
--- /dev/null	2007-05-04 11:54:36.000000000 +0100
+++ scripting/source/vbaevents/makefile.mk	2007-11-21 15:46:09.000000000 +0000
@@ -0,0 +1,58 @@
+PRJ=..$/..
+
+PRJNAME=vbaevents
+TARGET=vbaevents
+.IF "$(ENABLE_VBA)"!="YES"
+dummy:
+        @echo "not building vbaevents..."
+.ENDIF
+
+NO_BSYMBOLIC=	TRUE
+ENABLE_EXCEPTIONS=TRUE
+COMP1TYPELIST=$(TARGET)
+COMPRDB=$(SOLARBINDIR)$/types.rdb
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  settings.mk
+DLLPRE =
+
+# ------------------------------------------------------------------
+
+ALLTAR : \
+        $(MISC)$/$(TARGET).don \
+        $(SLOTARGET)
+
+$(MISC)$/$(TARGET).don : $(SOLARBINDIR)$/oovbaapi.rdb
+        +$(CPPUMAKER) -O$(OUT)$/inc -BUCR $(SOLARBINDIR)$/oovbaapi.rdb -X$(SOLARBINDIR)$/types.rdb && echo > $@
+        echo $@
+# ------------------------------------------------------------------
+
+#.INCLUDE :  ..$/cppumaker.mk
+
+SLOFILES= \
+		$(SLO)$/service.obj \
+		$(SLO)$/eventhelper.obj
+
+SHL1TARGET= $(TARGET)$(UPD)$(DLLPOSTFIX).uno
+SHL1IMPLIB=     i$(TARGET)
+
+SHL1VERSIONMAP=$(TARGET).map
+SHL1DEF=$(MISC)$/$(SHL1TARGET).def
+DEF1NAME=$(SHL1TARGET)
+                                                                              
+SHL1STDLIBS= \
+                $(CPPUHELPERLIB) \
+		$(BASICLIB) \
+		$(COMPHELPERLIB) \
+		$(SFXLIB) \
+                $(CPPULIB) \
+                $(TOOLSLIB) \
+                $(SALLIB)
+                                                                              
+SHL1DEPN=
+SHL1LIBS=$(SLB)$/$(TARGET).lib
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE :	target.mk
--- /dev/null	2007-05-04 11:54:36.000000000 +0100
+++ scripting/source/vbaevents/service.cxx	2007-11-21 15:46:09.000000000 +0000
@@ -0,0 +1,99 @@
+#include "cppuhelper/implementationentry.hxx"
+#include "com/sun/star/lang/XMultiServiceFactory.hpp"
+#include "com/sun/star/registry/XRegistryKey.hpp"
+
+// =============================================================================
+// component exports
+// =============================================================================
+using namespace ::com::sun::star;
+using namespace ::com::sun::star::uno;
+
+namespace evtlstner
+{
+    // =============================================================================
+    // component operations
+    // =============================================================================
+
+    uno::Reference< XInterface > SAL_CALL create(
+        Reference< XComponentContext > const & xContext )
+        SAL_THROW( () );
+
+    // -----------------------------------------------------------------------------
+
+    ::rtl::OUString SAL_CALL getImplementationName();
+
+    Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames();
+
+    Reference<XInterface> SAL_CALL create(
+        Sequence<Any> const &, Reference<XComponentContext> const & );
+} // end evtlstner
+
+namespace ooevtdescgen
+{
+    // =============================================================================
+    // component operations
+    // =============================================================================
+
+    uno::Reference< XInterface > SAL_CALL create(
+        Reference< XComponentContext > const & xContext )
+        SAL_THROW( () );
+
+    // -----------------------------------------------------------------------------
+
+    ::rtl::OUString SAL_CALL getImplementationName();
+
+    Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames();
+
+    Reference<XInterface> SAL_CALL create(
+        Sequence<Any> const &, Reference<XComponentContext> const & );
+} // end ooevtdescgen
+
+
+
+    // =============================================================================
+
+    const ::cppu::ImplementationEntry s_component_entries [] =
+    {
+        {
+            ::evtlstner::create, ::evtlstner::getImplementationName,
+            ::evtlstner::getSupportedServiceNames, 
+            ::cppu::createSingleComponentFactory,
+            0, 0
+        },
+        {
+            ::ooevtdescgen::create, ::ooevtdescgen::getImplementationName,
+            ::ooevtdescgen::getSupportedServiceNames, 
+            ::cppu::createSingleComponentFactory,
+            0, 0
+        },
+        { 0, 0, 0, 0, 0, 0 }
+    };
+
+extern "C"
+{
+    void SAL_CALL component_getImplementationEnvironment( 
+        const sal_Char ** ppEnvTypeName, uno_Environment ** ppEnv )
+    {
+        OSL_TRACE("In component_getImplementationEnv");
+        *ppEnvTypeName = CPPU_CURRENT_LANGUAGE_BINDING_NAME;
+    }
+
+    sal_Bool SAL_CALL component_writeInfo( 
+        lang::XMultiServiceFactory * pServiceManager, registry::XRegistryKey * pRegistryKey )
+    {
+        OSL_TRACE("In component_writeInfo");
+        if ( ::cppu::component_writeInfoHelper(
+            pServiceManager, pRegistryKey, s_component_entries ) )
+            return sal_True;
+        return sal_False;
+    }
+
+    void * SAL_CALL component_getFactory( 
+        const sal_Char * pImplName, lang::XMultiServiceFactory * pServiceManager,
+        registry::XRegistryKey * pRegistryKey )
+    {
+        OSL_TRACE("In component_getFactory");
+        return ::cppu::component_getFactoryHelper( 
+            pImplName, pServiceManager, pRegistryKey, s_component_entries );
+    }
+}
--- /dev/null	2007-05-04 11:54:36.000000000 +0100
+++ scripting/source/vbaevents/vbaevents.map	2007-11-21 15:46:09.000000000 +0000
@@ -0,0 +1,9 @@
+OOO_1.1 {
+	global:
+		component_getImplementationEnvironment;
+		component_getFactory;
+		component_writeInfo;
+
+	local:
+		*;
+};
--- /dev/null	2007-05-04 11:54:36.000000000 +0100
+++ scripting/source/vbaevents/vbaevents.xml	2007-11-21 15:46:09.000000000 +0000
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE module-description PUBLIC "-//StarOffice//DTD ComponentDescription 1.0//EN" "module-description.dtd">
+<module-description xmlns:xlink="http://www.w3.org/1999/xlink">
+
+    <module-name>vbaevents</module-name>
+    
+    <component-description>
+        <author>Noel Power </author>
+        <name>org.openoffice.vba.EventListener</name>
+        <description>Event listener to handle ooo events and to translate them to calls to basic macros ala Button_Click etc.</description>
+        <loader-name>com.sun.star.loader.SharedLibrary</loader-name>
+        <language>c++</language>
+        <status value="drafts"/>
+        <supported-service>org.openoffice.vba.EventListener</supported-service>
+        <type>com.sun.star.uno.XComponentContext</type>        
+    </component-description>
+    
+    <project-build-dependency>cppuhelper</project-build-dependency>
+    <project-build-dependency>cppu</project-build-dependency>
+    <project-build-dependency>sal</project-build-dependency>
+
+    <runtime-module-dependency>cppuhelper3$(COM)</runtime-module-dependency>
+    <runtime-module-dependency>cppu3</runtime-module-dependency>
+    <runtime-module-dependency>sal3</runtime-module-dependency>
+    
+</module-description>
--- oovbaapi/org/openoffice/vba/XVBAToOOEventDescGen.idl	2007-04-27 08:32:41.000000000 +0100
+++ /data4/scratch/oog680-m5/oovbaapi/org/openoffice/vba/XVBAToOOEventDescGen.idl	2007-12-07 10:24:44.000000000 +0000
@@ -50,5 +50,10 @@ interface XVBAToOOEventDescGen : com::su
 	com::sun::star::script::XScriptEventsSupplier getEventSupplier( [in] com::sun::star::uno::XInterface xControl );
 };
 
+interface XFakeVBAEventDescriptorSupplier : com::sun::star::uno::XInterface
+{
+	sequence< com::sun::star::script::ScriptEventDescriptor >  getEventDescriptions( [in] com::sun::star::uno::XInterface xControl );
+};
+
 }; }; };
 #endif
--- /dev/null	2007-05-04 11:54:36.000000000 +0100
+++ scripting/source/vbaevents/eventhelper.cxx	2007-12-10 15:30:15.000000000 +0000
@@ -0,0 +1,1025 @@
+#include <comphelper/processfactory.hxx>
+#include <comphelper/uno3.hxx>
+#include <comphelper/proparrhlp.hxx>
+#include <comphelper/propertycontainer.hxx>
+
+#include <org/openoffice/vba/XVBAToOOEventDescGen.hpp>
+
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/beans/XIntrospection.hpp>
+#include <com/sun/star/beans/PropertyAttribute.hpp>
+
+#include <com/sun/star/lang/XMultiComponentFactory.hpp>
+#include <com/sun/star/lang/XServiceName.hpp>
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#include <com/sun/star/lang/XInitialization.hpp>
+
+#include <com/sun/star/frame/XModel.hpp>
+
+#include <com/sun/star/script/XLibraryContainer.hpp>
+#include <com/sun/star/script/ScriptEventDescriptor.hpp>
+#include <com/sun/star/script/provider/XScriptProviderSupplier.hpp>
+
+#include <com/sun/star/drawing/XControlShape.hpp>
+
+#include <com/sun/star/awt/XControl.hpp>
+#include <com/sun/star/awt/KeyEvent.hpp>
+#include <com/sun/star/awt/MouseEvent.hpp>
+
+#include <msforms/ReturnInteger.hpp>
+
+#include <sfx2/objsh.hxx>
+#include <basic/sbstar.hxx>
+#include <basic/basmgr.hxx>
+#include <basic/sbmeth.hxx>
+#include <basic/sbmod.hxx>
+#include <basic/sbx.hxx>
+
+
+
+
+// for debug
+#include <comphelper/anytostring.hxx>
+
+
+#include <com/sun/star/lang/XMultiComponentFactory.hpp>
+#include <com/sun/star/script/XScriptListener.hpp>
+#include <cppuhelper/implbase1.hxx>
+#include <cppuhelper/implbase2.hxx>
+
+#include <set>
+#include <list>
+#include <hash_map>
+
+using namespace ::com::sun::star;
+using namespace ::com::sun::star::script;
+using namespace ::com::sun::star::uno;
+using namespace ::org::openoffice::vba;
+
+
+// Some constants 
+const static rtl::OUString DELIM = rtl::OUString::createFromAscii( "::" );
+const static sal_Int32 DELIMLEN = DELIM.getLength();
+
+// Helper Methods
+
+// TODO this method now appears/is-defined in at least three places
+// svx/source/forms/fmtools.cxx extensions/source/propctrlr/formcontroller.cxx
+// and here. We must do better than that
+Sequence< ::rtl::OUString> getEventMethods(const Type& type)
+{
+    typelib_InterfaceTypeDescription *pType=0;
+    type.getDescription( (typelib_TypeDescription**)&pType);
+
+    if(!pType)
+        return Sequence< ::rtl::OUString>();
+    
+    Sequence< ::rtl::OUString> aNames(pType->nMembers);
+    ::rtl::OUString* pNames = aNames.getArray();
+    for(sal_Int32 i=0;i<pType->nMembers;i++,++pNames)
+    {
+        // the decription reference
+        typelib_TypeDescriptionReference* pMemberDescriptionReference = pType->ppMembers[i];
+        // the description for the reference
+        typelib_TypeDescription* pMemberDescription = NULL;
+        typelib_typedescriptionreference_getDescription(&pMemberDescription, pMemberDescriptionReference);
+        if (pMemberDescription)
+        {
+            typelib_InterfaceMemberTypeDescription* pRealMemberDescription =
+            reinterpret_cast<typelib_InterfaceMemberTypeDescription*>(pMemberDescription);
+            *pNames = pRealMemberDescription->pMemberName;
+        }
+    }
+    typelib_typedescription_release( (typelib_TypeDescription *)pType );
+    return aNames;
+}
+
+// for debug only ( conditionalize out? ) 
+void dumpListeners( const Reference< beans::XIntrospection >& xIntrospection, const Reference<XInterface>& xIfc)
+{
+    Reference< beans::XIntrospectionAccess > xIntrospectionAccess;
+    if ( xIntrospection.is() )
+    {
+        xIntrospectionAccess = xIntrospection->inspect( 
+            makeAny( xIfc ) );
+        Sequence< Type > aControlListeners = 
+            xIntrospectionAccess->getSupportedListeners();
+        sal_Int32 nLength = aControlListeners.getLength();
+             
+        for ( sal_Int32 i = 0; i< nLength; ++i )
+        {
+            Type& listType = aControlListeners[ i ];
+            rtl::OUString sFullTypeName = listType.getTypeName();
+            rtl::OUString sTypeName = listType.getTypeName();
+            sal_Int32 lastDotIndex = -1;
+            if ( ( lastDotIndex = sFullTypeName.lastIndexOf( '.' ) ) > -1 )
+            {
+                sTypeName = sFullTypeName.copy( lastDotIndex + 1 );    
+            } 
+            Sequence< ::rtl::OUString > sMeths = getEventMethods( listType );    
+            sal_Int32 sMethLen = sMeths.getLength();
+            for ( sal_Int32 j=0 ; j < sMethLen; ++j )
+            {
+                OSL_TRACE("**Listener [%d] Type[%s] Method[%s]",j,
+                    rtl::OUStringToOString( sTypeName, 
+                        RTL_TEXTENCODING_UTF8 ).getStr(),
+                    rtl::OUStringToOString( sMeths[ j ], 
+                        RTL_TEXTENCODING_UTF8 ).getStr() );
+            }
+        }
+       
+    }
+}
+
+void dumpEvent( const ScriptEvent& evt )
+{
+    OSL_TRACE("dumpEvent: Source %s",
+        rtl::OUStringToOString( comphelper::anyToString( makeAny(evt.Source)), 
+            RTL_TEXTENCODING_UTF8 ).getStr() );
+
+    OSL_TRACE("dumpEvent: ScriptType %s",
+        rtl::OUStringToOString( evt.ScriptType, 
+            RTL_TEXTENCODING_UTF8 ).getStr() );
+    
+    OSL_TRACE("dumpEvent: ScriptCode %s",
+        rtl::OUStringToOString( evt.ScriptCode, 
+            RTL_TEXTENCODING_UTF8 ).getStr() );
+
+    OSL_TRACE("dumpEvent: ListenerType %s",
+        rtl::OUStringToOString( evt.ListenerType.getTypeName(), 
+            RTL_TEXTENCODING_UTF8 ).getStr() );
+    
+    OSL_TRACE("dumpEvent: Listener methodname %s",
+        rtl::OUStringToOString( evt.MethodName, 
+            RTL_TEXTENCODING_UTF8 ).getStr() );
+
+    OSL_TRACE("dumpEvent: arguments;");
+    sal_Int32 nLen = evt.Arguments.getLength();
+    for ( sal_Int32 index=0; index < nLen; ++index )
+    {
+        OSL_TRACE("\t [%d] %s", index, 
+        rtl::OUStringToOString( comphelper::anyToString( evt.Arguments[ index ] ), 
+            RTL_TEXTENCODING_UTF8 ).getStr() );
+
+    }
+}
+
+
+bool isKeyEventOk( awt::KeyEvent& evt, const Sequence< Any >& params )
+{
+    if ( !( params.getLength() > 0 ) ||
+        !( params[ 0 ] >>= evt ) )
+        return false;
+    return true;
+}
+
+bool isMouseEventOk( awt::MouseEvent& evt, const Sequence< Any >& params )
+{
+    if ( !( params.getLength() > 0 ) ||
+        !( params[ 0 ] >>= evt ) )
+        return false;
+    return true;
+}
+
+Sequence< Any > ooMouseEvtToVBADblClick( const Sequence< Any >& params )
+{
+    Sequence< Any > translatedParams;
+    awt::MouseEvent evt;
+
+    if ( !( isMouseEventOk(evt, params)) || 
+        (evt.ClickCount != 2) )
+        return Sequence< Any >(); 
+    // give back orig params, this will signal that the event is good
+    return params;
+}
+
+Sequence< Any > ooMouseEvtToVBAMouseEvt( const Sequence< Any >& params )
+{
+    Sequence< Any > translatedParams;
+    awt::MouseEvent evt;
+
+    if ( !isMouseEventOk(evt, params) )
+        return Sequence< Any >(); 
+
+    translatedParams.realloc(4);
+
+    // Buttons
+    translatedParams[ 0 ] <<= evt.Buttons;
+    // Shift
+    translatedParams[ 1 ] <<= evt.Modifiers;
+    // X
+    translatedParams[ 2 ] <<= evt.X;
+    // Y
+    translatedParams[ 3 ] <<= evt.Y;
+    return translatedParams;
+}
+
+Sequence< Any > ooKeyPressedToVBAKeyPressed( const Sequence< Any >& params )
+{
+    Sequence< Any > translatedParams;
+    awt::KeyEvent evt;
+
+    if ( !isKeyEventOk( evt, params ) )
+        return Sequence< Any >(); 
+
+    translatedParams.realloc(1);
+
+    msforms::ReturnInteger keyCode;
+    keyCode.Value = evt.KeyCode; 
+    translatedParams[0] <<= keyCode;
+    return  translatedParams;
+}
+
+Sequence< Any > ooKeyPressedToVBAKeyUpDown( const Sequence< Any >& params )
+{
+    Sequence< Any > translatedParams;
+    awt::KeyEvent evt;
+
+    if ( !isKeyEventOk( evt, params ) )
+        return Sequence< Any >(); 
+
+    translatedParams.realloc(2);
+
+    msforms::ReturnInteger keyCode;
+    sal_Int8 shift = evt.Modifiers;
+
+    // #TODO check whether values from OOO conform to values generated from vba
+    keyCode.Value = evt.KeyCode; 
+    translatedParams[0] <<= keyCode;
+    translatedParams[1] <<= shift;
+    return  translatedParams;
+}
+
+typedef Sequence< Any > (*Translator)(const Sequence< Any >&);
+
+struct TranslateInfo
+{
+    rtl::OUString sVBAName;
+    Translator toVBA;
+};
+
+
+typedef std::hash_map< rtl::OUString, 
+std::list< TranslateInfo >, 
+::rtl::OUStringHash,
+::std::equal_to< ::rtl::OUString > > EventInfoHash;
+
+
+EventInfoHash& getEventTransInfo()
+{
+    static bool initialised = false;
+    static EventInfoHash eventTransInfo;
+    if ( !initialised )
+    {
+        TranslateInfo  info;
+        // actionPerformed ooo event
+        std::list< TranslateInfo > actionInfos;
+        info.sVBAName = rtl::OUString::createFromAscii("_Click");
+        info.toVBA = NULL;
+        actionInfos.push_back( info );
+        eventTransInfo[ rtl::OUString::createFromAscii("actionPerformed") ] = actionInfos;
+        // changed ooo event
+        std::list< TranslateInfo > changeInfos;
+        info.sVBAName = rtl::OUString::createFromAscii("_Change");
+        info.toVBA = NULL;
+        changeInfos.push_back( info );
+        eventTransInfo[ rtl::OUString::createFromAscii("changed") ] = changeInfos;
+        // focusGained ooo event
+        std::list< TranslateInfo > focusGainedInfos;
+        info.sVBAName = rtl::OUString::createFromAscii("_GotFocus");
+        info.toVBA = NULL;
+        focusGainedInfos.push_back( info );
+        eventTransInfo[ rtl::OUString::createFromAscii("focusGained") ] = focusGainedInfos;
+        // focusLost ooo event
+        std::list< TranslateInfo > focusLostInfos;
+        info.sVBAName = rtl::OUString::createFromAscii("_LostFocus");
+        info.toVBA = NULL;
+        focusLostInfos.push_back( info );
+        eventTransInfo[ rtl::OUString::createFromAscii("focusGained") ] = focusLostInfos;
+        // adjustmentValueChanged ooo event
+        std::list< TranslateInfo > adjustInfos;
+        info.sVBAName = rtl::OUString::createFromAscii("_Scroll");
+        info.toVBA = NULL;
+        adjustInfos.push_back( info );
+        info.sVBAName = rtl::OUString::createFromAscii("_Change");
+        info.toVBA = NULL;
+        adjustInfos.push_back( info );
+        eventTransInfo[ rtl::OUString::createFromAscii("adjustmentValueChanged") ] = adjustInfos;
+        // textChanged ooo event
+        std::list< TranslateInfo > txtChangedInfos;
+        info.sVBAName = rtl::OUString::createFromAscii("_Change");
+        info.toVBA = NULL;
+        txtChangedInfos.push_back( info );
+        eventTransInfo[ rtl::OUString::createFromAscii("textChanged") ] = txtChangedInfos;
+
+        // keyReleased ooo event
+        std::list< TranslateInfo > keyReleasedInfos;
+        info.sVBAName = rtl::OUString::createFromAscii("_KeyUp");
+        info.toVBA = ooKeyPressedToVBAKeyUpDown;
+        keyReleasedInfos.push_back( info );
+        eventTransInfo[ rtl::OUString::createFromAscii("keyReleased") ] = keyReleasedInfos;
+        // mouseReleased ooo event
+        std::list< TranslateInfo > mouseReleasedInfos;
+        info.sVBAName = rtl::OUString::createFromAscii("_MouseUp");
+        info.toVBA = ooMouseEvtToVBAMouseEvt;
+        mouseReleasedInfos.push_back( info );
+        eventTransInfo[ rtl::OUString::createFromAscii("mouseReleased") ] = mouseReleasedInfos;
+        // mousePressed ooo event
+        std::list< TranslateInfo > mousePressedInfos;
+        info.sVBAName = rtl::OUString::createFromAscii("_MouseDown");
+        info.toVBA = ooMouseEvtToVBAMouseEvt;
+        mousePressedInfos.push_back( info );
+        info.sVBAName = rtl::OUString::createFromAscii("_DblClick");
+        // emulate double click event
+        info.toVBA = ooMouseEvtToVBADblClick;
+        mousePressedInfos.push_back( info );
+        eventTransInfo[ rtl::OUString::createFromAscii("mousePressed") ] = mousePressedInfos;
+        // mouseMoved ooo event
+        std::list< TranslateInfo > mouseMovedInfos;
+        info.sVBAName = rtl::OUString::createFromAscii("_MouseMoved");
+        info.toVBA = ooMouseEvtToVBAMouseEvt;
+        mouseMovedInfos.push_back( info );
+        eventTransInfo[ rtl::OUString::createFromAscii("mouseMoved") ] = mouseMovedInfos;
+        // keyPressed ooo event
+        std::list< TranslateInfo > keyPressedInfos;
+        info.sVBAName = rtl::OUString::createFromAscii("_KeyDown");
+        info.toVBA = ooKeyPressedToVBAKeyUpDown;
+        keyPressedInfos.push_back( info );
+        info.sVBAName = rtl::OUString::createFromAscii("_KeyPress");
+        info.toVBA = ooKeyPressedToVBAKeyPressed;
+        keyPressedInfos.push_back( info );
+        eventTransInfo[ rtl::OUString::createFromAscii("keyPressed") ] = keyPressedInfos;
+        initialised = true;
+    }
+    return eventTransInfo;
+}
+
+// Helper class
+
+class ScriptEventFactory
+{
+public:
+    static Sequence< ScriptEventDescriptor > createEvents( const Reference< XInterface >& xControl, const rtl::OUString& sLibModName, const Sequence< rtl::OUString >& sMethods );   
+    static ScriptEventFactory& instance() { static ScriptEventFactory inst; return inst; }
+    static rtl::OUString getControlName( const Reference< XInterface >& xControl );
+    static Sequence< rtl::OUString > getEventListeners( const Reference< XInterface >& xControl );
+private:
+    ScriptEventFactory();
+    Reference< XComponentContext > m_xCtx;
+};
+
+// Helper function
+bool
+eventMethodToDescriptors( const ::rtl::OUString& rEventMethod,  const Reference< XInterface >& xControl, const rtl::OUString& sLibModName, const Sequence< rtl::OUString >& sHandlerExts, Sequence< ScriptEventDescriptor >& evtDescs )
+{
+    // format of ControlListener is TypeName::methodname e.g.
+    // "com.sun.star.awt.XActionListener::actionPerformed" or
+    // "XActionListener::actionPerformed
+
+    ::rtl::OUString sMethodName;
+    ::rtl::OUString sTypeName;
+    sal_Int32 nDelimPos = rEventMethod.indexOf( DELIM );
+    if ( nDelimPos == -1 )
+    {
+        return false;
+    }
+    sMethodName = rEventMethod.copy( nDelimPos + DELIMLEN );
+    sTypeName = rEventMethod.copy( 0, nDelimPos );
+            
+    EventInfoHash& infos = getEventTransInfo();
+
+    // Only create an ScriptEventDescriptor for an event we can translate
+    // or emulate
+    EventInfoHash::const_iterator eventInfo_it = infos.find( sMethodName );
+    EventInfoHash::const_iterator it_end = infos.end();
+
+    if ( infos.find( sMethodName ) != infos.end() )
+    {
+        sal_Int32 nIndex = evtDescs.getLength();
+	evtDescs.realloc( evtDescs.getLength() + 1 );
+        evtDescs[ nIndex ].ScriptType = rtl::OUString::createFromAscii( "VBAInterop" );
+        evtDescs[ nIndex ].ScriptCode = sLibModName; // codeName	
+        evtDescs[ nIndex ].ListenerType = sTypeName;
+        evtDescs[ nIndex ].EventMethod = sMethodName;
+        return true;
+    }
+
+    return false;
+// go no further
+
+    // sLibModName ( could ) include the uri bits :-) from calc
+    rtl::OUString sPartialMacroName = sLibModName + rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".") ) + rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("$macro"));
+
+    if ( sMethodName.getLength() 
+         && sTypeName.getLength()
+         && ( infos.find( sMethodName ) != infos.end() ) )
+    {
+        std::list< TranslateInfo >::const_iterator txInfo =
+            eventInfo_it->second.begin();
+        std::list< TranslateInfo >::const_iterator txInfo_end = 
+            eventInfo_it->second.end();
+        for ( ; txInfo != txInfo_end; ++txInfo )
+        {
+            // Check if extension is support for this method, if
+            // so create an eventdescription for that
+            const rtl::OUString* pExt = sHandlerExts.getConstArray();
+            sal_Int32  nCount = sHandlerExts.getLength();
+            for ( sal_Int32 counter=0;  counter<nCount; ++counter, ++pExt )
+            {
+                if ( (*txInfo).sVBAName.equals( *pExt ) ) // handler for event
+                {
+                    sal_Int32 nIndex = evtDescs.getLength();
+	            evtDescs.realloc( evtDescs.getLength() + 1 );
+                    evtDescs[ nIndex ].ScriptCode =  sPartialMacroName + *pExt;
+                    evtDescs[ nIndex ].ListenerType = sTypeName;
+                    evtDescs[ nIndex ].EventMethod = sMethodName;
+
+                    // set this it VBAInterop, ensures that it doesn't
+                    // get persisted or shown in property editors
+                    evtDescs[ nIndex ].ScriptType = rtl::OUString::createFromAscii( "VBAInterop" );	
+                 }
+            }    
+        }
+        return true;
+    }
+    return false;
+
+}
+
+bool
+eventMethodToDescriptor( const ::rtl::OUString& rEventMethod, const Reference< XInterface >& xControl, ScriptEventDescriptor& evtDesc )
+{
+    // format of ControlListener is TypeName::methodname e.g.
+    // "com.sun.star.awt.XActionListener::actionPerformed" or
+    // "XActionListener::actionPerformed
+
+    ::rtl::OUString sMethodName;
+    ::rtl::OUString sTypeName;
+    sal_Int32 nDelimPos = rEventMethod.indexOf( DELIM );
+    if ( nDelimPos == -1 )
+    {
+        return false;
+    }
+    sMethodName = rEventMethod.copy( nDelimPos + DELIMLEN );
+    sTypeName = rEventMethod.copy( 0, nDelimPos );
+            
+    EventInfoHash& infos = getEventTransInfo();
+
+    // Only create an ScriptEventDescriptor for an event we can translate
+    // or emulate
+    if ( sMethodName.getLength() 
+         && sTypeName.getLength()
+         && ( infos.find( sMethodName ) != infos.end() ) )
+    {
+        // just fill in control name, event handler will
+        // do the rest e.g. search for this routine in the doc basic
+        // and run it.
+        evtDesc.ScriptCode =  ScriptEventFactory::instance().getControlName(xControl);
+        evtDesc.ListenerType = sTypeName;
+        evtDesc.EventMethod = sMethodName;
+
+        // set this it VBAInterop, ensures that it doesn't
+        // get persisted or shown in property editors
+        evtDesc.ScriptType = rtl::OUString::createFromAscii(
+            "VBAInterop" );	
+        return true;
+    }
+    return false;
+
+}
+
+ScriptEventFactory::ScriptEventFactory()
+{
+    Reference < beans::XPropertySet > xProps(
+        ::comphelper::getProcessServiceFactory(), UNO_QUERY_THROW );
+    m_xCtx.set( xProps->getPropertyValue( rtl::OUString(
+        RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), 
+        uno::UNO_QUERY_THROW );
+}
+rtl::OUString
+ScriptEventFactory::getControlName( const Reference< XInterface >& rXControl )
+{
+    Reference< XInterface > xIfModel;
+    Reference< awt::XControl > xControl( rXControl, UNO_QUERY );
+    if ( xControl.is() )
+        xIfModel = xControl->getModel();
+    else
+        xIfModel = rXControl;
+
+    Reference< beans::XPropertySet > xProps( xIfModel, UNO_QUERY );
+    ::rtl::OUString sName;
+    if ( xProps.is() )
+    {
+        try
+        {
+            xProps->getPropertyValue(
+                ::rtl::OUString::createFromAscii("Name") ) >>= sName;
+        }
+        catch(Exception& e)
+        {
+            OSL_TRACE("PropertyStuff mucked up no name got exception: %s",
+               (const sal_Char *) rtl::OUStringToOString( e.Message, RTL_TEXTENCODING_UTF8 ));	
+        }
+    }
+    return sName;
+}
+
+Sequence< rtl::OUString > 
+ScriptEventFactory::getEventListeners( const Reference< XInterface >& xControl )
+{
+    Reference< lang::XMultiComponentFactory > xMFac( 
+        instance().m_xCtx->getServiceManager(), UNO_QUERY );
+    std::list< rtl::OUString > eventMethods;
+
+    if ( xMFac.is() )
+    {
+        Reference< beans::XIntrospection > xIntrospection( 
+            xMFac->createInstanceWithContext( rtl::OUString( 
+                RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.beans.Introspection"  ) ), instance().m_xCtx ), UNO_QUERY );
+        //dumpListeners( xIntrospection, xControl );
+        //dumpListeners( xIntrospection, xControl->getModel() );
+        Reference< beans::XIntrospectionAccess > xIntrospectionAccess;
+	if  ( xIntrospection.is() )
+	{
+            xIntrospectionAccess = xIntrospection->inspect( 
+                makeAny( xControl ) );
+            Sequence< Type > aControlListeners = 
+                xIntrospectionAccess->getSupportedListeners();
+            sal_Int32 nLength = aControlListeners.getLength();             
+            for ( sal_Int32 i = 0; i< nLength; ++i )
+            {
+                Type& listType = aControlListeners[ i ];
+                rtl::OUString sFullTypeName = listType.getTypeName();
+                Sequence< ::rtl::OUString > sMeths = 
+                    getEventMethods( listType );    
+                sal_Int32 sMethLen = sMeths.getLength();
+                for ( sal_Int32 j=0 ; j < sMethLen; ++j )
+                {
+                    rtl::OUString sEventMethod = sFullTypeName;
+                    sEventMethod += DELIM;
+                    sEventMethod += sMeths[ j ];
+                    eventMethods.push_back( sEventMethod );
+                }
+            }
+            
+        }
+    }
+
+    Sequence< rtl::OUString > sEventMethodNames( eventMethods.size() );
+    std::list< rtl::OUString >::const_iterator it = eventMethods.begin();
+    rtl::OUString* pDest = sEventMethodNames.getArray();
+
+    for ( ; it != eventMethods.end(); ++it, ++pDest )
+        *pDest = *it;         
+
+    return sEventMethodNames;
+}
+
+Sequence< ScriptEventDescriptor > 
+ScriptEventFactory::createEvents( const Reference< XInterface >& xControl, const rtl::OUString& sLibModName, const Sequence< rtl::OUString >& sHandlerExts )
+{
+    Sequence< rtl::OUString > aControlListeners = ScriptEventFactory::instance().getEventListeners( xControl );
+    rtl::OUString* pSrc = aControlListeners.getArray();
+    sal_Int32 nLength = aControlListeners.getLength();             
+
+    Sequence< ScriptEventDescriptor > aDest( nLength * 2 );// sensible default
+    ScriptEventDescriptor* pDest = aDest.getArray();
+    sal_Int32 nEvts = 0;
+
+  
+    for ( sal_Int32 i = 0; i< nLength; ++i, ++pSrc )
+    {
+        // from getListeners eventName is of form
+        // "com.sun.star.awt.XActionListener::actionPerformed"
+        // we need to strip "com.sun.star.awt." from that for form
+        // controls
+        sal_Int32 lastDotIndex = -1;
+        ::rtl::OUString sNoNameSpaceMethod = *pSrc;
+        if ( ( lastDotIndex = pSrc->lastIndexOf( '.' ) ) > -1 )
+            sNoNameSpaceMethod = sNoNameSpaceMethod.copy( lastDotIndex + 1 );
+	
+    	Sequence< ScriptEventDescriptor > evtDescs;
+        if ( eventMethodToDescriptors( sNoNameSpaceMethod, xControl, sLibModName, sHandlerExts, evtDescs ) )
+        {
+            sal_Int32 dIndex = nEvts;
+            nEvts += evtDescs.getLength();
+            ScriptEventDescriptor* pDesc = evtDescs.getArray();
+            if ( nEvts > aDest.getLength() )
+                aDest.realloc( nEvts );// should never happen
+            for ( ; dIndex < nEvts; ++dIndex, ++pDesc )
+                aDest[ dIndex ] = *pDesc; 
+        }
+    }
+    aDest.realloc( nEvts );
+
+    return aDest;
+}
+
+
+typedef ::cppu::WeakImplHelper1< container::XNameContainer > NameContainer_BASE;
+
+class ReadOnlyEventsNameContainer : public NameContainer_BASE
+{
+public:
+    ReadOnlyEventsNameContainer( const Sequence< rtl::OUString >& eventMethods, const Reference< XInterface >& xControl );
+    // XNameContainer
+
+    virtual void SAL_CALL insertByName( const ::rtl::OUString& aName, const Any& aElement ) throw (lang::IllegalArgumentException, container::ElementExistException, lang::WrappedTargetException, RuntimeException)
+    {
+        throw RuntimeException( rtl::OUString::createFromAscii( "ReadOnly container" ), Reference< XInterface >() );
+ 
+    }
+    virtual void SAL_CALL removeByName( const ::rtl::OUString& Name ) throw (::com::sun::star::container::NoSuchElementException, lang::WrappedTargetException, RuntimeException)
+    {
+        throw RuntimeException( rtl::OUString::createFromAscii( "ReadOnly container" ), Reference< XInterface >() );
+    }
+
+    // XNameReplace
+    virtual void SAL_CALL replaceByName( const ::rtl::OUString& aName, const Any& aElement ) throw (lang::IllegalArgumentException, container::NoSuchElementException, lang::WrappedTargetException, RuntimeException)
+    {
+        throw RuntimeException( rtl::OUString::createFromAscii( "ReadOnly container" ), Reference< XInterface >() );
+ 
+    }
+                                                                                
+    // XNameAccess
+    virtual Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (container::NoSuchElementException, lang::WrappedTargetException, RuntimeException);
+    virtual Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (RuntimeException);
+    virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (RuntimeException);
+
+    // XElementAccess
+    virtual Type SAL_CALL getElementType(  ) throw (RuntimeException)
+    { return getCppuType(static_cast< const rtl::OUString * >(0) ); }
+    virtual ::sal_Bool SAL_CALL hasElements(  ) throw (RuntimeException)
+    { return ( ( m_hEvents.size() > 0 ? sal_True : sal_False ) ); }
+private:
+
+typedef std::hash_map< rtl::OUString, Any, ::rtl::OUStringHash,
+::std::equal_to< ::rtl::OUString > > EventSupplierHash;
+
+    EventSupplierHash m_hEvents;
+};
+
+ReadOnlyEventsNameContainer::ReadOnlyEventsNameContainer( const Sequence< rtl::OUString >& eventMethods, const Reference< XInterface >& xControl ) 
+{
+    const rtl::OUString* pSrc = eventMethods.getConstArray();
+    sal_Int32 nLen = eventMethods.getLength();
+    for ( sal_Int32 index = 0; index < nLen; ++index, ++pSrc )
+    {
+        Any aDesc;
+        ScriptEventDescriptor evtDesc;
+        if (  eventMethodToDescriptor( *pSrc, xControl, evtDesc ) )
+        {
+            aDesc <<= evtDesc; 
+            m_hEvents[ *pSrc ] = aDesc;
+        }
+    }
+}
+
+Any SAL_CALL 
+ReadOnlyEventsNameContainer::getByName( const ::rtl::OUString& aName ) throw (container::NoSuchElementException, lang::WrappedTargetException, RuntimeException){
+    EventSupplierHash::const_iterator it = m_hEvents.find( aName );
+    if ( it == m_hEvents.end() )
+        throw container::NoSuchElementException();
+    return it->second;
+}
+
+Sequence< ::rtl::OUString > SAL_CALL 
+ReadOnlyEventsNameContainer::getElementNames(  ) throw (RuntimeException)
+{
+    Sequence< ::rtl::OUString > names(m_hEvents.size());
+    rtl::OUString* pDest = names.getArray();
+    EventSupplierHash::const_iterator it = m_hEvents.begin();
+    EventSupplierHash::const_iterator it_end = m_hEvents.end();
+    for ( sal_Int32 index = 0; it != it_end; ++index, ++pDest, ++it )
+        *pDest = it->first;
+    return names;
+}
+
+sal_Bool SAL_CALL 
+ReadOnlyEventsNameContainer::hasByName( const ::rtl::OUString& aName ) throw (RuntimeException)
+{
+    EventSupplierHash::const_iterator it = m_hEvents.find( aName );
+    if ( it == m_hEvents.end() )
+        return sal_False;
+    return sal_True;
+}
+
+typedef ::cppu::WeakImplHelper1< XScriptEventsSupplier > EventsSupplier_BASE;
+
+class ReadOnlyEventsSupplier : public EventsSupplier_BASE
+{
+public:
+    ReadOnlyEventsSupplier( const Sequence< ::rtl::OUString >& eventMethods, const Reference< XInterface >& xControl )
+    { m_xNameContainer = new ReadOnlyEventsNameContainer( eventMethods, xControl ); }
+    
+    // XScriptEventSupplier
+    virtual Reference< container::XNameContainer > SAL_CALL getEvents(  ) throw (RuntimeException){ return m_xNameContainer; }
+private:
+    Reference< container::XNameContainer > m_xNameContainer;
+};
+
+typedef ::cppu::WeakImplHelper2< XScriptListener, lang::XInitialization > EventListener_BASE;
+
+#define EVENTLSTNR_PROPERTY_ID_MODEL         1
+#define EVENTLSTNR_PROPERTY_MODEL            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Model" ) )
+
+class EventListener : public EventListener_BASE
+    ,public ::comphelper::OMutexAndBroadcastHelper
+    ,public ::comphelper::OPropertyContainer
+    ,public ::comphelper::OPropertyArrayUsageHelper< EventListener >
+
+{
+public:
+    EventListener( const Reference< XComponentContext >& rxContext );
+    // XEventListener
+    virtual void SAL_CALL disposing(const lang::EventObject& Source) throw( RuntimeException );
+
+    // XScriptListener
+    virtual void SAL_CALL firing(const ScriptEvent& evt) throw(RuntimeException);
+    virtual Any SAL_CALL approveFiring(const ScriptEvent& evt) throw(reflection::InvocationTargetException, RuntimeException);
+    // XPropertySet
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySetInfo > SAL_CALL getPropertySetInfo(  ) throw (::com::sun::star::uno::RuntimeException);    
+    // XInitialization
+    virtual void SAL_CALL initialize( const Sequence< Any >& aArguments ) throw (Exception, RuntimeException);
+    // XInterface
+    DECLARE_XINTERFACE()
+
+    // XTypeProvider
+    DECLARE_XTYPEPROVIDER()
+
+protected:
+    // OPropertySetHelper
+    virtual ::cppu::IPropertyArrayHelper& SAL_CALL getInfoHelper(  );
+
+    // OPropertyArrayUsageHelper
+    virtual ::cppu::IPropertyArrayHelper* createArrayHelper(  ) const;
+
+private:
+    void firing_Impl( const  ScriptEvent& evt, Any *pSyncRet=NULL ) throw( RuntimeException );
+
+    Reference< XComponentContext > m_xContext;
+    Reference< frame::XModel > m_xModel;
+    
+};
+
+EventListener::EventListener( const Reference< XComponentContext >& rxContext ) :
+OPropertyContainer(GetBroadcastHelper()), m_xContext( rxContext )
+{
+    registerProperty( EVENTLSTNR_PROPERTY_MODEL, EVENTLSTNR_PROPERTY_ID_MODEL,
+        beans::PropertyAttribute::TRANSIENT, &m_xModel, ::getCppuType( &m_xModel ) );
+
+}
+
+//XEventListener
+void
+EventListener::disposing(const lang::EventObject& Source)  throw( RuntimeException )
+{
+}
+
+//XScriptListener
+
+void SAL_CALL 
+EventListener::firing(const ScriptEvent& evt) throw(RuntimeException)
+{
+    firing_Impl( evt );
+}
+
+Any SAL_CALL 
+EventListener::approveFiring(const ScriptEvent& evt) throw(reflection::InvocationTargetException, RuntimeException)
+{
+    Any ret;
+    firing_Impl( evt, &ret );
+    return ret;
+}
+
+// XInitialization
+void SAL_CALL 
+EventListener::initialize( const Sequence< Any >& aArguments ) throw (Exception, RuntimeException)
+{
+    if ( aArguments.getLength() == 1 )
+        aArguments[0] >>= m_xModel;
+    OSL_TRACE("EventListener::initialize() args %d m_xModel %d", aArguments.getLength(), m_xModel.is() );
+}
+
+// XInterface
+
+IMPLEMENT_FORWARD_XINTERFACE2( EventListener, EventListener_BASE, OPropertyContainer )
+
+// XTypeProvider
+
+IMPLEMENT_FORWARD_XTYPEPROVIDER2( EventListener, EventListener_BASE, OPropertyContainer )
+
+// OPropertySetHelper
+
+::cppu::IPropertyArrayHelper& 
+EventListener::getInfoHelper(  )
+{
+    return *getArrayHelper();
+}
+
+// OPropertyArrayUsageHelper
+
+::cppu::IPropertyArrayHelper* 
+EventListener::createArrayHelper(  ) const
+{
+    Sequence< beans::Property > aProps;
+    describeProperties( aProps );
+    return new ::cppu::OPropertyArrayHelper( aProps );
+}
+
+// XPropertySet
+Reference< beans::XPropertySetInfo > 
+EventListener::getPropertySetInfo(  ) throw (RuntimeException)
+{
+    Reference< beans::XPropertySetInfo > xInfo( createPropertySetInfo( getInfoHelper() ) );
+    return xInfo;
+}
+
+
+// EventListener
+
+void
+EventListener::firing_Impl(const ScriptEvent& evt, Any* pRet ) throw(RuntimeException)
+{
+	OSL_TRACE("EventListener::firing_Impl( FAKE VBA_EVENTS )");
+    static const ::rtl::OUString vbaInterOp =
+        ::rtl::OUString::createFromAscii("VBAInterop");
+
+    // let default handlers deal with non vba stuff
+    if ( !evt.ScriptType.equals( vbaInterOp ) )
+        return;
+    lang::EventObject aEvent;
+    evt.Arguments[ 0 ] >>= aEvent;
+	OSL_TRACE("Argument[0] is  %s", rtl::OUStringToOString( comphelper::anyToString( evt.Arguments[0] ), RTL_TEXTENCODING_UTF8 ).getStr() );
+	OSL_TRACE("Getting Control");
+    uno::Reference< awt::XControl > xControl( aEvent.Source, uno::UNO_QUERY_THROW );
+	OSL_TRACE("Getting properties");
+    uno::Reference< beans::XPropertySet > xProps( xControl->getModel(), uno::UNO_QUERY_THROW );
+    rtl::OUString sName;
+	OSL_TRACE("Getting Name");
+    xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Name") ) ) >>= sName;
+    //dumpEvent( evt );
+    EventInfoHash& infos = getEventTransInfo();
+    EventInfoHash::const_iterator eventInfo_it = infos.find( evt.MethodName );
+    EventInfoHash::const_iterator it_end = infos.end();
+    if ( eventInfo_it == it_end )
+    {
+        OSL_TRACE("Bogus event for %s",
+            rtl::OUStringToOString( evt.ScriptType, RTL_TEXTENCODING_UTF8 ).getStr() );
+        return;
+    }
+
+    uno::Reference< script::provider::XScriptProviderSupplier > xSPS( m_xModel, uno::UNO_QUERY );
+    uno::Reference< script::provider::XScriptProvider > xScriptProvider;
+    if ( xSPS.is() )
+        xScriptProvider =  xSPS->getScriptProvider();
+    if ( xScriptProvider.is() )
+    {
+        std::list< TranslateInfo > matchingMethods;
+        std::list< TranslateInfo >::const_iterator txInfo =
+            eventInfo_it->second.begin();
+        std::list< TranslateInfo >::const_iterator txInfo_end = eventInfo_it->second.end();
+        for ( ; txInfo != txInfo_end; ++txInfo )
+        {
+            // see if we have a match for the handlerextension
+            // where ScriptCode is methodname_handlerextension 
+            rtl::OUString sTemp = rtl::OUString::createFromAscii("Standard.").concat( evt.ScriptCode ).concat( rtl::OUString::createFromAscii(".") ).concat( sName ).concat( (*txInfo).sVBAName ); 
+            
+            OSL_TRACE("*** trying to invoke %s ",
+                rtl::OUStringToOString( sTemp, RTL_TEXTENCODING_UTF8 ).getStr() );
+            //if ( sTemp.equals( (*txInfo).sVBAName ) )
+            {
+                // !! translate arguments & emulate events where necessary 
+                Sequence< Any > aArguments;
+                if  ( (*txInfo).toVBA )
+                    aArguments = (*txInfo).toVBA( evt.Arguments );
+                else
+                    aArguments = evt.Arguments;
+                if ( aArguments.getLength() )
+                {
+                    // call basic event handlers for event
+
+                    static rtl::OUString part1 = rtl::OUString::createFromAscii( "vnd.sun.star.script:");
+                    static rtl::OUString part2 = rtl::OUString::createFromAscii("?language=Basic&location=document"); 
+
+                    // create script url
+                    rtl::OUString url = part1 + sTemp + part2;
+                 
+                    OSL_TRACE("script url = %s",
+                        rtl::OUStringToOString( url, 
+                            RTL_TEXTENCODING_UTF8 ).getStr() );
+                    Any aRet; // temp
+                    Sequence< sal_Int16 > aOutArgsIndex;
+                    Sequence< Any > aOutArgs;
+                    try
+                    {
+                        uno::Reference< script::provider::XScript > xScript = xScriptProvider->getScript( url );
+                        if ( xScript.is() )
+                           xScript->invoke( aArguments, aOutArgsIndex, aOutArgs );
+                    }
+                    catch ( uno::Exception& e )
+                    {
+                        OSL_TRACE("event script raised %s", rtl::OUStringToOString( e.Message, RTL_TEXTENCODING_UTF8 ).getStr() );
+                    }
+               } 
+           }
+       }
+    }
+}
+
+typedef ::cppu::WeakImplHelper1< XVBAToOOEventDescGen > VBAToOOEventDescGen_BASE;
+
+
+class VBAToOOEventDescGen : public VBAToOOEventDescGen_BASE
+{
+public:
+    VBAToOOEventDescGen( const Reference< XComponentContext >& rxContext );
+
+    // XVBAToOOEventDescGen
+    virtual Sequence< ScriptEventDescriptor > SAL_CALL getEventDescriptions( const Reference< XInterface >& control, const rtl::OUString& sLibModName, const Sequence< rtl::OUString >& sHandlerExts ) throw (RuntimeException);
+    virtual Reference< XScriptEventsSupplier > SAL_CALL getEventSupplier( const Reference< XInterface >& xControl ) throw (::com::sun::star::uno::RuntimeException);
+private:
+    Reference< XComponentContext > m_xContext;
+  
+};
+
+VBAToOOEventDescGen::VBAToOOEventDescGen( const Reference< XComponentContext >& rxContext ):m_xContext( rxContext ) {}
+
+Sequence< ScriptEventDescriptor > SAL_CALL 
+VBAToOOEventDescGen::getEventDescriptions( const Reference< XInterface >& xControl, const rtl::OUString& sLibModName, const Sequence< rtl::OUString >& sHandlerExts ) throw (RuntimeException)
+{
+    return ScriptEventFactory::instance().createEvents( xControl, sLibModName, sHandlerExts ); 
+}
+
+Reference< XScriptEventsSupplier > SAL_CALL 
+VBAToOOEventDescGen::getEventSupplier( const Reference< XInterface >& xControl ) throw (::com::sun::star::uno::RuntimeException)
+{
+    Reference< XScriptEventsSupplier > xSupplier = 
+        new ReadOnlyEventsSupplier( 
+            ScriptEventFactory::instance().getEventListeners( xControl ),
+            xControl ) ;
+    return xSupplier;
+}
+
+// Component related 
+
+namespace evtlstner
+{
+    ::rtl::OUString SAL_CALL getImplementationName()
+    {
+        static ::rtl::OUString* pImplName = 0;
+        if ( !pImplName )
+        {
+            ::osl::MutexGuard aGuard( ::osl::Mutex::getGlobalMutex() );
+            if ( !pImplName )
+            {
+                static ::rtl::OUString aImplName( RTL_CONSTASCII_USTRINGPARAM( "org.openoffice.vba.EventListener" ) );
+                pImplName = &aImplName;
+            }
+        }
+        return *pImplName;
+    }
+
+    uno::Reference< XInterface > SAL_CALL create(
+    Reference< XComponentContext > const & xContext )
+    SAL_THROW( () )
+    {
+        return static_cast< lang::XTypeProvider * >( new EventListener( xContext ) );
+    }
+
+    Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames()
+    {
+        const ::rtl::OUString strName( ::evtlstner::getImplementationName() );
+        return Sequence< ::rtl::OUString >( &strName, 1 );
+    }	
+}
+namespace ooevtdescgen 
+{
+    ::rtl::OUString SAL_CALL getImplementationName()
+    {
+        static ::rtl::OUString* pImplName = 0;
+        if ( !pImplName )
+        {
+            ::osl::MutexGuard aGuard( ::osl::Mutex::getGlobalMutex() );
+            if ( !pImplName )
+            {
+                static ::rtl::OUString aImplName( RTL_CONSTASCII_USTRINGPARAM( "org.openoffice.vba.VBAToOOEventDesc" ) );
+                pImplName = &aImplName;
+            }
+        }
+        return *pImplName;
+    }
+
+    uno::Reference< XInterface > SAL_CALL create(
+        Reference< XComponentContext > const & xContext )
+        SAL_THROW( () )
+    {
+        return static_cast< lang::XTypeProvider * >( new VBAToOOEventDescGen( xContext ) );
+    }
+
+    Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames()
+    {
+    	const ::rtl::OUString strName( ::ooevtdescgen::getImplementationName() );
+        return Sequence< ::rtl::OUString >( &strName, 1 );
+    }	
+}
