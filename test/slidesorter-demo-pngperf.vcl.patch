Index: vcl/inc/bitmap.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/bitmap.hxx,v
retrieving revision 1.18
retrieving revision 1.17.18.2
diff -u -p -r1.18 -r1.17.18.2
--- vcl/inc/bitmap.hxx	2 Nov 2005 13:26:51 -0000	1.18
+++ vcl/inc/bitmap.hxx	15 Nov 2005 09:46:35 -0000	1.17.18.2
@@ -4,9 +4,9 @@
  *
  *  $RCSfile: slidesorter-demo-pngperf.vcl.patch,v $
  *
- *  $Revision: 1.1 $
+ *  $Revision: 1.1 $
  *
- *  last change: $Author: rodo $ $Date: 2005/12/01 19:02:24 $
+ *  last change: $Author: rodo $ $Date: 2005/12/01 19:02:24 $
  *
  *  The Contents of this file are made available subject to
  *  the terms of GNU Lesser General Public License Version 2.1.
@@ -352,6 +352,15 @@ public:
     Size                    GetSizePixel() const;
 	void					SetSizePixel( const Size& rNewSize );
 
+    /**
+     * The pixel size of a bitmap's source (e.g. an image file)
+     * and the pixel size of its resulting bitmap can differ,
+     * e.g. when the image reader has its preview mode enabled.
+     */
+    Size                    GetSourceSizePixel() const;
+    void                    SetSourceSizePixel( const Size& );
+
+
     USHORT                  GetBitCount() const;
     inline ULONG            GetColorCount() const;
     inline ULONG            GetSizeBytes() const;
@@ -763,7 +772,6 @@ public:
 									const Link* pProgress = NULL );
 
 public:
-
     BitmapReadAccess*       AcquireReadAccess();
     BitmapWriteAccess*      AcquireWriteAccess();
     void                    ReleaseAccess( BitmapReadAccess* pAccess );
Index: vcl/inc/bmpacc.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/bmpacc.hxx,v
retrieving revision 1.10
retrieving revision 1.10.18.1
diff -u -p -r1.10 -r1.10.18.1
--- vcl/inc/bmpacc.hxx	9 Sep 2005 10:48:15 -0000	1.10
+++ vcl/inc/bmpacc.hxx	15 Nov 2005 12:24:22 -0000	1.10.18.1
@@ -4,9 +4,9 @@
  *
  *  $RCSfile: slidesorter-demo-pngperf.vcl.patch,v $
  *
- *  $Revision: 1.1 $
+ *  $Revision: 1.1 $
  *
- *  last change: $Author: rodo $ $Date: 2005/12/01 19:02:24 $
+ *  last change: $Author: rodo $ $Date: 2005/12/01 19:02:24 $
  *
  *  The Contents of this file are made available subject to
  *  the terms of GNU Lesser General Public License Version 2.1.
@@ -58,7 +58,7 @@
 // --------------------
 
 #define DECL_FORMAT_GETPIXEL( Format ) \
-static BitmapColor GetPixelFor##Format( Scanline pScanline, long nX, const ColorMask& rMask );
+static BitmapColor GetPixelFor##Format( ConstScanline pScanline, long nX, const ColorMask& rMask );
 
 #define DECL_FORMAT_SETPIXEL( Format ) \
 static void SetPixelFor##Format( Scanline pScanline, long nX, const BitmapColor& rBitmapColor, const ColorMask& rMask );
@@ -68,7 +68,7 @@ DECL_FORMAT_GETPIXEL( Format )  \
 DECL_FORMAT_SETPIXEL( Format )
 
 #define IMPL_FORMAT_GETPIXEL( Format ) \
-BitmapColor BitmapReadAccess::GetPixelFor##Format( Scanline pScanline, long nX, const ColorMask& rMask )
+BitmapColor BitmapReadAccess::GetPixelFor##Format( ConstScanline pScanline, long nX, const ColorMask& rMask )
 
 #define IMPL_FORMAT_SETPIXEL( Format ) \
 void BitmapReadAccess::SetPixelFor##Format( Scanline pScanline, long nX, const BitmapColor& rBitmapColor, const ColorMask& rMask )
@@ -87,7 +87,7 @@ break;
 // - Access functions -
 // --------------------
 
-typedef BitmapColor (*FncGetPixel)( Scanline pScanline, long nX, const ColorMask& rMask );
+typedef BitmapColor (*FncGetPixel)( ConstScanline pScanline, long nX, const ColorMask& rMask );
 typedef void (*FncSetPixel)( Scanline pScanline, long nX, const BitmapColor& rBitmapColor, const ColorMask& rMask );
 
 // --------------------
@@ -198,7 +198,7 @@ public:
     virtual                     ~BitmapWriteAccess();
 
     void                        CopyScanline( long nY, const BitmapReadAccess& rReadAcc );
-    void                        CopyScanline( long nY, const Scanline aSrcScanline, 
+    void                        CopyScanline( long nY, ConstScanline aSrcScanline, 
 											  ULONG nSrcScanlineFormat, ULONG nSrcScanlineSize );
 
     void                        CopyBuffer( const BitmapReadAccess& rReadAcc );
Index: vcl/inc/bmpfast.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/bmpfast.hxx,v
retrieving revision 1.3
retrieving revision 1.3.18.1
diff -u -p -r1.3 -r1.3.18.1
--- vcl/inc/bmpfast.hxx	9 Sep 2005 10:48:29 -0000	1.3
+++ vcl/inc/bmpfast.hxx	27 Sep 2005 10:14:21 -0000	1.3.18.1
@@ -4,9 +4,9 @@
  *
  *  $RCSfile: slidesorter-demo-pngperf.vcl.patch,v $
  *
- *  $Revision: 1.1 $
+ *  $Revision: 1.1 $
  *
- *  last change: $Author: rodo $ $Date: 2005/12/01 19:02:24 $
+ *  last change: $Author: rodo $ $Date: 2005/12/01 19:02:24 $
  *
  *  The Contents of this file are made available subject to
  *  the terms of GNU Lesser General Public License Version 2.1.
@@ -35,19 +35,25 @@
 
 #ifndef _SV_BMPFAST_HXX
 #define _SV_BMPFAST_HXX
- 
+
 class BitmapWriteAccess;
 class BitmapReadAccess;
 class BitmapBuffer;
+class BitmapColor;
 class Size;
 class Point;
 struct SalTwoRect;
- 
+
+// the bmpfast functions have signatures with good compatibility to
+// their canonic counterparts, which employ the GetPixel/SetPixel methods
+
 bool ImplFastBitmapConversion( BitmapBuffer& rDst, const BitmapBuffer& rSrc,
         const SalTwoRect& rTwoRect );
 
 bool ImplFastBitmapBlending( BitmapWriteAccess& rDst,
     const BitmapReadAccess& rSrc, const BitmapReadAccess& rMask,
     const SalTwoRect& rTwoRect );
+
+bool ImplFastEraseBitmap( BitmapBuffer&, const BitmapColor& );
 
 #endif // _SV_BMPFAST_HXX
Index: vcl/inc/graph.h
===================================================================
RCS file: /cvs/gsl/vcl/inc/graph.h,v
retrieving revision 1.3
retrieving revision 1.3.18.2
diff -u -p -r1.3 -r1.3.18.2
--- vcl/inc/graph.h	9 Sep 2005 10:59:00 -0000	1.3
+++ vcl/inc/graph.h	26 Oct 2005 11:45:28 -0000	1.3.18.2
@@ -4,9 +4,9 @@
  *
  *  $RCSfile: slidesorter-demo-pngperf.vcl.patch,v $
  *
- *  $Revision: 1.1 $
+ *  $Revision: 1.1 $
  *
- *  last change: $Author: rodo $ $Date: 2005/12/01 19:02:24 $
+ *  last change: $Author: rodo $ $Date: 2005/12/01 19:02:24 $
  *
  *  The Contents of this file are made available subject to
  *  the terms of GNU Lesser General Public License Version 2.1.
@@ -85,6 +85,13 @@ public:
     const String&   GetUpperFilterName() const { return maUpperName; }
     ReaderData*     GetReaderData() const { return mpReaderData; }
     BOOL            IsReading() const { return mbIsReading; }
+
+    // TODO: when incompatible changes are possible again
+    // the preview size hint should be redone
+    BOOL            IsPreviewModeEnabled() const;
+    void            DisablePreviewMode();
+    void            SetPreviewSize( const Size& );
+    Size            GetPreviewSize() const;
 };
 
 #endif // _SV_GRAPH_H
Index: vcl/inc/impbmp.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/impbmp.hxx,v
retrieving revision 1.4
retrieving revision 1.4.18.1
diff -u -p -r1.4 -r1.4.18.1
--- vcl/inc/impbmp.hxx	9 Sep 2005 11:02:46 -0000	1.4
+++ vcl/inc/impbmp.hxx	26 Oct 2005 11:43:45 -0000	1.4.18.1
@@ -4,9 +4,9 @@
  *
  *  $RCSfile: slidesorter-demo-pngperf.vcl.patch,v $
  *
- *  $Revision: 1.1 $
+ *  $Revision: 1.1 $
  *
- *  last change: $Author: rodo $ $Date: 2005/12/01 19:02:24 $
+ *  last change: $Author: rodo $ $Date: 2005/12/01 19:02:24 $
  *
  *  The Contents of this file are made available subject to
  *  the terms of GNU Lesser General Public License Version 2.1.
@@ -67,7 +67,8 @@ private:
 	ULONG				mnChecksum;
 	RMBitmap*			mpRMBitmap;
     SalBitmap*			mpSalBitmap;
-
+	Size				maSourceSize;
+    
 public:
 
 						ImpBitmap();
@@ -90,13 +91,15 @@ public:
     void				ImplDestroy();
 						
     Size				ImplGetSize() const;
+    Size				ImplGetSourceSize() const;
+    void				ImplSetSourceSize( const Size&);
     USHORT				ImplGetBitCount() const;
 						
     BitmapBuffer*		ImplAcquireBuffer( BOOL bReadOnly );
     void				ImplReleaseBuffer( BitmapBuffer* pBuffer, BOOL bReadOnly );
 						
 public:					
-
+	
     ULONG				ImplGetRefCount() const { return mnRefCount; }
     void				ImplIncRefCount() { mnRefCount++; }
     void				ImplDecRefCount() { mnRefCount--; }
@@ -106,5 +109,15 @@ public:					
 
 #endif // PRIVATE
 };
+
+inline Size ImpBitmap::ImplGetSourceSize() const
+{
+	return maSourceSize;
+}
+
+inline void ImpBitmap::ImplSetSourceSize( const Size& rSize)
+{
+	maSourceSize = rSize;
+}
 
 #endif // _SV_IMPBMP_HXX
Index: vcl/inc/pngread.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/pngread.hxx,v
retrieving revision 1.5
retrieving revision 1.5.18.2
diff -u -p -r1.5 -r1.5.18.2
--- vcl/inc/pngread.hxx	9 Sep 2005 11:14:10 -0000	1.5
+++ vcl/inc/pngread.hxx	13 Oct 2005 10:18:52 -0000	1.5.18.2
@@ -4,9 +4,9 @@
  *
  *  $RCSfile: slidesorter-demo-pngperf.vcl.patch,v $
  *
- *  $Revision: 1.1 $
+ *  $Revision: 1.1 $
  *
- *  last change: $Author: rodo $ $Date: 2005/12/01 19:02:24 $
+ *  last change: $Author: rodo $ $Date: 2005/12/01 19:02:24 $
  *
  *  The Contents of this file are made available subject to
  *  the terms of GNU Lesser General Public License Version 2.1.
@@ -73,6 +73,13 @@ namespace vcl
 			std::vector< sal_uInt8 >	aData;
 		};
 		const std::vector< ChunkData >&	GetChunks() const;
+
+		// TODO: when incompatible changes are possible again
+		// the preview size hint should be redone
+		static void SetPreviewSizeHint( const Size& r ) { aPreviewSizeHint = r; }
+		static void DisablePreviewMode() { aPreviewSizeHint = Size(0,0); }
+	private:
+		static Size aPreviewSizeHint;
 	};
 }
 
Index: vcl/inc/salbtype.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/salbtype.hxx,v
retrieving revision 1.10
retrieving revision 1.10.18.1
diff -u -p -r1.10 -r1.10.18.1
--- vcl/inc/salbtype.hxx	9 Sep 2005 11:18:10 -0000	1.10
+++ vcl/inc/salbtype.hxx	15 Nov 2005 12:24:22 -0000	1.10.18.1
@@ -4,9 +4,9 @@
  *
  *  $RCSfile: slidesorter-demo-pngperf.vcl.patch,v $
  *
- *  $Revision: 1.1 $
+ *  $Revision: 1.1 $
  *
- *  last change: $Author: rodo $ $Date: 2005/12/01 19:02:24 $
+ *  last change: $Author: rodo $ $Date: 2005/12/01 19:02:24 $
  *
  *  The Contents of this file are made available subject to
  *  the terms of GNU Lesser General Public License Version 2.1.
@@ -64,6 +64,8 @@
 
 typedef BYTE*		HPBYTE;
 typedef HPBYTE		Scanline;
+typedef const BYTE*	ConstHPBYTE;
+typedef ConstHPBYTE	ConstScanline;
 
 // --------------------
 // - Helper functions -
@@ -264,18 +266,18 @@ public:
 	inline ULONG		GetGreenMask() const;
 	inline ULONG		GetBlueMask() const;
 
-	inline void 		GetColorFor8Bit( BitmapColor& rColor, HPBYTE pPixel ) const;
+	inline void 		GetColorFor8Bit( BitmapColor& rColor, ConstHPBYTE pPixel ) const;
 	inline void 		SetColorFor8Bit( const BitmapColor& rColor, HPBYTE pPixel ) const;
 
-	inline void 		GetColorFor16BitMSB( BitmapColor& rColor, HPBYTE pPixel ) const;
+	inline void 		GetColorFor16BitMSB( BitmapColor& rColor, ConstHPBYTE pPixel ) const;
 	inline void 		SetColorFor16BitMSB( const BitmapColor& rColor, HPBYTE pPixel ) const;
-	inline void 		GetColorFor16BitLSB( BitmapColor& rColor, HPBYTE pPixel ) const;
+	inline void 		GetColorFor16BitLSB( BitmapColor& rColor, ConstHPBYTE pPixel ) const;
 	inline void 		SetColorFor16BitLSB( const BitmapColor& rColor, HPBYTE pPixel ) const;
 
-	inline void 		GetColorFor24Bit( BitmapColor& rColor, HPBYTE pPixel ) const;
+	inline void 		GetColorFor24Bit( BitmapColor& rColor, ConstHPBYTE pPixel ) const;
 	inline void 		SetColorFor24Bit( const BitmapColor& rColor, HPBYTE pPixel ) const;
 
-	inline void 		GetColorFor32Bit( BitmapColor& rColor, HPBYTE pPixel ) const;
+	inline void 		GetColorFor32Bit( BitmapColor& rColor, ConstHPBYTE pPixel ) const;
 	inline void 		SetColorFor32Bit( const BitmapColor& rColor, HPBYTE pPixel ) const;
 };
 
@@ -818,7 +820,7 @@ inline ULONG ColorMask::GetBlueMask() co
 
 // ------------------------------------------------------------------
 
-inline void ColorMask::GetColorFor8Bit( BitmapColor& rColor, HPBYTE pPixel ) const
+inline void ColorMask::GetColorFor8Bit( BitmapColor& rColor, ConstHPBYTE pPixel ) const
 {
 	const UINT32 nVal = *pPixel;
 	MASK_TO_COLOR( nVal, mnRMask, mnGMask, mnBMask, mnRShift, mnGShift, mnBShift, rColor );
@@ -833,7 +835,7 @@ inline void ColorMask::SetColorFor8Bit( 
 
 // ------------------------------------------------------------------
 
-inline void ColorMask::GetColorFor16BitMSB( BitmapColor& rColor, HPBYTE pPixel ) const
+inline void ColorMask::GetColorFor16BitMSB( BitmapColor& rColor, ConstHPBYTE pPixel ) const
 {
 #ifdef OSL_BIGENDIAN
 	const UINT32 nVal = *(UINT16*) pPixel;
@@ -853,7 +855,7 @@ inline void ColorMask::SetColorFor16BitM
 
 // ------------------------------------------------------------------
 
-inline void ColorMask::GetColorFor16BitLSB( BitmapColor& rColor, HPBYTE pPixel ) const
+inline void ColorMask::GetColorFor16BitLSB( BitmapColor& rColor, ConstHPBYTE pPixel ) const
 {
 #ifdef OSL_BIGENDIAN
 	const UINT32 nVal = pPixel[ 0 ] | ( (UINT32) pPixel[ 1 ] << 8UL );
@@ -879,7 +881,7 @@ inline void ColorMask::SetColorFor16BitL
 
 // ------------------------------------------------------------------
 
-inline void ColorMask::GetColorFor24Bit( BitmapColor& rColor, HPBYTE pPixel ) const
+inline void ColorMask::GetColorFor24Bit( BitmapColor& rColor, ConstHPBYTE pPixel ) const
 {
 	const UINT32 nVal = pPixel[ 0 ] | ( (UINT32) pPixel[ 1 ] << 8UL ) | ( (UINT32) pPixel[ 2 ] << 16UL );
 	MASK_TO_COLOR( nVal, mnRMask, mnGMask, mnBMask, mnRShift, mnGShift, mnBShift, rColor );
@@ -895,7 +897,7 @@ inline void ColorMask::SetColorFor24Bit(
 
 // ------------------------------------------------------------------
 
-inline void ColorMask::GetColorFor32Bit( BitmapColor& rColor, HPBYTE pPixel ) const
+inline void ColorMask::GetColorFor32Bit( BitmapColor& rColor, ConstHPBYTE pPixel ) const
 {
 #ifdef OSL_BIGENDIAN
 	const UINT32 nVal = (UINT32) pPixel[ 0 ] | ( (UINT32) pPixel[ 1 ] << 8UL ) |
Index: vcl/source/gdi/bitmap.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/bitmap.cxx,v
retrieving revision 1.13
retrieving revision 1.13.18.1
diff -u -p -r1.13 -r1.13.18.1
--- vcl/source/gdi/bitmap.cxx	9 Sep 2005 11:52:27 -0000	1.13
+++ vcl/source/gdi/bitmap.cxx	26 Oct 2005 11:45:57 -0000	1.13.18.1
@@ -4,9 +4,9 @@
  *
  *  $RCSfile: slidesorter-demo-pngperf.vcl.patch,v $
  *
- *  $Revision: 1.1 $
+ *  $Revision: 1.1 $
  *
- *  last change: $Author: rodo $ $Date: 2005/12/01 19:02:24 $
+ *  last change: $Author: rodo $ $Date: 2005/12/01 19:02:24 $
  *
  *  The Contents of this file are made available subject to
  *  the terms of GNU Lesser General Public License Version 2.1.
@@ -290,12 +290,26 @@ Size Bitmap::GetSizePixel() const
 {
 	return( mpImpBmp ? mpImpBmp->ImplGetSize() : Size() );
 }
-
 // ------------------------------------------------------------------
 
 void Bitmap::SetSizePixel( const Size& rNewSize )
 {
 	Scale( rNewSize );
+}
+
+// ------------------------------------------------------------------
+
+Size Bitmap::GetSourceSizePixel() const
+{
+	return( mpImpBmp ? mpImpBmp->ImplGetSourceSize() : Size() );
+}
+
+// ------------------------------------------------------------------
+
+void Bitmap::SetSourceSizePixel( const Size& rSize)
+{
+	if( mpImpBmp )
+		mpImpBmp->ImplSetSourceSize( rSize);
 }
 
 // ------------------------------------------------------------------
Index: vcl/source/gdi/bmpacc.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/bmpacc.cxx,v
retrieving revision 1.7
retrieving revision 1.7.18.1
diff -u -p -r1.7 -r1.7.18.1
--- vcl/source/gdi/bmpacc.cxx	9 Sep 2005 11:54:05 -0000	1.7
+++ vcl/source/gdi/bmpacc.cxx	15 Nov 2005 12:24:23 -0000	1.7.18.1
@@ -4,9 +4,9 @@
  *
  *  $RCSfile: slidesorter-demo-pngperf.vcl.patch,v $
  *
- *  $Revision: 1.1 $
+ *  $Revision: 1.1 $
  *
- *  last change: $Author: rodo $ $Date: 2005/12/01 19:02:24 $
+ *  last change: $Author: rodo $ $Date: 2005/12/01 19:02:24 $
  *
  *  The Contents of this file are made available subject to
  *  the terms of GNU Lesser General Public License Version 2.1.
@@ -336,7 +336,7 @@ void BitmapWriteAccess::CopyScanline( lo
 
 // ------------------------------------------------------------------
 
-void BitmapWriteAccess::CopyScanline( long nY, const Scanline aSrcScanline,
+void BitmapWriteAccess::CopyScanline( long nY, ConstScanline aSrcScanline,
 									  ULONG nSrcScanlineFormat, ULONG nSrcScanlineSize )
 {
 	const ULONG nFormat = BMP_SCANLINE_FORMAT( nSrcScanlineFormat );
Index: vcl/source/gdi/bmpacc3.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/bmpacc3.cxx,v
retrieving revision 1.6
retrieving revision 1.6.18.1
diff -u -p -r1.6 -r1.6.18.1
--- vcl/source/gdi/bmpacc3.cxx	9 Sep 2005 11:54:48 -0000	1.6
+++ vcl/source/gdi/bmpacc3.cxx	27 Sep 2005 10:13:57 -0000	1.6.18.1
@@ -4,9 +4,9 @@
  *
  *  $RCSfile: slidesorter-demo-pngperf.vcl.patch,v $
  *
- *  $Revision: 1.1 $
+ *  $Revision: 1.1 $
  *
- *  last change: $Author: rodo $ $Date: 2005/12/01 19:02:24 $
+ *  last change: $Author: rodo $ $Date: 2005/12/01 19:02:24 $
  *
  *  The Contents of this file are made available subject to
  *  the terms of GNU Lesser General Public License Version 2.1.
@@ -48,6 +48,9 @@
 #ifndef _SV_BMPACC_HXX
 #include <bmpacc.hxx>
 #endif
+#ifndef _SV_BMPFAST_HXX
+#include <bmpfast.hxx>
+#endif
 
 // ---------------------
 // - BitmapWriteAccess -
@@ -123,6 +126,11 @@ Color BitmapWriteAccess::GetFillColor() 
 
 void BitmapWriteAccess::Erase( const Color& rColor )
 {
+    // try fast bitmap method first
+    if( ImplFastEraseBitmap( *mpBuffer, rColor ) )
+        return;
+
+    // use the canonical method to clear the bitmap
 	BitmapColor*	pOldFillColor = mpFillColor ? new BitmapColor( *mpFillColor ) : NULL;
 	const Point		aPoint;	
 	const Rectangle	aRect( aPoint, maBitmap.GetSizePixel() );
Index: vcl/source/gdi/bmpfast.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/bmpfast.cxx,v
retrieving revision 1.4
retrieving revision 1.3.18.2
diff -u -p -r1.4 -r1.3.18.2
--- vcl/source/gdi/bmpfast.cxx	28 Sep 2005 14:43:04 -0000	1.4
+++ vcl/source/gdi/bmpfast.cxx	15 Nov 2005 09:58:59 -0000	1.3.18.2
@@ -4,9 +4,9 @@
  *
  *  $RCSfile: slidesorter-demo-pngperf.vcl.patch,v $
  *
- *  $Revision: 1.1 $
+ *  $Revision: 1.1 $
  *
- *  last change: $Author: rodo $ $Date: 2005/12/01 19:02:24 $
+ *  last change: $Author: rodo $ $Date: 2005/12/01 19:02:24 $
  *
  *  The Contents of this file are made available subject to
  *  the terms of GNU Lesser General Public License Version 2.1.
@@ -41,7 +41,7 @@
 #define _SOLAR__PRIVATE 1
 #include <bmpacc.hxx>
 
-//#define FAST_ARGB_BGRA
+#define FAST_ARGB_BGRA
 
 #include <stdlib.h>
 static bool bDisableFastBitops = (getenv( "SAL_DISABLE_BITMAPS_OPTS" ) != NULL);
@@ -56,7 +56,7 @@ public:
     PIXBYTE* GetRawPtr( void ) const                    { return mpPixel; }
     void    AddByteOffset( int nByteOffset )            { mpPixel += nByteOffset; }
     bool    operator<( const BasePixelPtr& rCmp ) const { return (mpPixel < rCmp.mpPixel); }
-   
+
 protected:
    PIXBYTE* mpPixel;
 };
@@ -69,7 +69,7 @@ public:
     PIXBYTE GetGreen() const;
     PIXBYTE GetBlue() const;
     PIXBYTE GetAlpha() const;
-    
+
     void    SetColor( PIXBYTE r, PIXBYTE g, PIXBYTE b ) const;
     void    SetAlpha( PIXBYTE a ) const;
     void    operator++(int);
@@ -83,13 +83,13 @@ class TrueColorPixelPtr<BMP_FORMAT_24BIT
 {
 public:
     void    operator++()       { mpPixel += 3; }
-    
+
     PIXBYTE GetRed() const     { return mpPixel[0]; }
     PIXBYTE GetGreen() const   { return mpPixel[1]; }
     PIXBYTE GetBlue() const    { return mpPixel[2]; }
     PIXBYTE GetAlpha() const   { return 0; }
     void SetAlpha( PIXBYTE ) const {}
-    
+
     void SetColor( PIXBYTE r, PIXBYTE g, PIXBYTE b ) const
     {
         mpPixel[0] = r;
@@ -103,13 +103,13 @@ class TrueColorPixelPtr<BMP_FORMAT_24BIT
 {
 public:
     void    operator++()        { mpPixel += 3; }
-    
+
     PIXBYTE GetRed() const      { return mpPixel[2]; }
     PIXBYTE GetGreen() const    { return mpPixel[1]; }
     PIXBYTE GetBlue() const     { return mpPixel[0]; }
     PIXBYTE GetAlpha() const    { return 0; }
     void SetAlpha( PIXBYTE ) const  {}
-    
+
     void SetColor( PIXBYTE r, PIXBYTE g, PIXBYTE b ) const
     {
         mpPixel[0] = b;
@@ -123,13 +123,13 @@ class TrueColorPixelPtr<BMP_FORMAT_32BIT
 {
 public:
     void    operator++()        { mpPixel += 4; }
-    
+
     PIXBYTE GetRed() const      { return mpPixel[1]; }
     PIXBYTE GetGreen() const    { return mpPixel[2]; }
     PIXBYTE GetBlue() const     { return mpPixel[3]; }
     PIXBYTE GetAlpha() const    { return mpPixel[0]; }
     void SetAlpha( PIXBYTE a ) const { mpPixel[0] = a; }
-    
+
     void SetColor( PIXBYTE r, PIXBYTE g, PIXBYTE b ) const
     {
         mpPixel[1] = r;
@@ -143,13 +143,13 @@ class TrueColorPixelPtr<BMP_FORMAT_32BIT
 {
 public:
     void    operator++()        { mpPixel += 4; }
-    
+
     PIXBYTE GetRed() const      { return mpPixel[3]; }
     PIXBYTE GetGreen() const    { return mpPixel[2]; }
     PIXBYTE GetBlue() const     { return mpPixel[1]; }
     PIXBYTE GetAlpha() const    { return mpPixel[0]; }
     void SetAlpha( PIXBYTE a ) const { mpPixel[0] = a; }
-    
+
     void SetColor( PIXBYTE r, PIXBYTE g, PIXBYTE b ) const
     {
         mpPixel[1] = b;
@@ -163,13 +163,13 @@ class TrueColorPixelPtr<BMP_FORMAT_32BIT
 {
 public:
     void    operator++()            { mpPixel += 4; }
-    
+
     PIXBYTE GetRed() const          { return mpPixel[0]; }
     PIXBYTE GetGreen() const        { return mpPixel[1]; }
     PIXBYTE GetBlue() const         { return mpPixel[2]; }
     PIXBYTE GetAlpha() const        { return mpPixel[3]; }
     void SetAlpha( PIXBYTE a ) const{ mpPixel[3] = a; }
-    
+
     void SetColor( PIXBYTE r, PIXBYTE g, PIXBYTE b ) const
     {
         mpPixel[0] = r;
@@ -183,13 +183,13 @@ class TrueColorPixelPtr<BMP_FORMAT_32BIT
 {
 public:
     void    operator++()            { mpPixel += 4; }
-    
+
     PIXBYTE GetRed() const          { return mpPixel[2]; }
     PIXBYTE GetGreen() const        { return mpPixel[1]; }
     PIXBYTE GetBlue() const         { return mpPixel[0]; }
     PIXBYTE GetAlpha() const        { return mpPixel[3]; }
     void SetAlpha( PIXBYTE a ) const{ mpPixel[3] = a; }
-    
+
     void SetColor( PIXBYTE r, PIXBYTE g, PIXBYTE b ) const
     {
         mpPixel[0] = b;
@@ -203,14 +203,14 @@ class TrueColorPixelPtr<BMP_FORMAT_16BIT
 {
 public:
     void    operator++()            { mpPixel += 2; }
-    
+
     // TODO: non565-RGB
     PIXBYTE GetRed() const          { return (mpPixel[0] & 0xF8U); }
     PIXBYTE GetGreen() const        { return (mpPixel[0]<<5U) | ((mpPixel[1]>>3U)&28U); }
     PIXBYTE GetBlue() const         { return (mpPixel[1]<<3U); }
     PIXBYTE GetAlpha() const        { return 0; }
     void SetAlpha( PIXBYTE ) const  {}
-    
+
     void SetColor( PIXBYTE r, PIXBYTE g, PIXBYTE b ) const
     {
         mpPixel[0] = ((g >> 5U) & 7U) | (r & 0xF8U);
@@ -223,14 +223,14 @@ class TrueColorPixelPtr<BMP_FORMAT_16BIT
 {
 public:
     void    operator++()            { mpPixel += 2; }
-    
+
     // TODO: non565-RGB
     PIXBYTE GetRed() const          { return (mpPixel[1] & 0xF8U); }
     PIXBYTE GetGreen() const        { return (mpPixel[1]<<5U) | ((mpPixel[0]>>3U)&28U); }
     PIXBYTE GetBlue() const         { return (mpPixel[0]<<3U); }
     PIXBYTE GetAlpha() const        { return 0; }
     void SetAlpha( PIXBYTE ) const  {}
-    
+
     void SetColor( PIXBYTE r, PIXBYTE g, PIXBYTE b ) const
     {
         mpPixel[0] = ((g & 28U)<< 3U) | (b >> 3U);
@@ -285,7 +285,7 @@ class TrueColorPixelPtr<BMP_FORMAT_32BIT
 {
 public:
     void operator++()   { mpPixel += 4; }
-    
+
     unsigned GetAlpha() const
     {
 #ifdef OSL_BIGENDIAN
@@ -298,7 +298,7 @@ public:
 #endif
         return nAlpha;
     }
-    
+
     void SetAlpha( unsigned nAlpha ) const
     {
 #ifdef OSL_BIGENDIAN
@@ -433,7 +433,7 @@ static bool ImplCopyImage( BitmapBuffer&
 {
     const int nSrcLinestep = rSrcBuffer.mnScanlineSize;
     int nDstLinestep = rDstBuffer.mnScanlineSize;
-    
+
     const PIXBYTE* pRawSrc = rSrcBuffer.mpBits;
     PIXBYTE* pRawDst = rDstBuffer.mpBits;
 
@@ -448,18 +448,18 @@ static bool ImplCopyImage( BitmapBuffer&
         memcpy( pRawDst, pRawSrc, rSrcBuffer.mnHeight * nDstLinestep );
         return true;
     }
-    
+
     int nByteWidth = nSrcLinestep;
     if( nByteWidth > rDstBuffer.mnScanlineSize )
         nByteWidth = rDstBuffer.mnScanlineSize;
-    
+
     for( int y = rSrcBuffer.mnHeight; --y >= 0; )
     {
         memcpy( pRawDst, pRawSrc, nByteWidth );
         pRawSrc += nSrcLinestep;
         pRawDst += nDstLinestep;
     }
-    
+
     return true;
 }
 
@@ -473,26 +473,26 @@ static bool ImplConvertToBitmap( TrueCol
     DBG_ASSERT( SRCFMT != DSTFMT, "ImplConvertToBitmap into same format");
     if( SRCFMT == DSTFMT )
         return false;
-        
+
     const int nSrcLinestep = rSrcBuffer.mnScanlineSize;
     int nDstLinestep = rDstBuffer.mnScanlineSize;
-    
+
     TrueColorPixelPtr<DSTFMT> aDstLine; aDstLine.SetRawPtr( rDstBuffer.mpBits );
-    
+
     // source and destination don't match upside down
     if( BMP_FORMAT_TOP_DOWN & (rSrcBuffer.mnFormat ^ rDstBuffer.mnFormat) )
     {
         aDstLine.AddByteOffset( (rSrcBuffer.mnHeight - 1) * nDstLinestep );
         nDstLinestep = -nDstLinestep;
     }
-        
+
     for( int y = rSrcBuffer.mnHeight; --y >= 0; )
     {
         ImplConvertLine( aDstLine, rSrcLine, rSrcBuffer.mnWidth );
         rSrcLine.AddByteOffset( nSrcLinestep );
         aDstLine.AddByteOffset( nDstLinestep );
     }
-    
+
     return true;
 }
 
@@ -502,7 +502,7 @@ template <ULONG SRCFMT>
 inline bool ImplConvertFromBitmap( BitmapBuffer& rDst, const BitmapBuffer& rSrc )
 {
     TrueColorPixelPtr<SRCFMT> aSrcType; aSrcType.SetRawPtr( rSrc.mpBits );
-    
+
     // select the matching instantiation for the destination's bitmap format
     switch( rDst.mnFormat & ~BMP_FORMAT_TOP_DOWN )
     {
@@ -512,7 +512,7 @@ inline bool ImplConvertFromBitmap( Bitma
         case BMP_FORMAT_4BIT_LSN_PAL:
         case BMP_FORMAT_8BIT_PAL:
             break;
-        
+
         case BMP_FORMAT_8BIT_TC_MASK:
 //            return ImplConvertToBitmap<BMP_FORMAT_8BIT_TC_MASK>( aSrcType, rDst, rSrc );
         case BMP_FORMAT_24BIT_TC_MASK:
@@ -520,12 +520,12 @@ inline bool ImplConvertFromBitmap( Bitma
         case BMP_FORMAT_32BIT_TC_MASK:
 //            return ImplConvertToBitmap<BMP_FORMAT_32BIT_TC_MASK>( aSrcType, rDst, rSrc );
             break;
-        
+
         case BMP_FORMAT_16BIT_TC_MSB_MASK:
             return ImplConvertToBitmap<BMP_FORMAT_16BIT_TC_MSB_MASK>( aSrcType, rDst, rSrc );
         case BMP_FORMAT_16BIT_TC_LSB_MASK:
             return ImplConvertToBitmap<BMP_FORMAT_16BIT_TC_LSB_MASK>( aSrcType, rDst, rSrc );
-        
+
         case BMP_FORMAT_24BIT_TC_BGR:
             return ImplConvertToBitmap<BMP_FORMAT_24BIT_TC_BGR>( aSrcType, rDst, rSrc );
         case BMP_FORMAT_24BIT_TC_RGB:
@@ -538,7 +538,7 @@ inline bool ImplConvertFromBitmap( Bitma
             return ImplConvertToBitmap<BMP_FORMAT_32BIT_TC_ARGB>( aSrcType, rDst, rSrc );
         case BMP_FORMAT_32BIT_TC_BGRA:
             return ImplConvertToBitmap<BMP_FORMAT_32BIT_TC_BGRA>( aSrcType, rDst, rSrc );
-#endif           
+#endif
         case BMP_FORMAT_32BIT_TC_RGBA:
             return ImplConvertToBitmap<BMP_FORMAT_32BIT_TC_RGBA>( aSrcType, rDst, rSrc );
     }
@@ -553,7 +553,7 @@ inline bool ImplConvertFromBitmap( Bitma
 
     return false;
 }
-    
+
 // =======================================================================
 
 // an universal stretching conversion is overkill in most common situations
@@ -571,19 +571,19 @@ bool ImplFastBitmapConversion( BitmapBuf
     if( rTR.mnDestHeight < 0 )
         // TODO: rDst.mnFormat ^= BMP_FORMAT_TOP_DOWN;
         return false;
-    
+
     // offseted conversion is not implemented yet
     if( rTR.mnSrcX || rTR.mnSrcY )
         return false;
     if( rTR.mnDestX || rTR.mnDestY )
         return false;
-        
+
     // stretched conversion is not implemented yet
     if( rTR.mnDestWidth != rTR.mnSrcWidth )
         return false;
     if( rTR.mnDestHeight!= rTR.mnSrcHeight )
         return false;
-    
+
     // check source image size
     if( rSrc.mnWidth < rTR.mnSrcX + rTR.mnSrcWidth )
         return false;
@@ -610,7 +610,7 @@ bool ImplFastBitmapConversion( BitmapBuf
         ||  rDst.maColorMask.GetGreenMask()!= 0x07E0
         ||  rDst.maColorMask.GetBlueMask() != 0x001F )
             return false;
-    
+
     // special handling of trivial cases
     if( nSrcFormat == nDstFormat )
     {
@@ -618,8 +618,8 @@ bool ImplFastBitmapConversion( BitmapBuf
         if( rSrc.maPalette != rDst.maPalette )
             return false;
         return ImplCopyImage( rDst, rSrc );
-    }            
-    
+    }
+
     // select the matching instantiation for the source's bitmap format
     switch( nSrcFormat )
     {
@@ -629,7 +629,7 @@ bool ImplFastBitmapConversion( BitmapBuf
         case BMP_FORMAT_4BIT_LSN_PAL:
         case BMP_FORMAT_8BIT_PAL:
             break;
-        
+
         case BMP_FORMAT_8BIT_TC_MASK:
 //            return ImplConvertFromBitmap<BMP_FORMAT_8BIT_TC_MASK>( rDst, rSrc );
         case BMP_FORMAT_24BIT_TC_MASK:
@@ -637,17 +637,17 @@ bool ImplFastBitmapConversion( BitmapBuf
         case BMP_FORMAT_32BIT_TC_MASK:
 //            return ImplConvertFromBitmap<BMP_FORMAT_32BIT_TC_MASK>( rDst, rSrc );
             break;
-        
+
         case BMP_FORMAT_16BIT_TC_MSB_MASK:
             return ImplConvertFromBitmap<BMP_FORMAT_16BIT_TC_MSB_MASK>( rDst, rSrc );
         case BMP_FORMAT_16BIT_TC_LSB_MASK:
             return ImplConvertFromBitmap<BMP_FORMAT_16BIT_TC_LSB_MASK>( rDst, rSrc );
-        
+
         case BMP_FORMAT_24BIT_TC_BGR:
             return ImplConvertFromBitmap<BMP_FORMAT_24BIT_TC_BGR>( rDst, rSrc );
         case BMP_FORMAT_24BIT_TC_RGB:
             return ImplConvertFromBitmap<BMP_FORMAT_24BIT_TC_RGB>( rDst, rSrc );
-        
+
         case BMP_FORMAT_32BIT_TC_ABGR:
             return ImplConvertFromBitmap<BMP_FORMAT_32BIT_TC_ABGR>( rDst, rSrc );
 #ifdef FAST_ARGB_BGRA
@@ -684,14 +684,14 @@ static bool ImplBlendToBitmap( TrueColor
     const int nSrcLinestep = rSrcBuffer.mnScanlineSize;
     int nMskLinestep = rMskBuffer.mnScanlineSize;
     int nDstLinestep = rDstBuffer.mnScanlineSize;
-    
+
     TrueColorPixelPtr<BMP_FORMAT_8BIT_PAL> aMskLine; aMskLine.SetRawPtr( rMskBuffer.mpBits );
     TrueColorPixelPtr<DSTFMT> aDstLine; aDstLine.SetRawPtr( rDstBuffer.mpBits );
-    
+
     // special case for single line masks
     if( rMskBuffer.mnHeight == 1 )
         nMskLinestep = 0;
-    
+
     // source and mask don't match: upside down
     if( (rSrcBuffer.mnFormat ^ rMskBuffer.mnFormat) & BMP_FORMAT_TOP_DOWN )
     {
@@ -705,7 +705,7 @@ static bool ImplBlendToBitmap( TrueColor
         aDstLine.AddByteOffset( (rSrcBuffer.mnHeight - 1) * nDstLinestep );
         nDstLinestep = -nDstLinestep;
     }
-        
+
     for( int y = rSrcBuffer.mnHeight; --y >= 0; )
     {
         ImplBlendLines<8>( aDstLine, rSrcLine, aMskLine, rDstBuffer.mnWidth );
@@ -713,7 +713,7 @@ static bool ImplBlendToBitmap( TrueColor
         rSrcLine.AddByteOffset( nSrcLinestep );
         aMskLine.AddByteOffset( nMskLinestep );
     }
-    
+
     return true;
 }
 
@@ -754,7 +754,7 @@ template <ULONG SRCFMT>
 static bool ImplBlendFromBitmap( BitmapBuffer& rDst, const BitmapBuffer& rSrc, const BitmapBuffer& rMsk )
 {
     TrueColorPixelPtr<SRCFMT> aSrcType; aSrcType.SetRawPtr( rSrc.mpBits );
-    
+
     // select the matching instantiation for the destination's bitmap format
     switch( rDst.mnFormat & ~BMP_FORMAT_TOP_DOWN )
     {
@@ -764,7 +764,7 @@ static bool ImplBlendFromBitmap( BitmapB
         case BMP_FORMAT_4BIT_LSN_PAL:
         case BMP_FORMAT_8BIT_PAL:
             break;
-        
+
         case BMP_FORMAT_8BIT_TC_MASK:
 //            return ImplBlendToBitmap<BMP_FORMAT_8BIT_TC_MASK>( aSrcType, rDst, rSrc, rMsk );
         case BMP_FORMAT_24BIT_TC_MASK:
@@ -772,12 +772,12 @@ static bool ImplBlendFromBitmap( BitmapB
         case BMP_FORMAT_32BIT_TC_MASK:
 //            return ImplBlendToBitmap<BMP_FORMAT_32BIT_TC_MASK>( aSrcType, rDst, rSrc, rMsk );
             break;
-        
+
         case BMP_FORMAT_16BIT_TC_MSB_MASK:
             return ImplBlendToBitmap<BMP_FORMAT_16BIT_TC_MSB_MASK>( aSrcType, rDst, rSrc, rMsk );
         case BMP_FORMAT_16BIT_TC_LSB_MASK:
             return ImplBlendToBitmap<BMP_FORMAT_16BIT_TC_LSB_MASK>( aSrcType, rDst, rSrc, rMsk );
-        
+
         case BMP_FORMAT_24BIT_TC_BGR:
             return ImplBlendToBitmap<BMP_FORMAT_24BIT_TC_BGR>( aSrcType, rDst, rSrc, rMsk );
         case BMP_FORMAT_24BIT_TC_RGB:
@@ -829,19 +829,19 @@ bool ImplFastBitmapBlending( BitmapWrite
     if( rTR.mnDestHeight < 0 )
         // TODO: rDst.mnFormat ^= BMP_FORMAT_TOP_DOWN;
         return false;
-    
+
     // offseted blending is not implemented yet
     if( rTR.mnSrcX || rTR.mnSrcY )
         return false;
     if( rTR.mnDestX || rTR.mnDestY )
         return false;
-        
+
     // stretched blending is not implemented yet
     if( rTR.mnDestWidth != rTR.mnSrcWidth )
         return false;
     if( rTR.mnDestHeight!= rTR.mnSrcHeight )
         return false;
-    
+
     // check source image size
     if( rSrcRA.Width() < rTR.mnSrcX + rTR.mnSrcWidth )
         return false;
@@ -860,14 +860,14 @@ bool ImplFastBitmapBlending( BitmapWrite
         return false;
     if( rDstWA.Height() < rTR.mnDestY + rTR.mnDestHeight )
         return false;
-    
+
     BitmapBuffer& rDst = *rDstWA.ImplGetBitmapBuffer();
     const BitmapBuffer& rSrc = *rSrcRA.ImplGetBitmapBuffer();
     const BitmapBuffer& rMsk = *rMskRA.ImplGetBitmapBuffer();
 
     const ULONG nSrcFormat = rSrc.mnFormat & ~BMP_FORMAT_TOP_DOWN;
     const ULONG nDstFormat = rDst.mnFormat & ~BMP_FORMAT_TOP_DOWN;
-    
+
     // accelerated conversions for 16bit colormasks with non-565 format are not yet implemented
     if( nSrcFormat & (BMP_FORMAT_16BIT_TC_LSB_MASK | BMP_FORMAT_16BIT_TC_MSB_MASK) )
         if( rSrc.maColorMask.GetRedMask()  != 0xF800
@@ -879,7 +879,7 @@ bool ImplFastBitmapBlending( BitmapWrite
         ||  rDst.maColorMask.GetGreenMask()!= 0x07E0
         ||  rDst.maColorMask.GetBlueMask() != 0x001F)
             return false;
-    
+
     // select the matching instantiation for the source's bitmap format
     switch( nSrcFormat )
     {
@@ -889,7 +889,7 @@ bool ImplFastBitmapBlending( BitmapWrite
         case BMP_FORMAT_4BIT_LSN_PAL:
         case BMP_FORMAT_8BIT_PAL:
             break;
-        
+
         case BMP_FORMAT_8BIT_TC_MASK:
 //            return ImplBlendFromBitmap<BMP_FORMAT_8BIT_TC_MASK>( rDst, rSrc );
         case BMP_FORMAT_24BIT_TC_MASK:
@@ -897,17 +897,17 @@ bool ImplFastBitmapBlending( BitmapWrite
         case BMP_FORMAT_32BIT_TC_MASK:
 //            return ImplBlendFromBitmap<BMP_FORMAT_32BIT_TC_MASK>( rDst, rSrc );
             break;
-        
+
         case BMP_FORMAT_16BIT_TC_MSB_MASK:
             return ImplBlendFromBitmap<BMP_FORMAT_16BIT_TC_MSB_MASK>( rDst, rSrc, rMsk );
         case BMP_FORMAT_16BIT_TC_LSB_MASK:
             return ImplBlendFromBitmap<BMP_FORMAT_16BIT_TC_LSB_MASK>( rDst, rSrc, rMsk );
-        
+
         case BMP_FORMAT_24BIT_TC_BGR:
             return ImplBlendFromBitmap<BMP_FORMAT_24BIT_TC_BGR>( rDst, rSrc, rMsk );
         case BMP_FORMAT_24BIT_TC_RGB:
             return ImplBlendFromBitmap<BMP_FORMAT_24BIT_TC_RGB>( rDst, rSrc, rMsk );
-        
+
         case BMP_FORMAT_32BIT_TC_ABGR:
             return ImplBlendFromBitmap<BMP_FORMAT_32BIT_TC_ABGR>( rDst, rSrc, rMsk );
 #ifdef FAST_ARGB_BGRA
@@ -931,6 +931,80 @@ bool ImplFastBitmapBlending( BitmapWrite
     return false;
 }
 
+bool ImplFastEraseBitmap( BitmapBuffer& rDst, const BitmapColor& rColor )
+{
+    if( bDisableFastBitops )
+        return false;
+
+    const ULONG nDstFormat = rDst.mnFormat & ~BMP_FORMAT_TOP_DOWN;
+
+    // erasing a bitmap is often just a byte-wise memory fill
+    bool bByteFill = true;
+    BYTE nIndex = rColor.GetIndex();
+    BYTE nFillByte;
+
+    switch( nDstFormat )
+    {
+        case BMP_FORMAT_1BIT_MSB_PAL:
+        case BMP_FORMAT_1BIT_LSB_PAL:
+            nFillByte = -(nIndex & 1);
+            break;
+        case BMP_FORMAT_4BIT_MSN_PAL:
+        case BMP_FORMAT_4BIT_LSN_PAL:
+            nFillByte = (nIndex & 0x0F);
+            nFillByte |= (nFillByte << 4);
+            break;
+        case BMP_FORMAT_8BIT_PAL:
+        case BMP_FORMAT_8BIT_TC_MASK:
+            nFillByte = nIndex;
+            break;
+
+        case BMP_FORMAT_24BIT_TC_MASK:
+        case BMP_FORMAT_24BIT_TC_BGR:
+        case BMP_FORMAT_24BIT_TC_RGB:
+            nFillByte = rColor.GetRed();
+            if( (nFillByte != rColor.GetGreen())
+            ||  (nFillByte != rColor.GetBlue()) )
+                bByteFill = false;
+            break;
+
+        default:
+            bByteFill = false;
+            break;
+    }
+
+    if( bByteFill )
+    {
+        long nByteCount = rDst.mnHeight * rDst.mnScanlineSize;
+        rtl_fillMemory( rDst.mpBits, nByteCount, nFillByte );
+        return true;
+    }
+
+    // handle other bitmap formats
+    switch( nDstFormat )
+    {
+        case BMP_FORMAT_32BIT_TC_MASK:
+        case BMP_FORMAT_16BIT_TC_MSB_MASK:
+        case BMP_FORMAT_16BIT_TC_LSB_MASK:
+
+        case BMP_FORMAT_24BIT_TC_BGR:
+        case BMP_FORMAT_24BIT_TC_RGB:
+
+        case BMP_FORMAT_32BIT_TC_ABGR:
+#ifdef FAST_ARGB_BGRA
+        case BMP_FORMAT_32BIT_TC_ARGB:
+        case BMP_FORMAT_32BIT_TC_BGRA:
+#endif
+        case BMP_FORMAT_32BIT_TC_RGBA:
+            break;
+
+        default:
+            break;
+    }
+
+    return false;
+}
+
 // =======================================================================
 
 #else // NO_OPTIMIZED_BITMAP_ACCESS
@@ -943,6 +1017,11 @@ bool ImplFastBitmapConversion( BitmapBuf
 bool ImplFastBitmapBlending( BitmapWriteAccess&,
     const BitmapReadAccess&, const BitmapReadAccess&,
     const Size&, const Point& )
+{
+    return false;
+}
+
+bool ImplFastEraseBitmap( BitmapBuffer&, const BitmapColor& )
 {
     return false;
 }
Index: vcl/source/gdi/impbmp.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/impbmp.cxx,v
retrieving revision 1.6
retrieving revision 1.6.18.1
diff -u -p -r1.6 -r1.6.18.1
--- vcl/source/gdi/impbmp.cxx	9 Sep 2005 12:00:57 -0000	1.6
+++ vcl/source/gdi/impbmp.cxx	26 Oct 2005 11:47:22 -0000	1.6.18.1
@@ -4,9 +4,9 @@
  *
  *  $RCSfile: slidesorter-demo-pngperf.vcl.patch,v $
  *
- *  $Revision: 1.1 $
+ *  $Revision: 1.1 $
  *
- *  last change: $Author: rodo $ $Date: 2005/12/01 19:02:24 $
+ *  last change: $Author: rodo $ $Date: 2005/12/01 19:02:24 $
  *
  *  The Contents of this file are made available subject to
  *  the terms of GNU Lesser General Public License Version 2.1.
@@ -55,7 +55,8 @@ ImpBitmap::ImpBitmap() :
 			mnRefCount	( 1UL ),
 			mnChecksum	( 0UL ),
 			mpRMBitmap	( NULL ),
-			mpSalBitmap ( ImplGetSVData()->mpDefInst->CreateSalBitmap() )
+			mpSalBitmap ( ImplGetSVData()->mpDefInst->CreateSalBitmap() ),
+			maSourceSize( 0, 0 )
 {
 }
 
@@ -76,6 +77,7 @@ void ImpBitmap::ImplSetSalBitmap( SalBit
 	
 BOOL ImpBitmap::ImplCreate( const Size& rSize, USHORT nBitCount, const BitmapPalette& rPal )
 {
+	maSourceSize = rSize;
 	return mpSalBitmap->Create( rSize, nBitCount, rPal );
 }
 
@@ -83,6 +85,7 @@ BOOL ImpBitmap::ImplCreate( const Size& 
 
 BOOL ImpBitmap::ImplCreate( const ImpBitmap& rImpBitmap )
 {
+	maSourceSize = rImpBitmap.maSourceSize;
 	mnChecksum = rImpBitmap.mnChecksum;
 	return mpSalBitmap->Create( *rImpBitmap.mpSalBitmap );
 }
Index: vcl/source/gdi/impgraph.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/impgraph.cxx,v
retrieving revision 1.21
retrieving revision 1.20.18.2
diff -u -p -r1.21 -r1.20.18.2
--- vcl/source/gdi/impgraph.cxx	19 Oct 2005 12:38:43 -0000	1.21
+++ vcl/source/gdi/impgraph.cxx	15 Nov 2005 09:59:07 -0000	1.20.18.2
@@ -1,12 +1,13 @@
+
 /*************************************************************************
  *
  *  OpenOffice.org - a multi-platform office productivity suite
  *
  *  $RCSfile: slidesorter-demo-pngperf.vcl.patch,v $
  *
- *  $Revision: 1.1 $
+ *  $Revision: 1.1 $
  *
- *  last change: $Author: rodo $ $Date: 2005/12/01 19:02:24 $
+ *  last change: $Author: rodo $ $Date: 2005/12/01 19:02:24 $
  *
  *  The Contents of this file are made available subject to
  *  the terms of GNU Lesser General Public License Version 2.1.
@@ -117,8 +118,54 @@ struct ImpSwapFile
 // - Graphicreader -
 // -----------------
 
+struct ReaderData
+{
+    Size    maPreviewSize;
+};
+
 GraphicReader::~GraphicReader()
 {
+    delete mpReaderData;
+}
+
+// ------------------------------------------------------------------------
+
+BOOL GraphicReader::IsPreviewModeEnabled() const
+{
+    if( !mpReaderData )
+        return FALSE;
+    if( mpReaderData->maPreviewSize.Width() )
+        return TRUE;
+    if( mpReaderData->maPreviewSize.Height() )
+        return TRUE;
+    return FALSE;
+}
+
+// ------------------------------------------------------------------------
+
+void GraphicReader::DisablePreviewMode()
+{
+    if( mpReaderData )
+        mpReaderData->maPreviewSize = Size( 0, 0 );
+}
+
+// ------------------------------------------------------------------------
+
+void GraphicReader::SetPreviewSize( const Size& rSize )
+{
+    if( !mpReaderData )
+        mpReaderData = new ReaderData;
+    mpReaderData->maPreviewSize = rSize;
+}
+
+// ------------------------------------------------------------------------
+
+Size GraphicReader::GetPreviewSize() const
+{
+    Size aSize( 0, 0 );
+    if( mpReaderData )
+        aSize = mpReaderData->maPreviewSize;
+    return aSize;
 }
 
 // --------------
Index: vcl/source/gdi/outmap.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/outmap.cxx,v
retrieving revision 1.16
retrieving revision 1.16.18.2
diff -u -p -r1.16 -r1.16.18.2
--- vcl/source/gdi/outmap.cxx	9 Sep 2005 12:07:42 -0000	1.16
+++ vcl/source/gdi/outmap.cxx	28 Sep 2005 06:53:47 -0000	1.16.18.2
@@ -4,9 +4,9 @@
  *
  *  $RCSfile: slidesorter-demo-pngperf.vcl.patch,v $
  *
- *  $Revision: 1.1 $
+ *  $Revision: 1.1 $
  *
- *  last change: $Author: rodo $ $Date: 2005/12/01 19:02:24 $
+ *  last change: $Author: rodo $ $Date: 2005/12/01 19:02:24 $
  *
  *  The Contents of this file are made available subject to
  *  the terms of GNU Lesser General Public License Version 2.1.
@@ -86,6 +86,8 @@
 #include <salgdi.hxx>
 #endif
 
+#define USE_64BIT_INTS
+
 // =======================================================================
 
 DBG_NAMEEX( OutputDevice );
@@ -205,6 +207,13 @@ static void ImplCalcBigIntThreshold( lon
 		else
 			rThresRes.mnThresPixToLogY = (long)(((ULONG)LONG_MAX + (ULONG)(-nProductY/2)) / nDenomY);
 	}
+
+#ifdef USE_64BIT_INTS
+    rThresRes.mnThresLogToPixX /= 2;
+    rThresRes.mnThresLogToPixY /= 2;
+    rThresRes.mnThresPixToLogX /= 2;
+    rThresRes.mnThresPixToLogY /= 2;
+#endif
 }
 
 // -----------------------------------------------------------------------
@@ -403,31 +412,41 @@ inline void ImplCalcMapResolution( const
 static long ImplLogicToPixel( long n, long nDPI, long nMapNum, long nMapDenom,
 							  long nThres )
 {
-#if 1
-	if ( Abs( n ) < nThres )
-	{
-		sal_Int64 n64 = n;
-		n64 *= nDPI * nMapNum;
-		if( nMapDenom == 1 )
-			n = (long)n64;
-		else
-		{
-			if( n >= 0 )
-				n64 += nMapDenom/2;
-			else
-				n64 -= (nMapDenom-1)/2;
-			n = (long)(n64 / nMapDenom);
-		}
-		return n;
-	}
-#else
+#ifdef USE_64BIT_INTS
+#if (SAL_TYPES_SIZEOFLONG < 8)
+    if( (+n < nThres) && (-n < nThres) )
+    {
+       n *= nMapNum * nDPI;
+       if( nMapDenom != 1 )
+       {
+          n = (2 * n) / nMapDenom;
+          if( n < 0 ) --n; else ++n;
+          n /= 2;
+       }
+    }
+    else
+#endif
+    {
+       sal_Int64 n64 = n;
+       n64 *= nMapNum;
+       n64 *= nDPI;
+       if( nMapDenom == 1 )
+          n = (long)n64;
+       else
+       {
+          n = (long)(2 * n64 / nMapDenom);
+          if( n < 0 ) --n; else ++n;
+          n /= 2;
+       }
+    }
+    return n;
+#else // USE_64BIT_INTS
 	if ( Abs( n ) < nThres )
 	{
 		n *= nDPI * nMapNum;
 		n += n >= 0 ? nMapDenom/2 : -((nMapDenom-1)/2);
                 return (n / nMapDenom);
 	}
-#endif
 	else
 	{
 		BigInt aTemp( n );
@@ -448,6 +467,7 @@ static long ImplLogicToPixel( long n, lo
 		aTemp /= BigInt( nMapDenom );
 		return (long)aTemp;
 	}
+#endif
 }
 
 // -----------------------------------------------------------------------
@@ -455,7 +475,21 @@ static long ImplLogicToPixel( long n, lo
 static long ImplPixelToLogic( long n, long nDPI, long nMapNum, long nMapDenom,
 							  long nThres )
 {
-#if 1
+#ifdef USE_64BIT_INTS
+#if (SAL_TYPES_SIZEOFLONG < 8)
+    if( (+n < nThres) && (-n < nThres) )
+        n = (2 * n * nMapDenom) / (nDPI * nMapNum);
+    else
+#endif
+    {
+        sal_Int64 n64 = n;
+        n64 *= nMapDenom;
+        long nDenom  = nDPI * nMapNum;
+        n = (long)(2 * n64 / nDenom);
+    }
+    if( n < 0 ) --n; else ++n;
+    return (n / 2);
+#else // USE_64BIT_INTS
 	if ( Abs( n ) < nThres )
 	{
 		long nDenom  = nDPI * nMapNum;
@@ -463,31 +497,9 @@ static long ImplPixelToLogic( long n, lo
 		if( (nNum ^ nDenom) >= 0 )
 			nNum += nDenom/2;
 		else
-			nNum -= (nDenom+1)/2;
+			nNum -= nDenom/2;
 		return (nNum / nDenom);
 	}
-#else
-	if ( Abs( n ) < nThres )
-	{
-		long nDenom  = nDPI * nMapNum;
-		long nNum    = n * nMapDenom;
-		if ( nNum >= 0 )
-		{
-			if ( nDenom >= 0 )
-				nNum  += nDenom/2;
-			else
-				nNum  -= (nDenom+1)/2;
-		}
-		else
-		{
-			if ( nDenom >= 0 )
-				nNum  -= (nDenom-1)/2;
-			else
-				nNum  += nDenom/2;
-		}
-		return (nNum / nDenom);
-	}
-#endif
 	else
 	{
 		BigInt aDenom( nDPI );
@@ -529,6 +541,7 @@ static long ImplPixelToLogic( long n, lo
 		aNum  /= aDenom;
 		return (long)aNum;
 	}
+#endif
 }
 
 // -----------------------------------------------------------------------
Index: vcl/source/gdi/pngread.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/pngread.cxx,v
retrieving revision 1.12
retrieving revision 1.10.18.16
diff -u -p -r1.12 -r1.10.18.16
--- vcl/source/gdi/pngread.cxx	24 Oct 2005 07:48:31 -0000	1.12
+++ vcl/source/gdi/pngread.cxx	1 Dec 2005 12:17:47 -0000	1.10.18.16
@@ -4,9 +4,9 @@
  *
  *  $RCSfile: slidesorter-demo-pngperf.vcl.patch,v $
  *
- *  $Revision: 1.1 $
+ *  $Revision: 1.1 $
  *
- *  last change: $Author: rodo $ $Date: 2005/12/01 19:02:24 $
+ *  last change: $Author: rodo $ $Date: 2005/12/01 19:02:24 $
  *
  *  The Contents of this file are made available subject to
  *  the terms of GNU Lesser General Public License Version 2.1.
@@ -74,24 +74,14 @@
 #define VIEWING_GAMMA		2.5
 #define DISPLAY_GAMMA		1.25
 
+#define MAX_CHUNKLEN        40000000
+
 namespace vcl
 {
 // -----------
 // - statics -
 // -----------
 
-static const BYTE aBlockHeight[ 8 ] = 
-{
-	0, 8, 8, 4, 4, 2, 2, 1 
-};
-
-// ------------------------------------------------------------------------------
-
-static const BYTE aBlockWidth[ 8 ]  = 
-{
-	0, 8, 4, 4, 2, 2, 1, 1 
-};
-
 // ------------------------------------------------------------------------------
 
 static const BYTE mpDefaultColorTable[ 256 ] =
@@ -113,70 +103,19 @@ static const BYTE mpDefaultColorTable[ 2
 	0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
 };
 
-/* ------------------------------------------------------------------------
-   SJ: InitChunkSeq reads all PNG chunks. The rStm stream position will be at
-   the end of the file afterwards.
-*/ 
-const sal_Bool InitChunkSeq( SvStream& rStm, std::vector< vcl::PNGReader::ChunkData >& rChunkSeq )
-{
-	sal_Bool	bRet = sal_True;
-	sal_uInt16	nIStmOldMode = rStm.GetNumberFormatInt();
-	rStm.SetNumberFormatInt( NUMBERFORMAT_INT_BIGENDIAN );
-
-	sal_uInt32 nDummy[ 2 ] = {0, 0};
-	rStm >> nDummy[0] >> nDummy[1];
-	if( ! ( nDummy[0] == 0x89504e47 ) && ( nDummy[1] == 0x0d0a1a0a ) )
-		bRet = sal_False;
-	else
-	{
-		sal_uInt32 nChunkLen, nCRC32, nCheck, nType = 0;
-		while( !rStm.IsEof() && ( rStm.GetError() == ERRCODE_NONE ) )
-		{
-			rChunkSeq.resize( rChunkSeq.size() + 1 );
-			vcl::PNGReader::ChunkData& rChunkData = rChunkSeq.back();		
-			rStm >> nChunkLen
-				 >> nType;
-			
-			rChunkData.nType = nType;
-			#if defined(__LITTLEENDIAN) || defined(OSL_LITENDIAN)
-				nType = SWAPLONG( nType );
-			#endif
-			nCRC32 = rtl_crc32( 0, &nType, 4 );
-			if ( nChunkLen && !rStm.IsEof() )
-			{
-				rChunkData.aData.resize( nChunkLen );
-				sal_uInt8* pPtr = &rChunkData.aData[ 0 ];
-				rStm.Read( pPtr, nChunkLen );
-				nCRC32 = rtl_crc32( nCRC32, pPtr, nChunkLen );
-			}
-			rStm >> nCheck;
-			if ( nCRC32 != nCheck )
-			{
-				bRet = sal_False;
-				break;
-			}
-			if ( rChunkData.nType == PNGCHUNK_IEND )
-				break;
-		}
-		if ( !rChunkSeq.size() || ( rChunkSeq[ 0 ].nType != PNGCHUNK_IHDR ) )
-			bRet = sal_False;
-	}
-	rStm.SetNumberFormatInt( nIStmOldMode );
-	return bRet;
-}
-
 // -------------
 // - PNGReaderImpl -
 // -------------
 
 class PNGReaderImpl
 {
-	friend class vcl::PNGReader;
-
-	std::vector< vcl::PNGReader::ChunkData >	maChunkSeq;
-	std::vector< sal_uInt8 >::iterator			maDataIter;
-	std::vector< sal_uInt8 >::iterator			maDataEnd;
-	sal_Int32									mnChunkLen;
+private:
+    SvStream&           mrPNGStream;
+    sal_uInt16          mnOrigStreamMode;
+
+    std::vector< vcl::PNGReader::ChunkData >    maChunkSeq;
+    std::vector< vcl::PNGReader::ChunkData >::iterator maChunkIter;
+    std::vector< sal_uInt8 >::iterator          maDataIter;
 
 	Bitmap*				mpBmp;
 	BitmapWriteAccess*	mpAcc;
@@ -185,31 +124,36 @@ class PNGReaderImpl
 	BitmapWriteAccess*	mpMaskAcc;
 	ZCodec* 			mpZCodec;
 	BYTE*				mpInflateInBuf; // as big as the size of a scanline + alphachannel + 1
-	BYTE*				mpScanprior;	// pointer to the latest scanline
-	BYTE*				mpTransTab;		//
-	BYTE*				mpScan;			// pointer in the current scanline
+	BYTE*				mpScanPrior;    // pointer to the latest scanline
+	BYTE*				mpTransTab;		// for transparency in images with palette colortype
+	BYTE*				mpScanCurrent;  // pointer into the current scanline
 	BYTE*				mpColorTable;	//
-	sal_uInt32			mnChunkType;	// Chunk which is currently open
-	sal_uInt32			mnWidth;
-	sal_uInt32			mnHeight;
-	sal_uInt32			mnBBP;			// number of bytes per pixel
-	sal_uInt32			mnScansize;		// max size of scanline
-	sal_uInt32			mnPrefWidth;	// preferred width in meter
-	sal_uInt32			mnPrefHeight;	// preferred Height in meter
-	sal_uInt32			mnYpos;			// latest y position;
+    sal_uInt32          mnChunkType;    // Type of current PNG chunk
+    sal_uInt32          mnChunkLen;     // Length of current PNG chunk
+    Size                maOrigSize;     // pixel size of the full image
+    Size                maTargetSize;   // pixel size of the result image
+    Size                maPhysSize;     // prefered size in MAP_100TH_MM units
+    sal_uInt32          mnBPP;          // number of bytes per pixel
+    sal_uInt32          mnScansize;     // max size of scanline
+    sal_uInt32          mnYpos;         // latest y position in full image
+    int                 mnPass;         // if interlaced the latest pass ( 1..7 ) else 7
+    sal_uInt32          mnXStart;       // the starting X for the current pass
+    sal_uInt32          mnXAdd;         // the increment for input images X coords for the current pass
+    sal_uInt32          mnYAdd;         // the increment for input images Y coords for the current pass
+    int                 mnPreviewShift; // shift to convert orig image coords into preview image coords
+    int                 mnPreviewMask;  // == ((1 << mnPreviewShift) - 1)
 	USHORT				mnIStmOldMode;
-	USHORT				mnDepth;		// pixel depth
+	USHORT				mnDepth;		// pixel depth of target bitmap
 	BYTE				mnTransRed;
 	BYTE				mnTransGreen;
 	BYTE				mnTransBlue;
-	BYTE				mnBitDepth;		// sample depth
+	BYTE				mnBitDepth;		// pixel depth of PNG data
 	BYTE				mnColorType;
 	BYTE				mnCompressionType;
 	BYTE				mnFilterType;
 	BYTE				mnInterlaceType;
-	BYTE				mnPass;			// if interlaced the latest pass ( 1..7 ) else 7
-	BYTE				cTransIndex1;
-	BYTE				cNonTransIndex1;
+	BitmapColor			mcTranspColor;  // transparency mask's transparency "color"
+	BitmapColor			mcOpaqueColor;  // transparency mask's opaque "color"
 	BOOL				mbStatus;
 	BOOL				mbTransparent;	// graphic includes an tRNS Chunk or an alpha Channel
 	BOOL				mbAlphaChannel;
@@ -217,40 +161,50 @@ class PNGReaderImpl
 	BOOL				mbPalette;		// FALSE if we need a Palette
 	BOOL				mbGrayScale;
 	BOOL				mbzCodecInUse;
-	BOOL				mbIDAT;			// TRUE if finished with the complete IDAT...
+	BOOL				mbIDAT;			// TRUE if finished with enough IDAT chunks
 	BOOL				mbGamma;		// TRUE if Gamma Correction available
 	BOOL				mbpHYs;			// TRUE if pysical size of pixel available
 
-	void				ImplSetPixel( sal_uInt32 y, sal_uInt32 x, const BitmapColor &, BOOL bTrans );
-	void				ImplSetPixel( sal_uInt32 y, sal_uInt32 x, BYTE nPalIndex, BOOL bTrans );
+    bool                ReadNextChunk();
+    void                ReadRemainingChunks();
+    void                SkipRemainingChunks();
+
+    void                ImplSetPixel( sal_uInt32 y, sal_uInt32 x, const BitmapColor & );
+    void                ImplSetPixel( sal_uInt32 y, sal_uInt32 x, BYTE nPalIndex );
+    void                ImplSetTranspPixel( sal_uInt32 y, sal_uInt32 x, const BitmapColor &, BOOL bTrans );
+    void                ImplSetTranspPixel( sal_uInt32 y, sal_uInt32 x, BYTE nPalIndex, BOOL bTrans );
 	void				ImplSetAlphaPixel( sal_uInt32 y, sal_uInt32 x, const BitmapColor&, BYTE nAlpha );
 	void				ImplReadIDAT();
-	void				ImplResizeScanline();
-	void				ImplGetFilter( sal_uInt32 nXStart=0, sal_uInt32 nXAdd=1 );
-	void				ImplReadTransparent();
+    bool                ImplPreparePass();
+    void                ImplApplyFilter();
+    void                ImplDrawScanline( sal_uInt32 nXStart, sal_uInt32 nXAdd );
+	BOOL				ImplReadTransparent();
 	void				ImplGetGamma();
 	void				ImplGetBackground();
 	BYTE				ImplScaleColor();
-	BOOL				ImplReadHeader();
+	BOOL				ImplReadHeader( const Size& rPreviewSizeHint );
 	BOOL				ImplReadPalette();
 	void				ImplGetGrayPalette( sal_uInt32 );
 	sal_uInt32			ImplReadsal_uInt32();
 
 public:
 
-									PNGReaderImpl( SvStream& rStm );
+									PNGReaderImpl( SvStream& );
 									~PNGReaderImpl();
 
-	BitmapEx						Read();	
+	BitmapEx						GetBitmapEx( const Size& rPreviewSizeHint );
+    const std::vector< PNGReader::ChunkData >& GetAllChunks();
 };
 
 // ------------------------------------------------------------------------------
 
-PNGReaderImpl::PNGReaderImpl( SvStream& rPNG ) :
+PNGReaderImpl::PNGReaderImpl( SvStream& rPNGStream )
+:   mrPNGStream( rPNGStream ),
+    mbIDAT( FALSE ),
 	mpAcc			( NULL ),
 	mpMaskAcc		( NULL ),
 	mpInflateInBuf	( NULL ),
-	mpScanprior 	( NULL ),
+	mpScanPrior 	( NULL ),
 	mpTransTab		( NULL ),
 	mpBmp			( NULL ),
 	mpMaskBmp		( NULL ),
@@ -261,49 +215,156 @@ PNGReaderImpl::PNGReaderImpl( SvStream& 
 	mpColorTable	( (sal_uInt8*) mpDefaultColorTable ),
 	mpZCodec		( new ZCodec( DEFAULT_IN_BUFSIZE, DEFAULT_OUT_BUFSIZE, MAX_MEM_USAGE ) )
 {
-	mbStatus = InitChunkSeq( rPNG, maChunkSeq );
+    // prepare the PNG data stream
+    mnOrigStreamMode = mrPNGStream.GetNumberFormatInt();
+    mrPNGStream.SetNumberFormatInt( NUMBERFORMAT_INT_BIGENDIAN );
+
+    // prepare the chunk reader
+    maChunkSeq.reserve( 16 );
+    maChunkIter = maChunkSeq.begin();
+
+    sal_uInt32 nDummy;
+    mrPNGStream >> nDummy;
+    mbStatus = (nDummy == 0x89504e47);
+    mrPNGStream >> nDummy;
+    mbStatus &= (nDummy == 0x0d0a1a0a);
+
+    mnPreviewShift = 0;
+    mnPreviewMask = (1 << mnPreviewShift) - 1;
 }
 
 // ------------------------------------------------------------------------
 
 PNGReaderImpl::~PNGReaderImpl()
 {
+    mrPNGStream.SetNumberFormatInt( mnOrigStreamMode );
+
 	if ( mbzCodecInUse )
 		mpZCodec->EndCompression();
 
 	if( mpColorTable != mpDefaultColorTable )
 		delete[] mpColorTable;
 
-	rtl_freeMemory( mpScanprior );
+    delete mpBmp;
+    delete mpAlphaMask;
+    delete mpMaskBmp;
+    delete[] mpTransTab;
+    delete[] mpInflateInBuf;
+    delete[] mpScanPrior;
+    delete mpZCodec;
+}
+
+// ------------------------------------------------------------------------
 
-	delete mpBmp;
-	delete mpAlphaMask;
-	delete mpMaskBmp;
-	delete[] mpTransTab;
-	delete[] mpInflateInBuf;
-	delete mpZCodec;
+bool PNGReaderImpl::ReadNextChunk()
+{
+    if( maChunkIter == maChunkSeq.end() )
+    {
+        // get the next chunk from the stream
+
+        // unless we are at the end of the PNG stream
+        if( mrPNGStream.IsEof() || (mrPNGStream.GetError() != ERRCODE_NONE) )
+            return false;
+        if( !maChunkSeq.empty() && (maChunkSeq.back().nType == PNGCHUNK_IEND) )
+            return false;
+
+        PNGReader::ChunkData aDummyChunk;
+        maChunkIter = maChunkSeq.insert( maChunkSeq.end(), aDummyChunk );
+        PNGReader::ChunkData& rChunkData = *maChunkIter;
+
+        // read the chunk header
+        mrPNGStream >> mnChunkLen >> mnChunkType;
+        rChunkData.nType = mnChunkType;
+
+        // #128377# sanity check for chunk length
+        if( mnChunkLen > MAX_CHUNKLEN)
+            return false;
+
+        // calculate chunktype CRC (swap it back to original byte order)
+        sal_uInt32 nChunkType = mnChunkType;;
+        #if defined(__LITTLEENDIAN) || defined(OSL_LITENDIAN)
+        nChunkType = SWAPLONG( nChunkType );
+        #endif
+        sal_uInt32 nCRC32 = rtl_crc32( 0, &nChunkType, 4 );
+
+        // read the chunk data and check the CRC
+        if( mnChunkLen && !mrPNGStream.IsEof() )
+        {
+            rChunkData.aData.resize( mnChunkLen );
+            sal_uInt8* pPtr = &rChunkData.aData[ 0 ];
+            mrPNGStream.Read( pPtr, mnChunkLen );
+            nCRC32 = rtl_crc32( nCRC32, pPtr, mnChunkLen );
+            maDataIter = rChunkData.aData.begin();
+        }
+        sal_uInt32 nCheck;
+        mrPNGStream >> nCheck;
+        if( nCRC32 != nCheck )
+            return false;
+    }
+    else
+    {
+        // the next chunk was already read
+        mnChunkType = (*maChunkIter).nType;
+        mnChunkLen = (*maChunkIter).aData.size();
+        maDataIter = (*maChunkIter).aData.begin();
+    }
+
+    ++maChunkIter;
+    if( mnChunkType == PNGCHUNK_IEND )
+        return false;
+    return true;
 }
 
 // ------------------------------------------------------------------------
 
-BitmapEx PNGReaderImpl::Read()
+// read the remaining chunks from mrPNGStream
+void PNGReaderImpl::ReadRemainingChunks()
 {
-	BitmapEx	aRet;
+    while( ReadNextChunk() );
+}
 
-	std::vector< vcl::PNGReader::ChunkData >::iterator aIter( maChunkSeq.begin() );
-	std::vector< vcl::PNGReader::ChunkData >::iterator aEnd ( maChunkSeq.end() );
+// ------------------------------------------------------------------------
 
-	while( mbStatus && ( aIter != aEnd ) && ( aIter->nType != PNGCHUNK_IEND ) )
-	{
-		maDataIter = aIter->aData.begin();
-		maDataEnd  = aIter->aData.end();
-		mnChunkLen = aIter->aData.size();
+// move position of mrPNGStream to the end of the file
+void PNGReaderImpl::SkipRemainingChunks()
+{
+    // nothing to skip if the last chunk was read
+    if( !maChunkSeq.empty() && (maChunkSeq.back().nType == PNGCHUNK_IEND) )
+        return;
+
+    // read from the stream until the IEND chunk is found
+    while( !mrPNGStream.IsEof() && (mrPNGStream.GetError() == ERRCODE_NONE) )
+    {
+        mrPNGStream >> mnChunkLen >> mnChunkType;
+        mrPNGStream.SeekRel( mnChunkLen + 4 );  // skip data + CRC
+        if( mnChunkType == PNGCHUNK_IEND )
+            break;
+    }
+}
 
-		switch ( aIter->nType )
+// ------------------------------------------------------------------------
+
+const std::vector< vcl::PNGReader::ChunkData >& PNGReaderImpl::GetAllChunks()
+{
+    ReadRemainingChunks();
+    return maChunkSeq;
+}
+
+// ------------------------------------------------------------------------
+
+BitmapEx PNGReaderImpl::GetBitmapEx( const Size& rPreviewSizeHint )
+{
+    // reset to the first chunk
+    maChunkIter = maChunkSeq.begin();
+
+    // parse the chunks
+    while( mbStatus && !mbIDAT && ReadNextChunk() )
+    {
+        switch( mnChunkType )
 		{
 			case PNGCHUNK_IHDR :
 			{
-				mbStatus = ImplReadHeader();
+				mbStatus = ImplReadHeader( rPreviewSizeHint );
 			}
 			break;
 
@@ -322,7 +383,7 @@ BitmapEx PNGReaderImpl::Read()
 			break;
 
 			case PNGCHUNK_tRNS :
-				ImplReadTransparent();
+				mbStatus = ImplReadTransparent();
 			break;
 
 			case PNGCHUNK_bKGD :								// the background chunk must appear
@@ -343,19 +404,29 @@ BitmapEx PNGReaderImpl::Read()
 			{
 				if ( !mbIDAT && mnChunkLen == 9 )
 				{
-					mnPrefWidth = ImplReadsal_uInt32();
-					mnPrefHeight= ImplReadsal_uInt32();
-
-					sal_uInt8 nUnitSpecifier = *maDataIter++;
+                    sal_uInt32 nXPixelPerMeter = ImplReadsal_uInt32();
+                    sal_uInt32 nYPixelPerMeter = ImplReadsal_uInt32();
 
-					if ( nUnitSpecifier == 1 )
-						mbpHYs = sal_True;
+                    sal_uInt8 nUnitSpecifier = *maDataIter++;
+                    if( (nUnitSpecifier == 1) && nXPixelPerMeter && nXPixelPerMeter )
+                    {
+                        mbpHYs = sal_True;
+
+                        // convert into MAP_100TH_MM
+                        maPhysSize.Width()  = (sal_Int32)( (100000.0 * maOrigSize.Width()) / nXPixelPerMeter );
+                        maPhysSize.Height() = (sal_Int32)( (100000.0 * maOrigSize.Height()) / nYPixelPerMeter );
+                    }
 				}
 			}
 			break;
+
+            case PNGCHUNK_IEND:
+                mbStatus = mbIDAT;  // there is a problem if the image is not complete yet
+            break;
 		}
-		aIter++;
 	}
+
+    // release write access of the bitmaps
 	if ( mpAcc )
 		mpBmp->ReleaseAccess( mpAcc ), mpAcc = NULL;
 
@@ -368,8 +439,13 @@ BitmapEx PNGReaderImpl::Read()
 
 		mpMaskAcc = NULL;
 	}
-	
-	if ( mbStatus )
+
+    // return the resulting BitmapEx
+    BitmapEx aRet;
+
+    if( !mbStatus || !mbIDAT )
+        aRet.Clear();
+    else
 	{
 		if ( mbAlphaChannel )
 			aRet = BitmapEx( *mpBmp, *mpAlphaMask );
@@ -378,57 +454,61 @@ BitmapEx PNGReaderImpl::Read()
 		else
 			aRet = *mpBmp;
 
-		if ( mbpHYs && mnPrefWidth && mnPrefHeight )
+		if ( mbpHYs && maPhysSize.Width() && maPhysSize.Height() )
 		{
-			sal_Int32 nPrefSizeX = (sal_Int32)( 100000.0 * ( (double)mnWidth / mnPrefWidth ) );
-			sal_Int32 nPrefSizeY = (sal_Int32)( 100000.0 * ( (double)mnHeight / mnPrefHeight ) );
-			
 			aRet.SetPrefMapMode( MAP_100TH_MM );
-			aRet.SetPrefSize( Size( nPrefSizeX, nPrefSizeY ) );
+			aRet.SetPrefSize( maPhysSize );
 		}
+
+#if 0
+        // TODO: make sure nobody depends on the stream being after the IEND chunks
+        // => let them do ReadChunks before
+        ReadRemainingChunks();
+#endif
 	}
-	if( !mbStatus )
-		aRet.Clear();
 
 	return aRet;
 }
 
 // ------------------------------------------------------------------------
 
-BOOL PNGReaderImpl::ImplReadHeader()
+BOOL PNGReaderImpl::ImplReadHeader( const Size& rPreviewSizeHint )
 {
-	mnWidth = ImplReadsal_uInt32();
-	mnHeight = ImplReadsal_uInt32();
-	
-	if ( ( mnWidth == 0 ) || ( mnHeight == 0 ) )
-		return FALSE;
-	
-	mnBitDepth = *maDataIter++;
-	mnColorType = *maDataIter++;
-	
-	if ( mnCompressionType = *maDataIter++ )
-		return FALSE;
-	
-	if ( mnFilterType = *maDataIter++ )
-		return FALSE;
-	
-	switch ( mnInterlaceType = *maDataIter++ )	// filter type valid ?
+    maOrigSize.Width()  = ImplReadsal_uInt32();
+    maOrigSize.Height() = ImplReadsal_uInt32();
+
+    if ( !maOrigSize.Width() || !maOrigSize.Height() )
+        return FALSE;
+
+    mnBitDepth = *(maDataIter++);
+    mnColorType = *(maDataIter++);
+
+    mnCompressionType = *(maDataIter++);
+    if( mnCompressionType != 0 )    // unknown compression type
+        return FALSE;
+
+    mnFilterType = *(maDataIter++);
+    if( mnFilterType != 0 )         // unknown filter type
+        return FALSE;
+
+    mnInterlaceType = *(maDataIter++);
+    switch ( mnInterlaceType ) // filter type valid ?
 	{
-		case 0 :
+		case 0 :  // progressive image
 			mnPass = 7;
 			break;
-		case 1 :
+		case 1 :  // Adam7-interlaced image
 			mnPass = 0;
 			break;
 		default:
 			return FALSE;
 	}
-	mnYpos = 0;
+
 	mbPalette = TRUE;
 	mbIDAT = mbAlphaChannel = mbTransparent = FALSE;
 	mbGrayScale = mbRGBTriple = FALSE;
 	mnDepth = mnBitDepth;
-	mnScansize = ( ( mnWidth * mnBitDepth ) + 7 ) >> 3;
+	mnScansize = ( ( maOrigSize.Width() * mnBitDepth ) + 7 ) >> 3;
 
 	// valid color types are 0,2,3,4 & 6
 	switch ( mnColorType )
@@ -455,7 +535,7 @@ BOOL PNGReaderImpl::ImplReadHeader()
 		case 2 :	// each pixel is an RGB triple
 		{
 			mbRGBTriple = TRUE;
-			mnScansize*=3;
+			mnScansize *= 3;
 			switch ( mnBitDepth )
 			{
 				case 16 :			// we have to reduce the bitmap
@@ -487,7 +567,7 @@ BOOL PNGReaderImpl::ImplReadHeader()
 
 		case 4 :	// each pixel is a grayscale sample followed by an alpha sample
 		{
-			mnScansize <<= 1;
+			mnScansize *= 2;
 			mbAlphaChannel = TRUE;
 			switch ( mnBitDepth )
 			{
@@ -505,7 +585,7 @@ BOOL PNGReaderImpl::ImplReadHeader()
 		case 6 :	// each pixel is an RGB triple followed by an alpha sample
 		{
 			mbRGBTriple = TRUE;
-			mnScansize*=4;
+			mnScansize *= 4;
 			mbAlphaChannel = TRUE;
 			switch (mnBitDepth )
 			{
@@ -522,44 +602,57 @@ BOOL PNGReaderImpl::ImplReadHeader()
 		default :
 			return FALSE;
 	}
-	mnBBP = mnScansize / mnWidth;
-	
-	if ( !mnBBP )
-		mnBBP = 1;
-
-	mnScansize++;		// each scanline includes one filterbyte
-	mpScan = mpInflateInBuf = new BYTE[ mnScansize ];
-	mpScanprior = (sal_uInt8*)rtl_allocateZeroMemory( mnScansize );
-
-	if ( mnInterlaceType )
-		ImplResizeScanline();
-
-	mpBmp = new Bitmap( Size( mnWidth, mnHeight ), mnDepth);
-	mpAcc = mpBmp->AcquireWriteAccess();
-
-	if ( mbAlphaChannel )
-	{
-		mpAlphaMask = new AlphaMask( Size( mnWidth, mnHeight ) );
-		mpAlphaMask->Erase( 128 );
-		mpMaskAcc = mpAlphaMask->AcquireWriteAccess();
-	}
-	else
-	{
-		mpMaskBmp = new Bitmap( Size( mnWidth, mnHeight ), 1 );
-		mpMaskBmp->Erase( Color( COL_WHITE ) );
-		mpMaskAcc = mpMaskBmp->AcquireWriteAccess();
-	}
 
-	if ( ( mpAcc == NULL ) || ( mpMaskAcc == NULL ) )
-		return FALSE;
-
-	const Color aWhite( COL_WHITE );
-	cTransIndex1 = (BYTE)mpMaskAcc->GetBestPaletteIndex( aWhite );
-	cNonTransIndex1 = cTransIndex1 ? 0 : 1;
+    mnBPP = mnScansize / maOrigSize.Width();
+    if ( !mnBPP )
+        mnBPP = 1;
+
+    mnScansize++;       // each scanline includes one filterbyte
+
+    // TODO: switch between both scanlines instead of copying
+    mpInflateInBuf = new BYTE[ mnScansize ];
+    mpScanCurrent = mpInflateInBuf;
+    mpScanPrior = new BYTE[ mnScansize ];
+
+    // calculate target size from original size and the preview hint
+    if( rPreviewSizeHint.Width() && rPreviewSizeHint.Height() )
+    {
+        maTargetSize = maOrigSize;
+        for( int i = 1; i < 5; ++i )
+        {
+            if( (maTargetSize.Width() >> i) < rPreviewSizeHint.Width() )
+                break;
+            if( (maTargetSize.Height() >> i) < rPreviewSizeHint.Height() )
+                break;
+            mnPreviewShift = i;
+        }
+        mnPreviewMask = (1 << mnPreviewShift) - 1;
+    }
+
+    maTargetSize.Width()  = (maOrigSize.Width() + mnPreviewMask) >> mnPreviewShift;
+    maTargetSize.Height() = (maOrigSize.Height() + mnPreviewMask) >> mnPreviewShift;
+
+    mpBmp = new Bitmap( maTargetSize, mnDepth );
+    mpAcc = mpBmp->AcquireWriteAccess();
+    if( !mpAcc )
+        return FALSE;
+
+    mpBmp->SetSourceSizePixel( maOrigSize );
+
+    if ( mbAlphaChannel )
+    {
+        mpAlphaMask = new AlphaMask( maTargetSize );
+        mpAlphaMask->Erase( 128 );
+        mpMaskAcc = mpAlphaMask->AcquireWriteAccess();
+        if( !mpMaskAcc )
+            return FALSE;
+    }
 
 	if ( mbGrayScale )
 		ImplGetGrayPalette( mnDepth );
 
+    ImplPreparePass();
+
 	return TRUE;
 }
 
@@ -594,16 +687,14 @@ BOOL PNGReaderImpl::ImplReadPalette()
 
 	if ( ( ( mnChunkLen % 3 ) == 0 ) && ( ( 0 < nCount ) && ( nCount <= 256 ) ) && mpAcc )
 	{
-		BYTE 	nRed, nGreen, nBlue;
-
 		mbPalette = TRUE;
 		mpAcc->SetPaletteEntryCount( (USHORT) nCount );
 
-		for ( USHORT i = 0; i < nCount; i++ )
+		for ( sal_uInt32 i = 0; i < nCount; i++ )
 		{
-			nRed =   mpColorTable[ *maDataIter++ ];
-			nGreen = mpColorTable[ *maDataIter++ ];
-			nBlue =  mpColorTable[ *maDataIter++ ];
+			BYTE nRed =   mpColorTable[ *maDataIter++ ];
+			BYTE nGreen = mpColorTable[ *maDataIter++ ];
+			BYTE nBlue =  mpColorTable[ *maDataIter++ ];
 			mpAcc->SetPaletteColor( i, Color( nRed, nGreen, nBlue ) );
 		}
 	}
@@ -615,7 +706,7 @@ BOOL PNGReaderImpl::ImplReadPalette()
 
 // ------------------------------------------------------------------------
 
-void PNGReaderImpl::ImplReadTransparent()
+BOOL PNGReaderImpl::ImplReadTransparent()
 {
 	if ( mpTransTab == NULL )
 	{
@@ -662,6 +753,19 @@ void PNGReaderImpl::ImplReadTransparent(
 			break;
 		}
 	}
+
+    if( mbTransparent && !mbAlphaChannel && !mpMaskBmp )
+    {
+        mpMaskBmp = new Bitmap( maTargetSize, 1 );
+        mpMaskAcc = mpMaskBmp->AcquireWriteAccess();
+        if( !mpMaskAcc )
+            return FALSE;
+        mcOpaqueColor = BitmapColor( COL_BLACK );
+        mcTranspColor = BitmapColor( COL_WHITE );
+        mpMaskAcc->Erase( mcOpaqueColor );
+    }
+
+    return TRUE;
 }
 
 // ------------------------------------------------------------------------
@@ -691,9 +795,6 @@ void PNGReaderImpl::ImplGetGamma()
 
 void PNGReaderImpl::ImplGetBackground()
 {
-	Point 		aPoint;
-	Rectangle	aRectangle( aPoint, Size( mnWidth, mnHeight ) );
-
 	switch ( mnColorType )
 	{
 		case 3 :
@@ -703,11 +804,10 @@ void PNGReaderImpl::ImplGetBackground()
 				UINT16 nCol = *maDataIter++;
 				if ( nCol < mpAcc->GetPaletteEntryCount() )
 				{
-					mpAcc->SetFillColor( (const Color&)mpAcc->GetPaletteColor( (BYTE)nCol ) );
-					mpAcc->FillRect( aRectangle );
+					mpAcc->Erase( mpAcc->GetPaletteColor( (BYTE)nCol ) );
 					break;
 				}
-			}			
+			}
 		}
 		break;
 
@@ -719,8 +819,7 @@ void PNGReaderImpl::ImplGetBackground()
                 // the color type 0 and 4 is always greyscale,
                 // so the return value can be used as index
 				sal_uInt8 nIndex = ImplScaleColor();
-				mpAcc->SetFillColor( (const Color&)mpAcc->GetPaletteColor( nIndex ) );
-				mpAcc->FillRect( aRectangle );
+				mpAcc->Erase( mpAcc->GetPaletteColor( nIndex ) );
 			}
 		}
 		break;
@@ -733,8 +832,7 @@ void PNGReaderImpl::ImplGetBackground()
 				sal_uInt8 nRed = ImplScaleColor();
 				sal_uInt8 nGreen = ImplScaleColor();
 				sal_uInt8 nBlue = ImplScaleColor();
-				mpAcc->SetFillColor( Color( nRed, nGreen, nBlue ) );
-				mpAcc->FillRect( aRectangle );
+				mpAcc->Erase( Color( nRed, nGreen, nBlue ) );
 			}
 		}
 		break;
@@ -759,11 +857,10 @@ sal_uInt8 PNGReaderImpl::ImplScaleColor(
 }
 
 // ------------------------------------------------------------------------
-// ImplReadIDAT reads as much bitmap data as possible
+// ImplReadIDAT reads as much image data as needed
 
 void PNGReaderImpl::ImplReadIDAT()
 {
-	sal_uInt32 nToRead, nRead;
 	if ( mnChunkLen )		// Chunk empty ?
 	{
 		if ( mbzCodecInUse == FALSE )
@@ -776,691 +873,588 @@ void PNGReaderImpl::ImplReadIDAT()
 
 		while ( ( mpZCodec->GetBreak() ) )
 		{
-			// get bytes needed to fill the current scanline
-			nToRead = mnScansize - ( mpScan - mpInflateInBuf );
-
-			if ( ( nRead = mpZCodec->ReadAsynchron( aIStrm, mpScan, nToRead ) ) < 0 )
+            // get bytes needed to fill the current scanline
+            sal_uInt32 nToRead = mnScansize - (mpScanCurrent - mpInflateInBuf);
+            sal_uInt32 nRead = mpZCodec->ReadAsynchron( aIStrm, mpScanCurrent, nToRead );
+            if ( nRead < 0 )
 			{
 				mbStatus = FALSE;
 				break;
 			}
 			if ( nRead < nToRead )
 			{
-				mpScan += nRead;			// ZStream is Broken
+				mpScanCurrent += nRead; // more ZStream data in the next IDAT chunk
 				break;
 			}
-			else
+			else  // this scanline is Finished
 			{
-				mpScan = mpInflateInBuf;	// this scanline is Finished
-
-				if ( mnInterlaceType == 0	)
-				{
-					ImplGetFilter ( 0, 1 );
-					mnYpos++;
-				}
-				else
-				{
-					// interlace mode
-					switch ( mnPass )
-					{
-						case 1 :																			// pass 1
-						{
-							ImplGetFilter ( 0, 8 );
-							mnYpos += 8;
-						}
-						break;
-
-						case 2 :																			// pass 2
-						{
-							ImplGetFilter ( 4, 8 );
-							mnYpos += 8;
-						}
-						break;
-
-						case 3 :																			// pass 3
-						{
-							if ( mnYpos >= 4 )
-							{
-								ImplGetFilter ( 0, 4 );
-							}
-							mnYpos += 8;
-						}
-						break;
-
-						case 4 :																			// pass 4
-						{
-							ImplGetFilter ( 2, 4 );
-							mnYpos += 4;
-						}
-						break;
+				mpScanCurrent = mpInflateInBuf;
+                ImplApplyFilter();
 
-						case 5 :																			// pass 5
-						{
-							if ( mnYpos >= 2 )
-							{
-								ImplGetFilter ( 0, 2 );
-							}
-							mnYpos += 4;
-						}
-						break;
-
-						case 6 :																			// pass 6
-						{
-								ImplGetFilter ( 1, 2 );
-								mnYpos += 2;
-						}
-						break;
-
-						case 7 :																			// pass 7
-						{
-							if ( mnYpos >= 1 )
-							{
-								ImplGetFilter ( 0, 1 );
-							}
-							mnYpos += 2;
-						}
-						break;
-					}
-				}
+                ImplDrawScanline( mnXStart, mnXAdd );
+                mnYpos += mnYAdd;
 			}
 
-			if ( mnYpos >= mnHeight )
+			if ( mnYpos >= maOrigSize.Height() )
 			{
-				if ( mnPass == 7 )
-					break;
-				else
-				{
-					ImplResizeScanline();
-				}
+                if( (mnPass < 7) && mnInterlaceType )
+                    if( ImplPreparePass() )
+                        continue;
+                mbIDAT = true;
+                break;
 			}
 		}
 	}
 
-	if ( ( mnPass >= 7 ) && ( mnYpos >= mnHeight ) )
+	if( mbIDAT )
 	{
 		mpZCodec->EndCompression();
 		mbzCodecInUse = FALSE;
-		mbIDAT = TRUE;
 	}
 }
 
 // ---------------------------------------------------------------------------------------------------
 
-void PNGReaderImpl::ImplResizeScanline( void )
+bool PNGReaderImpl::ImplPreparePass()
 {
-	long nScansize;
-
-	while ( mnPass < 7 )
-	{
-		sal_uInt32 nX = 0;
+    struct InterlaceParams{ int mnXStart, mnYStart, mnXAdd, mnYAdd; };
+    static const InterlaceParams aInterlaceParams[8] =
+    {
+        // non-interlaced
+        { 0, 0, 1, 1 },
+        // Adam7-interlaced
+        { 0, 0, 8, 8 },    // pass 1
+        { 4, 0, 8, 8 },    // pass 2
+        { 0, 4, 4, 8 },    // pass 3
+        { 2, 0, 4, 4 },    // pass 4
+        { 0, 2, 2, 4 },    // pass 5
+        { 1, 0, 2, 2 },    // pass 6
+        { 0, 1, 1, 2 }     // pass 7
+    };
+
+    const InterlaceParams* pParam = &aInterlaceParams[ 0 ];
+    if( mnInterlaceType )
+    {
+        while( ++mnPass <= 7 )
+        {
+            pParam = &aInterlaceParams[ mnPass ];
+
+            // skip this pass if the original image is too small for it
+            if( (pParam->mnXStart < maOrigSize.Width())
+            &&  (pParam->mnYStart < maOrigSize.Height()) )
+                break;
+        }
+        if( mnPass > 7 )
+            return false;
+
+        // skip the last passes if possible (for scaled down target images)
+        if( mnPreviewMask & (pParam->mnXStart | pParam->mnYStart) )
+            return false;
+    }
+
+    mnYpos      = pParam->mnYStart;
+    mnXStart    = pParam->mnXStart;
+    mnXAdd      = pParam->mnXAdd;
+    mnYAdd      = pParam->mnYAdd;
+
+    long nScansize = (maOrigSize.Width() - mnXStart + mnXAdd - 1) / mnXAdd;
+
+    // in Interlace mode the size of scanline is not constant
+    // so first we calculate the number of entrys
+    mnScansize = nScansize * mnBitDepth;
+
+    if ( mbRGBTriple )
+        mnScansize *= 3;
+
+    // convert bitsize to byte
+    mnScansize = ( mnScansize + 7 ) >> 3;
 
-		mnYpos = 0;
-		mnPass++;
-
-		switch ( mnPass )
-		{
-			case 1 :
-				nScansize = ( mnWidth + 7 ) >> 3;
-			break;
+    if ( mbAlphaChannel )
+        mnScansize += nScansize;
 
-			case 2 :
-				nX += 4;
-				nScansize = ( mnWidth + 3 ) >> 3;
-			break;
+    ++mnScansize; // scan size also needs room for the filtertype byte
+    rtl_zeroMemory( mpScanPrior, mnScansize );
 
-			case 3 :
-				mnYpos += 4;
-				nScansize = ( mnWidth + 3 ) >> 2;
-			break;
-
-			case 4 :
-				nX += 2;
-				nScansize = ( mnWidth + 1) >> 2;
-			break;
-
-			case 5 :
-				mnYpos += 2;
-				nScansize = ( mnWidth + 1 ) >> 1;
-			break;
-
-			case 6 :
-				nX++;
-				nScansize = mnWidth >> 1;
-			break;
-
-			case 7 :
-				mnYpos++;
-				nScansize = mnWidth;
-			break;
-
-			default:
-			    nScansize = 0;
-			break;
-		}
-
-		if ( ( mnYpos >= mnHeight ) || ( nX >= mnWidth ) )	// is pass to be skipped ?
-			continue;
-
-		// in Interlace mode the size of scanline is not constant
-		// so first we calculate the number of entrys
-		mnScansize = nScansize * mnBitDepth;
+    return true;
+}
 
-		if ( mbRGBTriple )
-			mnScansize *= 3;
+// ---------------------------------------------------------------------------------------------------
+// ImplApplyFilter writes the complete Scanline (nY) - in interlace mode the parameter nXStart and nXAdd
+// appends to the currently used pass
 
-		// convert bitsize to byte
-		mnScansize = ( mnScansize + 7 ) >> 3;
+void PNGReaderImpl::ImplApplyFilter()
+{
+    const BYTE* const pScanEnd = mpInflateInBuf + mnScansize;
 
-		if ( mbAlphaChannel )
-			mnScansize += ( ( nScansize * mnBitDepth ) >> 3 );
+    BYTE nFilterType = *mpInflateInBuf; // the filter type may change each scanline
+    switch ( nFilterType )
+    {
+        default: // unknown Scanline Filter Type
+        case 0: // Filter Type "None"
+            // we let the pixels pass and display the data unfiltered
+            break;
+
+        case 1: // Scanline Filter Type "Sub"
+        {
+            BYTE* p1 = mpInflateInBuf + 1;;
+            const BYTE* p2 = p1;
+            p1 += mnBPP;
+
+            // use left pixels
+            do
+                *p1 += *(p2++);
+            while( ++p1 < pScanEnd );
+        }
+        break;
+
+        case 2: // Scanline Filter Type "Up"
+        {
+            BYTE* p1 = mpInflateInBuf + 1;;
+            const BYTE* p2 = mpScanPrior + 1;
+
+            // use pixels from prior line
+            do
+                *p1 += *(p2++);
+            while( ++p1 < pScanEnd );
+        }
+        break;
+
+        case 3: // Scanline Filter Type "Average"
+        {
+            BYTE* p1 = mpInflateInBuf + 1;;
+            const BYTE* p2 = mpScanPrior + 1;
+            const BYTE* p3 = p1;
+
+            // use one pixel from prior line
+            for( int n = mnBPP; --n >= 0; )
+                *(p1++) += *(p2++) >> 1;
+
+            // predict by averaging the left and prior line pixels
+            do
+                *p1 += (BYTE)( ( (unsigned)*(p2++) + *(p3++) ) >> 1 );
+            while( ++p1 < pScanEnd );
+        }
+        break;
+
+        case 4: // Scanline Filter Type "PaethPredictor"
+        {
+            BYTE* p1 = mpInflateInBuf + 1;;
+            const BYTE* p2 = mpScanPrior + 1;
+            const BYTE* p3 = p1;
+            const BYTE* p4 = p2;
+
+            // use one pixel from prior line
+            for( int n = mnBPP; --n >= 0; )
+                *(p1++) += *(p2++);
+
+            // predict by using the left and the prior line pixels
+            do
+            {
+                int na = *(p2++);
+                int nb = *(p3++);
+                int nc = *(p4++);
+
+                int npa = nb - (int)nc;
+                int npb = na - (int)nc;
+                int npc = npa + npb;
+
+                if( npa < 0 )
+                    npa =-npa;
+                if( npb < 0 )
+                    npb =-npb;
+                if( npc < 0 )
+                    npc =-npc;
+
+                if( npa > npb )
+                    na = nb, npa = npb;
+                if( npa > npc )
+                    na = nc;
+
+                *p1 += static_cast<BYTE>(na);
+            }
+            while( ++p1 < pScanEnd );
+        }
+        break;
+    }
 
-		rtl_zeroMemory( mpScanprior, ++mnScansize );
-		break;
-	}
+    rtl_copyMemory( mpScanPrior, mpInflateInBuf, mnScansize );
 }
 
 // ---------------------------------------------------------------------------------------------------
-// ImplGetFilter writes the complete Scanline (nY) - in interlace mode the parameter nXStart and nXAdd
-// appends to the currently used pass
-// the complete size of scanline will be returned - in interlace mode zero is possible!
+// ImplDrawScanlines draws the complete Scanline (nY) into the target bitmap
+// In interlace mode the parameter nXStart and nXAdd append to the currently used pass
 
-void PNGReaderImpl::ImplGetFilter ( sal_uInt32 nXStart, sal_uInt32 nXAdd )
+void PNGReaderImpl::ImplDrawScanline( sal_uInt32 nXStart, sal_uInt32 nXAdd )
 {
-	BYTE* 		pTmp = mpInflateInBuf;
-	BYTE* 		p1;
-	BYTE* 		p2;
-	BYTE* 		p3;
-	BYTE* 		p4;
-	BYTE  		nFilterType;
-	BYTE		nCol = 0;
-	sal_uInt32	nXIndex, nX, nY = mnYpos, n1, n2, na, nb, nc;
-	sal_Int32	np, npa, npb, npc;
+    // optimization for downscaling
+    if( mnYpos & mnPreviewMask )
+        return;
+    if( nXStart & mnPreviewMask )
+        return;
 
-	sal_uInt32 nBBP = mnBBP;
+    // convert nY to pixel units in the target image
+    // => TODO; also do this for nX here instead of in the ImplSet*Pixel() methods
+    const sal_uInt32 nY = mnYpos >> mnPreviewShift;
 
-	if ( nXStart < (sal_uInt32)mnWidth )
+    const BYTE* pTmp = mpInflateInBuf + 1;
+	if ( mpAcc->HasPalette() ) // alphachannel is not allowed by pictures including palette entries
 	{
-		nFilterType = *pTmp++;	// the filter type may change each scanline
-
-		switch ( nFilterType )
+		switch ( mpAcc->GetBitCount() )
 		{
 			case 1 :
 			{
-				p1 = pTmp + nBBP;
-				p2 = pTmp;
-		
-				while ( p1 < pTmp + mnScansize - 1 )
-					( *p1++ ) += ( *p2++ );
-			}
-			break;
-
-			case 2 :
-			{
-				p1 = pTmp;
-				p2 = mpScanprior+1;
-
-				while ( p1 < pTmp + mnScansize - 1 )
-					( *p1++ ) += ( *p2++ );
-			}
-			break;
-
-			case 3 :
-			{
-				p1 = pTmp;
-				p2 = mpScanprior + 1;
-				p3 = pTmp-nBBP;
-
-				while ( p1 < pTmp + mnScansize - 1 )
-				{
-					n1 = (BYTE)( *p2++ );
-					n2 = ( p3 >= pTmp ) ? (BYTE)*p3 : 0;
-					p3++;
-					( *p1++ ) += (BYTE)( ( n1 + n2 ) >> 1 );
-				}
-			}
-			break;
-
-			case 4 :
-			{
-				p1 = pTmp;
-				p2 = p1 - nBBP;
-				p3 = mpScanprior + 1;
-				p4 = p3 - nBBP;
-
-				while ( p1 < pTmp + mnScansize - 1 )
+				if ( mbTransparent )
 				{
-					nb = *p3++;
-					if ( p2 >= pTmp )
+                    for ( sal_uInt32 nX = nXStart, nShift = 0; nX < maOrigSize.Width(); nX += nXAdd )
 					{
-						na = *p2;
-						nc = *p4;
-					}
-					else
-						na = nc = 0;
-
-					np = na + nb;
-					np -= nc;
-					npa = np - na;
-					npb = np - nb;
-					npc = np - nc;
-					
-					if ( npa < 0 )
-						npa =-npa;
-					if ( npb < 0 )
-						npb =-npb;
-					if ( npc < 0 )
-						npc =-npc;
-
-					if ( ( npa <= npb ) && ( npa <= npc ) ) 
-						*p1++ += (BYTE)na;
-					else if ( npb <= npc )
-						*p1++ += (BYTE)nb;
-					else
-						*p1++ += (BYTE)nc;
+                        BYTE nCol;
+                        nShift = (nShift - 1) & 7;
+						if ( nShift == 0 )
+							nCol = ( *pTmp++ );
+						else
+							nCol = ( *pTmp >> nShift );
+                        nCol &= 1;
 
-					p2++;
-					p4++;
-				}
-			}
-			break;
-			// undefined FilterType -> we will let them pass and display the data unfiltered
-		}
-		if ( mpAcc->HasPalette() )	// alphachannel is not allowed by pictures including palette entries
-		{
-			switch ( mpAcc->GetBitCount() )
-			{
-				case 1 :
-				{
-					if ( mbTransparent )
-					{
-						for ( nX = nXStart, nXIndex = 0; nX < (sal_uInt32)mnWidth; nX += nXAdd, nXIndex++ )
-						{
-							sal_uInt32 nShift = ( nXIndex & 7 ) ^ 7;
-					
-							if ( nShift == 0 )
-								nCol = ( *pTmp++ ) & 1;
-							else
-								nCol = ( *pTmp >> nShift ) & 1;
-	
-							ImplSetPixel( nY, nX, nCol, mpTransTab[ nCol ] < PNG_TRANS_VAL );
-						}
+						ImplSetTranspPixel( nY, nX, nCol, mpTransTab[ nCol ] < PNG_TRANS_VAL );
 					}
-					else
+				}
+				else
+				{   // BMP_FORMAT_1BIT_MSB_PAL
+					for ( sal_uInt32 nX = nXStart, nShift = 0; nX < maOrigSize.Width(); nX += nXAdd )
 					{
-						for ( nX = nXStart, nXIndex = 0; nX < (sal_uInt32)mnWidth; nX += nXAdd, nXIndex++ )
-						{
-							sal_uInt32 nShift = ( nXIndex & 7 ) ^ 7;
+                        nShift = (nShift - 1) & 7;
 
-							if ( nShift == 0 )
-								ImplSetPixel( nY, nX, ( *pTmp++ & 1 ), FALSE );
-							else
-								ImplSetPixel( nY, nX, ( *pTmp >> nShift ) & 1, FALSE );
-						}
+						if ( nShift == 0 )
+							ImplSetPixel( nY, nX, ( *pTmp++ & 1 ) );
+						else
+							ImplSetPixel( nY, nX, ( *pTmp >> nShift ) & 1 );
 					}
 				}
-				break;
+			}
+			break;
 
-				case 4 :
+			case 4 :
+			{
+				if ( mbTransparent )
 				{
-					if ( mbTransparent )
+					if ( mnBitDepth == 4 )	// maybe the source is a two bitmap graphic
 					{
-						if ( mnBitDepth == 4 )	// maybe the source is a two bitmap graphic
+						for ( sal_uInt32 nX = nXStart, nXIndex = 0; nX < maOrigSize.Width(); nX += nXAdd, ++nXIndex )
 						{
-							for ( nX = nXStart, nXIndex = 0; nX < mnWidth; nX += nXAdd, nXIndex++ )
+							if( nXIndex & 1 )
 							{
-								if( nXIndex & 1 )
-								{
-									ImplSetPixel( nY, nX, *pTmp & 0x0f, mpTransTab[ *pTmp & 0x0f ] < PNG_TRANS_VAL );
-									pTmp++;
-								}
-								else
-								{
-									ImplSetPixel( nY, nX, ( *pTmp >> 4 ) & 0x0f, mpTransTab[ *pTmp >> 4 ] < PNG_TRANS_VAL );
-								}
+								ImplSetTranspPixel( nY, nX, *pTmp & 0x0f, mpTransTab[ *pTmp & 0x0f ] < PNG_TRANS_VAL );
+								pTmp++;
 							}
-						}
-						else
-						{
-							for ( nX = nXStart, nXIndex = 0; nX < mnWidth; nX += nXAdd, nXIndex++ )
+							else
 							{
-								switch( nXIndex & 3 )
-								{
-									case 0 :
-										nCol = *pTmp >> 6;
-									break;
-
-									case 1 :
-										nCol = ( *pTmp >> 4 ) & 0x03 ;
-									break;
-
-									case 2 :
-										nCol = ( *pTmp >> 2 ) & 0x03;
-									break;
-
-									case 3 :
-										nCol = ( *pTmp++ ) & 0x03;
-									break;
-								}
-
-								ImplSetPixel( nY, nX, nCol, mpTransTab[ nCol ] < PNG_TRANS_VAL );
+								ImplSetTranspPixel( nY, nX, ( *pTmp >> 4 ) & 0x0f, mpTransTab[ *pTmp >> 4 ] < PNG_TRANS_VAL );
 							}
 						}
 					}
 					else
 					{
-						if ( mnBitDepth == 4 )	// maybe the source is a two bitmap graphic
+						for ( sal_uInt32 nX = nXStart, nXIndex = 0; nX < maOrigSize.Width(); nX += nXAdd, nXIndex++ )
 						{
-							for ( nX = nXStart, nXIndex = 0; nX < mnWidth; nX += nXAdd, nXIndex++ )
+                            BYTE nCol;
+							switch( nXIndex & 3 )
 							{
-								if( nXIndex & 1 )
-									ImplSetPixel( nY, nX, *pTmp++ & 0x0f, FALSE );
-								else
-									ImplSetPixel( nY, nX, ( *pTmp >> 4 ) & 0x0f, FALSE );
-							}
-						}
-						else
-						{
-							for ( nX = nXStart, nXIndex = 0; nX < mnWidth; nX += nXAdd, nXIndex++ )
-							{
-								switch( nXIndex & 3 )
-								{
-									case 0 :
-										ImplSetPixel( nY, nX, *pTmp >> 6, FALSE );
-									break;
-
-									case 1 :
-										ImplSetPixel( nY, nX, ( *pTmp >> 4 ) & 0x03, FALSE );
-									break;
-
-									case 2 :
-										ImplSetPixel( nY, nX, ( *pTmp >> 2 ) & 0x03, FALSE );
-									break;
-
-									case 3 :
-										ImplSetPixel( nY, nX, *pTmp++ & 0x03, FALSE );
-									break;
-								}
+								case 0 :
+									nCol = *pTmp >> 6;
+								break;
+
+								case 1 :
+									nCol = ( *pTmp >> 4 ) & 0x03 ;
+								break;
+
+								case 2 :
+									nCol = ( *pTmp >> 2 ) & 0x03;
+								break;
+
+								case 3 :
+									nCol = ( *pTmp++ ) & 0x03;
+								break;
+
+                                default:    // get rid of nCol uninitialized warning
+                                    nCol = 0;
+                                    break;
 							}
+
+							ImplSetTranspPixel( nY, nX, nCol, mpTransTab[ nCol ] < PNG_TRANS_VAL );
 						}
 					}
 				}
-				break;
-
-				case 8 :
+				else
 				{
-					if ( mbAlphaChannel )
-					{
-						if ( mnBitDepth == 8 )	// maybe the source is a 16 bit grayscale
-						{
-							for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp += 2 )
-								ImplSetAlphaPixel( nY, nX, pTmp[ 0 ], pTmp[ 1 ] );
-						}
-						else
+					if ( mnBitDepth == 4 )	// maybe the source is a two bitmap graphic
+					{   // BMP_FORMAT_4BIT_LSN_PAL
+						for ( sal_uInt32 nX = nXStart, nXIndex = 0; nX < maOrigSize.Width(); nX += nXAdd, nXIndex++ )
 						{
-							for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp += 4 )
-								ImplSetAlphaPixel( nY, nX, pTmp[ 0 ], pTmp[ 2 ] );
+							if( nXIndex & 1 )
+								ImplSetPixel( nY, nX, *pTmp++ & 0x0f );
+							else
+								ImplSetPixel( nY, nX, ( *pTmp >> 4 ) & 0x0f );
 						}
 					}
 					else
 					{
-						if ( mbTransparent )
-						{
-							if ( mnBitDepth == 8 )	// maybe the source is a 16 bit grayscale
-							{
-								for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp++ )
-									ImplSetPixel( nY, nX, *pTmp, mpTransTab[ *pTmp ] < PNG_TRANS_VAL );
-							}
-							else
-							{
-								for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp += 2 )
-									ImplSetPixel( nY, nX, *pTmp, mpTransTab[ *pTmp ] < PNG_TRANS_VAL );
-							}
-						}
-						else
+						for ( sal_uInt32 nX = nXStart, nXIndex = 0; nX < maOrigSize.Width(); nX += nXAdd, nXIndex++ )
 						{
-							if ( mnBitDepth == 8 )	// maybe the source is a 16 bit grayscale
-							{
-								if ( mnPass == 7 )	// mnPass == 7 -> no interlace or whole scanline is available
-									mpAcc->CopyScanline( nY, pTmp, BMP_FORMAT_8BIT_PAL, mnScansize -1 );
-								else
-								{
-									for ( nX = nXStart; nX < mnWidth; nX += nXAdd )
-										ImplSetPixel( nY, nX, *pTmp++, FALSE );
-								}
-							}
-							else
+							switch( nXIndex & 3 )
 							{
-								for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp += 2 )
-									ImplSetPixel( nY, nX, *pTmp, FALSE );
+								case 0 :
+									ImplSetPixel( nY, nX, *pTmp >> 6 );
+								break;
+
+								case 1 :
+									ImplSetPixel( nY, nX, ( *pTmp >> 4 ) & 0x03 );
+								break;
+
+								case 2 :
+									ImplSetPixel( nY, nX, ( *pTmp >> 2 ) & 0x03 );
+								break;
+
+								case 3 :
+									ImplSetPixel( nY, nX, *pTmp++ & 0x03 );
+								break;
 							}
 						}
 					}
 				}
-				break;
-
-				default :
-					mbStatus = FALSE;
-				break;
 			}
-		}
-		else
-		{
-			if ( mbAlphaChannel || mbTransparent )
+			break;
+
+			case 8 :
 			{
 				if ( mbAlphaChannel )
 				{
-					if ( mnBitDepth == 8 )	// maybe the source is a 16 bit each sample
+					if ( mnBitDepth == 8 )	// maybe the source is a 16 bit grayscale
 					{
-						if ( mpColorTable != mpDefaultColorTable )
-						{
-							for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp += 4 )
-								ImplSetAlphaPixel( nY, nX, BitmapColor( mpColorTable[ pTmp[ 0 ] ],
-																			mpColorTable[ pTmp[ 1 ] ],
-																				mpColorTable[ pTmp[ 2 ] ] ), pTmp[ 3 ] );
-						}
-						else
-						{
-//							if ( mnPass == 7 )	// mnPass == 7 -> no interlace or whole scanline is available
-//								mpAcc->CopyScanline( nY, pTmp, BMP_FORMAT_32BIT_TC_RGBA, mnScansize -1 );
-//							else
-							{
-								for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp += 4 )
-									ImplSetAlphaPixel( nY, nX, BitmapColor( pTmp[ 0 ], pTmp[ 1 ], pTmp[ 2 ] ), pTmp[ 3 ] );
-							}
-						}
+						for ( sal_uInt32 nX = nXStart; nX < maOrigSize.Width(); nX += nXAdd, pTmp += 2 )
+							ImplSetAlphaPixel( nY, nX, pTmp[ 0 ], pTmp[ 1 ] );
 					}
 					else
 					{
-						for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp += 8 )
-							ImplSetAlphaPixel( nY, nX, BitmapColor( mpColorTable[ pTmp[ 0 ] ],
-																		mpColorTable[ pTmp[ 2 ] ],
-																			mpColorTable[ pTmp[ 4 ] ] ), pTmp[6] );
+						for ( sal_uInt32 nX = nXStart; nX < maOrigSize.Width(); nX += nXAdd, pTmp += 4 )
+							ImplSetAlphaPixel( nY, nX, pTmp[ 0 ], pTmp[ 2 ] );
 					}
 				}
-				else // Transparency chunk
+				else if ( mbTransparent )
 				{
-					sal_Bool	bTransparent;
-					sal_uInt8	nRed, nGreen, nBlue;
-
-					if ( mnBitDepth == 8 )	// maybe the source is a 16 bit each sample
+					if ( mnBitDepth == 8 )	// maybe the source is a 16 bit grayscale
 					{
-						for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp += 3 )
-						{
-							nRed = pTmp[ 0 ];
-							nGreen = pTmp[ 1 ];
-							nBlue = pTmp[ 2 ];
-							bTransparent = ( ( nRed == mnTransRed )
-											&& ( nGreen == mnTransGreen )
-												&& ( nBlue == mnTransBlue ) );
-
-							ImplSetPixel( nY, nX, BitmapColor( mpColorTable[ nRed ],
-																mpColorTable[ nGreen ],
-																	mpColorTable[ nBlue ] ), bTransparent );
-						}
+						for ( sal_uInt32 nX = nXStart; nX < maOrigSize.Width(); nX += nXAdd, pTmp++ )
+							ImplSetTranspPixel( nY, nX, *pTmp, mpTransTab[ *pTmp ] < PNG_TRANS_VAL );
 					}
 					else
 					{
-						for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp += 6 )
-						{
-							nRed = pTmp[ 0 ];
-							nGreen = pTmp[ 2 ];
-							nBlue = pTmp[ 4 ];
-							bTransparent = ( ( nRed == mnTransRed )
-											&& ( nGreen == mnTransGreen )
-												&& ( nBlue == mnTransBlue ) );
-
-							ImplSetPixel( nY, nX, BitmapColor( mpColorTable[ nRed ],
-																mpColorTable[ nGreen ],
-																	mpColorTable[ nBlue ] ), bTransparent );
-						}
+						for ( sal_uInt32 nX = nXStart; nX < maOrigSize.Width(); nX += nXAdd, pTmp += 2 )
+							ImplSetTranspPixel( nY, nX, *pTmp, mpTransTab[ *pTmp ] < PNG_TRANS_VAL );
 					}
 				}
-			}
-			else
-			{
-				if ( mnBitDepth == 8 )	// maybe the source is a 16 bit each sample
+				else // neither alpha nor transparency
 				{
-					if ( mpColorTable != mpDefaultColorTable )
+					if ( mnBitDepth == 8 )	// maybe the source is a 16 bit grayscale
 					{
-						for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp += 3 )
-							ImplSetPixel( nY, nX, BitmapColor( mpColorTable[ pTmp[ 0 ] ],
-																mpColorTable[ pTmp[ 1 ] ],
-																	mpColorTable[ pTmp[ 2 ] ] ), FALSE );
+                        if( nXAdd == 1 )  // copy raw line data if possible
+                        {
+                            pTmp += nXStart;
+                            int nLineBytes = maOrigSize.Width() - nXStart;
+                            mpAcc->CopyScanline( nY, pTmp, BMP_FORMAT_8BIT_PAL, nLineBytes );
+                            pTmp += nLineBytes;
+                        }
+                        else
+                        {
+                            for ( sal_uInt32 nX = nXStart; nX < maOrigSize.Width(); nX += nXAdd )
+                                ImplSetPixel( nY, nX, *pTmp++ );
+                        }
 					}
 					else
 					{
-						if ( mnPass == 7 )	// mnPass == 7 -> no interlace or whole scanline is available
-							mpAcc->CopyScanline( nY, pTmp, BMP_FORMAT_24BIT_TC_RGB, mnScansize -1 );
-						else
-						{
-							for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp += 3 )
-								ImplSetPixel( nY, nX, BitmapColor( pTmp[ 0 ], pTmp[ 1 ], pTmp[ 2 ] ), FALSE );
-						}
-
+						for ( sal_uInt32 nX = nXStart; nX < maOrigSize.Width(); nX += nXAdd, pTmp += 2 )
+							ImplSetPixel( nY, nX, *pTmp );
 					}
 				}
-				else
+			}
+			break;
+
+			default :
+				mbStatus = FALSE;
+			break;
+		}
+	}
+	else // no palette => truecolor
+	{
+		if( mbAlphaChannel ) // has RGB + alpha
+		{   // BMP_FORMAT_32BIT_TC_RGBA
+			if ( mnBitDepth == 8 )  // maybe the source has 16 bit per sample
+			{
+                if ( mpColorTable != mpDefaultColorTable )
+                {
+                    for ( sal_uInt32 nX = nXStart; nX < maOrigSize.Width(); nX += nXAdd, pTmp += 4 )
+                       ImplSetAlphaPixel( nY, nX, BitmapColor( mpColorTable[ pTmp[ 0 ] ],
+                                                               mpColorTable[ pTmp[ 1 ] ],
+                                                               mpColorTable[ pTmp[ 2 ] ] ), pTmp[ 3 ] );
+                }
+                else
+                {
+//                  if ( nXAdd == 1 ) // copy raw line data if possible
+//                  {
+//                      pTmp += 4 * nXStart;
+//                      int nLineBytes = 4 * (maOrigSize.Width() - nXStart);
+//                      mpAcc->CopyScanline( nY, pTmp, BMP_FORMAT_32BIT_TC_RGBA, nLineBytes );
+//                      pTmp += nLineBytes;
+//                  }
+//                  else
+                    {
+                        for ( sal_uInt32 nX = nXStart; nX < maOrigSize.Width(); nX += nXAdd, pTmp += 4 )
+                            ImplSetAlphaPixel( nY, nX, BitmapColor( pTmp[0], pTmp[1], pTmp[2] ), pTmp[3] );
+                    }
+                }
+			}
+			else
+			{   // BMP_FORMAT_64BIT_TC_RGBA
+				for ( sal_uInt32 nX = nXStart; nX < maOrigSize.Width(); nX += nXAdd, pTmp += 8 )
+					ImplSetAlphaPixel( nY, nX, BitmapColor( mpColorTable[ pTmp[ 0 ] ],
+														mpColorTable[ pTmp[ 2 ] ],
+														mpColorTable[ pTmp[ 4 ] ] ), pTmp[6] );
+			}
+		}
+		else if( mbTransparent ) // has RGB + transparency
+		{   // BMP_FORMAT_24BIT_TC_RGB
+			if ( mnBitDepth == 8 )  // maybe the source has 16 bit per sample
+			{
+				for ( sal_uInt32 nX = nXStart; nX < maOrigSize.Width(); nX += nXAdd, pTmp += 3 )
+				{
+					sal_uInt8 nRed = pTmp[ 0 ];
+					sal_uInt8 nGreen = pTmp[ 1 ];
+					sal_uInt8 nBlue = pTmp[ 2 ];
+					sal_Bool bTransparent = ( ( nRed == mnTransRed )
+							 	        && ( nGreen == mnTransGreen )
+										&& ( nBlue == mnTransBlue ) );
+
+					ImplSetTranspPixel( nY, nX, BitmapColor( mpColorTable[ nRed ],
+														mpColorTable[ nGreen ],
+														mpColorTable[ nBlue ] ), bTransparent );
+				}
+			}
+			else
+			{   // BMP_FORMAT_48BIT_TC_RGB
+				for ( sal_uInt32 nX = nXStart; nX < maOrigSize.Width(); nX += nXAdd, pTmp += 6 )
 				{
-					for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp += 6 )
-						ImplSetPixel( nY, nX, BitmapColor( mpColorTable[ pTmp[ 0 ] ],
-															mpColorTable[ pTmp[ 2 ] ],
-																mpColorTable[ pTmp[ 4 ] ] ), FALSE );
+					sal_uInt8 nRed = pTmp[ 0 ];
+					sal_uInt8 nGreen = pTmp[ 2 ];
+					sal_uInt8 nBlue = pTmp[ 4 ];
+					sal_Bool bTransparent = ( ( nRed == mnTransRed )
+									&& ( nGreen == mnTransGreen )
+										&& ( nBlue == mnTransBlue ) );
+
+					ImplSetTranspPixel( nY, nX, BitmapColor( mpColorTable[ nRed ],
+														mpColorTable[ nGreen ],
+														mpColorTable[ nBlue ] ), bTransparent );
 				}
 			}
 		}
+		else  // has RGB but neither alpha nor transparency
+		{   // BMP_FORMAT_24BIT_TC_RGB
+			if ( mnBitDepth == 8 )   // maybe the source has 16 bit per sample
+			{
+                if ( mpColorTable != mpDefaultColorTable )
+                {
+                    for ( sal_uInt32 nX = nXStart; nX < maOrigSize.Width(); nX += nXAdd, pTmp += 3 )
+                        ImplSetPixel( nY, nX, BitmapColor( mpColorTable[ pTmp[ 0 ] ],
+                                                            mpColorTable[ pTmp[ 1 ] ],
+                                                            mpColorTable[ pTmp[ 2 ] ] ) );
+                }
+                else
+                {
+                    if( nXAdd == 1 ) // copy raw line data if possible
+                    {
+                        pTmp += 3 * nXStart;
+                        int nLineBytes = (maOrigSize.Width() - nXStart) * 3;
+                        mpAcc->CopyScanline( nY, pTmp, BMP_FORMAT_24BIT_TC_RGB, nLineBytes );
+                        pTmp += nLineBytes;
+                    }
+                    else
+                    {
+                        for ( sal_uInt32 nX = nXStart; nX < maOrigSize.Width(); nX += nXAdd, pTmp += 3 )
+                            ImplSetPixel( nY, nX, BitmapColor( pTmp[0], pTmp[1], pTmp[2] ) );
+                    }
+                }
+			}
+			else
+			{   // BMP_FORMAT_48BIT_TC_RGB
+				for ( sal_uInt32 nX = nXStart; nX < maOrigSize.Width(); nX += nXAdd, pTmp += 6 )
+					ImplSetPixel( nY, nX, BitmapColor( mpColorTable[ pTmp[ 0 ] ],
+														mpColorTable[ pTmp[ 2 ] ],
+														mpColorTable[ pTmp[ 4 ] ] ) );
+			}
+		}
 	}
-
-	rtl_copyMemory( mpScanprior, mpInflateInBuf, mnScansize );
 }
 
 // ------------------------------------------------------------------------
 
-void PNGReaderImpl::ImplSetPixel( sal_uInt32 nY, sal_uInt32 nX, const BitmapColor& rBitmapColor, BOOL bTrans )
+void PNGReaderImpl::ImplSetPixel( sal_uInt32 nY, sal_uInt32 nX, const BitmapColor& rBitmapColor )
 {
-	if ( mnPass == 7 )
-	{
-		mpAcc->SetPixel( nY, nX, rBitmapColor );
-
-		if ( bTrans )
-			mpMaskAcc->SetPixel( nY, nX, cTransIndex1 );
-		else
-			mpMaskAcc->SetPixel( nY, nX, cNonTransIndex1 );
-	}
-	else
-	{
-		sal_uInt32 nTX;
-
-		for ( int nBHeight = 0; nBHeight < aBlockHeight[ mnPass ]; nBHeight++ )
-		{
-			nTX = nX;
-
-			for ( int nBWidth = 0; nBWidth < aBlockWidth[ mnPass ]; nBWidth++ )
-			{
-				mpAcc->SetPixel( nY, nTX, rBitmapColor );
-
-				if ( bTrans )
-					mpMaskAcc->SetPixel( nY, nTX, cTransIndex1 );
-				else
-					mpMaskAcc->SetPixel( nY, nTX, cNonTransIndex1 );
-
-				if ( ++nTX == mnWidth )
-					break;
-			}
-
-			if ( ++nY == mnHeight )
-				break;
-		}
-	}
+    if( nX & mnPreviewMask )
+        return;
+    nX >>= mnPreviewShift;
+    mpAcc->SetPixel( nY, nX, rBitmapColor );
 }
 
 // ------------------------------------------------------------------------
 
-void PNGReaderImpl::ImplSetPixel( sal_uInt32 nY, sal_uInt32 nX, BYTE nPalIndex, BOOL bTrans )
+void PNGReaderImpl::ImplSetPixel( sal_uInt32 nY, sal_uInt32 nX, BYTE nPalIndex )
 {
-	if ( mnPass == 7 )
-	{
-		mpAcc->SetPixel( nY, nX, (BYTE)nPalIndex );
-
-		if ( bTrans )
-			mpMaskAcc->SetPixel( nY, nX, cTransIndex1 );
-		else
-			mpMaskAcc->SetPixel( nY, nX, cNonTransIndex1 );
-	}
-	else
-	{
-		sal_uInt32 nTX;
+    if( nX & mnPreviewMask )
+        return;
+    nX >>= mnPreviewShift;
+    mpAcc->SetPixel( nY, nX, nPalIndex );
+}
 
-		for ( int nBHeight = 0; nBHeight < aBlockHeight[ mnPass ]; nBHeight++ )
-		{
-			nTX = nX;
+// ------------------------------------------------------------------------
 
-			for ( int nBWidth = 0; nBWidth < aBlockWidth[ mnPass ]; nBWidth++ )
-			{
-				mpAcc->SetPixel( nY, nTX, (BYTE)nPalIndex );
+void PNGReaderImpl::ImplSetTranspPixel( sal_uInt32 nY, sal_uInt32 nX, const BitmapColor& rBitmapColor, BOOL bTrans )
+{
+    if( nX & mnPreviewMask )
+        return;
+    nX >>= mnPreviewShift;
+
+    mpAcc->SetPixel( nY, nX, rBitmapColor );
+
+    if ( bTrans )
+        mpMaskAcc->SetPixel( nY, nX, mcTranspColor );
+    else
+        mpMaskAcc->SetPixel( nY, nX, mcOpaqueColor );
+}
 
-				if ( bTrans )
-					mpMaskAcc->SetPixel( nY, nTX, cTransIndex1 );
-				else
-					mpMaskAcc->SetPixel( nY, nTX, cNonTransIndex1 );
+// ------------------------------------------------------------------------
 
-				if ( ++nTX == mnWidth )
-					break;
-			}
-			if ( ++nY == mnHeight )
-				break;
-		}
-	}
+void PNGReaderImpl::ImplSetTranspPixel( sal_uInt32 nY, sal_uInt32 nX, BYTE nPalIndex, BOOL bTrans )
+{
+    if( nX & mnPreviewMask )
+        return;
+    nX >>= mnPreviewShift;
+
+    mpAcc->SetPixel( nY, nX, nPalIndex );
+
+    if ( bTrans )
+        mpMaskAcc->SetPixel( nY, nX, mcTranspColor );
+    else
+        mpMaskAcc->SetPixel( nY, nX, mcOpaqueColor );
 }
 
 // ------------------------------------------------------------------------
 
 void PNGReaderImpl::ImplSetAlphaPixel( sal_uInt32 nY, sal_uInt32 nX, const BitmapColor& rBitmapColor, BYTE nAlpha )
 {
-	if ( mnPass == 7 )
-	{
-		mpAcc->SetPixel( nY, nX, rBitmapColor );
-		mpMaskAcc->SetPixel( nY, nX, 255 - nAlpha );
-	}
-	else
-	{
-		sal_uInt32 nTX;
+    if( nX & mnPreviewMask )
+        return;
+    nX >>= mnPreviewShift;
 
-		for ( int nBHeight = 0; nBHeight < aBlockHeight[ mnPass ]; nBHeight++ )
-		{
-			nTX = nX;
-
-			for ( int nBWidth = 0; nBWidth < aBlockWidth[ mnPass ]; nBWidth++ )
-			{
-				mpAcc->SetPixel( nY, nTX, rBitmapColor );
-				mpMaskAcc->SetPixel( nY, nTX, 255 - nAlpha );
-				if ( ++nTX == mnWidth )
-					break;
-			}
-
-			if ( ++nY == mnHeight )
-				break;
-		}
-	}
+    mpAcc->SetPixel( nY, nX, rBitmapColor );
+    mpMaskAcc->SetPixel( nY, nX, 255 - nAlpha );
 }
 
 // ------------------------------------------------------------------------
@@ -1498,16 +1492,18 @@ PNGReader::~PNGReader()
 
 // ------------------------------------------------------------------------
 
+Size PNGReader::aPreviewSizeHint;
+
 BitmapEx PNGReader::Read()
 {
-	return mpImpl->Read();
+    return mpImpl->GetBitmapEx( aPreviewSizeHint );
 }
 
 // ------------------------------------------------------------------------
 
 const std::vector< vcl::PNGReader::ChunkData >& PNGReader::GetChunks() const
 {
-	return mpImpl->maChunkSeq;
+	return mpImpl->GetAllChunks();
 }
 
 } // namespace vcl
