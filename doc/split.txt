TODO:
	+ split the source, as per kendy's instructions.
	+ perhaps go bottom-up first !? ...
	+ split postprocess into it's own bit.

Build splitting notes:

	+ we need the same environment, and we need to link against a
	  given path instead of the solver.
		+ so for 'sw' we need:
			+ isolate it.
		+ get include files out - into separate place.
			+ do we need IDL ?

	+ we can use "src-pack" to do the build explosion.

	+ sw-dev300-m19/
		- 
	+ lib-dev300-m19/
		+ needs a symlink to itself 'unxlngi6.pro' or somesuch
		- bits we need from the solver:
		+ bits we need from solenv/
		- can we include LinuxIntelEnv.Set.sh in here ?
			+ how much does that hard-code the cwd ?
		+ bin: svidl, transex3, makedepend
	+ libraries from:
		+ /opt/OOInstall/basis3.0/program
	


	+ We need LinuxIntelEnv.Set.sh ...
		+ source it & clobber bits ...

* Major tasks:
	+ incremental pieces:
		+ hack bits out of scp2 as we go:
		+ #ifndef EXTERNAL_SW
		+ #endif // etc.

	+ install static libraries too [somewhere] ?
		+ basically we want 'deliver' really ...
		+ can we create a boot-strapping OO.o without
		  much pain otherwise: just bastardize make_installer.pl ?
			+ how much does it do that is really useful ?
			+ building component registry / rdbs (?)
		+ need to do that on rpm install anyway ?
			+ do it in one big rpm at the end ?
		+ have file-install lists per module (d.lst) ... (?)
			+ tag files "devel" vs. "non-devel"
			+ or have some black-list in a 'deliver' script ?

	+ possible deliver heuristics:
		+ all libraries -> installed system
			+ attempt to register each of them in registry.rdb
			+ [ what RPM file contains that rdb ? ]
				+ can we not do that at the end ?
				+ meta 'OpenOffice' package that
				  does registration.
			+ make make_installer run against the
			  final system
		+ all uiconfig* -> install
		+ all layout*.zip -> install
		+ have a path mapping:
			+ from solver -> inst image.


	+ split the scp2 - move it into each module ... [!?] ...
	+ Can we bootstrap from 'deliver' !?
	+ *or* - add tags to the scp - annotating where it comes from ?
		+ or run the make_installer in a minimal way that
		  just installs what is there ;-)
		+ [ we would need to accelerate that script ... ]

Source splitting notes:

icu		8236k
stlport:	4704k
libxmlsec:	1925k
rhino:		1185k
nas:		1165k
curl:		805k
neon:		601k
regexp:		444k
sablot:		372k
expat:		236k
berkeleydb:     209k
msfontextract:	196k
unixODBC: 	180k
twain:		148k
x11_extensions: 92k


moz:		36009k
dictionaries:	11858k
libxml:		2995k
zlib:		260k


	@echo -n $(SHL1LINKER) $(SHL1LINKFLAGS) $(LINKFLAGSSHL) -L$(PRJ)$/$(ROUT)$/lib $(SOLARLIB) -o $@ \

cannot find -luno_cppuhelpergcc3
	+ we need symlinks for:
	+ /opt/OOInstall/ure/lib/libuno_cppuhelpergcc3.so.3 -> .so [etc.]
		+ a -devel RPM for this.

	+ *or* ... something else (?)
		+ just whack the symlinks in ure/lib itself ... (?)

	for a in *.so.*; do ln -s $a `echo $a | sed 's/\.[0-9]*$//'`; done

Common pieces we need in the "finish up" phase:
	+ icon: ilst files
	+ res: files [ translations ]

TODO:
	+ check for pre-requisite packages when we configure.


	+ create a shell-script to clobber the bits we want
	+ make configure do that clobbering ?
	+ create a dummy Makefile to wrap the beastie.
	+ get on with it ;-)


	+ Translation [! -urgh- ]
		+ ideas
			+ duplicate all makefile.mk's into a separate lang-package
			+ duplicate all .src files [etc.] into there
				+ FIXME: if we patch things; what then ?
				+ we need to be the canonical 'master' really.
			+ include translation tools in there [ self contained ]
			+ 

			+ Allow parallel translation builds

		+ insert dummy translation rules into the makefiles
		  for writer etc. just 'touch' the files.
		+ [ or? ]

	+ Translation is spread all over the code
		+ => we need two modes
		+ "compile mode" and "translate mode"
			+ do these exist already ?

	+ or do we cheat ?
		+ just whack the translation files into the -devel package ?
		+ and copy from that (?)


Resolved:
	+ copy the translations into a known place in the -devel package and
	  collate them later into the main OO.o binary.
		+ allows developer to add new strings easily etc.
		+ adding new / individual translations perhaps a big
		  pain though.
	+ same for ilst files [etc.]
		+ hack this into 'deliver'
		+ build the 'solver' much in the same way.
		+ just minus the installable files.


	+ sort out the ooo-build wrapper ...
		+ urgh;
	+ make 'sw' build standalone nicely ...
		+ fix the wrapper later ?

	+ 'postprocess' ...

Kendy's take:
	+ http://www.mail-archive.com/dev%40tools.openoffice.org/msg00786.html


for a in  ../HEAD/src/dev300-m19*.tar.bz2; do tar -xjf $a; done


FIXME:
	+ do we wrap all the bits with ooo-build ?
	+ can we adapt it's behavior based on what we see in src/ ? :-)


+ configure.in:
	+ added "--with-split" ...
        --with-installed-ooo-dirname=%ooo_home: ooo_home => "ooo-2.0"
	from "setup.in":
		OOINSTBASE=@libdir@/@OOOINSTALLDIRNAME@

	+ whack the solver in: /usr/lib/ooo-2.0/solver/
		+ prune down the things that are simply not used ...


* OODESTDIR ... (?)
	+ use it to test ?

* ooo-build: how much hassle do we need ?
	+ add a "--with-devel-path" and default to /usr/lib/ooo-2.0/solver

	+ we won't need to do -so- much work in an 'inferior' package (?)
		+ all the configure options will be set ahead of time.

	+ --with-devel-path=
		- will set all the options (?)
		- [ in the #1st analysis at least ;-]

	+ do we even need ooo-build ?
		+ yes for patching [sadly]
		+ so ... 

	+ switch to /usr/lib/ooo-3 instead ...
	+ 

	+ copy all our patches into the solver ?
		+ and apply.pl (?) ... ;-)


** FIXME:
	+ we need our 'build logic' split up and used in lots of
	  different places.
		+ "unpack" needs splitting into lots of pieces.
		+ "ooinstall" likewise
		+ can we create a set of scripts: one per piece,
		  and just run them in sequence ?

** FIXME:
	+ just install the whole solver into /usr/lib/... ?
		+ use that as the -devel RPM ?
		+ delete junk out of it ?
			+ remove duplicates (somehow)
			+ install earlier ?

TODO:
	+ make 'build.pl' efficient
		+ create a pseudo-module (somehow)
		+ work with that.
		+ make it deliver as it goes (?)
	+ symlink solver/lib -> /usr/lib/ooo-3/program
		+ [ how do we do the multi-layer-ness ? ]
			[ different symlink for the ure build ? ]
		+ ensure the real RPMs actually have -something-
		  in them :-)


Build order:
	+ bootstrap
	+ ure | libs_extern
	+ libs_gui
	+ libs_core
	+ components | artwork
	+ l10n
	+ impress | filters
	+ 


build.pl:
	+ from 'BuildAll' ? - goodness starts (?)
		=> GetParentDeps () ...
		=> $build_all_cont ... [!]

	+ PickPrjToBuild ...
		-> FindIdepPrj
	+ all comes from the build hash ...
	+ build_multiprocessing


VCL bits:

Making: ../../unxlngi6.pro/bin/vclzh-CN.res
Making: ../../unxlngi6.pro/bin/vclzh-TW.res
Making: ../../unxlngi6.pro/bin/vclzu.res
using rsc multi-res feature
rsc -presponse @/tmp/mkMnJcdx > /dev/null

f268: Error: The image(s) <check checkwin checkos2 checkmac checkunx
checkmono radio radiowin radioos2 radiomac radiounx radiomono msgbox
pin splhpin splvpin splharw splvarw scrmsk scrbmp closedoc closedochc
mainapp_48_8 mainapp_48_8 odt_48_8 ott_48_8 ods_48_8 ots_48_8 odg_48_8
otg_48_8 odp_48_8 otp_48_8 odp_48_8 odm_48_8 oth_48_8 mainapp_48_8
odb_48_8 odf_48_8 mainapp_48_8 mainapp_48_8 printeradmin_48_8
mainapp_32_8 mainapp_32_8 odt_32_8 ott_32_8 ods_32_8 ots_32_8 odg_32_8
otg_32_8 odp_32_8 otp_32_8 odp_32_8 odm_32_8 oth_32_8 mainapp_32_8
odb_32_8 odf_32_8 mainapp_32_8 mainapp_32_8 printeradmin_32_8
mainapp_16_8 mainapp_16_8 odt_16_8 ott_16_8 ods_16_8 ots_16_8 odg_16_8
otg_16_8 odp_16_8 otp_16_8 odp_16_8 odm_16_8 oth_16_8 mainapp_16_8
odb_16_8 odf_16_8 mainapp_16_8 mainapp_16_8 printeradmin_16_8
mainapp_32 mainapp_32 lx03251 lx03255 lx03250 lx03254 lx03246 lx03252
lx03249 lx03253 lx03241 lx03248 lx03139 lx03128 lx03245 lx03247
lx03242 lx03216 printeradmin_32 mainapp_16 mainapp_16 sx03251 sx03255
sx03250 sx03254 sx03246 sx03252 sx03249 sx03253 sx03241 sx03248
sx03139 sx03128 sx03245 sx03247 sx03242 sx03216 printeradmin_16
mainapp_32_h mainapp_32_h lxh03251 lxh03255 lxh03250 lxh03254 lxh03246
lxh03252 lxh03249 lxh03253 lxh03241 lxh03248 lxh03139 lxh03128
lxh03245 lxh03247 lxh03242 lxh03216 printeradmin_32_h mainapp_16_h
mainapp_16_h sxh03251 sxh03255 sxh03250 sxh03254 sxh03246 sxh03252
sxh03249 sxh03253 sxh03241 sxh03248 sxh03139 sxh03128 sxh03245
sxh03247 sxh03242 sxh03216 printeradmin_16_h> could not be found.

Terminating compiler
dmake:  Error code 1, while making '../../unxlngi6.pro/misc/rsc_vcl'

ERROR: Error 65280 occurred while making /home/usr/src/packages/BUILD/dev300-m21-libs_gui/vcl/source/src


/bin/ls | tr '\n' ':'


[ PYUNO -> depends on 'tools' !? ...
  testshl2 -> from 'sal' ;-) ]
	+ hmm ...

  
SOLARBINDIR - check for it in bootstrap/URE etc. & re-vector it from the bottom up ?

Questions:
	+ should we try a different approach
	+ "solver" is the system 'solver'
		+ deliver [ etc. ] tweak it ...
		+ 

    my $build_sosl    = $ENV{'BUILD_SOSL'};
    my $common_outdir = $ENV{'COMMON_OUTDIR'};
    my $inpath        = $ENV{'INPATH'};
    my $solarversion  = $ENV{'SOLARVERSION'};
    my $updater       = $ENV{'UPDATER'};
    my $updminor      = $ENV{'UPDMINOR'};
    my $work_stamp    = $ENV{'WORK_STAMP'};

install to 'SOLARVERSION' ?


* deliver is the only thing that copies output anywhere;
	=> we need to fool deliver.
	=> we need to ensure that our compile flags [etc.]
	   include the local intermediate / non-solver.

