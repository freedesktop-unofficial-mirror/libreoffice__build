* Research:
    + s/aquire/acquire/ :-)

    + Need:
	+ total number of string calls (from KCacheGrind (or a plain dump?))
	+ string ops on XML file load ?
	+ performance regression tests ... [!]
	    + [ need a big list of strings ]
	    + with small pool, with stuffed pool.

Check Kai's numbers:
	http://wiki.services.openoffice.org/wiki/Uno/Binary/Analysis/String_Performance

Q1. - do we have to 'intern' everything ?
    + Ans: no - Java doesn't prolly for good reason.

Q2. - 'reliability' - and a local cache ?
    + Ans: not need to be reliable.

Q3. - 'lifecycle' - hold a ref ?
	+ annotating an 'interned' string - ref. count fair game ?
    + <mmeeks> 2 bits: 1 is a 'static' flag (also a guard against huge /wrap-around ref-counts)
      <mmeeks> and bit 2 is the "is-interned" flag
      <mmeeks> ;-)
      * mmeeks really goes.
      <kr_> you mean least significant, don't you?
      <kr_> sounds fine for me !

Q4. - is OUString only acceptable ?

Q5. - ignore 'long' strings > 1024 chars ?

* Need 1 more atomic operation:
    + 'setBit'  (or atomic Xor I guess)

1st concept:

Current design thoughts:
    + explicit "intern" calls, in hot string spots (?)
	+ "intern" only works for 'small' < page strings.
    + comparison operator optimised for ptr == first.
	+ becomes a more common case.

    + problem:
	+ "how can you tell an 'interned' string"
	    + bit-mask on the length ?
	    + bit-mask on the 'refCount' ?
	    + "static" bit on the 'refCount' ?
	    + store a byte 'cookie' / 'canary' at
	      the end ?
	    + cookie.
	+ OR:
	    + a garbage type impl.
	    	+ small hash ~1 page of entries in
		  'thread private storage'
		+ holds a ref on the strings
	    + when this gets full [ size > N bytes ]
		+ scan for 'ref == 1'
	    + 'old' strings - moved to 'old' list (?)
	    + occasionally scan whole list
	      for 'ref == 1' strings

* What about a 'static-intern' (?) :-)
    + never ref count it ...


* Performance points:
    + charset conversion is -normally- done
      in constructors
	+ we can subvert these ?

static OUString createIntern( sal_Unicode *, sal_Int32 nLength );
static OUString createIntern( sal_Char *, sal_Int32 nLength, rtl_TextEncoding );
static OUString createFromAsciiIntern( sal_Char *, sal_Int32 nLength, rtl_TextEncoding );
	+ makes sense ...


ustring.c:
void SAL_CALL rtl_string2UString( rtl_uString** ppThis,
                                  const sal_Char* pStr,
                                  sal_Int32 nLen,
                                  rtl_TextEncoding eTextEncoding,
                                  sal_uInt32 nCvtFlags )

	+ We -could- adapt this to pass an alloca'd "scratch" buffer,
	  and have a more complex calling behavior (and/or duplicate
	  the special cases for _ASCII & _UTF8) & fall-back to a
	  dup/free for others ?


* InterlockedXor (!?)
* InterlockedAnd (!?)
    + do we need interlock on the 'And' ?
	+ can set coming out of the pool lock ?

http://www.gamasutra.com/features/20060630/paquet_01.shtml

* Need a WRITE_BARRIER between lock & a compare ...


* consistency: important,
    + how to update a per-thread cache ?
	+ hold a ref inside the cache ?
	+ if the bit is set ... when we get down to 1 ref ... (?)
	    + transfer it to the main cache & set the bit -only- when out of the per-thead cache ...


TODO:
    hack in the 'sal' CWS ...

* Get a list of all strings allocated / freed at OO.o startup
* Get another list: all strings loading a writer document (?)

* Looking at 'all' strings ...
    + there are a lot [!]
    + 


Static strings:

<kr_> how do I past something here?
<kr_> search for lines with RTL_CONST gave:
<kr_>  String literals found: 20121
<kr_>  Chars in these literals: 321687
<kr_> search for lines with "createFrom" gave:
<kr_>  String literals found: 9676
<kr_>  Chars in these literals: 187719
<kr_> if every strings gets instantiated once, than we have 1018812 ==
1m to save, not counting duplicates ...


gcc - use pre-processor to create in-line static strings,
    + use crack-tastic gcc extensions to do it ...

Charset stuff:
 -fexec-charset 

http://developer.mozilla.org/en/docs/XPCOM_string_guide

The STRING versions of these macros provide a portable way of
declaring UTF-16 versions of the given literal string, avoiding
runtime conversion on platforms which support literal UTF-16 strings
(e.g., MSVC++ and GCC with the -fshort-wchar option).

+ check boost ... (for string literals etc.)


typedef struct {
    int ref;
    int len;
    const wchar_t buffer[4];
} Str;

giveStr(&((const Str) { 12, 3, L"Foo" }));//{ 'f', 'o', 'o' } }));

gcc -O2 -S -std=c99 -Wall -fshort-wchar -fwide-exec-charset=UTF-16 ~/a.c

#define DECL_STR(a) \
    ((Str *)(&((const struct { int r; int l; const wchar_t b[strlen(a) + 1]; } ) { (1<<30)+1, strlen(a), L##a })))

-fshort-wchar is sufficient ...
In fact -fwide-exec-charset=UTF16 - breaks stuff ...

TODO:
    + remove interned strings on destruction
      from the pool ...
    + add primes for hash sizes ...
    + add debug to show pool size / re-size.
    + beef up the regression tests & make it
      resize the pool more frequently.