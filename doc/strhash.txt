* Research:
    + Need:
	+ total number of string calls (from KCacheGrind (or a plain dump?))
	+ string ops on XML file load ?
	+ performance regression tests ... [!]
	    + [ need a big list of strings ]
	    + with small pool, with stuffed pool.

Check Kai's numbers:
	http://wiki.services.openoffice.org/wiki/Uno/Binary/Analysis/String_Performance

Q1. - do we have to 'intern' everything ?
    + Ans: no - Java doesn't prolly for good reason.

Q2. - 'reliability' - and a local cache ?
    + Ans: not need to be reliable.

Q3. - 'lifecycle' - hold a ref ?
	+ annotating an 'interned' string - ref. count fair game ?
    + <mmeeks> 2 bits: 1 is a 'static' flag (also a guard against huge /wrap-around ref-counts)
      <mmeeks> and bit 2 is the "is-interned" flag
      <mmeeks> ;-)
      * mmeeks really goes.
      <kr_> you mean least significant, don't you?
      <kr_> sounds fine for me !

Q4. - is OUString only acceptable ?

Q5. - ignore 'long' strings > 1024 chars ?

* Need 1 more atomic operation:
    + 'setBit'  (or atomic Xor I guess)

1st concept:

Current design thoughts:
    + explicit "intern" calls, in hot string spots (?)
	+ "intern" only works for 'small' < page strings.
    + comparison operator optimised for ptr == first.
	+ becomes a more common case.

    + problem:
	+ "how can you tell an 'interned' string"
	    + bit-mask on the length ?
	    + bit-mask on the 'refCount' ?
	    + "static" bit on the 'refCount' ?
	    + store a byte 'cookie' / 'canary' at
	      the end ?
	    + cookie.
	+ OR:
	    + a garbage type impl.
	    	+ small hash ~1 page of entries in
		  'thread private storage'
		+ holds a ref on the strings
	    + when this gets full [ size > N bytes ]
		+ scan for 'ref == 1'
	    + 'old' strings - moved to 'old' list (?)
	    + occasionally scan whole list
	      for 'ref == 1' strings

* What about a 'static-intern' (?) :-)
    + never ref count it ...


* Performance points:
    + charset conversion is -normally- done
      in constructors
	+ we can subvert these ?

static OUString createIntern( sal_Unicode *, sal_Int32 nLength );
static OUString createIntern( sal_Char *, sal_Int32 nLength, rtl_TextEncoding );
static OUString createFromAsciiIntern( sal_Char *, sal_Int32 nLength, rtl_TextEncoding );
	+ makes sense ...


ustring.c:
void SAL_CALL rtl_string2UString( rtl_uString** ppThis,
                                  const sal_Char* pStr,
                                  sal_Int32 nLen,
                                  rtl_TextEncoding eTextEncoding,
                                  sal_uInt32 nCvtFlags )

	+ We -could- adapt this to pass an alloca'd "scratch" buffer,
	  and have a more complex calling behavior (and/or duplicate
	  the special cases for _ASCII & _UTF8) & fall-back to a
	  dup/free for others ?


* InterlockedXor (!?)
* InterlockedAnd (!?)
    + do we need interlock on the 'And' ?
	+ can set coming out of the pool lock ?

http://www.gamasutra.com/features/20060630/paquet_01.shtml

* Need a WRITE_BARRIER between lock & a compare ...


* consistency: important,
    + how to update a per-thread cache ?
	+ hold a ref inside the cache ?
	+ if the bit is set ... when we get down to 1 ref ... (?)
	    + transfer it to the main cache & set the bit -only- when out of the per-thead cache ...


TODO:
    hack in the 'sal' CWS ...

* Get a list of all strings allocated / freed at OO.o startup
* Get another list: all strings loading a writer document (?)

* Looking at 'all' strings ...
    + there are a lot [!]
    + 
