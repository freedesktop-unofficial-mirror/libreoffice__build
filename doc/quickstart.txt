
	We do quick-start in ooo-wrapper.in by handling the extra
--session-quickstart argument.

	However; the OO.o internal quickstart code is a mess:

* From the desktop end

	* framework/source/services/desktop.cxx: it seems that
xQuickLauncher isn't => always quitting. Added via
'addTerminateListener'; two listeners:

** QuickLauncher: 'desktop.QuickstartWrapper'.

	The shutdown icon sits in the systray and allows the user to
keep the office instance running for quicker restart. Implemented in:
sfx2/source/appl/shutdownicon.cxx - but that has to be a throw-back,
and doesn't appear to work.


** PipeTerminator: 'OfficeIPCThreadController'

	* desktop/source/app/officeipcthread.cxx: here is where the
action lurks; seems to have no discrimination between a session
shutdown vs. a user terminate. cf.


* Session management:

	* vcl/unx/source/app/sm.cxx (ShutDownHdl): calls 'ShutDown' on
GetSalData()->pFirstFrame_ - if we have one.


* From the 'quickstart' angle

	+ -headless + -invisible seems to work modulo 'exit', we could
do with a hacked version of the 'shutdown icon' thing that works with
session management.

	+ ARGH - so we have to hack the OfficeIPCFooBaa vetoing baz,
we will provide a few really nasty hacks - to make life worthwhile. We
need to connect (somehow) to the SM death signal, and in that case emit
something nasty like shutdownicon.cxx (terminateDesktop).

	+ Ugly ongoing bug - multi-display stuff is uber-broken.

	+ Can we create an 'immortal' first toplevel frame, that
responds to 'Shutdown' from the SM; and disobey's Exit ?

'Exit' ->
	sfx2/source/appl/appserv.cxx: xDesktop->terminate.

'Sm Quit' ->
	SalFrameData::Shutdown ->
		{ return pProc_( pInst_, pFrame_, SALEVENT_SHUTDOWN, 0 ); }

	SALEVENT_CLOSE vs. SALEVENT_SHUTDOWN ...
	-> vcl/source/window/winproc.cxx (ImplWindowFrameProc)
		-> GetpApp->QueryExit -> 
			-> Does a 'Close' on the app
		-> Application::Quit
			Application::PostUserEvent(
				STATIC_LINK( NULL, ImplSVAppData, ImplQuitMsg ) );
			sets:
				ImplGetSVData()->maAppData.mbAppQuit = TRUE;
			-> svapp.cxx: Application::Execute terminates

--

So the current solution that we have is that ShutdownIcon adds itself to the
Desktop::addTerminateListener and then when the application is about to quit,
all the TerminateListeners are queried whether or not it is okay to quit. When
the ShutdownIcon decides to stay back in the background, it sets a veto
variable to true, and when queried by Desktop on quit, vetoes the termination
and stays back in the background. Effectively, the quickstarter is up and
running with:

--- desktop/source/app/cmdlineargs.cxx	2005-09-08 22:35:40.000000000 +0530
+++ desktop/source/app/cmdlineargs.cxx	2005-10-17 16:38:06.000000000 +0530
@@ -350,9 +350,7 @@
 	}
 	else if ( aArg.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "-quickstart" )) == sal_True )
 	{
-#ifdef WNT
 		SetBoolParam_Impl( CMD_BOOLPARAM_QUICKSTART, sal_True );
-#endif
 		return sal_True;
 	}
 	else if ( aArg.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "-terminate_after_init" )) == sal_True )
--- sfx2/source/appl/shutdownicon.cxx	2005-09-07 23:18:37.000000000 +0530
+++ sfx2/source/appl/shutdownicon.cxx	2005-10-17 16:39:46.000000000 +0530
@@ -547,6 +547,10 @@
 				ShutdownIcon::pShutdownIcon = this;
 #ifdef WNT
 				initSystray();
+#else
+				// disable shutdown
+				getInstance()->SetVeto( true );
+				getInstance()->addTerminateListener();
 #endif
 			}
 			catch(const ::com::sun::star::lang::IllegalArgumentException&)


