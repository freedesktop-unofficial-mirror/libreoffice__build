Linker hacking:

       make -C .. objdir=`pwd` -C elf subdir_lib

    include/link.h: linker structures.

struct link_map
    - describes a loaded shared object;
    has lots of struct r_scope_elem 

core:
    do-lookup.h (do_lookup_x)
	+ looks through a single scope (list of link maps
	  / libraries) for a symbol.

    dl-lookup.c (_dl_lookup_symbol_x)
	+ passed a NULL terminated array of
	  scopes (4th arg)

    callers:
	dl-reloc.c (RESOLVE, RESOLVE_MAP)
	dl-rtld.c
	    + (dl_main): debugging code
	    + (struct: .dl_lookup_symbol_x) - hook
	dl-runtime.c
	    + (profile_fixup) - profiling only
	    + (fixup) - the real entry point
		        called per PLT entry via.
			the trampoline.


	dl-deps.c (_dl_map_object_deps)
	    + builds the dep list we want into l_searchlist
		+ only seems to work for dlopened' stuff.
		    ( & deps )
	    + 
    
const ElfW(Sym) *sym = &symtab[ELFW(R_SYM) (reloc->r_info)];
	+ our local symbol info:

elf/elf.h:

typedef struct
{
  Elf32_Word	st_name;		/* Symbol name (string tbl index) */
  Elf32_Addr	st_value;		/* Symbol value */
  Elf32_Word	st_size;		/* Symbol size */
  unsigned char	st_info;		/* Symbol type and binding */
  unsigned char	st_other;		/* Symbol visibility */
  Elf32_Section	st_shndx;		/* Section index */
} Elf32_Sym;


st_info: 

/* Legal values for ST_BIND subfield of st_info (symbol binding).  */

#define STB_LOCAL	0		/* Local symbol */
#define STB_GLOBAL	1		/* Global symbol */
#define STB_WEAK	2		/* Weak symbol */
#define	STB_NUM		3		/* Number of defined types.  */
#define STB_LOOS	10		/* Start of OS-specific */
#define STB_HIOS	12		/* End of OS-specific */
#define STB_LOPROC	13		/* Start of processor-specific */
#define STB_HIPROC	15		/* End of processor-specific */
    
#define ELF32_ST_BIND(val) (((unsigned char) (val)) >> 4)

if (*ref == NULL || ELFW(ST_BIND) ((*ref)->st_info) != STB_WEAK)

_dl_lookup_symbol_skip (...)
	+ only looks at objects loaded after
	  the described object - pretty pants, but better.


fixup:
    passed 'link_map' l -> scope
    Have Sym *symtab; & local sym; ie. can:

    if (ELFW(ST_BIND) ((*ref)->st_info) != STB_WEAK)
       ... do something fast ...

    switch (l->l_info[VERSYMIDX (DT_VERSYM)] != NULL) {
	   is or is not versioned ...
	      [ versioned symbols can be dog slow too ]
    }

    Passes l->l_scope for _both_ methods.
	+ l_searchlist (?) - DT_NEEDED dependencies & their deps in order :-)
	    + ... looks ideal ... [ dependency order ? ]


LD_DEBUG=<anything but reloc> stops 'fixup' being called;
    + also stops things working nastily.