Notes on configmgr2
      [ why is this so impossibly slow & inefficient ! ]

Observations
    + the UNO API mandates that everything must be thread-safe
	+ across 2 adjacent key access everything could change
	+ this is not what anyone wants

    + new API ?
	+ any = getStructure (path, type)
	    + 1 set of locking & iteration (?)
	    + getSubPath:

*** Performance ***
    + ~NotifierImpl - burns 56million instructions
	-> listenercontainer.hxx ...
	invariably has just 1 listener.
	    + created by ApiTreeImpl:
		+ m_aNotifier (new NotifierImpl(aTree))
	    + NotifierImplHolder:
		+ a vos::ORef<NotifierImpl>
		+ [ can it not smart-create ? ]


*** Notes ***

    + 2 types of 'tree' node:
	+ Group - presumably a normal node
	+ Set - presumably a simple list

    + Question:
	+ is it *really* worth screwing around with
	  this design ?
	+ generate some statistics.

*** API ***

**** UNO ****

container::XChild, container::XNamed, lang::XComponent,
configuration::XTemplateInstance, lang::XUnoTunnel
beans::XPropertySet, beans::XMultiPropertySet ...
util::XRefreshable, util::XFlushable, util::XStringEscape

  + source/
    + api2/
	+ elementaccess.hxx:
	    + BasicInnerElement: XChild, XNamed
	    + BasicSetElement: XChild, XNamed, XComponent
			       XTemplateInstance, XUnoTunnel
	    + BasicRootElement: XNamed, XComponent,
				XChangesNotifier, XLocalizable
	    + BasicUpdateelement: BasicRootElement, XChangesBatch
	+ groupaccess.hxx:
	    + BasicGroupAccess: XNameAccess, XHierarchicalName,
				XHierarchicalNameAccess, XContainer,
				XExactName, XProperty
	+ propertysetaccess.hxx:
	    + BasicPropertySet: XPropertySet, XMultiPropertySet,
				XHierarchicalPropertySet,
				XMultiHierarchicalPropertySet,
				XPropertyState, XMultiPropertyStates
	+ provider.hxx:
	    + OProvider: XMultiServiceFactory, XLocalizable,
			 XRefreshable, XFlushable
	+ setaccess.hxx:
	    + BasicSetAccess: XNameAccess, XHierarchicalName,
			      XHierarchicalNameAccess, XContainer,
			      XExactName, XProperty, XPropertySetInfo,
			      XTemplateContainer, XStringEscape

**** api2/configapi layer ****

    This is used by all the UNO wrappers, and features a much simpler
API, works on both NodeGroup & NodeSet node references
[NodeSetInfoAccess eg.]

	+ All operates on:
	    + configuration::Tree references

	+ apinodeaccess.cxx:
	    + makeElement
	    + makeUnoElement
	    + GuardedNodeAccess:
	+ accessimpl.cxx:
	    + implGetByName
		+ takes a GuardedNodeDataAccess lock.

	+ calls into 'configuration' API
	    ::configuration::getChildOrElement
	    ::configuration::validateAndReducePath
	    ::configuration::getDeepDescendant

	+ apifactory.cxx:
	    + configapi::Factory::
		+ makes UNO proxies for things

	+ apifactoryimpl.cxx:
	    + ReadOnlyObjectFactory::doCreateSetElement
		+ creates set elements.

	+ groupobjects.cxx:
	    + OSetElementGroupInfo

	+ apiaccessobj.hxx:
	    + OSetElement
		+ instantiates an ApiTreeImpl

	+ apitreeimplobj.cxx:
	    + ApiTreeImpl::ApiTreeImpl + ::init
	    + adds notifiers & all manner of gubbins

	+ notifierimpl.hxx
	    + 1 member: a SpecialListenerContainer

	+ listenercontainer.cxx
	    + manages XEventListener, XContainerListener,
	      XChangesListener, XPropertyChangeListener,
	      XVetoableChangeListener [etc.]
	      XPropertiesChangeListener
**	    + the vetoing - requires synchronous
	      listening (always?) ... 

	    typedef SpecialListenerContainer <SubNodeID,SubNodeHash,SubNodeEq,SubNodeToIndex> SpecialContainer;
	    ...
	    typedef cppu::OMultiTypeInterfaceContainerHelperVar< Key_,KeyHash_,KeyEq_ >	SpecialContainerHelper;
	    + Slowness via  OBroadcastHelperVar<> m_aSpecialHelper
	    	    + 100 elements ?
		    + default bucket count:
			+ we -usually- only use 1 element so ...

	+ what are in these buckets ?
	    + are there 100 buckets to clear (each?)
	    + 36million cycles


* Listener Impls *
	+ provider.cxx:
	    + OProviderDisposingListener
	    + implements XEventListener_BASE
	+ propertiesfilterednotifier.cxx:
	    + XPropertiesChangeListener,
	      XEventListener
	+ broadcaster.cxx (?)



    /*/.Name,.Property,.Value


  + 'GetGreatBlob' API call
    + how to manage the UNO type data for that ?
    + how to create a truly 'generic' type ?
	+ ultimately a sequence of any's (right) ?
	+ do we need a new type ?
	+ can we mangle some existing call ?
	