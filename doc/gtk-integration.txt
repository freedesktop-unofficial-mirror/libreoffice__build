Some blurb about gtk+ integration pain:

* gtk+

** main-loop
	+ The first thread to the main-loop gets to lurk in the
	  'select' - any other thread gets to block on that.
	+ Not a problem, since all timeout adds etc. interrupt
	  the existing mainloop.
	+ Lock state in the filter_function:
		+ gdk_event_translate: lock must be held when called
			+ lock taken without notifying SalYieldMutex::acquire
			+ we must setup SalYieldMutex / and tear-down too.

	+ How can we cope with gtk+ inferior loops !?
		+ cross toolkit calls ? - a nasty ?

	+ What happens when gtk+ drops it's lock ?
		+ thread-id is same ? - assumed safe; but is it ?
		+ GDK_THREADS_ENTER/LEAVE all do an operation on
		  gdk_threads_mutex; hrm...

* vcl
	+ we drop our lock as we poll
	+ we then re-take any locks & re-poll with the guard taken.
		+ cf. saldata.hxx's YieldMutexReleaser.
	+ we do not XInitThreads ...
	+ we guard XNextEvent etc. with the YieldMutex
		+ cf. vcl/unx/source/app/saldisp.cxx (Yield) from
		+ vcl/unx/source/app/saldata.cxx (Yield)

	+ vcl/source/app/svapp.cxx (Application::Yield): ->
	  SalInstance::Yield ->
	  GetSalData()->GetLib()->Yield( bWait );
	  SalInstance::AcquireYieldMutex - called by:
	  Application::AcquireSolarMutex

** Solar Mutex == YieldMutex
	cf. Application::GetSolarMutex -> GetYieldMutex.
	also cf. Application::GetMainThreadIdentifier


** Recursive lock <-> non recursive impl.
	+ need a slave lock to handle ThreadId changes etc.


* Solutions
	+ grab the X events as normal
