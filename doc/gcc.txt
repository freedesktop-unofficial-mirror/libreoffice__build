Performance:
    + create a small test library
    + find some genuinely weak / duplicate symbols in OO.o ...
    + add annotation etc. to that
    + checkout vtable instantation etc.


We are still doing too much work with symbol lookup
    + most of it highly avoidable.

    + ~95% is relocation processing ...
	+ fn relocations ...
    + populating vtable:
	+ looking up global / weak symbols [ why ? ]
	+ [ can they not be -Bsymbolic or something ? ]
	+ if 'dllexport' or the visibility attribute are 
	  used - we should/could hide local vtable
	  lookup bits ?
	+ we want the symbols to be 'protected' so they
	  are exported - by are resolved internally to
	  symbol-freea relocations
	+ The whole thing is crazy:
	    + we need only 1 'get-vtable' method per class ...
	+ Mark all 'virtual' methods of (SPECIFIED && DEFAULT)
	  linkage as 'protected' - ditto for generated thunks (?)
    + Understand the weak symbol issue [!?]
	+ add a throw/catch ...
	  fprintf (file, " %c%c%c%c%c%c%c",
	    ((type & BSF_LOCAL)
	    ? (type & BSF_GLOBAL) ? '!' : 'l'
	    : (type & BSF_GLOBAL) ? 'g' : ' '),
	   (type & BSF_WEAK) ? 'w' : ' ',
	   (type & BSF_CONSTRUCTOR) ? 'C' : ' ',
	   (type & BSF_WARNING) ? 'W' : ' ',
	   (type & BSF_INDIRECT) ? 'I' : ' ',
	   (type & BSF_DEBUGGING) ? 'd' : (type & BSF_DYNAMIC) ? 'D' : ' ',
	   ((type & BSF_FUNCTION)
	    ? 'F'
	    : ((type & BSF_FILE)
	       ? 'f'
	       : ((type & BSF_OBJECT) ? 'O' : ' '))));
	+ Weak symbols generated by:
	    + Templates ...
	    + Reference<Foo> type stuff ...
	    	    + non-virtual thunks
		    + type info (_ZTI)
		    + vtables (_ZTV)

    + [all to do with typeinfo behavior]
	+ re-read: http://www.nedprod.com/programs/gccvisibility.html
	  very carefully ...
    + Can we annotate the source with 'protected' for most methods ?

    + parent chaining ?
	+ doesn't go via vtable - but direct fn. call ...

    + Looks like we do all those bindings (relocs?)
	+ at dlopen time [!?] [ 10k relocations building vtables ? ]

    + need to check vs. gcc-4.x ...
	[ should be able to prune ... ]

Thoughts: (problem/soln/problem/...)
    + the deep / vcl OutputDevice -> Window -> Control -> ...
      vtable building issue is bad, bad news.
	+ why can't we get/copy the parent's vtable
	  with 'memcpy' ? instead of lots of lookups ?
    + can we parallelise the linker ?
	+ this problem is easily partitionable, surely ...
	    + [ no thread support in the linker ... ]

    + a 'thunk' fn does:
	+ adjust 'this' pointer & call method [ and MI feature ]

+ Things to check:
	+ anonymous namespaces ... - file path mangled in ?



** Parent / Copy VTables ... **
    + Use: options to dump tree data to aid debugging.

	-fdump-class-hierarchy[-N]
    + With this we get:
	cp/class.c (dump_vtable):

eg.

Vtable for SubClass
SubClass::_ZTV8SubClass: 9u entries
0     (int (*)(...))0
4     (int (*)(...))(& _ZTI8SubClass)
8     SubClass::doFoo
12    BaseClass::count
16    BaseClass::operator[]
20    SubClass::doAnother
24    (int (*)(...))-0x000000008
28    (int (*)(...))(& _ZTI8SubClass)
32    SubClass::_ZThn8_N8SubClass9doAnotherEi

Called from:
    + cp/class.c (initialize_vtable)
	+ We need to identify simple cases somewhere
	  here & eliminate sillies.

/* Make BINFO's vtable have N entries, including RTTI entries,
   vbase and vcall offsets, etc.  Set its type and call the backend
   to lay it out.  */

static void
layout_vtable_decl (tree binfo, int n)

/* Virtual function table initialization.  */

/* Create all the necessary vtables for T and its base classes.  */

static void
finish_vtbls (tree t)

Calls:

/* Initialize the vtable for BINFO with the INITS.  */

static void
initialize_vtable (tree binfo, tree inits)

* It seems initializer ordering is unpredictable:

works:

extern ParamFoo aBaa;
ParamFoo aBaa;
StaticInit aStatic(aBaa);

doesn't work:

extern ParamFoo aBaa;
StaticInit aStatic(aBaa);
ParamFoo aBaa;

* Initialization etc. bits:

http://gcc.gnu.org/onlinedocs/gcc-4.1.1/gccint/Initialization.html

.ctors section.
    + find something that puts code in
      the .ctors section (?)

Emit a fn. that will do the construction (?)
    + make it a .ctor (?)


*/

static void
finish_vtbls (tree t)

Calls:

/* Initialize the vtable for BINFO with the INITS.  */

static void
initialize_vtable (tree binfo, tree inits)

* It seems initializer ordering is unpredictable:

works:

extern ParamFoo aBaa;
ParamFoo aBaa;
StaticInit aStatic(aBaa);

doesn't work:

extern ParamFoo aBaa;
StaticInit aStatic(aBaa);
ParamFoo aBaa;

* Initialization etc. bits:

http://gcc.gnu.org/onlinedocs/gcc-4.1.1/gccint/Initialization.html

.ctors section.
    + find something that puts code in
      the .ctors section (?)

Emit a fn. that will do the construction (?)


* Avoid duplicate VTable construction:

    + need to hook the vague linkage constructs:

http://m68hc11.serveftp.org/doc/gcc_6.html

    + but for methods [ ie. same as 'inline' methods ?! ;-]


+ 1st step:
    + get gcc to emit a constructor call to
      a custom fn ...

+ 2nd step
    + generate bit-masks &
      impl. that function to do a copy

+ 3rd step
    + generate that fn. internally



** Ordering:
    + absolutely critical ...
	+ to make it efficient:
	    + have to copy from direct parents only
		=> have to ensure the parent is initialized
		   (copied) itself first ...
	    + have to copy only once
    + Linker support ...

** Assumption:
    + it will ~always be more compact and
      efficient to do vtable copies ourself
      (in shared libraries)
	    + we can make this dependent on -fPIC ...

** Minimality
    + is it possible to do the ordering without
      binutils support ?
	+ we could call a 'weak'
	  parent 'copyVTable' method (if present)
	+ each constructor:
	    + initVTable<Name>
	    + emit a constructor call to that
		+ let initialization sort it out (?)
		+ [ would that break stuff ?]
	    + how bad would that be ?
		+ can we add support to elide
		  duplicate constructors in binutils ?

    + could we do (idle) vtable construction on 1st
      class instance use ?
	+ might be somewhat bloating & evil.
	+ OTOH currently ~valid - since no parent
	  use without foo ?

    + With binutils support:
	+ can call a minimal number of fn's ...
	    + but more difficult (?) ...
	+ the 'sort' is easy
	    + need code walk-through;
		+ where are vtables emitted (by the backend) [!?]
	+ can be made more succinct
	    + can be made .rodata (?)
		+ then needs glibc support [?]
		    + [ for symbol lookup ? ]

** Questions:
    + what forms of symbol / invocation ellision can we use ?

    + I -like- the idea of an 'initVTable' method
      being called (with ~weak stuff?)
	+ isolates the fix in g++ itself, with no
	  binutils/glibc pain.

    + in gcc: where is the vtable building code ?
	+ class.c: initialize_vtable
	    + [ initialize_artificial_var (...)
	+ class.c: (build_vtbl_initializer)
	    + sets up BINFO_VTABLE -
	      (an expression that points at an
	      offset into the vtable ].
	+ class.c (

    + in gcc: where is the vtable emission code ?
	+ 


    + helpful blurb:

   Define accessor macros for information about type inheritance
   and basetypes.

   A "basetype" means a particular usage of a data type for inheritance
   in another type.  Each such basetype usage has its own "binfo"
   object to describe it.  The binfo object is a TREE_VEC node.

   Inheritance is represented by the binfo nodes allocated for a
   given type.  For example, given types C and D, such that D is
   inherited by C, 3 binfo nodes will be allocated: one for describing
   the binfo properties of C, similarly one for D, and one for
   describing the binfo properties of D as a base type for C.
   Thus, given a pointer to class C, one can get a pointer to the binfo
   of D acting as a basetype for C by looking at C's binfo's basetypes.  */



* Considerations:
    + Information
    + Representaiton
    + Data sharing
    + Space efficiency

M-x set-variable\ntab-width 8



<micha> What I implemented until then was just some dumping routines
in the frontend to see how and where it put together the member method
decls, and if it were a overrider, or something inherited.  Then I
thought about it, and thought the whole complicateness is not needed
anymore anyway, then we spoke about it, then I thought again that it's
needed, but never returned to do something on it.  But the patch for
getting a feel in cp/class.c is somewhere

<micha> ...
<micha> ~matz/copy-vtable/diff

<micha> What's left is a multitude of stuff: 1) remembering in
lists-per-class, where the overriders were, 2) emitting a decl for
that list, which could be interpreted at runtime, 3) writing the
runtime support to interpret all these lists, 4) make ld.so call that
runtime support before everything else (also before other static
ctors)

* So
    + we can (I think correctly) identify the slots we want to copy

* Next:
    + generating a new section:
	+ read the constructor code ...

+ decl2.c - remember ? - RTL generation etc. ? :-)

./gcc/cp/decl2.c:#define SSDF_IDENTIFIER "__static_initialization_and_destruction"
./gcc/cp/decl2.c:  char id[sizeof (SSDF_IDENTIFIER) + 1 /* '\0' */ + 32];
./gcc/cp/decl2.c:     SSDF_IDENTIFIER_<number>.  */
./gcc/cp/decl2.c:  sprintf (id, "%s_%u", SSDF_IDENTIFIER, count);

./gcc/cp/cp-tree.h:extern GTY(()) tree static_aggregates;



    static_aggregates = tree_cons (init, decl, static_aggregates);

  while (*var)
    {
      tree t = *var;
      tree decl = TREE_VALUE (t);
      tree init = TREE_PURPOSE (t);

      *var = TREE_CHAIN (t);
      TREE_CHAIN (t) = result;
    }


** We need an intermediate representation (!?)
    + trees of what ?
	+ 2 tree pairs ?
	+ source & dest ?
	    + source == ptr to vtable + offset ...
		+ [ can we make an offset expression ? - perhaps ... ]
	    + dest == ptr to vtable + offset ...

	+ can we use DECL_VINDEX instead ?
	    [ then we have it all ]
	    + just store the fn ptr ?
		+ do we duplicate the fn. decls
		  per vtable ?

    + Then sort/crunch these on output ...
	+ 

    + cp_finish_decl builds 'static_aggregates'

+ Question:
    + is there a different fn. decl per vtable slot
      assignment ? - with a different DECL_VINDEX ?
	+ since we assign DECL_VINDEX on a BV_FN(fn):
	    + it must be ...
      for (vindex = 0, fn = BINFO_VIRTUALS (TYPE_BINFO (t));
	{
	  tree fndecl = BV_FN (fn);
	  ...
	    DECL_VINDEX (fndecl) = build_int_cst (NULL_TREE, vindex);
	}

        + in vtbl_initialize - 'fn' - is the BV_FN ...

    + Is there already a list of vtables we can
      come back to & operate on later (at emission time ?)
	... 
	+ why not build one ? & operate on it later ?
	+ First build simple list:
	    + then re-consider: can we post-generate this ?

    + can we just sort binutils to ensure that no source
      address is read before a dest is written (?)
	+ then sort read/writes etc.



 Every class has an associated "binfo", which can be obtained with
`TYPE_BINFO'.  Binfos are used to represent base-classes.  The binfo
given by `TYPE_BINFO' is the degenerate case, whereby every class is
considered to be its own base-class.  The base binfos for a particular
binfo are held in a vector, whose length is obtained with
`BINFO_N_BASE_BINFOS'.  The base binfos themselves are obtained with
`BINFO_BASE_BINFO' and `BINFO_BASE_ITERATE'.  To add a new binfo, use
`BINFO_BASE_APPEND'.  The vector of base binfos can be obtained with
`BINFO_BASE_BINFOS', but normally you do not need to use that.  The
class type associated with a binfo is given by `BINFO_TYPE'.  It is not
always the case that `BINFO_TYPE (TYPE_BINFO (x))', because of typedefs
and qualified types.  Neither is it the case that `TYPE_BINFO
(BINFO_TYPE (y))' is the same binfo as `y'.  The reason is that if `y'
is a binfo representing a base-class `B' of a derived class `D', then
`BINFO_TYPE (y)' will be `B', and `TYPE_BINFO (BINFO_TYPE (y))' will be
`B' as its own base-class, rather than as a base-class of `D'.

 The access to a base type can be found with `BINFO_BASE_ACCESS'.  This
will produce `access_public_node', `access_private_node' or
`access_protected_node'.  If bases are always public,
`BINFO_BASE_ACCESSES' may be `NULL'.

 `BINFO_VIRTUAL_P' is used to specify whether the binfo is inherited
virtually or not.  The other flags, `BINFO_MARKED_P' and `BINFO_FLAG_1'
to `BINFO_FLAG_6' can be used for language specific use.

 The following macros can be used on a tree node representing a
class-type.

`LOCAL_CLASS_P'
     This predicate holds if the class is local class _i.e._ declared
     inside a function body.

`TYPE_POLYMORPHIC_P'
     This predicate holds if the class has at least one virtual function
     (declared or inherited).

`TYPE_HAS_DEFAULT_CONSTRUCTOR'
     This predicate holds whenever its argument represents a class-type
     with default constructor.

`CLASSTYPE_HAS_MUTABLE'
`TYPE_HAS_MUTABLE_P'
     These predicates hold for a class-type having a mutable data
     member.

