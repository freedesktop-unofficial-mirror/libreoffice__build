Performance:
    + create a small test library
    + find some genuinely weak / duplicate symbols in OO.o ...
    + add annotation etc. to that
    + checkout vtable instantation etc.


We are still doing too much work with symbol lookup
    + most of it highly avoidable.

    + ~95% is relocation processing ...
	+ fn relocations ...
    + populating vtable:
	+ looking up global / weak symbols [ why ? ]
	+ [ can they not be -Bsymbolic or something ? ]
	+ if 'dllexport' or the visibility attribute are 
	  used - we should/could hide local vtable
	  lookup bits ?
	+ we want the symbols to be 'protected' so they
	  are exported - by are resolved internally to
	  symbol-freea relocations
	+ The whole thing is crazy:
	    + we need only 1 'get-vtable' method per class ...
	+ Mark all 'virtual' methods of (SPECIFIED && DEFAULT)
	  linkage as 'protected' - ditto for generated thunks (?)
    + Understand the weak symbol issue [!?]
	+ add a throw/catch ...
	  fprintf (file, " %c%c%c%c%c%c%c",
	    ((type & BSF_LOCAL)
	    ? (type & BSF_GLOBAL) ? '!' : 'l'
	    : (type & BSF_GLOBAL) ? 'g' : ' '),
	   (type & BSF_WEAK) ? 'w' : ' ',
	   (type & BSF_CONSTRUCTOR) ? 'C' : ' ',
	   (type & BSF_WARNING) ? 'W' : ' ',
	   (type & BSF_INDIRECT) ? 'I' : ' ',
	   (type & BSF_DEBUGGING) ? 'd' : (type & BSF_DYNAMIC) ? 'D' : ' ',
	   ((type & BSF_FUNCTION)
	    ? 'F'
	    : ((type & BSF_FILE)
	       ? 'f'
	       : ((type & BSF_OBJECT) ? 'O' : ' '))));
	+ Weak symbols generated by:
	    + Templates ...
	    + Reference<Foo> type stuff ...
	    	    + non-virtual thunks
		    + type info (_ZTI)
		    + vtables (_ZTV)

    + [all to do with typeinfo behavior]
	+ re-read: http://www.nedprod.com/programs/gccvisibility.html
	  very carefully ...
    + Can we annotate the source with 'protected' for most methods ?

    + parent chaining ?
	+ doesn't go via vtable - but direct fn. call ...

    + Looks like we do all those bindings (relocs?)
	+ at dlopen time [!?] [ 10k relocations building vtables ? ]

    + need to check vs. gcc-4.x ...
	[ should be able to prune ... ]

Thoughts: (problem/soln/problem/...)
    + the deep / vcl OutputDevice -> Window -> Control -> ...
      vtable building issue is bad, bad news.
	+ why can't we get/copy the parent's vtable
	  with 'memcpy' ? instead of lots of lookups ?
    + can we parallelise the linker ?
	+ this problem is easily partitionable, surely ...
	    + [ no thread support in the linker ... ]

    + a 'thunk' fn does:
	+ adjust 'this' pointer & call method [ and MI feature ]

+ Things to check:
	+ anonymous namespaces ... - file path mangled in ?



** Parent / Copy VTables ... **
    + Use: options to dump tree data to aid debugging.

	-fdump-class-hierarchy[-N]
    + With this we get:
	cp/class.c (dump_vtable):

eg.

Vtable for SubClass
SubClass::_ZTV8SubClass: 9u entries
0     (int (*)(...))0
4     (int (*)(...))(& _ZTI8SubClass)
8     SubClass::doFoo
12    BaseClass::count
16    BaseClass::operator[]
20    SubClass::doAnother
24    (int (*)(...))-0x000000008
28    (int (*)(...))(& _ZTI8SubClass)
32    SubClass::_ZThn8_N8SubClass9doAnotherEi

Called from:
    + cp/class.c (initialize_vtable)
	+ We need to identify simple cases somewhere
	  here & eliminate sillies.

/* Make BINFO's vtable have N entries, including RTTI entries,
   vbase and vcall offsets, etc.  Set its type and call the backend
   to lay it out.  */

static void
layout_vtable_decl (tree binfo, int n)

/* Virtual function table initialization.  */

/* Create all the necessary vtables for T and its base classes.  */

static void
finish_vtbls (tree t)

Calls:

/* Initialize the vtable for BINFO with the INITS.  */

static void
initialize_vtable (tree binfo, tree inits)

* It seems initializer ordering is unpredictable:

works:

extern ParamFoo aBaa;
ParamFoo aBaa;
StaticInit aStatic(aBaa);

doesn't work:

extern ParamFoo aBaa;
StaticInit aStatic(aBaa);
ParamFoo aBaa;

* Initialization etc. bits:

http://gcc.gnu.org/onlinedocs/gcc-4.1.1/gccint/Initialization.html

.ctors section.
    + find something that puts code in
      the .ctors section (?)

Emit a fn. that will do the construction (?)
    + make it a .ctor (?)


*/

static void
finish_vtbls (tree t)

Calls:

/* Initialize the vtable for BINFO with the INITS.  */

static void
initialize_vtable (tree binfo, tree inits)

* It seems initializer ordering is unpredictable:

works:

extern ParamFoo aBaa;
ParamFoo aBaa;
StaticInit aStatic(aBaa);

doesn't work:

extern ParamFoo aBaa;
StaticInit aStatic(aBaa);
ParamFoo aBaa;

* Initialization etc. bits:

http://gcc.gnu.org/onlinedocs/gcc-4.1.1/gccint/Initialization.html

.ctors section.
    + find something that puts code in
      the .ctors section (?)

Emit a fn. that will do the construction (?)


* Avoid duplicate VTable construction:

    + need to hook the vague linkage constructs:

http://m68hc11.serveftp.org/doc/gcc_6.html

    + but for methods [ ie. same as 'inline' methods ?! ;-]


+ 1st step:
    + get gcc to emit a constructor call to
      a custom fn ...

+ 2nd step
    + generate bit-masks &
      impl. that function to do a copy

+ 3rd step
    + generate that fn. internally

