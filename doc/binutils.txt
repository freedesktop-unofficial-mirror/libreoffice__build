Improving binutils' symbol & reloc sorting efficiency:

// Improved binutils symbol sorting for cache efficiency ...
    + Unfortunately -Wl,-combreloc exports & re-imports
      the relocs before sorting them [ most odd ]

    + We sort .dynsym nicely (by elf hash)
	+ we fail to sort .dynstr
	    - in sequence of suffix order [!?]
	+ elf-strtab.c (_bfd_elf_strtab_finalize)
	    + does a sort - but only on a copy ...
		+ also assigns hard addresses [!]
	    + ultimately in bfd_strtab_add order ...
		+ can we sort earlier & influence that ?
	    + red herring:
	    	    + '_bfd_elf_export_symbol' ...
	    + _bfd_elf_merge_symbol (?)
	    + *Unfortunately*
		+ the sym table is already built & swapped out (?)

    + we want relocs sorted by absolute elf hash value
	+ Unfortunately - we don't have the symbol foo here
	+ which *really* sucks ...
	+ The relocs are typically just copied from the source
	  though so ... _bfd_elf_link_output_relocs ...
	    + the SymStrTab + contains all the symbols
	    + in the right order - given an index each
	    + unfortunately inaccessible by 'index' ...
    + Back the strhash with the actual string data ? [!?]
	+ thus avoiding foos ?

    + and we want symbols sorted by % hash_table_size
        + HACK: _bfd_elf_link_renumber_dynsyms [!?]
	    + sort as we renumber ?
	+ bfd_elf_final_link
	    + elf_link_hash_traverse ... elf_link_output_extsym
	    + [ elf_sort_symbol ? ]

    ** Could we have a flat array of entries ?
	+ we need Index [ it's a byte index ... ]
	+ urgh ...
		+ st_name is a byte offset into foo


    ** Problems:
	+ dynsym index order is: (bfd_elf_final_link):
	    + dummy_symbol [elf_link_output_sym ...]
	    + elf_link_hash_traverse (elf_link_output_extsym...)
		localsyms = true
	    + abfd->sections order
	    + local dynsyms ...
	    + elf_link_hash_traverse (elf_link_output_extsym)
		localsyms = false
    ** To Do:
	+ 'simply' - pre-quicksort on 
	    (elf_link_hash_entry):
	    ** h->u.elf_hash_value % hash_size [!?]
	+ iterate over that instead of the hash ...
	+ also sorts the strings by elf hash incidentally :-)

	+ bucketcount = elf_hash_table (finfo->info)->bucketcount;
	+ bucket = h->u.elf_hash_value % bucketcount;

	    + compute_bucket_count ...
		+ builds 'hashcodes' list ...
		+ used only locally ...

    ** What about _bfd_elf_link_renumber_dynsyms ...
	+ what about hash table removals
	    - surely they change the order of traversal ?

** Hack elf_link_hash_traverse
	+ in 2 modes: pre-sort & post sort.

** We want to sort before _bfd_elf_link_renumber_dynsyms:
	from bfd_elf_size_dynamic_sections ...
	    + bucketcount calculated on line 5787
		+ bfd_elf_size_dynamic_sections [4987->5816]
	    + renumber_dynsyms is line 5715
		+ [urk]

dltest.c - simple dlopen 100 times of libvcl:
Iter 0.12241 us
Iter 0.12255 us
Iter 0.12828 us

sorted alphabetically:
Iter 0.12222 us
Iter 0.12506 us
Iter 0.12137 us

just libvcl sorted by elf_hash % bucketcount:
Iter 0.11994 us
Iter 0.11950 us
Iter 0.11959 us

more libvcl ldd output re-linked:
     sal, libutl, libsot

unchanged:
Iter 0.36873 us
Iter 0.36727 us
Iter 0.3777 us
Iter 0.39592 us
Iter 0.41514 us -- outlier
Iter 0.38233 us

Avg: 0.3784 ( + 0.3845 with outlier)

changed:
Iter 0.35362 us
Iter 0.35221 us
Iter 0.3547 us
Iter 0.37611 us
Iter 0.38871 us
Iter 0.37706 us

Avg: 0.3671

** sorting relocs by elf hash
   + store the hash value as we write it out ?!
   + store an array of 'h' pointers per reloc ?
...
    + then we have an array of foo ...
	+ or ? ... symbol foo...
    + OR - store the symbol strings in a chunk
      instead & index by offsets ?
	+ can realloc take that ?
	+ can we work out the size in advance ?
	+ can we get a very-slow prototype ?
    + foo:
	+ just read-in the elf string tab anyway.
	+ it got emitted by bfd_stringtab_emit just above anyway.

    + relocations - point into dynsym ? - if so - horay ;-)
	+ we can use the previous sort / foo table too ?
	+ otherwise we screwed that up nastily [?]
	    + hmm.

    + relocs must have a dynsym ptr - since that's
      what we accelerate -Bdirect with ...

** TODO
	+ Write ChangeLog entry ...
	+ dynsym sort:
		+ free array
		+ ** +
	+ free 'sorted' (x 2)
		+ strip out the -Bdirect stuff ...
#define bfd_link_hash_table_create(abfd) \
       BFD_SEND (abfd, _bfd_link_hash_table_create, (abfd))
#define bfd_link_hash_table_free(abfd, hash) \
       BFD_SEND (abfd, _bfd_link_hash_table_free, (hash))

		+ hack elf32_target.h
		    + don't use the generic free ...

	+ check array_sorted etc. correctly initialized...
	+ copy types for 'int' foo form dynidx etc. [ long ]
	+ better string sort ?
		+ into same order ? - re-use '*h' ?


+ Issues:
	+ qsort 'global' closure ?
	    + Pre % the elf symbol hash data with the
	      bucket count ! :-)

	+ add an elf_link_hash_entry pointer and pass
	  that (if we can) from bfd_elf_link_record_dynamic_symbol ?
	+ then we can avoid re-calculating the symbol hash etc.
	  also get the foo to baa more nicely ... (?)
	+ fix the elf strtab leak thing ... [ugh]

** Further work
	+ sort the relocations by owner & by
	  elf_hash % owner_bucket_count


** Way better:
    + 30% faster ...
	[ for my 1 test ;-]

** For just libsvx: - each avg of 10 runs:

Unsorted:
Iter 549 ms
Iter 552 ms
Iter 550 ms
     Avg: 550ms

Sorted:
Iter 536 ms
Iter 540 ms
Iter 540 ms
     Avg: 539ms


** For libvcl: avg of 50 runs
    + with 5 of it's deps re-linked:

Unsorted:
Iter 88.45 ms
Iter 88.27 ms
Iter 89.89 ms
Iter 88.65 ms

Sorted:
Iter 85.11 ms
Iter 85.22 ms
Iter 85.43 ms
Iter 84.57 ms


** Analysis of the test harness:

L2 data read misses:

do_lookup_x    362k -> 130k
strcmp	       159k -> 53k
_dl_elf_hash   158k -> 147k

L1 data read misses:

_dl_relocate_obj    1649k -> 587k
do_lookup_x	    923k -> 295k
_dl_elf_hash	    187k -> 162k
strcmp		    216k -> 80k
