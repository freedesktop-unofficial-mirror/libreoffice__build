-Bdirect linking:

+ need to elide 'vague linkage' stuff [ re-use regexp map logic ? ]

+ behaves like an optimial -Bsymbolic in-library +
+ stores library index [1 per symbol ?] for the dynamic sym table
	[ sol seems to do somewhat better than that ]

+ elflink.c:

	bfd_boolean
	bfd_elf_link_record_dynamic_symbol (struct bfd_link_info *info,
					    struct elf_link_hash_entry *h)

	+ calls _bfd_elf_strtab_add (...)
	+ sets (elf_link_hash_entry) h->dynstr_index to that ...
		+ of course - string table can contain anything (?)
		+ we want a symbol-table index (?)

		.dynsym <symbol data> .dynstr <string data>
		+ Precisely 1 entry in '.direct' for every entry
		  in .dynsym
			+ elf_hash_table(info)->dynsymcount ...

	+ bfd_elf_size_dynamic_sections:
		+ working nicely

	+ Need the list of external libraries (section?)
		+ what is that ?
		+ DT_NEEDED ?
			+ lots of NEEDED libs
			+ get a clear order ?
		+ [ elf_add_dt_needed_tag ]:
			+ goes through '.dynamic' section
			+ pages in all Elf_Internal_Dyn records
				+ sub-sets on DT_NEEDED
				+ etc. ...
			+ slow but reliable ;-)
		+ *Should*
			+ count index of existing DT_NEEDEDs
				+ copy elf_dt_name (bfd)
***				& assign elf_dt_index (bfd)
			+ then just use elsewhere ...

	+ elf_link_output_extsym ...
		+ build .direct here ...
		+ use the 'bfd_link_hash_entry'
			+ switch on type
			+ for 'def'
				+ asection *section [ symbol section ]
			+ [ what it resolves to ? ]
				+ is this the post link data ?
				+ [ what about weak / multiple hits !? ]
			+ section->owner == bfd ...
				+ bfd.h:3942 
					+ const char *filename
			+ elf_dt_name (bfd) = soname ...
				(const char *)
			+ so we can get that easily.


